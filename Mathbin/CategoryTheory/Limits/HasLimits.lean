/-
Copyright (c) 2018 Scott Morrison. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Reid Barton, Mario Carneiro, Scott Morrison, Floris van Doorn

! This file was ported from Lean 3 source module category_theory.limits.has_limits
! leanprover-community/mathlib commit ee05e9ce1322178f0c12004eb93c00d2c8c00ed2
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.CategoryTheory.Limits.IsLimit
import Mathbin.CategoryTheory.Category.Ulift

/-!
# Existence of limits and colimits

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

In `category_theory.limits.is_limit` we defined `is_limit c`,
the data showing that a cone `c` is a limit cone.

The two main structures defined in this file are:
* `limit_cone F`, which consists of a choice of cone for `F` and the fact it is a limit cone, and
* `has_limit F`, asserting the mere existence of some limit cone for `F`.

`has_limit` is a propositional typeclass
(it's important that it is a proposition merely asserting the existence of a limit,
as otherwise we would have non-defeq problems from incompatible instances).

While `has_limit` only asserts the existence of a limit cone,
we happily use the axiom of choice in mathlib,
so there are convenience functions all depending on `has_limit F`:
* `limit F : C`, producing some limit object (of course all such are isomorphic)
* `limit.œÄ F j : limit F ‚ü∂ F.obj j`, the morphisms out of the limit,
* `limit.lift F c : c.X ‚ü∂ limit F`, the universal morphism from any other `c : cone F`, etc.

Key to using the `has_limit` interface is that there is an `@[ext]` lemma stating that
to check `f = g`, for `f g : Z ‚ü∂ limit F`, it suffices to check `f ‚â´ limit.œÄ F j = g ‚â´ limit.œÄ F j`
for every `j`.
This, combined with `@[simp]` lemmas, makes it possible to prove many easy facts about limits using
automation (e.g. `tidy`).

There are abbreviations `has_limits_of_shape J C` and `has_limits C`
asserting the existence of classes of limits.
Later more are introduced, for finite limits, special shapes of limits, etc.

Ideally, many results about limits should be stated first in terms of `is_limit`,
and then a result in terms of `has_limit` derived from this.
At this point, however, this is far from uniformly achieved in mathlib ---
often statements are only written in terms of `has_limit`.

## Implementation
At present we simply say everything twice, in order to handle both limits and colimits.
It would be highly desirable to have some automation support,
e.g. a `@[dualize]` attribute that behaves similarly to `@[to_additive]`.

## References
* [Stacks: Limits and colimits](https://stacks.math.columbia.edu/tag/002D)

-/


noncomputable section

open CategoryTheory CategoryTheory.Category CategoryTheory.Functor Opposite

namespace CategoryTheory.Limits

-- morphism levels before object levels. See note [category_theory universes].
universe v‚ÇÅ u‚ÇÅ v‚ÇÇ u‚ÇÇ v‚ÇÉ u‚ÇÉ v v' v'' u u' u''

variable {J : Type u‚ÇÅ} [Category.{v‚ÇÅ} J] {K : Type u‚ÇÇ} [Category.{v‚ÇÇ} K]

variable {C : Type u} [Category.{v} C]

variable {F : J ‚•§ C}

section Limit

#print CategoryTheory.Limits.LimitCone /-
/-- `limit_cone F` contains a cone over `F` together with the information that it is a limit. -/
@[nolint has_nonempty_instance]
structure LimitCone (F : J ‚•§ C) where
  Cone : Cone F
  IsLimit : IsLimit cone
#align category_theory.limits.limit_cone CategoryTheory.Limits.LimitCone
-/

#print CategoryTheory.Limits.HasLimit /-
/-- `has_limit F` represents the mere existence of a limit for `F`. -/
class HasLimit (F : J ‚•§ C) : Prop where mk' ::
  exists_limit : Nonempty (LimitCone F)
#align category_theory.limits.has_limit CategoryTheory.Limits.HasLimit
-/

#print CategoryTheory.Limits.HasLimit.mk /-
theorem HasLimit.mk {F : J ‚•§ C} (d : LimitCone F) : HasLimit F :=
  ‚ü®Nonempty.intro d‚ü©
#align category_theory.limits.has_limit.mk CategoryTheory.Limits.HasLimit.mk
-/

#print CategoryTheory.Limits.getLimitCone /-
/-- Use the axiom of choice to extract explicit `limit_cone F` from `has_limit F`. -/
def getLimitCone (F : J ‚•§ C) [HasLimit F] : LimitCone F :=
  Classical.choice <| HasLimit.exists_limit
#align category_theory.limits.get_limit_cone CategoryTheory.Limits.getLimitCone
-/

variable (J C)

#print CategoryTheory.Limits.HasLimitsOfShape /-
/-- `C` has limits of shape `J` if there exists a limit for every functor `F : J ‚•§ C`. -/
class HasLimitsOfShape : Prop where
  HasLimit : ‚àÄ F : J ‚•§ C, HasLimit F := by infer_instance
#align category_theory.limits.has_limits_of_shape CategoryTheory.Limits.HasLimitsOfShape
-/

#print CategoryTheory.Limits.HasLimitsOfSize /-
/-- `C` has all limits of size `v‚ÇÅ u‚ÇÅ` (`has_limits_of_size.{v‚ÇÅ u‚ÇÅ} C`)
if it has limits of every shape `J : Type u‚ÇÅ` with `[category.{v‚ÇÅ} J]`.
-/
class HasLimitsOfSize (C : Type u) [Category.{v} C] : Prop where
  HasLimitsOfShape : ‚àÄ (J : Type u‚ÇÅ) [ùí• : Category.{v‚ÇÅ} J], HasLimitsOfShape J C := by
    infer_instance
#align category_theory.limits.has_limits_of_size CategoryTheory.Limits.HasLimitsOfSize
-/

#print CategoryTheory.Limits.HasLimits /-
/-- `C` has all (small) limits if it has limits of every shape that is as big as its hom-sets. -/
abbrev HasLimits (C : Type u) [Category.{v} C] : Prop :=
  HasLimitsOfSize.{v, v} C
#align category_theory.limits.has_limits CategoryTheory.Limits.HasLimits
-/

#print CategoryTheory.Limits.HasLimits.has_limits_of_shape /-
theorem HasLimits.has_limits_of_shape {C : Type u} [Category.{v} C] [HasLimits C] (J : Type v)
    [Category.{v} J] : HasLimitsOfShape J C :=
  HasLimitsOfSize.hasLimitsOfShape J
#align category_theory.limits.has_limits.has_limits_of_shape CategoryTheory.Limits.HasLimits.has_limits_of_shape
-/

variable {J C}

#print CategoryTheory.Limits.hasLimitOfHasLimitsOfShape /-
-- see Note [lower instance priority]
instance (priority := 100) hasLimitOfHasLimitsOfShape {J : Type u‚ÇÅ} [Category.{v‚ÇÅ} J]
    [H : HasLimitsOfShape J C] (F : J ‚•§ C) : HasLimit F :=
  HasLimitsOfShape.hasLimit F
#align category_theory.limits.has_limit_of_has_limits_of_shape CategoryTheory.Limits.hasLimitOfHasLimitsOfShape
-/

#print CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits /-
-- see Note [lower instance priority]
instance (priority := 100) hasLimitsOfShapeOfHasLimits {J : Type u‚ÇÅ} [Category.{v‚ÇÅ} J]
    [H : HasLimitsOfSize.{v‚ÇÅ, u‚ÇÅ} C] : HasLimitsOfShape J C :=
  HasLimitsOfSize.hasLimitsOfShape J
#align category_theory.limits.has_limits_of_shape_of_has_limits CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits
-/

#print CategoryTheory.Limits.limit.cone /-
-- Interface to the `has_limit` class.
/-- An arbitrary choice of limit cone for a functor. -/
def limit.cone (F : J ‚•§ C) [HasLimit F] : Cone F :=
  (getLimitCone F).Cone
#align category_theory.limits.limit.cone CategoryTheory.Limits.limit.cone
-/

#print CategoryTheory.Limits.limit /-
/-- An arbitrary choice of limit object of a functor. -/
def limit (F : J ‚•§ C) [HasLimit F] :=
  (limit.cone F).pt
#align category_theory.limits.limit CategoryTheory.Limits.limit
-/

/- warning: category_theory.limits.limit.œÄ -> CategoryTheory.Limits.limit.œÄ is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {C : Type.{u4}} [_inst_3 : CategoryTheory.Category.{u3, u4} C] (F : CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) [_inst_4 : CategoryTheory.Limits.HasLimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F] (j : J), Quiver.Hom.{succ u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Limits.limit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4) (CategoryTheory.Functor.obj.{u1, u3, u2, u4} J _inst_1 C _inst_3 F j)
but is expected to have type
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {C : Type.{u4}} [_inst_3 : CategoryTheory.Category.{u3, u4} C] (F : CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) [_inst_4 : CategoryTheory.Limits.HasLimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F] (j : J), Quiver.Hom.{succ u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Limits.limit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4) (Prefunctor.obj.{succ u1, succ u3, u2, u4} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, u4} J _inst_1 C _inst_3 F) j)
Case conversion may be inaccurate. Consider using '#align category_theory.limits.limit.œÄ CategoryTheory.Limits.limit.œÄ‚Çì'. -/
/-- The projection from the limit object to a value of the functor. -/
def limit.œÄ (F : J ‚•§ C) [HasLimit F] (j : J) : limit F ‚ü∂ F.obj j :=
  (limit.cone F).œÄ.app j
#align category_theory.limits.limit.œÄ CategoryTheory.Limits.limit.œÄ

#print CategoryTheory.Limits.limit.cone_x /-
@[simp]
theorem limit.cone_x {F : J ‚•§ C} [HasLimit F] : (limit.cone F).pt = limit F :=
  rfl
#align category_theory.limits.limit.cone_X CategoryTheory.Limits.limit.cone_x
-/

/- warning: category_theory.limits.limit.cone_œÄ -> CategoryTheory.Limits.limit.cone_œÄ is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {C : Type.{u4}} [_inst_3 : CategoryTheory.Category.{u3, u4} C] {F : CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3} [_inst_4 : CategoryTheory.Limits.HasLimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F], Eq.{max (succ u2) (succ u3)} (forall (X : J), Quiver.Hom.{succ u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Functor.obj.{u1, u3, u2, u4} J _inst_1 C _inst_3 (CategoryTheory.Functor.obj.{u3, max u2 u3, u4, max u1 u3 u2 u4} C _inst_3 (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.const.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Limits.Cone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 F (CategoryTheory.Limits.limit.cone.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4))) X) (CategoryTheory.Functor.obj.{u1, u3, u2, u4} J _inst_1 C _inst_3 F X)) (CategoryTheory.NatTrans.app.{u1, u3, u2, u4} J _inst_1 C _inst_3 (CategoryTheory.Functor.obj.{u3, max u2 u3, u4, max u1 u3 u2 u4} C _inst_3 (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.const.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Limits.Cone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 F (CategoryTheory.Limits.limit.cone.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4))) F (CategoryTheory.Limits.Cone.œÄ.{u1, u3, u2, u4} J _inst_1 C _inst_3 F (CategoryTheory.Limits.limit.cone.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4))) (CategoryTheory.Limits.limit.œÄ.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4)
but is expected to have type
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {C : Type.{u4}} [_inst_3 : CategoryTheory.Category.{u3, u4} C] {F : CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3} [_inst_4 : CategoryTheory.Limits.HasLimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F], Eq.{max (succ u2) (succ u3)} (forall (X : J), Quiver.Hom.{succ u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (Prefunctor.obj.{succ u1, succ u3, u2, u4} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, u4} J _inst_1 C _inst_3 (Prefunctor.obj.{succ u3, max (succ u2) (succ u3), u4, max (max (max u2 u1) u3) u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u3, max (max (max u2 u1) u4) u3} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Category.toCategoryStruct.{max u2 u3, max (max (max u2 u1) u4) u3} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3))) (CategoryTheory.Functor.toPrefunctor.{u3, max u2 u3, u4, max (max (max u2 u1) u4) u3} C _inst_3 (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.const.{u1, u3, u2, u4} J _inst_1 C _inst_3)) (CategoryTheory.Limits.Cone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 F (CategoryTheory.Limits.limit.cone.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4)))) X) (Prefunctor.obj.{succ u1, succ u3, u2, u4} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, u4} J _inst_1 C _inst_3 F) X)) (CategoryTheory.NatTrans.app.{u1, u3, u2, u4} J _inst_1 C _inst_3 (Prefunctor.obj.{succ u3, max (succ u2) (succ u3), u4, max (max (max u2 u1) u3) u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u3, max (max (max u2 u1) u4) u3} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Category.toCategoryStruct.{max u2 u3, max (max (max u2 u1) u4) u3} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3))) (CategoryTheory.Functor.toPrefunctor.{u3, max u2 u3, u4, max (max (max u2 u1) u4) u3} C _inst_3 (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.const.{u1, u3, u2, u4} J _inst_1 C _inst_3)) (CategoryTheory.Limits.Cone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 F (CategoryTheory.Limits.limit.cone.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4))) F (CategoryTheory.Limits.Cone.œÄ.{u1, u3, u2, u4} J _inst_1 C _inst_3 F (CategoryTheory.Limits.limit.cone.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4))) (CategoryTheory.Limits.limit.œÄ.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4)
Case conversion may be inaccurate. Consider using '#align category_theory.limits.limit.cone_œÄ CategoryTheory.Limits.limit.cone_œÄ‚Çì'. -/
@[simp]
theorem limit.cone_œÄ {F : J ‚•§ C} [HasLimit F] : (limit.cone F).œÄ.app = limit.œÄ _ :=
  rfl
#align category_theory.limits.limit.cone_œÄ CategoryTheory.Limits.limit.cone_œÄ

/- warning: category_theory.limits.limit.w -> CategoryTheory.Limits.limit.w is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {C : Type.{u4}} [_inst_3 : CategoryTheory.Category.{u3, u4} C] (F : CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) [_inst_4 : CategoryTheory.Limits.HasLimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F] {j : J} {j' : J} (f : Quiver.Hom.{succ u1, u2} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) j j'), Eq.{succ u3} (Quiver.Hom.{succ u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Limits.limit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4) (CategoryTheory.Functor.obj.{u1, u3, u2, u4} J _inst_1 C _inst_3 F j')) (CategoryTheory.CategoryStruct.comp.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3) (CategoryTheory.Limits.limit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4) (CategoryTheory.Functor.obj.{u1, u3, u2, u4} J _inst_1 C _inst_3 F j) (CategoryTheory.Functor.obj.{u1, u3, u2, u4} J _inst_1 C _inst_3 F j') (CategoryTheory.Limits.limit.œÄ.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4 j) (CategoryTheory.Functor.map.{u1, u3, u2, u4} J _inst_1 C _inst_3 F j j' f)) (CategoryTheory.Limits.limit.œÄ.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4 j')
but is expected to have type
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {C : Type.{u4}} [_inst_3 : CategoryTheory.Category.{u3, u4} C] (F : CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) [_inst_4 : CategoryTheory.Limits.HasLimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F] {j : J} {j' : J} (f : Quiver.Hom.{succ u1, u2} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) j j'), Eq.{succ u3} (Quiver.Hom.{succ u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Limits.limit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4) (Prefunctor.obj.{succ u1, succ u3, u2, u4} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, u4} J _inst_1 C _inst_3 F) j')) (CategoryTheory.CategoryStruct.comp.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3) (CategoryTheory.Limits.limit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4) (Prefunctor.obj.{succ u1, succ u3, u2, u4} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, u4} J _inst_1 C _inst_3 F) j) (Prefunctor.obj.{succ u1, succ u3, u2, u4} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, u4} J _inst_1 C _inst_3 F) j') (CategoryTheory.Limits.limit.œÄ.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4 j) (Prefunctor.map.{succ u1, succ u3, u2, u4} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, u4} J _inst_1 C _inst_3 F) j j' f)) (CategoryTheory.Limits.limit.œÄ.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4 j')
Case conversion may be inaccurate. Consider using '#align category_theory.limits.limit.w CategoryTheory.Limits.limit.w‚Çì'. -/
@[simp, reassoc.1]
theorem limit.w (F : J ‚•§ C) [HasLimit F] {j j' : J} (f : j ‚ü∂ j') :
    limit.œÄ F j ‚â´ F.map f = limit.œÄ F j' :=
  (limit.cone F).w f
#align category_theory.limits.limit.w CategoryTheory.Limits.limit.w

#print CategoryTheory.Limits.limit.isLimit /-
/-- Evidence that the arbitrary choice of cone provied by `limit.cone F` is a limit cone. -/
def limit.isLimit (F : J ‚•§ C) [HasLimit F] : IsLimit (limit.cone F) :=
  (getLimitCone F).IsLimit
#align category_theory.limits.limit.is_limit CategoryTheory.Limits.limit.isLimit
-/

#print CategoryTheory.Limits.limit.lift /-
/-- The morphism from the cone point of any other cone to the limit object. -/
def limit.lift (F : J ‚•§ C) [HasLimit F] (c : Cone F) : c.pt ‚ü∂ limit F :=
  (limit.isLimit F).lift c
#align category_theory.limits.limit.lift CategoryTheory.Limits.limit.lift
-/

#print CategoryTheory.Limits.limit.isLimit_lift /-
@[simp]
theorem limit.isLimit_lift {F : J ‚•§ C} [HasLimit F] (c : Cone F) :
    (limit.isLimit F).lift c = limit.lift F c :=
  rfl
#align category_theory.limits.limit.is_limit_lift CategoryTheory.Limits.limit.isLimit_lift
-/

/- warning: category_theory.limits.limit.lift_œÄ -> CategoryTheory.Limits.limit.lift_œÄ is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {C : Type.{u4}} [_inst_3 : CategoryTheory.Category.{u3, u4} C] {F : CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3} [_inst_4 : CategoryTheory.Limits.HasLimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F] (c : CategoryTheory.Limits.Cone.{u1, u3, u2, u4} J _inst_1 C _inst_3 F) (j : J), Eq.{succ u3} (Quiver.Hom.{succ u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Limits.Cone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 F c) (CategoryTheory.Functor.obj.{u1, u3, u2, u4} J _inst_1 C _inst_3 F j)) (CategoryTheory.CategoryStruct.comp.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3) (CategoryTheory.Limits.Cone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 F c) (CategoryTheory.Limits.limit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4) (CategoryTheory.Functor.obj.{u1, u3, u2, u4} J _inst_1 C _inst_3 F j) (CategoryTheory.Limits.limit.lift.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4 c) (CategoryTheory.Limits.limit.œÄ.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4 j)) (CategoryTheory.NatTrans.app.{u1, u3, u2, u4} J _inst_1 C _inst_3 (CategoryTheory.Functor.obj.{u3, max u2 u3, u4, max u1 u3 u2 u4} C _inst_3 (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.const.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Limits.Cone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 F c)) F (CategoryTheory.Limits.Cone.œÄ.{u1, u3, u2, u4} J _inst_1 C _inst_3 F c) j)
but is expected to have type
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {C : Type.{u4}} [_inst_3 : CategoryTheory.Category.{u3, u4} C] {F : CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3} [_inst_4 : CategoryTheory.Limits.HasLimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F] (c : CategoryTheory.Limits.Cone.{u1, u3, u2, u4} J _inst_1 C _inst_3 F) (j : J), Eq.{succ u3} (Quiver.Hom.{succ u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Limits.Cone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 F c) (Prefunctor.obj.{succ u1, succ u3, u2, u4} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, u4} J _inst_1 C _inst_3 F) j)) (CategoryTheory.CategoryStruct.comp.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3) (CategoryTheory.Limits.Cone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 F c) (CategoryTheory.Limits.limit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4) (Prefunctor.obj.{succ u1, succ u3, u2, u4} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, u4} J _inst_1 C _inst_3 F) j) (CategoryTheory.Limits.limit.lift.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4 c) (CategoryTheory.Limits.limit.œÄ.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4 j)) (CategoryTheory.NatTrans.app.{u1, u3, u2, u4} J _inst_1 C _inst_3 (Prefunctor.obj.{succ u3, max (succ u2) (succ u3), u4, max (max (max u2 u1) u3) u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u3, max (max (max u2 u1) u4) u3} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Category.toCategoryStruct.{max u2 u3, max (max (max u2 u1) u4) u3} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3))) (CategoryTheory.Functor.toPrefunctor.{u3, max u2 u3, u4, max (max (max u2 u1) u4) u3} C _inst_3 (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.const.{u1, u3, u2, u4} J _inst_1 C _inst_3)) (CategoryTheory.Limits.Cone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 F c)) F (CategoryTheory.Limits.Cone.œÄ.{u1, u3, u2, u4} J _inst_1 C _inst_3 F c) j)
Case conversion may be inaccurate. Consider using '#align category_theory.limits.limit.lift_œÄ CategoryTheory.Limits.limit.lift_œÄ‚Çì'. -/
@[simp, reassoc.1]
theorem limit.lift_œÄ {F : J ‚•§ C} [HasLimit F] (c : Cone F) (j : J) :
    limit.lift F c ‚â´ limit.œÄ F j = c.œÄ.app j :=
  IsLimit.fac _ c j
#align category_theory.limits.limit.lift_œÄ CategoryTheory.Limits.limit.lift_œÄ

#print CategoryTheory.Limits.limMap /-
/-- Functoriality of limits.

Usually this morphism should be accessed through `lim.map`,
but may be needed separately when you have specified limits for the source and target functors,
but not necessarily for all functors of shape `J`.
-/
def limMap {F G : J ‚•§ C} [HasLimit F] [HasLimit G] (Œ± : F ‚ü∂ G) : limit F ‚ü∂ limit G :=
  IsLimit.map _ (limit.isLimit G) Œ±
#align category_theory.limits.lim_map CategoryTheory.Limits.limMap
-/

/- warning: category_theory.limits.lim_map_œÄ -> CategoryTheory.Limits.limMap_œÄ is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {C : Type.{u4}} [_inst_3 : CategoryTheory.Category.{u3, u4} C] {F : CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3} {G : CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3} [_inst_4 : CategoryTheory.Limits.HasLimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F] [_inst_5 : CategoryTheory.Limits.HasLimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 G] (Œ± : Quiver.Hom.{succ (max u2 u3), max u1 u3 u2 u4} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u3, max u1 u3 u2 u4} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Category.toCategoryStruct.{max u2 u3, max u1 u3 u2 u4} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3))) F G) (j : J), Eq.{succ u3} (Quiver.Hom.{succ u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Limits.limit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4) (CategoryTheory.Functor.obj.{u1, u3, u2, u4} J _inst_1 C _inst_3 G j)) (CategoryTheory.CategoryStruct.comp.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3) (CategoryTheory.Limits.limit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4) (CategoryTheory.Limits.limit.{u1, u2, u3, u4} J _inst_1 C _inst_3 G _inst_5) (CategoryTheory.Functor.obj.{u1, u3, u2, u4} J _inst_1 C _inst_3 G j) (CategoryTheory.Limits.limMap.{u1, u2, u3, u4} J _inst_1 C _inst_3 F G _inst_4 _inst_5 Œ±) (CategoryTheory.Limits.limit.œÄ.{u1, u2, u3, u4} J _inst_1 C _inst_3 G _inst_5 j)) (CategoryTheory.CategoryStruct.comp.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3) (CategoryTheory.Limits.limit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4) (CategoryTheory.Functor.obj.{u1, u3, u2, u4} J _inst_1 C _inst_3 F j) (CategoryTheory.Functor.obj.{u1, u3, u2, u4} J _inst_1 C _inst_3 G j) (CategoryTheory.Limits.limit.œÄ.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4 j) (CategoryTheory.NatTrans.app.{u1, u3, u2, u4} J _inst_1 C _inst_3 F G Œ± j))
but is expected to have type
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {C : Type.{u4}} [_inst_3 : CategoryTheory.Category.{u3, u4} C] {F : CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3} {G : CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3} [_inst_4 : CategoryTheory.Limits.HasLimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F] [_inst_5 : CategoryTheory.Limits.HasLimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 G] (Œ± : Quiver.Hom.{max (succ u2) (succ u3), max (max (max u4 u2) u3) u1} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u3, max (max (max u4 u2) u3) u1} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Category.toCategoryStruct.{max u2 u3, max (max (max u4 u2) u3) u1} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3))) F G) (j : J), Eq.{succ u3} (Quiver.Hom.{succ u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Limits.limit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4) (Prefunctor.obj.{succ u1, succ u3, u2, u4} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, u4} J _inst_1 C _inst_3 G) j)) (CategoryTheory.CategoryStruct.comp.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3) (CategoryTheory.Limits.limit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4) (CategoryTheory.Limits.limit.{u1, u2, u3, u4} J _inst_1 C _inst_3 G _inst_5) (Prefunctor.obj.{succ u1, succ u3, u2, u4} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, u4} J _inst_1 C _inst_3 G) j) (CategoryTheory.Limits.limMap.{u1, u2, u3, u4} J _inst_1 C _inst_3 F G _inst_4 _inst_5 Œ±) (CategoryTheory.Limits.limit.œÄ.{u1, u2, u3, u4} J _inst_1 C _inst_3 G _inst_5 j)) (CategoryTheory.CategoryStruct.comp.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3) (CategoryTheory.Limits.limit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4) (Prefunctor.obj.{succ u1, succ u3, u2, u4} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, u4} J _inst_1 C _inst_3 F) j) (Prefunctor.obj.{succ u1, succ u3, u2, u4} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, u4} J _inst_1 C _inst_3 G) j) (CategoryTheory.Limits.limit.œÄ.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4 j) (CategoryTheory.NatTrans.app.{u1, u3, u2, u4} J _inst_1 C _inst_3 F G Œ± j))
Case conversion may be inaccurate. Consider using '#align category_theory.limits.lim_map_œÄ CategoryTheory.Limits.limMap_œÄ‚Çì'. -/
@[simp, reassoc.1]
theorem limMap_œÄ {F G : J ‚•§ C} [HasLimit F] [HasLimit G] (Œ± : F ‚ü∂ G) (j : J) :
    limMap Œ± ‚â´ limit.œÄ G j = limit.œÄ F j ‚â´ Œ±.app j :=
  limit.lift_œÄ _ j
#align category_theory.limits.lim_map_œÄ CategoryTheory.Limits.limMap_œÄ

#print CategoryTheory.Limits.limit.coneMorphism /-
/-- The cone morphism from any cone to the arbitrary choice of limit cone. -/
def limit.coneMorphism {F : J ‚•§ C} [HasLimit F] (c : Cone F) : c ‚ü∂ limit.cone F :=
  (limit.isLimit F).liftConeMorphism c
#align category_theory.limits.limit.cone_morphism CategoryTheory.Limits.limit.coneMorphism
-/

#print CategoryTheory.Limits.limit.coneMorphism_hom /-
@[simp]
theorem limit.coneMorphism_hom {F : J ‚•§ C} [HasLimit F] (c : Cone F) :
    (limit.coneMorphism c).Hom = limit.lift F c :=
  rfl
#align category_theory.limits.limit.cone_morphism_hom CategoryTheory.Limits.limit.coneMorphism_hom
-/

/- warning: category_theory.limits.limit.cone_morphism_œÄ -> CategoryTheory.Limits.limit.coneMorphism_œÄ is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {C : Type.{u4}} [_inst_3 : CategoryTheory.Category.{u3, u4} C] {F : CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3} [_inst_4 : CategoryTheory.Limits.HasLimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F] (c : CategoryTheory.Limits.Cone.{u1, u3, u2, u4} J _inst_1 C _inst_3 F) (j : J), Eq.{succ u3} (Quiver.Hom.{succ u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Limits.Cone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 F c) (CategoryTheory.Functor.obj.{u1, u3, u2, u4} J _inst_1 C _inst_3 F j)) (CategoryTheory.CategoryStruct.comp.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3) (CategoryTheory.Limits.Cone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 F c) (CategoryTheory.Limits.Cone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 F (CategoryTheory.Limits.limit.cone.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4)) (CategoryTheory.Functor.obj.{u1, u3, u2, u4} J _inst_1 C _inst_3 F j) (CategoryTheory.Limits.ConeMorphism.hom.{u1, u3, u2, u4} J _inst_1 C _inst_3 F c (CategoryTheory.Limits.limit.cone.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4) (CategoryTheory.Limits.limit.coneMorphism.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4 c)) (CategoryTheory.Limits.limit.œÄ.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4 j)) (CategoryTheory.NatTrans.app.{u1, u3, u2, u4} J _inst_1 C _inst_3 (CategoryTheory.Functor.obj.{u3, max u2 u3, u4, max u1 u3 u2 u4} C _inst_3 (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.const.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Limits.Cone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 F c)) F (CategoryTheory.Limits.Cone.œÄ.{u1, u3, u2, u4} J _inst_1 C _inst_3 F c) j)
but is expected to have type
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {C : Type.{u4}} [_inst_3 : CategoryTheory.Category.{u3, u4} C] {F : CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3} [_inst_4 : CategoryTheory.Limits.HasLimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F] (c : CategoryTheory.Limits.Cone.{u1, u3, u2, u4} J _inst_1 C _inst_3 F) (j : J), Eq.{succ u3} (Quiver.Hom.{succ u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Limits.Cone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 F c) (Prefunctor.obj.{succ u1, succ u3, u2, u4} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, u4} J _inst_1 C _inst_3 F) j)) (CategoryTheory.CategoryStruct.comp.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3) (CategoryTheory.Limits.Cone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 F c) (CategoryTheory.Limits.Cone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 F (CategoryTheory.Limits.limit.cone.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4)) (Prefunctor.obj.{succ u1, succ u3, u2, u4} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, u4} J _inst_1 C _inst_3 F) j) (CategoryTheory.Limits.ConeMorphism.Hom.{u1, u3, u2, u4} J _inst_1 C _inst_3 F c (CategoryTheory.Limits.limit.cone.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4) (CategoryTheory.Limits.limit.coneMorphism.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4 c)) (CategoryTheory.Limits.limit.œÄ.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4 j)) (CategoryTheory.NatTrans.app.{u1, u3, u2, u4} J _inst_1 C _inst_3 (Prefunctor.obj.{succ u3, max (succ u2) (succ u3), u4, max (max (max u2 u1) u3) u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u3, max (max (max u2 u1) u4) u3} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Category.toCategoryStruct.{max u2 u3, max (max (max u2 u1) u4) u3} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3))) (CategoryTheory.Functor.toPrefunctor.{u3, max u2 u3, u4, max (max (max u2 u1) u4) u3} C _inst_3 (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.const.{u1, u3, u2, u4} J _inst_1 C _inst_3)) (CategoryTheory.Limits.Cone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 F c)) F (CategoryTheory.Limits.Cone.œÄ.{u1, u3, u2, u4} J _inst_1 C _inst_3 F c) j)
Case conversion may be inaccurate. Consider using '#align category_theory.limits.limit.cone_morphism_œÄ CategoryTheory.Limits.limit.coneMorphism_œÄ‚Çì'. -/
theorem limit.coneMorphism_œÄ {F : J ‚•§ C} [HasLimit F] (c : Cone F) (j : J) :
    (limit.coneMorphism c).Hom ‚â´ limit.œÄ F j = c.œÄ.app j := by simp
#align category_theory.limits.limit.cone_morphism_œÄ CategoryTheory.Limits.limit.coneMorphism_œÄ

/- warning: category_theory.limits.limit.cone_point_unique_up_to_iso_hom_comp -> CategoryTheory.Limits.limit.conePointUniqueUpToIso_hom_comp is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {C : Type.{u4}} [_inst_3 : CategoryTheory.Category.{u3, u4} C] {F : CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3} [_inst_4 : CategoryTheory.Limits.HasLimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F] {c : CategoryTheory.Limits.Cone.{u1, u3, u2, u4} J _inst_1 C _inst_3 F} (hc : CategoryTheory.Limits.IsLimit.{u1, u3, u2, u4} J _inst_1 C _inst_3 F c) (j : J), Eq.{succ u3} (Quiver.Hom.{succ u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Limits.Cone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 F c) (CategoryTheory.Functor.obj.{u1, u3, u2, u4} J _inst_1 C _inst_3 F j)) (CategoryTheory.CategoryStruct.comp.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3) (CategoryTheory.Limits.Cone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 F c) (CategoryTheory.Limits.Cone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 F (CategoryTheory.Limits.limit.cone.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4)) (CategoryTheory.Functor.obj.{u1, u3, u2, u4} J _inst_1 C _inst_3 F j) (CategoryTheory.Iso.hom.{u3, u4} C _inst_3 (CategoryTheory.Limits.Cone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 F c) (CategoryTheory.Limits.Cone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 F (CategoryTheory.Limits.limit.cone.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4)) (CategoryTheory.Limits.IsLimit.conePointUniqueUpToIso.{u1, u3, u2, u4} J _inst_1 C _inst_3 F c (CategoryTheory.Limits.limit.cone.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4) hc (CategoryTheory.Limits.limit.isLimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4))) (CategoryTheory.Limits.limit.œÄ.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4 j)) (CategoryTheory.NatTrans.app.{u1, u3, u2, u4} J _inst_1 C _inst_3 (CategoryTheory.Functor.obj.{u3, max u2 u3, u4, max u1 u3 u2 u4} C _inst_3 (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.const.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Limits.Cone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 F c)) F (CategoryTheory.Limits.Cone.œÄ.{u1, u3, u2, u4} J _inst_1 C _inst_3 F c) j)
but is expected to have type
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {C : Type.{u4}} [_inst_3 : CategoryTheory.Category.{u3, u4} C] {F : CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3} [_inst_4 : CategoryTheory.Limits.HasLimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F] {c : CategoryTheory.Limits.Cone.{u1, u3, u2, u4} J _inst_1 C _inst_3 F} (hc : CategoryTheory.Limits.IsLimit.{u1, u3, u2, u4} J _inst_1 C _inst_3 F c) (j : J), Eq.{succ u3} (Quiver.Hom.{succ u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Limits.Cone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 F c) (Prefunctor.obj.{succ u1, succ u3, u2, u4} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, u4} J _inst_1 C _inst_3 F) j)) (CategoryTheory.CategoryStruct.comp.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3) (CategoryTheory.Limits.Cone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 F c) (CategoryTheory.Limits.Cone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 F (CategoryTheory.Limits.limit.cone.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4)) (Prefunctor.obj.{succ u1, succ u3, u2, u4} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, u4} J _inst_1 C _inst_3 F) j) (CategoryTheory.Iso.hom.{u3, u4} C _inst_3 (CategoryTheory.Limits.Cone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 F c) (CategoryTheory.Limits.Cone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 F (CategoryTheory.Limits.limit.cone.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4)) (CategoryTheory.Limits.IsLimit.conePointUniqueUpToIso.{u1, u3, u2, u4} J _inst_1 C _inst_3 F c (CategoryTheory.Limits.limit.cone.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4) hc (CategoryTheory.Limits.limit.isLimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4))) (CategoryTheory.Limits.limit.œÄ.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4 j)) (CategoryTheory.NatTrans.app.{u1, u3, u2, u4} J _inst_1 C _inst_3 (Prefunctor.obj.{succ u3, max (succ u2) (succ u3), u4, max (max (max u2 u1) u3) u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u3, max (max (max u2 u1) u4) u3} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Category.toCategoryStruct.{max u2 u3, max (max (max u2 u1) u4) u3} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3))) (CategoryTheory.Functor.toPrefunctor.{u3, max u2 u3, u4, max (max (max u2 u1) u4) u3} C _inst_3 (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.const.{u1, u3, u2, u4} J _inst_1 C _inst_3)) (CategoryTheory.Limits.Cone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 F c)) F (CategoryTheory.Limits.Cone.œÄ.{u1, u3, u2, u4} J _inst_1 C _inst_3 F c) j)
Case conversion may be inaccurate. Consider using '#align category_theory.limits.limit.cone_point_unique_up_to_iso_hom_comp CategoryTheory.Limits.limit.conePointUniqueUpToIso_hom_comp‚Çì'. -/
@[simp, reassoc.1]
theorem limit.conePointUniqueUpToIso_hom_comp {F : J ‚•§ C} [HasLimit F] {c : Cone F} (hc : IsLimit c)
    (j : J) : (IsLimit.conePointUniqueUpToIso hc (limit.isLimit _)).Hom ‚â´ limit.œÄ F j = c.œÄ.app j :=
  IsLimit.conePointUniqueUpToIso_hom_comp _ _ _
#align category_theory.limits.limit.cone_point_unique_up_to_iso_hom_comp CategoryTheory.Limits.limit.conePointUniqueUpToIso_hom_comp

/- warning: category_theory.limits.limit.cone_point_unique_up_to_iso_inv_comp -> CategoryTheory.Limits.limit.conePointUniqueUpToIso_inv_comp is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {C : Type.{u4}} [_inst_3 : CategoryTheory.Category.{u3, u4} C] {F : CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3} [_inst_4 : CategoryTheory.Limits.HasLimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F] {c : CategoryTheory.Limits.Cone.{u1, u3, u2, u4} J _inst_1 C _inst_3 F} (hc : CategoryTheory.Limits.IsLimit.{u1, u3, u2, u4} J _inst_1 C _inst_3 F c) (j : J), Eq.{succ u3} (Quiver.Hom.{succ u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Limits.Cone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 F c) (CategoryTheory.Functor.obj.{u1, u3, u2, u4} J _inst_1 C _inst_3 F j)) (CategoryTheory.CategoryStruct.comp.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3) (CategoryTheory.Limits.Cone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 F c) (CategoryTheory.Limits.Cone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 F (CategoryTheory.Limits.limit.cone.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4)) (CategoryTheory.Functor.obj.{u1, u3, u2, u4} J _inst_1 C _inst_3 F j) (CategoryTheory.Iso.inv.{u3, u4} C _inst_3 (CategoryTheory.Limits.Cone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 F (CategoryTheory.Limits.limit.cone.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4)) (CategoryTheory.Limits.Cone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 F c) (CategoryTheory.Limits.IsLimit.conePointUniqueUpToIso.{u1, u3, u2, u4} J _inst_1 C _inst_3 F (CategoryTheory.Limits.limit.cone.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4) c (CategoryTheory.Limits.limit.isLimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4) hc)) (CategoryTheory.Limits.limit.œÄ.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4 j)) (CategoryTheory.NatTrans.app.{u1, u3, u2, u4} J _inst_1 C _inst_3 (CategoryTheory.Functor.obj.{u3, max u2 u3, u4, max u1 u3 u2 u4} C _inst_3 (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.const.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Limits.Cone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 F c)) F (CategoryTheory.Limits.Cone.œÄ.{u1, u3, u2, u4} J _inst_1 C _inst_3 F c) j)
but is expected to have type
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {C : Type.{u4}} [_inst_3 : CategoryTheory.Category.{u3, u4} C] {F : CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3} [_inst_4 : CategoryTheory.Limits.HasLimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F] {c : CategoryTheory.Limits.Cone.{u1, u3, u2, u4} J _inst_1 C _inst_3 F} (hc : CategoryTheory.Limits.IsLimit.{u1, u3, u2, u4} J _inst_1 C _inst_3 F c) (j : J), Eq.{succ u3} (Quiver.Hom.{succ u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Limits.Cone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 F c) (Prefunctor.obj.{succ u1, succ u3, u2, u4} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, u4} J _inst_1 C _inst_3 F) j)) (CategoryTheory.CategoryStruct.comp.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3) (CategoryTheory.Limits.Cone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 F c) (CategoryTheory.Limits.Cone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 F (CategoryTheory.Limits.limit.cone.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4)) (Prefunctor.obj.{succ u1, succ u3, u2, u4} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, u4} J _inst_1 C _inst_3 F) j) (CategoryTheory.Iso.inv.{u3, u4} C _inst_3 (CategoryTheory.Limits.Cone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 F (CategoryTheory.Limits.limit.cone.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4)) (CategoryTheory.Limits.Cone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 F c) (CategoryTheory.Limits.IsLimit.conePointUniqueUpToIso.{u1, u3, u2, u4} J _inst_1 C _inst_3 F (CategoryTheory.Limits.limit.cone.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4) c (CategoryTheory.Limits.limit.isLimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4) hc)) (CategoryTheory.Limits.limit.œÄ.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4 j)) (CategoryTheory.NatTrans.app.{u1, u3, u2, u4} J _inst_1 C _inst_3 (Prefunctor.obj.{succ u3, max (succ u2) (succ u3), u4, max (max (max u2 u1) u3) u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u3, max (max (max u2 u1) u4) u3} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Category.toCategoryStruct.{max u2 u3, max (max (max u2 u1) u4) u3} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3))) (CategoryTheory.Functor.toPrefunctor.{u3, max u2 u3, u4, max (max (max u2 u1) u4) u3} C _inst_3 (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.const.{u1, u3, u2, u4} J _inst_1 C _inst_3)) (CategoryTheory.Limits.Cone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 F c)) F (CategoryTheory.Limits.Cone.œÄ.{u1, u3, u2, u4} J _inst_1 C _inst_3 F c) j)
Case conversion may be inaccurate. Consider using '#align category_theory.limits.limit.cone_point_unique_up_to_iso_inv_comp CategoryTheory.Limits.limit.conePointUniqueUpToIso_inv_comp‚Çì'. -/
@[simp, reassoc.1]
theorem limit.conePointUniqueUpToIso_inv_comp {F : J ‚•§ C} [HasLimit F] {c : Cone F} (hc : IsLimit c)
    (j : J) : (IsLimit.conePointUniqueUpToIso (limit.isLimit _) hc).inv ‚â´ limit.œÄ F j = c.œÄ.app j :=
  IsLimit.conePointUniqueUpToIso_inv_comp _ _ _
#align category_theory.limits.limit.cone_point_unique_up_to_iso_inv_comp CategoryTheory.Limits.limit.conePointUniqueUpToIso_inv_comp

/- warning: category_theory.limits.limit.exists_unique -> CategoryTheory.Limits.limit.existsUnique is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {C : Type.{u4}} [_inst_3 : CategoryTheory.Category.{u3, u4} C] {F : CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3} [_inst_4 : CategoryTheory.Limits.HasLimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F] (t : CategoryTheory.Limits.Cone.{u1, u3, u2, u4} J _inst_1 C _inst_3 F), ExistsUnique.{succ u3} (Quiver.Hom.{succ u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Limits.Cone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 F t) (CategoryTheory.Limits.limit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4)) (fun (l : Quiver.Hom.{succ u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Limits.Cone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 F t) (CategoryTheory.Limits.limit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4)) => forall (j : J), Eq.{succ u3} (Quiver.Hom.{succ u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Limits.Cone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 F t) (CategoryTheory.Functor.obj.{u1, u3, u2, u4} J _inst_1 C _inst_3 F j)) (CategoryTheory.CategoryStruct.comp.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3) (CategoryTheory.Limits.Cone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 F t) (CategoryTheory.Limits.limit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4) (CategoryTheory.Functor.obj.{u1, u3, u2, u4} J _inst_1 C _inst_3 F j) l (CategoryTheory.Limits.limit.œÄ.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4 j)) (CategoryTheory.NatTrans.app.{u1, u3, u2, u4} J _inst_1 C _inst_3 (CategoryTheory.Functor.obj.{u3, max u2 u3, u4, max u1 u3 u2 u4} C _inst_3 (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.const.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Limits.Cone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 F t)) F (CategoryTheory.Limits.Cone.œÄ.{u1, u3, u2, u4} J _inst_1 C _inst_3 F t) j))
but is expected to have type
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {C : Type.{u4}} [_inst_3 : CategoryTheory.Category.{u3, u4} C] {F : CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3} [_inst_4 : CategoryTheory.Limits.HasLimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F] (t : CategoryTheory.Limits.Cone.{u1, u3, u2, u4} J _inst_1 C _inst_3 F), ExistsUnique.{succ u3} (Quiver.Hom.{succ u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Limits.Cone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 F t) (CategoryTheory.Limits.limit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4)) (fun (l : Quiver.Hom.{succ u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Limits.Cone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 F t) (CategoryTheory.Limits.limit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4)) => forall (j : J), Eq.{succ u3} (Quiver.Hom.{succ u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Limits.Cone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 F t) (Prefunctor.obj.{succ u1, succ u3, u2, u4} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, u4} J _inst_1 C _inst_3 F) j)) (CategoryTheory.CategoryStruct.comp.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3) (CategoryTheory.Limits.Cone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 F t) (CategoryTheory.Limits.limit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4) (Prefunctor.obj.{succ u1, succ u3, u2, u4} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, u4} J _inst_1 C _inst_3 F) j) l (CategoryTheory.Limits.limit.œÄ.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4 j)) (CategoryTheory.NatTrans.app.{u1, u3, u2, u4} J _inst_1 C _inst_3 (Prefunctor.obj.{succ u3, max (succ u2) (succ u3), u4, max (max (max u2 u1) u3) u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u3, max (max (max u2 u1) u4) u3} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Category.toCategoryStruct.{max u2 u3, max (max (max u2 u1) u4) u3} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3))) (CategoryTheory.Functor.toPrefunctor.{u3, max u2 u3, u4, max (max (max u2 u1) u4) u3} C _inst_3 (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.const.{u1, u3, u2, u4} J _inst_1 C _inst_3)) (CategoryTheory.Limits.Cone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 F t)) F (CategoryTheory.Limits.Cone.œÄ.{u1, u3, u2, u4} J _inst_1 C _inst_3 F t) j))
Case conversion may be inaccurate. Consider using '#align category_theory.limits.limit.exists_unique CategoryTheory.Limits.limit.existsUnique‚Çì'. -/
theorem limit.existsUnique {F : J ‚•§ C} [HasLimit F] (t : Cone F) :
    ‚àÉ! l : t.pt ‚ü∂ limit F, ‚àÄ j, l ‚â´ limit.œÄ F j = t.œÄ.app j :=
  (limit.isLimit F).ExistsUnique _
#align category_theory.limits.limit.exists_unique CategoryTheory.Limits.limit.existsUnique

#print CategoryTheory.Limits.limit.isoLimitCone /-
/-- Given any other limit cone for `F`, the chosen `limit F` is isomorphic to the cone point.
-/
def limit.isoLimitCone {F : J ‚•§ C} [HasLimit F] (t : LimitCone F) : limit F ‚âÖ t.Cone.pt :=
  IsLimit.conePointUniqueUpToIso (limit.isLimit F) t.IsLimit
#align category_theory.limits.limit.iso_limit_cone CategoryTheory.Limits.limit.isoLimitCone
-/

/- warning: category_theory.limits.limit.iso_limit_cone_hom_œÄ -> CategoryTheory.Limits.limit.isoLimitCone_hom_œÄ is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {C : Type.{u4}} [_inst_3 : CategoryTheory.Category.{u3, u4} C] {F : CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3} [_inst_4 : CategoryTheory.Limits.HasLimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F] (t : CategoryTheory.Limits.LimitCone.{u1, u2, u3, u4} J _inst_1 C _inst_3 F) (j : J), Eq.{succ u3} (Quiver.Hom.{succ u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Limits.limit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4) (CategoryTheory.Functor.obj.{u1, u3, u2, u4} J _inst_1 C _inst_3 F j)) (CategoryTheory.CategoryStruct.comp.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3) (CategoryTheory.Limits.limit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4) (CategoryTheory.Limits.Cone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 F (CategoryTheory.Limits.LimitCone.cone.{u1, u2, u3, u4} J _inst_1 C _inst_3 F t)) (CategoryTheory.Functor.obj.{u1, u3, u2, u4} J _inst_1 C _inst_3 F j) (CategoryTheory.Iso.hom.{u3, u4} C _inst_3 (CategoryTheory.Limits.limit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4) (CategoryTheory.Limits.Cone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 F (CategoryTheory.Limits.LimitCone.cone.{u1, u2, u3, u4} J _inst_1 C _inst_3 F t)) (CategoryTheory.Limits.limit.isoLimitCone.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4 t)) (CategoryTheory.NatTrans.app.{u1, u3, u2, u4} J _inst_1 C _inst_3 (CategoryTheory.Functor.obj.{u3, max u2 u3, u4, max u1 u3 u2 u4} C _inst_3 (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.const.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Limits.Cone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 F (CategoryTheory.Limits.LimitCone.cone.{u1, u2, u3, u4} J _inst_1 C _inst_3 F t))) F (CategoryTheory.Limits.Cone.œÄ.{u1, u3, u2, u4} J _inst_1 C _inst_3 F (CategoryTheory.Limits.LimitCone.cone.{u1, u2, u3, u4} J _inst_1 C _inst_3 F t)) j)) (CategoryTheory.Limits.limit.œÄ.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4 j)
but is expected to have type
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {C : Type.{u4}} [_inst_3 : CategoryTheory.Category.{u3, u4} C] {F : CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3} [_inst_4 : CategoryTheory.Limits.HasLimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F] (t : CategoryTheory.Limits.LimitCone.{u1, u2, u3, u4} J _inst_1 C _inst_3 F) (j : J), Eq.{succ u3} (Quiver.Hom.{succ u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Limits.limit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4) (Prefunctor.obj.{succ u1, succ u3, u2, u4} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, u4} J _inst_1 C _inst_3 F) j)) (CategoryTheory.CategoryStruct.comp.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3) (CategoryTheory.Limits.limit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4) (CategoryTheory.Limits.Cone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 F (CategoryTheory.Limits.LimitCone.cone.{u1, u2, u3, u4} J _inst_1 C _inst_3 F t)) (Prefunctor.obj.{succ u1, succ u3, u2, u4} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, u4} J _inst_1 C _inst_3 F) j) (CategoryTheory.Iso.hom.{u3, u4} C _inst_3 (CategoryTheory.Limits.limit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4) (CategoryTheory.Limits.Cone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 F (CategoryTheory.Limits.LimitCone.cone.{u1, u2, u3, u4} J _inst_1 C _inst_3 F t)) (CategoryTheory.Limits.limit.isoLimitCone.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4 t)) (CategoryTheory.NatTrans.app.{u1, u3, u2, u4} J _inst_1 C _inst_3 (Prefunctor.obj.{succ u3, max (succ u2) (succ u3), u4, max (max (max u2 u1) u3) u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u3, max (max (max u2 u1) u4) u3} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Category.toCategoryStruct.{max u2 u3, max (max (max u2 u1) u4) u3} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3))) (CategoryTheory.Functor.toPrefunctor.{u3, max u2 u3, u4, max (max (max u2 u1) u4) u3} C _inst_3 (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.const.{u1, u3, u2, u4} J _inst_1 C _inst_3)) (CategoryTheory.Limits.Cone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 F (CategoryTheory.Limits.LimitCone.cone.{u1, u2, u3, u4} J _inst_1 C _inst_3 F t))) F (CategoryTheory.Limits.Cone.œÄ.{u1, u3, u2, u4} J _inst_1 C _inst_3 F (CategoryTheory.Limits.LimitCone.cone.{u1, u2, u3, u4} J _inst_1 C _inst_3 F t)) j)) (CategoryTheory.Limits.limit.œÄ.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4 j)
Case conversion may be inaccurate. Consider using '#align category_theory.limits.limit.iso_limit_cone_hom_œÄ CategoryTheory.Limits.limit.isoLimitCone_hom_œÄ‚Çì'. -/
@[simp, reassoc.1]
theorem limit.isoLimitCone_hom_œÄ {F : J ‚•§ C} [HasLimit F] (t : LimitCone F) (j : J) :
    (limit.isoLimitCone t).Hom ‚â´ t.Cone.œÄ.app j = limit.œÄ F j :=
  by
  dsimp [limit.iso_limit_cone, is_limit.cone_point_unique_up_to_iso]
  tidy
#align category_theory.limits.limit.iso_limit_cone_hom_œÄ CategoryTheory.Limits.limit.isoLimitCone_hom_œÄ

/- warning: category_theory.limits.limit.iso_limit_cone_inv_œÄ -> CategoryTheory.Limits.limit.isoLimitCone_inv_œÄ is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {C : Type.{u4}} [_inst_3 : CategoryTheory.Category.{u3, u4} C] {F : CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3} [_inst_4 : CategoryTheory.Limits.HasLimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F] (t : CategoryTheory.Limits.LimitCone.{u1, u2, u3, u4} J _inst_1 C _inst_3 F) (j : J), Eq.{succ u3} (Quiver.Hom.{succ u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Limits.Cone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 F (CategoryTheory.Limits.LimitCone.cone.{u1, u2, u3, u4} J _inst_1 C _inst_3 F t)) (CategoryTheory.Functor.obj.{u1, u3, u2, u4} J _inst_1 C _inst_3 F j)) (CategoryTheory.CategoryStruct.comp.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3) (CategoryTheory.Limits.Cone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 F (CategoryTheory.Limits.LimitCone.cone.{u1, u2, u3, u4} J _inst_1 C _inst_3 F t)) (CategoryTheory.Limits.limit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4) (CategoryTheory.Functor.obj.{u1, u3, u2, u4} J _inst_1 C _inst_3 F j) (CategoryTheory.Iso.inv.{u3, u4} C _inst_3 (CategoryTheory.Limits.limit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4) (CategoryTheory.Limits.Cone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 F (CategoryTheory.Limits.LimitCone.cone.{u1, u2, u3, u4} J _inst_1 C _inst_3 F t)) (CategoryTheory.Limits.limit.isoLimitCone.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4 t)) (CategoryTheory.Limits.limit.œÄ.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4 j)) (CategoryTheory.NatTrans.app.{u1, u3, u2, u4} J _inst_1 C _inst_3 (CategoryTheory.Functor.obj.{u3, max u2 u3, u4, max u1 u3 u2 u4} C _inst_3 (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.const.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Limits.Cone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 F (CategoryTheory.Limits.LimitCone.cone.{u1, u2, u3, u4} J _inst_1 C _inst_3 F t))) F (CategoryTheory.Limits.Cone.œÄ.{u1, u3, u2, u4} J _inst_1 C _inst_3 F (CategoryTheory.Limits.LimitCone.cone.{u1, u2, u3, u4} J _inst_1 C _inst_3 F t)) j)
but is expected to have type
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {C : Type.{u4}} [_inst_3 : CategoryTheory.Category.{u3, u4} C] {F : CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3} [_inst_4 : CategoryTheory.Limits.HasLimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F] (t : CategoryTheory.Limits.LimitCone.{u1, u2, u3, u4} J _inst_1 C _inst_3 F) (j : J), Eq.{succ u3} (Quiver.Hom.{succ u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Limits.Cone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 F (CategoryTheory.Limits.LimitCone.cone.{u1, u2, u3, u4} J _inst_1 C _inst_3 F t)) (Prefunctor.obj.{succ u1, succ u3, u2, u4} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, u4} J _inst_1 C _inst_3 F) j)) (CategoryTheory.CategoryStruct.comp.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3) (CategoryTheory.Limits.Cone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 F (CategoryTheory.Limits.LimitCone.cone.{u1, u2, u3, u4} J _inst_1 C _inst_3 F t)) (CategoryTheory.Limits.limit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4) (Prefunctor.obj.{succ u1, succ u3, u2, u4} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, u4} J _inst_1 C _inst_3 F) j) (CategoryTheory.Iso.inv.{u3, u4} C _inst_3 (CategoryTheory.Limits.limit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4) (CategoryTheory.Limits.Cone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 F (CategoryTheory.Limits.LimitCone.cone.{u1, u2, u3, u4} J _inst_1 C _inst_3 F t)) (CategoryTheory.Limits.limit.isoLimitCone.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4 t)) (CategoryTheory.Limits.limit.œÄ.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4 j)) (CategoryTheory.NatTrans.app.{u1, u3, u2, u4} J _inst_1 C _inst_3 (Prefunctor.obj.{succ u3, max (succ u2) (succ u3), u4, max (max (max u2 u1) u3) u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u3, max (max (max u2 u1) u4) u3} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Category.toCategoryStruct.{max u2 u3, max (max (max u2 u1) u4) u3} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3))) (CategoryTheory.Functor.toPrefunctor.{u3, max u2 u3, u4, max (max (max u2 u1) u4) u3} C _inst_3 (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.const.{u1, u3, u2, u4} J _inst_1 C _inst_3)) (CategoryTheory.Limits.Cone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 F (CategoryTheory.Limits.LimitCone.cone.{u1, u2, u3, u4} J _inst_1 C _inst_3 F t))) F (CategoryTheory.Limits.Cone.œÄ.{u1, u3, u2, u4} J _inst_1 C _inst_3 F (CategoryTheory.Limits.LimitCone.cone.{u1, u2, u3, u4} J _inst_1 C _inst_3 F t)) j)
Case conversion may be inaccurate. Consider using '#align category_theory.limits.limit.iso_limit_cone_inv_œÄ CategoryTheory.Limits.limit.isoLimitCone_inv_œÄ‚Çì'. -/
@[simp, reassoc.1]
theorem limit.isoLimitCone_inv_œÄ {F : J ‚•§ C} [HasLimit F] (t : LimitCone F) (j : J) :
    (limit.isoLimitCone t).inv ‚â´ limit.œÄ F j = t.Cone.œÄ.app j :=
  by
  dsimp [limit.iso_limit_cone, is_limit.cone_point_unique_up_to_iso]
  tidy
#align category_theory.limits.limit.iso_limit_cone_inv_œÄ CategoryTheory.Limits.limit.isoLimitCone_inv_œÄ

/- warning: category_theory.limits.limit.hom_ext -> CategoryTheory.Limits.limit.hom_ext is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {C : Type.{u4}} [_inst_3 : CategoryTheory.Category.{u3, u4} C] {F : CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3} [_inst_4 : CategoryTheory.Limits.HasLimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F] {X : C} {f : Quiver.Hom.{succ u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) X (CategoryTheory.Limits.limit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4)} {f' : Quiver.Hom.{succ u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) X (CategoryTheory.Limits.limit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4)}, (forall (j : J), Eq.{succ u3} (Quiver.Hom.{succ u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) X (CategoryTheory.Functor.obj.{u1, u3, u2, u4} J _inst_1 C _inst_3 F j)) (CategoryTheory.CategoryStruct.comp.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3) X (CategoryTheory.Limits.limit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4) (CategoryTheory.Functor.obj.{u1, u3, u2, u4} J _inst_1 C _inst_3 F j) f (CategoryTheory.Limits.limit.œÄ.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4 j)) (CategoryTheory.CategoryStruct.comp.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3) X (CategoryTheory.Limits.limit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4) (CategoryTheory.Functor.obj.{u1, u3, u2, u4} J _inst_1 C _inst_3 F j) f' (CategoryTheory.Limits.limit.œÄ.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4 j))) -> (Eq.{succ u3} (Quiver.Hom.{succ u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) X (CategoryTheory.Limits.limit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4)) f f')
but is expected to have type
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {C : Type.{u4}} [_inst_3 : CategoryTheory.Category.{u3, u4} C] {F : CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3} [_inst_4 : CategoryTheory.Limits.HasLimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F] {X : C} {f : Quiver.Hom.{succ u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) X (CategoryTheory.Limits.limit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4)} {f' : Quiver.Hom.{succ u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) X (CategoryTheory.Limits.limit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4)}, (forall (j : J), Eq.{succ u3} (Quiver.Hom.{succ u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) X (Prefunctor.obj.{succ u1, succ u3, u2, u4} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, u4} J _inst_1 C _inst_3 F) j)) (CategoryTheory.CategoryStruct.comp.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3) X (CategoryTheory.Limits.limit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4) (Prefunctor.obj.{succ u1, succ u3, u2, u4} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, u4} J _inst_1 C _inst_3 F) j) f (CategoryTheory.Limits.limit.œÄ.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4 j)) (CategoryTheory.CategoryStruct.comp.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3) X (CategoryTheory.Limits.limit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4) (Prefunctor.obj.{succ u1, succ u3, u2, u4} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, u4} J _inst_1 C _inst_3 F) j) f' (CategoryTheory.Limits.limit.œÄ.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4 j))) -> (Eq.{succ u3} (Quiver.Hom.{succ u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) X (CategoryTheory.Limits.limit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4)) f f')
Case conversion may be inaccurate. Consider using '#align category_theory.limits.limit.hom_ext CategoryTheory.Limits.limit.hom_ext‚Çì'. -/
@[ext]
theorem limit.hom_ext {F : J ‚•§ C} [HasLimit F] {X : C} {f f' : X ‚ü∂ limit F}
    (w : ‚àÄ j, f ‚â´ limit.œÄ F j = f' ‚â´ limit.œÄ F j) : f = f' :=
  (limit.isLimit F).hom_ext w
#align category_theory.limits.limit.hom_ext CategoryTheory.Limits.limit.hom_ext

/- warning: category_theory.limits.limit.lift_map -> CategoryTheory.Limits.limit.lift_map is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {C : Type.{u4}} [_inst_3 : CategoryTheory.Category.{u3, u4} C] {F : CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3} {G : CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3} [_inst_4 : CategoryTheory.Limits.HasLimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F] [_inst_5 : CategoryTheory.Limits.HasLimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 G] (c : CategoryTheory.Limits.Cone.{u1, u3, u2, u4} J _inst_1 C _inst_3 F) (Œ± : Quiver.Hom.{succ (max u2 u3), max u1 u3 u2 u4} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u3, max u1 u3 u2 u4} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Category.toCategoryStruct.{max u2 u3, max u1 u3 u2 u4} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3))) F G), Eq.{succ u3} (Quiver.Hom.{succ u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Limits.Cone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 F c) (CategoryTheory.Limits.limit.{u1, u2, u3, u4} J _inst_1 C _inst_3 G _inst_5)) (CategoryTheory.CategoryStruct.comp.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3) (CategoryTheory.Limits.Cone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 F c) (CategoryTheory.Limits.limit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4) (CategoryTheory.Limits.limit.{u1, u2, u3, u4} J _inst_1 C _inst_3 G _inst_5) (CategoryTheory.Limits.limit.lift.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4 c) (CategoryTheory.Limits.limMap.{u1, u2, u3, u4} J _inst_1 C _inst_3 F G _inst_4 _inst_5 Œ±)) (CategoryTheory.Limits.limit.lift.{u1, u2, u3, u4} J _inst_1 C _inst_3 G _inst_5 (CategoryTheory.Functor.obj.{u3, u3, max u2 u4 u3, max u2 u4 u3} (CategoryTheory.Limits.Cone.{u1, u3, u2, u4} J _inst_1 C _inst_3 F) (CategoryTheory.Limits.Cone.category.{u1, u3, u2, u4} J _inst_1 C _inst_3 F) (CategoryTheory.Limits.Cone.{u1, u3, u2, u4} J _inst_1 C _inst_3 G) (CategoryTheory.Limits.Cone.category.{u1, u3, u2, u4} J _inst_1 C _inst_3 G) (CategoryTheory.Limits.Cones.postcompose.{u1, u3, u2, u4} J _inst_1 C _inst_3 F G Œ±) c))
but is expected to have type
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {C : Type.{u4}} [_inst_3 : CategoryTheory.Category.{u3, u4} C] {F : CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3} {G : CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3} [_inst_4 : CategoryTheory.Limits.HasLimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F] [_inst_5 : CategoryTheory.Limits.HasLimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 G] (c : CategoryTheory.Limits.Cone.{u1, u3, u2, u4} J _inst_1 C _inst_3 F) (Œ± : Quiver.Hom.{max (succ u2) (succ u3), max (max (max u4 u2) u3) u1} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u3, max (max (max u4 u2) u3) u1} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Category.toCategoryStruct.{max u2 u3, max (max (max u4 u2) u3) u1} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3))) F G), Eq.{succ u3} (Quiver.Hom.{succ u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Limits.Cone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 F c) (CategoryTheory.Limits.limit.{u1, u2, u3, u4} J _inst_1 C _inst_3 G _inst_5)) (CategoryTheory.CategoryStruct.comp.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3) (CategoryTheory.Limits.Cone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 F c) (CategoryTheory.Limits.limit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4) (CategoryTheory.Limits.limit.{u1, u2, u3, u4} J _inst_1 C _inst_3 G _inst_5) (CategoryTheory.Limits.limit.lift.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4 c) (CategoryTheory.Limits.limMap.{u1, u2, u3, u4} J _inst_1 C _inst_3 F G _inst_4 _inst_5 Œ±)) (CategoryTheory.Limits.limit.lift.{u1, u2, u3, u4} J _inst_1 C _inst_3 G _inst_5 (Prefunctor.obj.{succ u3, succ u3, max (max u4 u2) u3, max (max u4 u2) u3} (CategoryTheory.Limits.Cone.{u1, u3, u2, u4} J _inst_1 C _inst_3 F) (CategoryTheory.CategoryStruct.toQuiver.{u3, max (max u4 u2) u3} (CategoryTheory.Limits.Cone.{u1, u3, u2, u4} J _inst_1 C _inst_3 F) (CategoryTheory.Category.toCategoryStruct.{u3, max (max u4 u2) u3} (CategoryTheory.Limits.Cone.{u1, u3, u2, u4} J _inst_1 C _inst_3 F) (CategoryTheory.Limits.Cone.category.{u1, u3, u2, u4} J _inst_1 C _inst_3 F))) (CategoryTheory.Limits.Cone.{u1, u3, u2, u4} J _inst_1 C _inst_3 G) (CategoryTheory.CategoryStruct.toQuiver.{u3, max (max u4 u2) u3} (CategoryTheory.Limits.Cone.{u1, u3, u2, u4} J _inst_1 C _inst_3 G) (CategoryTheory.Category.toCategoryStruct.{u3, max (max u4 u2) u3} (CategoryTheory.Limits.Cone.{u1, u3, u2, u4} J _inst_1 C _inst_3 G) (CategoryTheory.Limits.Cone.category.{u1, u3, u2, u4} J _inst_1 C _inst_3 G))) (CategoryTheory.Functor.toPrefunctor.{u3, u3, max (max u4 u2) u3, max (max u4 u2) u3} (CategoryTheory.Limits.Cone.{u1, u3, u2, u4} J _inst_1 C _inst_3 F) (CategoryTheory.Limits.Cone.category.{u1, u3, u2, u4} J _inst_1 C _inst_3 F) (CategoryTheory.Limits.Cone.{u1, u3, u2, u4} J _inst_1 C _inst_3 G) (CategoryTheory.Limits.Cone.category.{u1, u3, u2, u4} J _inst_1 C _inst_3 G) (CategoryTheory.Limits.Cones.postcompose.{u1, u3, u2, u4} J _inst_1 C _inst_3 F G Œ±)) c))
Case conversion may be inaccurate. Consider using '#align category_theory.limits.limit.lift_map CategoryTheory.Limits.limit.lift_map‚Çì'. -/
@[simp]
theorem limit.lift_map {F G : J ‚•§ C} [HasLimit F] [HasLimit G] (c : Cone F) (Œ± : F ‚ü∂ G) :
    limit.lift F c ‚â´ limMap Œ± = limit.lift G ((Cones.postcompose Œ±).obj c) :=
  by
  ext
  rw [assoc, lim_map_œÄ, limit.lift_œÄ_assoc, limit.lift_œÄ]
  rfl
#align category_theory.limits.limit.lift_map CategoryTheory.Limits.limit.lift_map

#print CategoryTheory.Limits.limit.lift_cone /-
@[simp]
theorem limit.lift_cone {F : J ‚•§ C} [HasLimit F] : limit.lift F (limit.cone F) = ùüô (limit F) :=
  (limit.isLimit _).lift_self
#align category_theory.limits.limit.lift_cone CategoryTheory.Limits.limit.lift_cone
-/

/- warning: category_theory.limits.limit.hom_iso -> CategoryTheory.Limits.limit.homIso is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {C : Type.{u4}} [_inst_3 : CategoryTheory.Category.{u3, u4} C] (F : CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) [_inst_4 : CategoryTheory.Limits.HasLimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F] (W : C), CategoryTheory.Iso.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (ULift.{u2, u3} (Quiver.Hom.{succ u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) W (CategoryTheory.Limits.limit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4))) (CategoryTheory.Functor.obj.{u3, max u2 u3, u4, succ (max u2 u3)} (Opposite.{succ u4} C) (CategoryTheory.Category.opposite.{u3, u4} C _inst_3) Type.{max u2 u3} CategoryTheory.types.{max u2 u3} (CategoryTheory.Functor.cones.{u1, u3, u2, u4} J _inst_1 C _inst_3 F) (Opposite.op.{succ u4} C W))
but is expected to have type
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {C : Type.{u4}} [_inst_3 : CategoryTheory.Category.{u3, u4} C] (F : CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) [_inst_4 : CategoryTheory.Limits.HasLimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F] (W : C), CategoryTheory.Iso.{max u2 u3, max (succ u2) (succ u3)} Type.{max u3 u2} CategoryTheory.types.{max u2 u3} (ULift.{u2, u3} (Quiver.Hom.{succ u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) W (CategoryTheory.Limits.limit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4))) (Prefunctor.obj.{succ u3, max (succ u2) (succ u3), u4, max (succ u2) (succ u3)} (Opposite.{succ u4} C) (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} (Opposite.{succ u4} C) (CategoryTheory.Category.toCategoryStruct.{u3, u4} (Opposite.{succ u4} C) (CategoryTheory.Category.opposite.{u3, u4} C _inst_3))) Type.{max u2 u3} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u3, max (succ u2) (succ u3)} Type.{max u2 u3} (CategoryTheory.Category.toCategoryStruct.{max u2 u3, max (succ u2) (succ u3)} Type.{max u2 u3} CategoryTheory.types.{max u2 u3})) (CategoryTheory.Functor.toPrefunctor.{u3, max u2 u3, u4, max (succ u2) (succ u3)} (Opposite.{succ u4} C) (CategoryTheory.Category.opposite.{u3, u4} C _inst_3) Type.{max u2 u3} CategoryTheory.types.{max u2 u3} (CategoryTheory.Functor.cones.{u1, u3, u2, u4} J _inst_1 C _inst_3 F)) (Opposite.op.{succ u4} C W))
Case conversion may be inaccurate. Consider using '#align category_theory.limits.limit.hom_iso CategoryTheory.Limits.limit.homIso‚Çì'. -/
/-- The isomorphism (in `Type`) between
morphisms from a specified object `W` to the limit object,
and cones with cone point `W`.
-/
def limit.homIso (F : J ‚•§ C) [HasLimit F] (W : C) :
    ULift.{u‚ÇÅ} (W ‚ü∂ limit F : Type v) ‚âÖ F.cones.obj (op W) :=
  (limit.isLimit F).homIso W
#align category_theory.limits.limit.hom_iso CategoryTheory.Limits.limit.homIso

/- warning: category_theory.limits.limit.hom_iso_hom -> CategoryTheory.Limits.limit.homIso_hom is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {C : Type.{u4}} [_inst_3 : CategoryTheory.Category.{u3, u4} C] (F : CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) [_inst_4 : CategoryTheory.Limits.HasLimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F] {W : C} (f : ULift.{u2, u3} (Quiver.Hom.{succ u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) W (CategoryTheory.Limits.limit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4))), Eq.{succ (max u2 u3)} (CategoryTheory.Functor.obj.{u3, max u2 u3, u4, succ (max u2 u3)} (Opposite.{succ u4} C) (CategoryTheory.Category.opposite.{u3, u4} C _inst_3) Type.{max u2 u3} CategoryTheory.types.{max u2 u3} (CategoryTheory.Functor.cones.{u1, u3, u2, u4} J _inst_1 C _inst_3 F) (Opposite.op.{succ u4} C W)) (CategoryTheory.Iso.hom.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (ULift.{u2, u3} (Quiver.Hom.{succ u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) W (CategoryTheory.Limits.limit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4))) (CategoryTheory.Functor.obj.{u3, max u2 u3, u4, succ (max u2 u3)} (Opposite.{succ u4} C) (CategoryTheory.Category.opposite.{u3, u4} C _inst_3) Type.{max u2 u3} CategoryTheory.types.{max u2 u3} (CategoryTheory.Functor.cones.{u1, u3, u2, u4} J _inst_1 C _inst_3 F) (Opposite.op.{succ u4} C W)) (CategoryTheory.Limits.limit.homIso.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4 W) f) (CategoryTheory.CategoryStruct.comp.{max u2 u3, max u1 u3 u2 u4} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Category.toCategoryStruct.{max u2 u3, max u1 u3 u2 u4} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3)) (Opposite.unop.{succ (max u1 u3 u2 u4)} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.obj.{u3, max u2 u3, u4, max u1 u3 u2 u4} (Opposite.{succ u4} C) (CategoryTheory.Category.opposite.{u3, u4} C _inst_3) (Opposite.{succ (max u1 u3 u2 u4)} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3)) (CategoryTheory.Category.opposite.{max u2 u3, max u1 u3 u2 u4} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3)) (CategoryTheory.Functor.op.{u3, max u2 u3, u4, max u1 u3 u2 u4} C _inst_3 (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.const.{u1, u3, u2, u4} J _inst_1 C _inst_3)) (Opposite.op.{succ u4} C W))) (CategoryTheory.Functor.obj.{u3, max u2 u3, u4, max u1 u3 u2 u4} C _inst_3 (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.const.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Limits.limit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4)) F (CategoryTheory.Functor.map.{u3, max u2 u3, u4, max u1 u3 u2 u4} C _inst_3 (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.const.{u1, u3, u2, u4} J _inst_1 C _inst_3) (Opposite.unop.{succ u4} C (Opposite.op.{succ u4} C W)) (CategoryTheory.Limits.limit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4) (ULift.down.{u2, u3} (Quiver.Hom.{succ u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) W (CategoryTheory.Limits.limit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4)) f)) (CategoryTheory.Limits.Cone.œÄ.{u1, u3, u2, u4} J _inst_1 C _inst_3 F (CategoryTheory.Limits.limit.cone.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4)))
but is expected to have type
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {C : Type.{u4}} [_inst_3 : CategoryTheory.Category.{u3, u4} C] (F : CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) [_inst_4 : CategoryTheory.Limits.HasLimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F] {W : C} (f : ULift.{u2, u3} (Quiver.Hom.{succ u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) W (CategoryTheory.Limits.limit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4))), Eq.{max (succ u2) (succ u3)} (Prefunctor.obj.{succ u3, max (succ u2) (succ u3), u4, max (succ u2) (succ u3)} (Opposite.{succ u4} C) (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} (Opposite.{succ u4} C) (CategoryTheory.Category.toCategoryStruct.{u3, u4} (Opposite.{succ u4} C) (CategoryTheory.Category.opposite.{u3, u4} C _inst_3))) Type.{max u2 u3} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u3, max (succ u2) (succ u3)} Type.{max u2 u3} (CategoryTheory.Category.toCategoryStruct.{max u2 u3, max (succ u2) (succ u3)} Type.{max u2 u3} CategoryTheory.types.{max u2 u3})) (CategoryTheory.Functor.toPrefunctor.{u3, max u2 u3, u4, max (succ u2) (succ u3)} (Opposite.{succ u4} C) (CategoryTheory.Category.opposite.{u3, u4} C _inst_3) Type.{max u2 u3} CategoryTheory.types.{max u2 u3} (CategoryTheory.Functor.cones.{u1, u3, u2, u4} J _inst_1 C _inst_3 F)) (Opposite.op.{succ u4} C W)) (CategoryTheory.Iso.hom.{max u2 u3, max (succ u2) (succ u3)} Type.{max u3 u2} CategoryTheory.types.{max u2 u3} (ULift.{u2, u3} (Quiver.Hom.{succ u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) W (CategoryTheory.Limits.limit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4))) (Prefunctor.obj.{succ u3, max (succ u2) (succ u3), u4, max (succ u2) (succ u3)} (Opposite.{succ u4} C) (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} (Opposite.{succ u4} C) (CategoryTheory.Category.toCategoryStruct.{u3, u4} (Opposite.{succ u4} C) (CategoryTheory.Category.opposite.{u3, u4} C _inst_3))) Type.{max u2 u3} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u3, max (succ u2) (succ u3)} Type.{max u2 u3} (CategoryTheory.Category.toCategoryStruct.{max u2 u3, max (succ u2) (succ u3)} Type.{max u2 u3} CategoryTheory.types.{max u2 u3})) (CategoryTheory.Functor.toPrefunctor.{u3, max u2 u3, u4, max (succ u2) (succ u3)} (Opposite.{succ u4} C) (CategoryTheory.Category.opposite.{u3, u4} C _inst_3) Type.{max u2 u3} CategoryTheory.types.{max u2 u3} (CategoryTheory.Functor.cones.{u1, u3, u2, u4} J _inst_1 C _inst_3 F)) (Opposite.op.{succ u4} C W)) (CategoryTheory.Limits.limit.homIso.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4 W) f) (CategoryTheory.CategoryStruct.comp.{max u2 u3, max (max (max u2 u1) u3) u4} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Category.toCategoryStruct.{max u2 u3, max (max (max u2 u1) u3) u4} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3)) (Prefunctor.obj.{succ u3, max (succ u2) (succ u3), u4, max (max (max u2 u1) u3) u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u3, max (max (max u2 u1) u4) u3} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Category.toCategoryStruct.{max u2 u3, max (max (max u2 u1) u4) u3} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3))) (CategoryTheory.Functor.toPrefunctor.{u3, max u2 u3, u4, max (max (max u2 u1) u4) u3} C _inst_3 (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.const.{u1, u3, u2, u4} J _inst_1 C _inst_3)) W) (Prefunctor.obj.{succ u3, max (succ u2) (succ u3), u4, max (max (max u2 u1) u3) u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u3, max (max (max u2 u1) u4) u3} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Category.toCategoryStruct.{max u2 u3, max (max (max u2 u1) u4) u3} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3))) (CategoryTheory.Functor.toPrefunctor.{u3, max u2 u3, u4, max (max (max u2 u1) u4) u3} C _inst_3 (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.const.{u1, u3, u2, u4} J _inst_1 C _inst_3)) (CategoryTheory.Limits.limit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4)) F (Prefunctor.map.{succ u3, max (succ u2) (succ u3), u4, max (max (max u2 u1) u3) u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u3, max (max (max u2 u1) u4) u3} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Category.toCategoryStruct.{max u2 u3, max (max (max u2 u1) u4) u3} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3))) (CategoryTheory.Functor.toPrefunctor.{u3, max u2 u3, u4, max (max (max u2 u1) u4) u3} C _inst_3 (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.const.{u1, u3, u2, u4} J _inst_1 C _inst_3)) W (CategoryTheory.Limits.limit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4) (ULift.down.{u2, u3} (Quiver.Hom.{succ u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) W (CategoryTheory.Limits.limit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4)) f)) (CategoryTheory.Limits.Cone.œÄ.{u1, u3, u2, u4} J _inst_1 C _inst_3 F (CategoryTheory.Limits.limit.cone.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4)))
Case conversion may be inaccurate. Consider using '#align category_theory.limits.limit.hom_iso_hom CategoryTheory.Limits.limit.homIso_hom‚Çì'. -/
@[simp]
theorem limit.homIso_hom (F : J ‚•§ C) [HasLimit F] {W : C} (f : ULift (W ‚ü∂ limit F)) :
    (limit.homIso F W).Hom f = (const J).map f.down ‚â´ (limit.cone F).œÄ :=
  (limit.isLimit F).homIso_hom f
#align category_theory.limits.limit.hom_iso_hom CategoryTheory.Limits.limit.homIso_hom

/- warning: category_theory.limits.limit.hom_iso' -> CategoryTheory.Limits.limit.homIso' is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {C : Type.{u4}} [_inst_3 : CategoryTheory.Category.{u3, u4} C] (F : CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) [_inst_4 : CategoryTheory.Limits.HasLimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F] (W : C), CategoryTheory.Iso.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (ULift.{u2, u3} (Quiver.Hom.{succ u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) W (CategoryTheory.Limits.limit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4))) (Subtype.{max (succ u2) (succ u3)} (forall (j : J), Quiver.Hom.{succ u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) W (CategoryTheory.Functor.obj.{u1, u3, u2, u4} J _inst_1 C _inst_3 F j)) (fun (p : forall (j : J), Quiver.Hom.{succ u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) W (CategoryTheory.Functor.obj.{u1, u3, u2, u4} J _inst_1 C _inst_3 F j)) => forall {j : J} {j' : J} (f : Quiver.Hom.{succ u1, u2} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) j j'), Eq.{succ u3} (Quiver.Hom.{succ u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) W (CategoryTheory.Functor.obj.{u1, u3, u2, u4} J _inst_1 C _inst_3 F j')) (CategoryTheory.CategoryStruct.comp.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3) W (CategoryTheory.Functor.obj.{u1, u3, u2, u4} J _inst_1 C _inst_3 F j) (CategoryTheory.Functor.obj.{u1, u3, u2, u4} J _inst_1 C _inst_3 F j') (p j) (CategoryTheory.Functor.map.{u1, u3, u2, u4} J _inst_1 C _inst_3 F j j' f)) (p j')))
but is expected to have type
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {C : Type.{u4}} [_inst_3 : CategoryTheory.Category.{u3, u4} C] (F : CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) [_inst_4 : CategoryTheory.Limits.HasLimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F] (W : C), CategoryTheory.Iso.{max u2 u3, max (succ u2) (succ u3)} Type.{max u3 u2} CategoryTheory.types.{max u2 u3} (ULift.{u2, u3} (Quiver.Hom.{succ u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) W (CategoryTheory.Limits.limit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4))) (Subtype.{max (succ u2) (succ u3)} (forall (j : J), Quiver.Hom.{succ u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) W (Prefunctor.obj.{succ u1, succ u3, u2, u4} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, u4} J _inst_1 C _inst_3 F) j)) (fun (p : forall (j : J), Quiver.Hom.{succ u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) W (Prefunctor.obj.{succ u1, succ u3, u2, u4} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, u4} J _inst_1 C _inst_3 F) j)) => forall {j : J} {j' : J} (f : Quiver.Hom.{succ u1, u2} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) j j'), Eq.{succ u3} (Quiver.Hom.{succ u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) W (Prefunctor.obj.{succ u1, succ u3, u2, u4} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, u4} J _inst_1 C _inst_3 F) j')) (CategoryTheory.CategoryStruct.comp.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3) W (Prefunctor.obj.{succ u1, succ u3, u2, u4} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, u4} J _inst_1 C _inst_3 F) j) (Prefunctor.obj.{succ u1, succ u3, u2, u4} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, u4} J _inst_1 C _inst_3 F) j') (p j) (Prefunctor.map.{succ u1, succ u3, u2, u4} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, u4} J _inst_1 C _inst_3 F) j j' f)) (p j')))
Case conversion may be inaccurate. Consider using '#align category_theory.limits.limit.hom_iso' CategoryTheory.Limits.limit.homIso'‚Çì'. -/
/-- The isomorphism (in `Type`) between
morphisms from a specified object `W` to the limit object,
and an explicit componentwise description of cones with cone point `W`.
-/
def limit.homIso' (F : J ‚•§ C) [HasLimit F] (W : C) :
    ULift.{u‚ÇÅ} (W ‚ü∂ limit F : Type v) ‚âÖ
      { p : ‚àÄ j, W ‚ü∂ F.obj j // ‚àÄ {j j' : J} (f : j ‚ü∂ j'), p j ‚â´ F.map f = p j' } :=
  (limit.isLimit F).homIso' W
#align category_theory.limits.limit.hom_iso' CategoryTheory.Limits.limit.homIso'

#print CategoryTheory.Limits.limit.lift_extend /-
theorem limit.lift_extend {F : J ‚•§ C} [HasLimit F] (c : Cone F) {X : C} (f : X ‚ü∂ c.pt) :
    limit.lift F (c.extend f) = f ‚â´ limit.lift F c := by obviously
#align category_theory.limits.limit.lift_extend CategoryTheory.Limits.limit.lift_extend
-/

#print CategoryTheory.Limits.hasLimitOfIso /-
/-- If a functor `F` has a limit, so does any naturally isomorphic functor.
-/
theorem hasLimitOfIso {F G : J ‚•§ C} [HasLimit F] (Œ± : F ‚âÖ G) : HasLimit G :=
  HasLimit.mk
    { Cone := (Cones.postcompose Œ±.Hom).obj (limit.cone F)
      IsLimit :=
        { lift := fun s => limit.lift F ((Cones.postcompose Œ±.inv).obj s)
          fac := fun s j =>
            by
            rw [cones.postcompose_obj_œÄ, nat_trans.comp_app, limit.cone_œÄ, ‚Üê category.assoc,
              limit.lift_œÄ]
            simp
          uniq := fun s m w => by
            apply limit.hom_ext; intro j
            rw [limit.lift_œÄ, cones.postcompose_obj_œÄ, nat_trans.comp_app, ‚Üê nat_iso.app_inv,
              iso.eq_comp_inv]
            simpa using w j } }
#align category_theory.limits.has_limit_of_iso CategoryTheory.Limits.hasLimitOfIso
-/

#print CategoryTheory.Limits.HasLimit.ofConesIso /-
-- See the construction of limits from products and equalizers
-- for an example usage.
/-- If a functor `G` has the same collection of cones as a functor `F`
which has a limit, then `G` also has a limit. -/
theorem HasLimit.ofConesIso {J K : Type u‚ÇÅ} [Category.{v‚ÇÅ} J] [Category.{v‚ÇÇ} K] (F : J ‚•§ C)
    (G : K ‚•§ C) (h : F.cones ‚âÖ G.cones) [HasLimit F] : HasLimit G :=
  HasLimit.mk ‚ü®_, IsLimit.ofNatIso (IsLimit.natIso (limit.isLimit F) ‚â™‚â´ h)‚ü©
#align category_theory.limits.has_limit.of_cones_iso CategoryTheory.Limits.HasLimit.ofConesIso
-/

#print CategoryTheory.Limits.HasLimit.isoOfNatIso /-
/-- The limits of `F : J ‚•§ C` and `G : J ‚•§ C` are isomorphic,
if the functors are naturally isomorphic.
-/
def HasLimit.isoOfNatIso {F G : J ‚•§ C} [HasLimit F] [HasLimit G] (w : F ‚âÖ G) : limit F ‚âÖ limit G :=
  IsLimit.conePointsIsoOfNatIso (limit.isLimit F) (limit.isLimit G) w
#align category_theory.limits.has_limit.iso_of_nat_iso CategoryTheory.Limits.HasLimit.isoOfNatIso
-/

/- warning: category_theory.limits.has_limit.iso_of_nat_iso_hom_œÄ -> CategoryTheory.Limits.HasLimit.isoOfNatIso_hom_œÄ is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {C : Type.{u4}} [_inst_3 : CategoryTheory.Category.{u3, u4} C] {F : CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3} {G : CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3} [_inst_4 : CategoryTheory.Limits.HasLimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F] [_inst_5 : CategoryTheory.Limits.HasLimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 G] (w : CategoryTheory.Iso.{max u2 u3, max u1 u3 u2 u4} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3) F G) (j : J), Eq.{succ u3} (Quiver.Hom.{succ u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Limits.limit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4) (CategoryTheory.Functor.obj.{u1, u3, u2, u4} J _inst_1 C _inst_3 G j)) (CategoryTheory.CategoryStruct.comp.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3) (CategoryTheory.Limits.limit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4) (CategoryTheory.Limits.limit.{u1, u2, u3, u4} J _inst_1 C _inst_3 G _inst_5) (CategoryTheory.Functor.obj.{u1, u3, u2, u4} J _inst_1 C _inst_3 G j) (CategoryTheory.Iso.hom.{u3, u4} C _inst_3 (CategoryTheory.Limits.limit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4) (CategoryTheory.Limits.limit.{u1, u2, u3, u4} J _inst_1 C _inst_3 G _inst_5) (CategoryTheory.Limits.HasLimit.isoOfNatIso.{u1, u2, u3, u4} J _inst_1 C _inst_3 F G _inst_4 _inst_5 w)) (CategoryTheory.Limits.limit.œÄ.{u1, u2, u3, u4} J _inst_1 C _inst_3 G _inst_5 j)) (CategoryTheory.CategoryStruct.comp.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3) (CategoryTheory.Limits.limit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4) (CategoryTheory.Functor.obj.{u1, u3, u2, u4} J _inst_1 C _inst_3 F j) (CategoryTheory.Functor.obj.{u1, u3, u2, u4} J _inst_1 C _inst_3 G j) (CategoryTheory.Limits.limit.œÄ.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4 j) (CategoryTheory.NatTrans.app.{u1, u3, u2, u4} J _inst_1 C _inst_3 F G (CategoryTheory.Iso.hom.{max u2 u3, max u1 u3 u2 u4} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3) F G w) j))
but is expected to have type
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {C : Type.{u4}} [_inst_3 : CategoryTheory.Category.{u3, u4} C] {F : CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3} {G : CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3} [_inst_4 : CategoryTheory.Limits.HasLimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F] [_inst_5 : CategoryTheory.Limits.HasLimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 G] (w : CategoryTheory.Iso.{max u2 u3, max (max (max u4 u2) u3) u1} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3) F G) (j : J), Eq.{succ u3} (Quiver.Hom.{succ u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Limits.limit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4) (Prefunctor.obj.{succ u1, succ u3, u2, u4} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, u4} J _inst_1 C _inst_3 G) j)) (CategoryTheory.CategoryStruct.comp.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3) (CategoryTheory.Limits.limit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4) (CategoryTheory.Limits.limit.{u1, u2, u3, u4} J _inst_1 C _inst_3 G _inst_5) (Prefunctor.obj.{succ u1, succ u3, u2, u4} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, u4} J _inst_1 C _inst_3 G) j) (CategoryTheory.Iso.hom.{u3, u4} C _inst_3 (CategoryTheory.Limits.limit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4) (CategoryTheory.Limits.limit.{u1, u2, u3, u4} J _inst_1 C _inst_3 G _inst_5) (CategoryTheory.Limits.HasLimit.isoOfNatIso.{u1, u2, u3, u4} J _inst_1 C _inst_3 F G _inst_4 _inst_5 w)) (CategoryTheory.Limits.limit.œÄ.{u1, u2, u3, u4} J _inst_1 C _inst_3 G _inst_5 j)) (CategoryTheory.CategoryStruct.comp.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3) (CategoryTheory.Limits.limit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4) (Prefunctor.obj.{succ u1, succ u3, u2, u4} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, u4} J _inst_1 C _inst_3 F) j) (Prefunctor.obj.{succ u1, succ u3, u2, u4} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, u4} J _inst_1 C _inst_3 G) j) (CategoryTheory.Limits.limit.œÄ.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4 j) (CategoryTheory.NatTrans.app.{u1, u3, u2, u4} J _inst_1 C _inst_3 F G (CategoryTheory.Iso.hom.{max u2 u3, max (max (max u4 u2) u3) u1} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3) F G w) j))
Case conversion may be inaccurate. Consider using '#align category_theory.limits.has_limit.iso_of_nat_iso_hom_œÄ CategoryTheory.Limits.HasLimit.isoOfNatIso_hom_œÄ‚Çì'. -/
@[simp, reassoc.1]
theorem HasLimit.isoOfNatIso_hom_œÄ {F G : J ‚•§ C} [HasLimit F] [HasLimit G] (w : F ‚âÖ G) (j : J) :
    (HasLimit.isoOfNatIso w).Hom ‚â´ limit.œÄ G j = limit.œÄ F j ‚â´ w.Hom.app j :=
  IsLimit.conePointsIsoOfNatIso_hom_comp _ _ _ _
#align category_theory.limits.has_limit.iso_of_nat_iso_hom_œÄ CategoryTheory.Limits.HasLimit.isoOfNatIso_hom_œÄ

/- warning: category_theory.limits.has_limit.iso_of_nat_iso_inv_œÄ -> CategoryTheory.Limits.HasLimit.isoOfNatIso_inv_œÄ is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {C : Type.{u4}} [_inst_3 : CategoryTheory.Category.{u3, u4} C] {F : CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3} {G : CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3} [_inst_4 : CategoryTheory.Limits.HasLimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F] [_inst_5 : CategoryTheory.Limits.HasLimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 G] (w : CategoryTheory.Iso.{max u2 u3, max u1 u3 u2 u4} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3) F G) (j : J), Eq.{succ u3} (Quiver.Hom.{succ u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Limits.limit.{u1, u2, u3, u4} J _inst_1 C _inst_3 G _inst_5) (CategoryTheory.Functor.obj.{u1, u3, u2, u4} J _inst_1 C _inst_3 F j)) (CategoryTheory.CategoryStruct.comp.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3) (CategoryTheory.Limits.limit.{u1, u2, u3, u4} J _inst_1 C _inst_3 G _inst_5) (CategoryTheory.Limits.limit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4) (CategoryTheory.Functor.obj.{u1, u3, u2, u4} J _inst_1 C _inst_3 F j) (CategoryTheory.Iso.inv.{u3, u4} C _inst_3 (CategoryTheory.Limits.limit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4) (CategoryTheory.Limits.limit.{u1, u2, u3, u4} J _inst_1 C _inst_3 G _inst_5) (CategoryTheory.Limits.HasLimit.isoOfNatIso.{u1, u2, u3, u4} J _inst_1 C _inst_3 F G _inst_4 _inst_5 w)) (CategoryTheory.Limits.limit.œÄ.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4 j)) (CategoryTheory.CategoryStruct.comp.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3) (CategoryTheory.Limits.limit.{u1, u2, u3, u4} J _inst_1 C _inst_3 G _inst_5) (CategoryTheory.Functor.obj.{u1, u3, u2, u4} J _inst_1 C _inst_3 G j) (CategoryTheory.Functor.obj.{u1, u3, u2, u4} J _inst_1 C _inst_3 F j) (CategoryTheory.Limits.limit.œÄ.{u1, u2, u3, u4} J _inst_1 C _inst_3 G _inst_5 j) (CategoryTheory.NatTrans.app.{u1, u3, u2, u4} J _inst_1 C _inst_3 G F (CategoryTheory.Iso.inv.{max u2 u3, max u1 u3 u2 u4} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3) F G w) j))
but is expected to have type
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {C : Type.{u4}} [_inst_3 : CategoryTheory.Category.{u3, u4} C] {F : CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3} {G : CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3} [_inst_4 : CategoryTheory.Limits.HasLimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F] [_inst_5 : CategoryTheory.Limits.HasLimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 G] (w : CategoryTheory.Iso.{max u2 u3, max (max (max u4 u2) u3) u1} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3) F G) (j : J), Eq.{succ u3} (Quiver.Hom.{succ u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Limits.limit.{u1, u2, u3, u4} J _inst_1 C _inst_3 G _inst_5) (Prefunctor.obj.{succ u1, succ u3, u2, u4} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, u4} J _inst_1 C _inst_3 F) j)) (CategoryTheory.CategoryStruct.comp.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3) (CategoryTheory.Limits.limit.{u1, u2, u3, u4} J _inst_1 C _inst_3 G _inst_5) (CategoryTheory.Limits.limit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4) (Prefunctor.obj.{succ u1, succ u3, u2, u4} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, u4} J _inst_1 C _inst_3 F) j) (CategoryTheory.Iso.inv.{u3, u4} C _inst_3 (CategoryTheory.Limits.limit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4) (CategoryTheory.Limits.limit.{u1, u2, u3, u4} J _inst_1 C _inst_3 G _inst_5) (CategoryTheory.Limits.HasLimit.isoOfNatIso.{u1, u2, u3, u4} J _inst_1 C _inst_3 F G _inst_4 _inst_5 w)) (CategoryTheory.Limits.limit.œÄ.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4 j)) (CategoryTheory.CategoryStruct.comp.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3) (CategoryTheory.Limits.limit.{u1, u2, u3, u4} J _inst_1 C _inst_3 G _inst_5) (Prefunctor.obj.{succ u1, succ u3, u2, u4} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, u4} J _inst_1 C _inst_3 G) j) (Prefunctor.obj.{succ u1, succ u3, u2, u4} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, u4} J _inst_1 C _inst_3 F) j) (CategoryTheory.Limits.limit.œÄ.{u1, u2, u3, u4} J _inst_1 C _inst_3 G _inst_5 j) (CategoryTheory.NatTrans.app.{u1, u3, u2, u4} J _inst_1 C _inst_3 G F (CategoryTheory.Iso.inv.{max u2 u3, max (max (max u4 u2) u3) u1} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3) F G w) j))
Case conversion may be inaccurate. Consider using '#align category_theory.limits.has_limit.iso_of_nat_iso_inv_œÄ CategoryTheory.Limits.HasLimit.isoOfNatIso_inv_œÄ‚Çì'. -/
@[simp, reassoc.1]
theorem HasLimit.isoOfNatIso_inv_œÄ {F G : J ‚•§ C} [HasLimit F] [HasLimit G] (w : F ‚âÖ G) (j : J) :
    (HasLimit.isoOfNatIso w).inv ‚â´ limit.œÄ F j = limit.œÄ G j ‚â´ w.inv.app j :=
  IsLimit.conePointsIsoOfNatIso_inv_comp _ _ _ _
#align category_theory.limits.has_limit.iso_of_nat_iso_inv_œÄ CategoryTheory.Limits.HasLimit.isoOfNatIso_inv_œÄ

/- warning: category_theory.limits.has_limit.lift_iso_of_nat_iso_hom -> CategoryTheory.Limits.HasLimit.lift_isoOfNatIso_hom is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {C : Type.{u4}} [_inst_3 : CategoryTheory.Category.{u3, u4} C] {F : CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3} {G : CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3} [_inst_4 : CategoryTheory.Limits.HasLimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F] [_inst_5 : CategoryTheory.Limits.HasLimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 G] (t : CategoryTheory.Limits.Cone.{u1, u3, u2, u4} J _inst_1 C _inst_3 F) (w : CategoryTheory.Iso.{max u2 u3, max u1 u3 u2 u4} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3) F G), Eq.{succ u3} (Quiver.Hom.{succ u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Limits.Cone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 F t) (CategoryTheory.Limits.limit.{u1, u2, u3, u4} J _inst_1 C _inst_3 G _inst_5)) (CategoryTheory.CategoryStruct.comp.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3) (CategoryTheory.Limits.Cone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 F t) (CategoryTheory.Limits.limit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4) (CategoryTheory.Limits.limit.{u1, u2, u3, u4} J _inst_1 C _inst_3 G _inst_5) (CategoryTheory.Limits.limit.lift.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4 t) (CategoryTheory.Iso.hom.{u3, u4} C _inst_3 (CategoryTheory.Limits.limit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4) (CategoryTheory.Limits.limit.{u1, u2, u3, u4} J _inst_1 C _inst_3 G _inst_5) (CategoryTheory.Limits.HasLimit.isoOfNatIso.{u1, u2, u3, u4} J _inst_1 C _inst_3 F G _inst_4 _inst_5 w))) (CategoryTheory.Limits.limit.lift.{u1, u2, u3, u4} J _inst_1 C _inst_3 G _inst_5 (CategoryTheory.Functor.obj.{u3, u3, max u2 u4 u3, max u2 u4 u3} (CategoryTheory.Limits.Cone.{u1, u3, u2, u4} J _inst_1 C _inst_3 F) (CategoryTheory.Limits.Cone.category.{u1, u3, u2, u4} J _inst_1 C _inst_3 F) (CategoryTheory.Limits.Cone.{u1, u3, u2, u4} J _inst_1 C _inst_3 G) (CategoryTheory.Limits.Cone.category.{u1, u3, u2, u4} J _inst_1 C _inst_3 G) (CategoryTheory.Limits.Cones.postcompose.{u1, u3, u2, u4} J _inst_1 C _inst_3 F G (CategoryTheory.Iso.hom.{max u2 u3, max u1 u3 u2 u4} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3) F G w)) t))
but is expected to have type
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {C : Type.{u4}} [_inst_3 : CategoryTheory.Category.{u3, u4} C] {F : CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3} {G : CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3} [_inst_4 : CategoryTheory.Limits.HasLimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F] [_inst_5 : CategoryTheory.Limits.HasLimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 G] (t : CategoryTheory.Limits.Cone.{u1, u3, u2, u4} J _inst_1 C _inst_3 F) (w : CategoryTheory.Iso.{max u2 u3, max (max (max u4 u2) u3) u1} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3) F G), Eq.{succ u3} (Quiver.Hom.{succ u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Limits.Cone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 F t) (CategoryTheory.Limits.limit.{u1, u2, u3, u4} J _inst_1 C _inst_3 G _inst_5)) (CategoryTheory.CategoryStruct.comp.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3) (CategoryTheory.Limits.Cone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 F t) (CategoryTheory.Limits.limit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4) (CategoryTheory.Limits.limit.{u1, u2, u3, u4} J _inst_1 C _inst_3 G _inst_5) (CategoryTheory.Limits.limit.lift.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4 t) (CategoryTheory.Iso.hom.{u3, u4} C _inst_3 (CategoryTheory.Limits.limit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4) (CategoryTheory.Limits.limit.{u1, u2, u3, u4} J _inst_1 C _inst_3 G _inst_5) (CategoryTheory.Limits.HasLimit.isoOfNatIso.{u1, u2, u3, u4} J _inst_1 C _inst_3 F G _inst_4 _inst_5 w))) (CategoryTheory.Limits.limit.lift.{u1, u2, u3, u4} J _inst_1 C _inst_3 G _inst_5 (Prefunctor.obj.{succ u3, succ u3, max (max u4 u2) u3, max (max u4 u2) u3} (CategoryTheory.Limits.Cone.{u1, u3, u2, u4} J _inst_1 C _inst_3 F) (CategoryTheory.CategoryStruct.toQuiver.{u3, max (max u4 u2) u3} (CategoryTheory.Limits.Cone.{u1, u3, u2, u4} J _inst_1 C _inst_3 F) (CategoryTheory.Category.toCategoryStruct.{u3, max (max u4 u2) u3} (CategoryTheory.Limits.Cone.{u1, u3, u2, u4} J _inst_1 C _inst_3 F) (CategoryTheory.Limits.Cone.category.{u1, u3, u2, u4} J _inst_1 C _inst_3 F))) (CategoryTheory.Limits.Cone.{u1, u3, u2, u4} J _inst_1 C _inst_3 G) (CategoryTheory.CategoryStruct.toQuiver.{u3, max (max u4 u2) u3} (CategoryTheory.Limits.Cone.{u1, u3, u2, u4} J _inst_1 C _inst_3 G) (CategoryTheory.Category.toCategoryStruct.{u3, max (max u4 u2) u3} (CategoryTheory.Limits.Cone.{u1, u3, u2, u4} J _inst_1 C _inst_3 G) (CategoryTheory.Limits.Cone.category.{u1, u3, u2, u4} J _inst_1 C _inst_3 G))) (CategoryTheory.Functor.toPrefunctor.{u3, u3, max (max u4 u2) u3, max (max u4 u2) u3} (CategoryTheory.Limits.Cone.{u1, u3, u2, u4} J _inst_1 C _inst_3 F) (CategoryTheory.Limits.Cone.category.{u1, u3, u2, u4} J _inst_1 C _inst_3 F) (CategoryTheory.Limits.Cone.{u1, u3, u2, u4} J _inst_1 C _inst_3 G) (CategoryTheory.Limits.Cone.category.{u1, u3, u2, u4} J _inst_1 C _inst_3 G) (CategoryTheory.Limits.Cones.postcompose.{u1, u3, u2, u4} J _inst_1 C _inst_3 F G (CategoryTheory.Iso.hom.{max u2 u3, max (max (max u4 u2) u3) u1} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3) F G w))) t))
Case conversion may be inaccurate. Consider using '#align category_theory.limits.has_limit.lift_iso_of_nat_iso_hom CategoryTheory.Limits.HasLimit.lift_isoOfNatIso_hom‚Çì'. -/
@[simp, reassoc.1]
theorem HasLimit.lift_isoOfNatIso_hom {F G : J ‚•§ C} [HasLimit F] [HasLimit G] (t : Cone F)
    (w : F ‚âÖ G) :
    limit.lift F t ‚â´ (HasLimit.isoOfNatIso w).Hom =
      limit.lift G ((Cones.postcompose w.Hom).obj _) :=
  IsLimit.lift_comp_conePointsIsoOfNatIso_hom _ _ _
#align category_theory.limits.has_limit.lift_iso_of_nat_iso_hom CategoryTheory.Limits.HasLimit.lift_isoOfNatIso_hom

/- warning: category_theory.limits.has_limit.lift_iso_of_nat_iso_inv -> CategoryTheory.Limits.HasLimit.lift_isoOfNatIso_inv is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {C : Type.{u4}} [_inst_3 : CategoryTheory.Category.{u3, u4} C] {F : CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3} {G : CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3} [_inst_4 : CategoryTheory.Limits.HasLimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F] [_inst_5 : CategoryTheory.Limits.HasLimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 G] (t : CategoryTheory.Limits.Cone.{u1, u3, u2, u4} J _inst_1 C _inst_3 G) (w : CategoryTheory.Iso.{max u2 u3, max u1 u3 u2 u4} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3) F G), Eq.{succ u3} (Quiver.Hom.{succ u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Limits.Cone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 G t) (CategoryTheory.Limits.limit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4)) (CategoryTheory.CategoryStruct.comp.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3) (CategoryTheory.Limits.Cone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 G t) (CategoryTheory.Limits.limit.{u1, u2, u3, u4} J _inst_1 C _inst_3 G _inst_5) (CategoryTheory.Limits.limit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4) (CategoryTheory.Limits.limit.lift.{u1, u2, u3, u4} J _inst_1 C _inst_3 G _inst_5 t) (CategoryTheory.Iso.inv.{u3, u4} C _inst_3 (CategoryTheory.Limits.limit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4) (CategoryTheory.Limits.limit.{u1, u2, u3, u4} J _inst_1 C _inst_3 G _inst_5) (CategoryTheory.Limits.HasLimit.isoOfNatIso.{u1, u2, u3, u4} J _inst_1 C _inst_3 F G _inst_4 _inst_5 w))) (CategoryTheory.Limits.limit.lift.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4 (CategoryTheory.Functor.obj.{u3, u3, max u2 u4 u3, max u2 u4 u3} (CategoryTheory.Limits.Cone.{u1, u3, u2, u4} J _inst_1 C _inst_3 G) (CategoryTheory.Limits.Cone.category.{u1, u3, u2, u4} J _inst_1 C _inst_3 G) (CategoryTheory.Limits.Cone.{u1, u3, u2, u4} J _inst_1 C _inst_3 F) (CategoryTheory.Limits.Cone.category.{u1, u3, u2, u4} J _inst_1 C _inst_3 F) (CategoryTheory.Limits.Cones.postcompose.{u1, u3, u2, u4} J _inst_1 C _inst_3 G F (CategoryTheory.Iso.inv.{max u2 u3, max u1 u3 u2 u4} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3) F G w)) t))
but is expected to have type
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {C : Type.{u4}} [_inst_3 : CategoryTheory.Category.{u3, u4} C] {F : CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3} {G : CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3} [_inst_4 : CategoryTheory.Limits.HasLimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F] [_inst_5 : CategoryTheory.Limits.HasLimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 G] (t : CategoryTheory.Limits.Cone.{u1, u3, u2, u4} J _inst_1 C _inst_3 G) (w : CategoryTheory.Iso.{max u2 u3, max (max (max u4 u2) u3) u1} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3) F G), Eq.{succ u3} (Quiver.Hom.{succ u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Limits.Cone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 G t) (CategoryTheory.Limits.limit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4)) (CategoryTheory.CategoryStruct.comp.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3) (CategoryTheory.Limits.Cone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 G t) (CategoryTheory.Limits.limit.{u1, u2, u3, u4} J _inst_1 C _inst_3 G _inst_5) (CategoryTheory.Limits.limit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4) (CategoryTheory.Limits.limit.lift.{u1, u2, u3, u4} J _inst_1 C _inst_3 G _inst_5 t) (CategoryTheory.Iso.inv.{u3, u4} C _inst_3 (CategoryTheory.Limits.limit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4) (CategoryTheory.Limits.limit.{u1, u2, u3, u4} J _inst_1 C _inst_3 G _inst_5) (CategoryTheory.Limits.HasLimit.isoOfNatIso.{u1, u2, u3, u4} J _inst_1 C _inst_3 F G _inst_4 _inst_5 w))) (CategoryTheory.Limits.limit.lift.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4 (Prefunctor.obj.{succ u3, succ u3, max (max u4 u2) u3, max (max u4 u2) u3} (CategoryTheory.Limits.Cone.{u1, u3, u2, u4} J _inst_1 C _inst_3 G) (CategoryTheory.CategoryStruct.toQuiver.{u3, max (max u4 u2) u3} (CategoryTheory.Limits.Cone.{u1, u3, u2, u4} J _inst_1 C _inst_3 G) (CategoryTheory.Category.toCategoryStruct.{u3, max (max u4 u2) u3} (CategoryTheory.Limits.Cone.{u1, u3, u2, u4} J _inst_1 C _inst_3 G) (CategoryTheory.Limits.Cone.category.{u1, u3, u2, u4} J _inst_1 C _inst_3 G))) (CategoryTheory.Limits.Cone.{u1, u3, u2, u4} J _inst_1 C _inst_3 F) (CategoryTheory.CategoryStruct.toQuiver.{u3, max (max u4 u2) u3} (CategoryTheory.Limits.Cone.{u1, u3, u2, u4} J _inst_1 C _inst_3 F) (CategoryTheory.Category.toCategoryStruct.{u3, max (max u4 u2) u3} (CategoryTheory.Limits.Cone.{u1, u3, u2, u4} J _inst_1 C _inst_3 F) (CategoryTheory.Limits.Cone.category.{u1, u3, u2, u4} J _inst_1 C _inst_3 F))) (CategoryTheory.Functor.toPrefunctor.{u3, u3, max (max u4 u2) u3, max (max u4 u2) u3} (CategoryTheory.Limits.Cone.{u1, u3, u2, u4} J _inst_1 C _inst_3 G) (CategoryTheory.Limits.Cone.category.{u1, u3, u2, u4} J _inst_1 C _inst_3 G) (CategoryTheory.Limits.Cone.{u1, u3, u2, u4} J _inst_1 C _inst_3 F) (CategoryTheory.Limits.Cone.category.{u1, u3, u2, u4} J _inst_1 C _inst_3 F) (CategoryTheory.Limits.Cones.postcompose.{u1, u3, u2, u4} J _inst_1 C _inst_3 G F (CategoryTheory.Iso.inv.{max u2 u3, max (max (max u4 u2) u3) u1} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3) F G w))) t))
Case conversion may be inaccurate. Consider using '#align category_theory.limits.has_limit.lift_iso_of_nat_iso_inv CategoryTheory.Limits.HasLimit.lift_isoOfNatIso_inv‚Çì'. -/
@[simp, reassoc.1]
theorem HasLimit.lift_isoOfNatIso_inv {F G : J ‚•§ C} [HasLimit F] [HasLimit G] (t : Cone G)
    (w : F ‚âÖ G) :
    limit.lift G t ‚â´ (HasLimit.isoOfNatIso w).inv =
      limit.lift F ((Cones.postcompose w.inv).obj _) :=
  IsLimit.lift_comp_conePointsIsoOfNatIso_inv _ _ _
#align category_theory.limits.has_limit.lift_iso_of_nat_iso_inv CategoryTheory.Limits.HasLimit.lift_isoOfNatIso_inv

/- warning: category_theory.limits.has_limit.iso_of_equivalence -> CategoryTheory.Limits.HasLimit.isoOfEquivalence is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {K : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u3, u4} K] {C : Type.{u6}} [_inst_3 : CategoryTheory.Category.{u5, u6} C] {F : CategoryTheory.Functor.{u1, u5, u2, u6} J _inst_1 C _inst_3} [_inst_4 : CategoryTheory.Limits.HasLimit.{u1, u2, u5, u6} J _inst_1 C _inst_3 F] {G : CategoryTheory.Functor.{u3, u5, u4, u6} K _inst_2 C _inst_3} [_inst_5 : CategoryTheory.Limits.HasLimit.{u3, u4, u5, u6} K _inst_2 C _inst_3 G] (e : CategoryTheory.Equivalence.{u1, u3, u2, u4} J _inst_1 K _inst_2), (CategoryTheory.Iso.{max u2 u5, max u1 u5 u2 u6} (CategoryTheory.Functor.{u1, u5, u2, u6} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u5, u2, u6} J _inst_1 C _inst_3) (CategoryTheory.Functor.comp.{u1, u3, u5, u2, u4, u6} J _inst_1 K _inst_2 C _inst_3 (CategoryTheory.Equivalence.functor.{u1, u3, u2, u4} J _inst_1 K _inst_2 e) G) F) -> (CategoryTheory.Iso.{u5, u6} C _inst_3 (CategoryTheory.Limits.limit.{u1, u2, u5, u6} J _inst_1 C _inst_3 F _inst_4) (CategoryTheory.Limits.limit.{u3, u4, u5, u6} K _inst_2 C _inst_3 G _inst_5))
but is expected to have type
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {K : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u3, u4} K] {C : Type.{u6}} [_inst_3 : CategoryTheory.Category.{u5, u6} C] {F : CategoryTheory.Functor.{u1, u5, u2, u6} J _inst_1 C _inst_3} [_inst_4 : CategoryTheory.Limits.HasLimit.{u1, u2, u5, u6} J _inst_1 C _inst_3 F] {G : CategoryTheory.Functor.{u3, u5, u4, u6} K _inst_2 C _inst_3} [_inst_5 : CategoryTheory.Limits.HasLimit.{u3, u4, u5, u6} K _inst_2 C _inst_3 G] (e : CategoryTheory.Equivalence.{u1, u3, u2, u4} J K _inst_1 _inst_2), (CategoryTheory.Iso.{max u2 u5, max (max (max u6 u2) u5) u1} (CategoryTheory.Functor.{u1, u5, u2, u6} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u5, u2, u6} J _inst_1 C _inst_3) (CategoryTheory.Functor.comp.{u1, u3, u5, u2, u4, u6} J _inst_1 K _inst_2 C _inst_3 (CategoryTheory.Equivalence.functor.{u1, u3, u2, u4} J K _inst_1 _inst_2 e) G) F) -> (CategoryTheory.Iso.{u5, u6} C _inst_3 (CategoryTheory.Limits.limit.{u1, u2, u5, u6} J _inst_1 C _inst_3 F _inst_4) (CategoryTheory.Limits.limit.{u3, u4, u5, u6} K _inst_2 C _inst_3 G _inst_5))
Case conversion may be inaccurate. Consider using '#align category_theory.limits.has_limit.iso_of_equivalence CategoryTheory.Limits.HasLimit.isoOfEquivalence‚Çì'. -/
/-- The limits of `F : J ‚•§ C` and `G : K ‚•§ C` are isomorphic,
if there is an equivalence `e : J ‚âå K` making the triangle commute up to natural isomorphism.
-/
def HasLimit.isoOfEquivalence {F : J ‚•§ C} [HasLimit F] {G : K ‚•§ C} [HasLimit G] (e : J ‚âå K)
    (w : e.Functor ‚ãô G ‚âÖ F) : limit F ‚âÖ limit G :=
  IsLimit.conePointsIsoOfEquivalence (limit.isLimit F) (limit.isLimit G) e w
#align category_theory.limits.has_limit.iso_of_equivalence CategoryTheory.Limits.HasLimit.isoOfEquivalence

/- warning: category_theory.limits.has_limit.iso_of_equivalence_hom_œÄ -> CategoryTheory.Limits.HasLimit.isoOfEquivalence_hom_œÄ is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {K : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u3, u4} K] {C : Type.{u6}} [_inst_3 : CategoryTheory.Category.{u5, u6} C] {F : CategoryTheory.Functor.{u1, u5, u2, u6} J _inst_1 C _inst_3} [_inst_4 : CategoryTheory.Limits.HasLimit.{u1, u2, u5, u6} J _inst_1 C _inst_3 F] {G : CategoryTheory.Functor.{u3, u5, u4, u6} K _inst_2 C _inst_3} [_inst_5 : CategoryTheory.Limits.HasLimit.{u3, u4, u5, u6} K _inst_2 C _inst_3 G] (e : CategoryTheory.Equivalence.{u1, u3, u2, u4} J _inst_1 K _inst_2) (w : CategoryTheory.Iso.{max u2 u5, max u1 u5 u2 u6} (CategoryTheory.Functor.{u1, u5, u2, u6} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u5, u2, u6} J _inst_1 C _inst_3) (CategoryTheory.Functor.comp.{u1, u3, u5, u2, u4, u6} J _inst_1 K _inst_2 C _inst_3 (CategoryTheory.Equivalence.functor.{u1, u3, u2, u4} J _inst_1 K _inst_2 e) G) F) (k : K), Eq.{succ u5} (Quiver.Hom.{succ u5, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u5, u6} C (CategoryTheory.Category.toCategoryStruct.{u5, u6} C _inst_3)) (CategoryTheory.Limits.limit.{u1, u2, u5, u6} J _inst_1 C _inst_3 F _inst_4) (CategoryTheory.Functor.obj.{u3, u5, u4, u6} K _inst_2 C _inst_3 G k)) (CategoryTheory.CategoryStruct.comp.{u5, u6} C (CategoryTheory.Category.toCategoryStruct.{u5, u6} C _inst_3) (CategoryTheory.Limits.limit.{u1, u2, u5, u6} J _inst_1 C _inst_3 F _inst_4) (CategoryTheory.Limits.limit.{u3, u4, u5, u6} K _inst_2 C _inst_3 G _inst_5) (CategoryTheory.Functor.obj.{u3, u5, u4, u6} K _inst_2 C _inst_3 G k) (CategoryTheory.Iso.hom.{u5, u6} C _inst_3 (CategoryTheory.Limits.limit.{u1, u2, u5, u6} J _inst_1 C _inst_3 F _inst_4) (CategoryTheory.Limits.limit.{u3, u4, u5, u6} K _inst_2 C _inst_3 G _inst_5) (CategoryTheory.Limits.HasLimit.isoOfEquivalence.{u1, u2, u3, u4, u5, u6} J _inst_1 K _inst_2 C _inst_3 F _inst_4 G _inst_5 e w)) (CategoryTheory.Limits.limit.œÄ.{u3, u4, u5, u6} K _inst_2 C _inst_3 G _inst_5 k)) (CategoryTheory.CategoryStruct.comp.{u5, u6} C (CategoryTheory.Category.toCategoryStruct.{u5, u6} C _inst_3) (CategoryTheory.Limits.limit.{u1, u2, u5, u6} J _inst_1 C _inst_3 F _inst_4) (CategoryTheory.Functor.obj.{u1, u5, u2, u6} J _inst_1 C _inst_3 F (CategoryTheory.Functor.obj.{u3, u1, u4, u2} K _inst_2 J _inst_1 (CategoryTheory.Equivalence.inverse.{u1, u3, u2, u4} J _inst_1 K _inst_2 e) k)) (CategoryTheory.Functor.obj.{u3, u5, u4, u6} K _inst_2 C _inst_3 G k) (CategoryTheory.Limits.limit.œÄ.{u1, u2, u5, u6} J _inst_1 C _inst_3 F _inst_4 (CategoryTheory.Functor.obj.{u3, u1, u4, u2} K _inst_2 J _inst_1 (CategoryTheory.Equivalence.inverse.{u1, u3, u2, u4} J _inst_1 K _inst_2 e) k)) (CategoryTheory.CategoryStruct.comp.{u5, u6} C (CategoryTheory.Category.toCategoryStruct.{u5, u6} C _inst_3) (CategoryTheory.Functor.obj.{u1, u5, u2, u6} J _inst_1 C _inst_3 F (CategoryTheory.Functor.obj.{u3, u1, u4, u2} K _inst_2 J _inst_1 (CategoryTheory.Equivalence.inverse.{u1, u3, u2, u4} J _inst_1 K _inst_2 e) k)) (CategoryTheory.Functor.obj.{u1, u5, u2, u6} J _inst_1 C _inst_3 (CategoryTheory.Functor.comp.{u1, u3, u5, u2, u4, u6} J _inst_1 K _inst_2 C _inst_3 (CategoryTheory.Equivalence.functor.{u1, u3, u2, u4} J _inst_1 K _inst_2 e) G) (CategoryTheory.Functor.obj.{u3, u1, u4, u2} K _inst_2 J _inst_1 (CategoryTheory.Equivalence.inverse.{u1, u3, u2, u4} J _inst_1 K _inst_2 e) k)) (CategoryTheory.Functor.obj.{u3, u5, u4, u6} K _inst_2 C _inst_3 G k) (CategoryTheory.NatTrans.app.{u1, u5, u2, u6} J _inst_1 C _inst_3 F (CategoryTheory.Functor.comp.{u1, u3, u5, u2, u4, u6} J _inst_1 K _inst_2 C _inst_3 (CategoryTheory.Equivalence.functor.{u1, u3, u2, u4} J _inst_1 K _inst_2 e) G) (CategoryTheory.Iso.inv.{max u2 u5, max u1 u5 u2 u6} (CategoryTheory.Functor.{u1, u5, u2, u6} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u5, u2, u6} J _inst_1 C _inst_3) (CategoryTheory.Functor.comp.{u1, u3, u5, u2, u4, u6} J _inst_1 K _inst_2 C _inst_3 (CategoryTheory.Equivalence.functor.{u1, u3, u2, u4} J _inst_1 K _inst_2 e) G) F w) (CategoryTheory.Functor.obj.{u3, u1, u4, u2} K _inst_2 J _inst_1 (CategoryTheory.Equivalence.inverse.{u1, u3, u2, u4} J _inst_1 K _inst_2 e) k)) (CategoryTheory.Functor.map.{u3, u5, u4, u6} K _inst_2 C _inst_3 G (CategoryTheory.Functor.obj.{u1, u3, u2, u4} J _inst_1 K _inst_2 (CategoryTheory.Equivalence.functor.{u1, u3, u2, u4} J _inst_1 K _inst_2 e) (CategoryTheory.Functor.obj.{u3, u1, u4, u2} K _inst_2 J _inst_1 (CategoryTheory.Equivalence.inverse.{u1, u3, u2, u4} J _inst_1 K _inst_2 e) k)) k (CategoryTheory.NatTrans.app.{u3, u3, u4, u4} K _inst_2 K _inst_2 (CategoryTheory.Functor.comp.{u3, u1, u3, u4, u2, u4} K _inst_2 J _inst_1 K _inst_2 (CategoryTheory.Equivalence.inverse.{u1, u3, u2, u4} J _inst_1 K _inst_2 e) (CategoryTheory.Equivalence.functor.{u1, u3, u2, u4} J _inst_1 K _inst_2 e)) (CategoryTheory.Functor.id.{u3, u4} K _inst_2) (CategoryTheory.Equivalence.counit.{u1, u3, u2, u4} J _inst_1 K _inst_2 e) k))))
but is expected to have type
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {K : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u3, u4} K] {C : Type.{u6}} [_inst_3 : CategoryTheory.Category.{u5, u6} C] {F : CategoryTheory.Functor.{u1, u5, u2, u6} J _inst_1 C _inst_3} [_inst_4 : CategoryTheory.Limits.HasLimit.{u1, u2, u5, u6} J _inst_1 C _inst_3 F] {G : CategoryTheory.Functor.{u3, u5, u4, u6} K _inst_2 C _inst_3} [_inst_5 : CategoryTheory.Limits.HasLimit.{u3, u4, u5, u6} K _inst_2 C _inst_3 G] (e : CategoryTheory.Equivalence.{u1, u3, u2, u4} J K _inst_1 _inst_2) (w : CategoryTheory.Iso.{max u2 u5, max (max (max u6 u2) u5) u1} (CategoryTheory.Functor.{u1, u5, u2, u6} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u5, u2, u6} J _inst_1 C _inst_3) (CategoryTheory.Functor.comp.{u1, u3, u5, u2, u4, u6} J _inst_1 K _inst_2 C _inst_3 (CategoryTheory.Equivalence.functor.{u1, u3, u2, u4} J K _inst_1 _inst_2 e) G) F) (k : K), Eq.{succ u5} (Quiver.Hom.{succ u5, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u5, u6} C (CategoryTheory.Category.toCategoryStruct.{u5, u6} C _inst_3)) (CategoryTheory.Limits.limit.{u1, u2, u5, u6} J _inst_1 C _inst_3 F _inst_4) (Prefunctor.obj.{succ u3, succ u5, u4, u6} K (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} K (CategoryTheory.Category.toCategoryStruct.{u3, u4} K _inst_2)) C (CategoryTheory.CategoryStruct.toQuiver.{u5, u6} C (CategoryTheory.Category.toCategoryStruct.{u5, u6} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u3, u5, u4, u6} K _inst_2 C _inst_3 G) k)) (CategoryTheory.CategoryStruct.comp.{u5, u6} C (CategoryTheory.Category.toCategoryStruct.{u5, u6} C _inst_3) (CategoryTheory.Limits.limit.{u1, u2, u5, u6} J _inst_1 C _inst_3 F _inst_4) (CategoryTheory.Limits.limit.{u3, u4, u5, u6} K _inst_2 C _inst_3 G _inst_5) (Prefunctor.obj.{succ u3, succ u5, u4, u6} K (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} K (CategoryTheory.Category.toCategoryStruct.{u3, u4} K _inst_2)) C (CategoryTheory.CategoryStruct.toQuiver.{u5, u6} C (CategoryTheory.Category.toCategoryStruct.{u5, u6} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u3, u5, u4, u6} K _inst_2 C _inst_3 G) k) (CategoryTheory.Iso.hom.{u5, u6} C _inst_3 (CategoryTheory.Limits.limit.{u1, u2, u5, u6} J _inst_1 C _inst_3 F _inst_4) (CategoryTheory.Limits.limit.{u3, u4, u5, u6} K _inst_2 C _inst_3 G _inst_5) (CategoryTheory.Limits.HasLimit.isoOfEquivalence.{u1, u2, u3, u4, u5, u6} J _inst_1 K _inst_2 C _inst_3 F _inst_4 G _inst_5 e w)) (CategoryTheory.Limits.limit.œÄ.{u3, u4, u5, u6} K _inst_2 C _inst_3 G _inst_5 k)) (CategoryTheory.CategoryStruct.comp.{u5, u6} C (CategoryTheory.Category.toCategoryStruct.{u5, u6} C _inst_3) (CategoryTheory.Limits.limit.{u1, u2, u5, u6} J _inst_1 C _inst_3 F _inst_4) (Prefunctor.obj.{succ u1, succ u5, u2, u6} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u5, u6} C (CategoryTheory.Category.toCategoryStruct.{u5, u6} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u5, u2, u6} J _inst_1 C _inst_3 F) (Prefunctor.obj.{succ u3, succ u1, u4, u2} K (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} K (CategoryTheory.Category.toCategoryStruct.{u3, u4} K _inst_2)) J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u3, u1, u4, u2} K _inst_2 J _inst_1 (CategoryTheory.Equivalence.inverse.{u1, u3, u2, u4} J K _inst_1 _inst_2 e)) k)) (Prefunctor.obj.{succ u3, succ u5, u4, u6} K (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} K (CategoryTheory.Category.toCategoryStruct.{u3, u4} K _inst_2)) C (CategoryTheory.CategoryStruct.toQuiver.{u5, u6} C (CategoryTheory.Category.toCategoryStruct.{u5, u6} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u3, u5, u4, u6} K _inst_2 C _inst_3 G) (Prefunctor.obj.{succ u3, succ u3, u4, u4} K (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} K (CategoryTheory.Category.toCategoryStruct.{u3, u4} K _inst_2)) K (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} K (CategoryTheory.Category.toCategoryStruct.{u3, u4} K _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u3, u4, u4} K _inst_2 K _inst_2 (CategoryTheory.Functor.id.{u3, u4} K _inst_2)) k)) (CategoryTheory.Limits.limit.œÄ.{u1, u2, u5, u6} J _inst_1 C _inst_3 F _inst_4 (Prefunctor.obj.{succ u3, succ u1, u4, u2} K (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} K (CategoryTheory.Category.toCategoryStruct.{u3, u4} K _inst_2)) J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u3, u1, u4, u2} K _inst_2 J _inst_1 (CategoryTheory.Equivalence.inverse.{u1, u3, u2, u4} J K _inst_1 _inst_2 e)) k)) (CategoryTheory.CategoryStruct.comp.{u5, u6} C (CategoryTheory.Category.toCategoryStruct.{u5, u6} C _inst_3) (Prefunctor.obj.{succ u1, succ u5, u2, u6} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u5, u6} C (CategoryTheory.Category.toCategoryStruct.{u5, u6} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u5, u2, u6} J _inst_1 C _inst_3 F) (Prefunctor.obj.{succ u3, succ u1, u4, u2} K (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} K (CategoryTheory.Category.toCategoryStruct.{u3, u4} K _inst_2)) J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u3, u1, u4, u2} K _inst_2 J _inst_1 (CategoryTheory.Equivalence.inverse.{u1, u3, u2, u4} J K _inst_1 _inst_2 e)) k)) (Prefunctor.obj.{succ u1, succ u5, u2, u6} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u5, u6} C (CategoryTheory.Category.toCategoryStruct.{u5, u6} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u5, u2, u6} J _inst_1 C _inst_3 (CategoryTheory.Functor.comp.{u1, u3, u5, u2, u4, u6} J _inst_1 K _inst_2 C _inst_3 (CategoryTheory.Equivalence.functor.{u1, u3, u2, u4} J K _inst_1 _inst_2 e) G)) (Prefunctor.obj.{succ u3, succ u1, u4, u2} K (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} K (CategoryTheory.Category.toCategoryStruct.{u3, u4} K _inst_2)) J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u3, u1, u4, u2} K _inst_2 J _inst_1 (CategoryTheory.Equivalence.inverse.{u1, u3, u2, u4} J K _inst_1 _inst_2 e)) k)) (Prefunctor.obj.{succ u3, succ u5, u4, u6} K (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} K (CategoryTheory.Category.toCategoryStruct.{u3, u4} K _inst_2)) C (CategoryTheory.CategoryStruct.toQuiver.{u5, u6} C (CategoryTheory.Category.toCategoryStruct.{u5, u6} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u3, u5, u4, u6} K _inst_2 C _inst_3 G) (Prefunctor.obj.{succ u3, succ u3, u4, u4} K (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} K (CategoryTheory.Category.toCategoryStruct.{u3, u4} K _inst_2)) K (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} K (CategoryTheory.Category.toCategoryStruct.{u3, u4} K _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u3, u4, u4} K _inst_2 K _inst_2 (CategoryTheory.Functor.id.{u3, u4} K _inst_2)) k)) (CategoryTheory.NatTrans.app.{u1, u5, u2, u6} J _inst_1 C _inst_3 F (CategoryTheory.Functor.comp.{u1, u3, u5, u2, u4, u6} J _inst_1 K _inst_2 C _inst_3 (CategoryTheory.Equivalence.functor.{u1, u3, u2, u4} J K _inst_1 _inst_2 e) G) (CategoryTheory.Iso.inv.{max u2 u5, max (max (max u6 u2) u5) u1} (CategoryTheory.Functor.{u1, u5, u2, u6} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u5, u2, u6} J _inst_1 C _inst_3) (CategoryTheory.Functor.comp.{u1, u3, u5, u2, u4, u6} J _inst_1 K _inst_2 C _inst_3 (CategoryTheory.Equivalence.functor.{u1, u3, u2, u4} J K _inst_1 _inst_2 e) G) F w) (Prefunctor.obj.{succ u3, succ u1, u4, u2} K (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} K (CategoryTheory.Category.toCategoryStruct.{u3, u4} K _inst_2)) J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u3, u1, u4, u2} K _inst_2 J _inst_1 (CategoryTheory.Equivalence.inverse.{u1, u3, u2, u4} J K _inst_1 _inst_2 e)) k)) (Prefunctor.map.{succ u3, succ u5, u4, u6} K (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} K (CategoryTheory.Category.toCategoryStruct.{u3, u4} K _inst_2)) C (CategoryTheory.CategoryStruct.toQuiver.{u5, u6} C (CategoryTheory.Category.toCategoryStruct.{u5, u6} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u3, u5, u4, u6} K _inst_2 C _inst_3 G) (Prefunctor.obj.{succ u1, succ u3, u2, u4} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) K (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} K (CategoryTheory.Category.toCategoryStruct.{u3, u4} K _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, u4} J _inst_1 K _inst_2 (CategoryTheory.Equivalence.functor.{u1, u3, u2, u4} J K _inst_1 _inst_2 e)) (Prefunctor.obj.{succ u3, succ u1, u4, u2} K (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} K (CategoryTheory.Category.toCategoryStruct.{u3, u4} K _inst_2)) J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u3, u1, u4, u2} K _inst_2 J _inst_1 (CategoryTheory.Equivalence.inverse.{u1, u3, u2, u4} J K _inst_1 _inst_2 e)) k)) (Prefunctor.obj.{succ u3, succ u3, u4, u4} K (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} K (CategoryTheory.Category.toCategoryStruct.{u3, u4} K _inst_2)) K (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} K (CategoryTheory.Category.toCategoryStruct.{u3, u4} K _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u3, u4, u4} K _inst_2 K _inst_2 (CategoryTheory.Functor.id.{u3, u4} K _inst_2)) k) (CategoryTheory.NatTrans.app.{u3, u3, u4, u4} K _inst_2 K _inst_2 (CategoryTheory.Functor.comp.{u3, u1, u3, u4, u2, u4} K _inst_2 J _inst_1 K _inst_2 (CategoryTheory.Equivalence.inverse.{u1, u3, u2, u4} J K _inst_1 _inst_2 e) (CategoryTheory.Equivalence.functor.{u1, u3, u2, u4} J K _inst_1 _inst_2 e)) (CategoryTheory.Functor.id.{u3, u4} K _inst_2) (CategoryTheory.Equivalence.counit.{u1, u3, u2, u4} J _inst_1 K _inst_2 e) k))))
Case conversion may be inaccurate. Consider using '#align category_theory.limits.has_limit.iso_of_equivalence_hom_œÄ CategoryTheory.Limits.HasLimit.isoOfEquivalence_hom_œÄ‚Çì'. -/
@[simp]
theorem HasLimit.isoOfEquivalence_hom_œÄ {F : J ‚•§ C} [HasLimit F] {G : K ‚•§ C} [HasLimit G]
    (e : J ‚âå K) (w : e.Functor ‚ãô G ‚âÖ F) (k : K) :
    (HasLimit.isoOfEquivalence e w).Hom ‚â´ limit.œÄ G k =
      limit.œÄ F (e.inverse.obj k) ‚â´ w.inv.app (e.inverse.obj k) ‚â´ G.map (e.counit.app k) :=
  by
  simp only [has_limit.iso_of_equivalence, is_limit.cone_points_iso_of_equivalence_hom]
  dsimp
  simp
#align category_theory.limits.has_limit.iso_of_equivalence_hom_œÄ CategoryTheory.Limits.HasLimit.isoOfEquivalence_hom_œÄ

/- warning: category_theory.limits.has_limit.iso_of_equivalence_inv_œÄ -> CategoryTheory.Limits.HasLimit.isoOfEquivalence_inv_œÄ is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {K : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u3, u4} K] {C : Type.{u6}} [_inst_3 : CategoryTheory.Category.{u5, u6} C] {F : CategoryTheory.Functor.{u1, u5, u2, u6} J _inst_1 C _inst_3} [_inst_4 : CategoryTheory.Limits.HasLimit.{u1, u2, u5, u6} J _inst_1 C _inst_3 F] {G : CategoryTheory.Functor.{u3, u5, u4, u6} K _inst_2 C _inst_3} [_inst_5 : CategoryTheory.Limits.HasLimit.{u3, u4, u5, u6} K _inst_2 C _inst_3 G] (e : CategoryTheory.Equivalence.{u1, u3, u2, u4} J _inst_1 K _inst_2) (w : CategoryTheory.Iso.{max u2 u5, max u1 u5 u2 u6} (CategoryTheory.Functor.{u1, u5, u2, u6} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u5, u2, u6} J _inst_1 C _inst_3) (CategoryTheory.Functor.comp.{u1, u3, u5, u2, u4, u6} J _inst_1 K _inst_2 C _inst_3 (CategoryTheory.Equivalence.functor.{u1, u3, u2, u4} J _inst_1 K _inst_2 e) G) F) (j : J), Eq.{succ u5} (Quiver.Hom.{succ u5, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u5, u6} C (CategoryTheory.Category.toCategoryStruct.{u5, u6} C _inst_3)) (CategoryTheory.Limits.limit.{u3, u4, u5, u6} K _inst_2 C _inst_3 G _inst_5) (CategoryTheory.Functor.obj.{u1, u5, u2, u6} J _inst_1 C _inst_3 F j)) (CategoryTheory.CategoryStruct.comp.{u5, u6} C (CategoryTheory.Category.toCategoryStruct.{u5, u6} C _inst_3) (CategoryTheory.Limits.limit.{u3, u4, u5, u6} K _inst_2 C _inst_3 G _inst_5) (CategoryTheory.Limits.limit.{u1, u2, u5, u6} J _inst_1 C _inst_3 F _inst_4) (CategoryTheory.Functor.obj.{u1, u5, u2, u6} J _inst_1 C _inst_3 F j) (CategoryTheory.Iso.inv.{u5, u6} C _inst_3 (CategoryTheory.Limits.limit.{u1, u2, u5, u6} J _inst_1 C _inst_3 F _inst_4) (CategoryTheory.Limits.limit.{u3, u4, u5, u6} K _inst_2 C _inst_3 G _inst_5) (CategoryTheory.Limits.HasLimit.isoOfEquivalence.{u1, u2, u3, u4, u5, u6} J _inst_1 K _inst_2 C _inst_3 F _inst_4 G _inst_5 e w)) (CategoryTheory.Limits.limit.œÄ.{u1, u2, u5, u6} J _inst_1 C _inst_3 F _inst_4 j)) (CategoryTheory.CategoryStruct.comp.{u5, u6} C (CategoryTheory.Category.toCategoryStruct.{u5, u6} C _inst_3) (CategoryTheory.Limits.limit.{u3, u4, u5, u6} K _inst_2 C _inst_3 G _inst_5) (CategoryTheory.Functor.obj.{u3, u5, u4, u6} K _inst_2 C _inst_3 G (CategoryTheory.Functor.obj.{u1, u3, u2, u4} J _inst_1 K _inst_2 (CategoryTheory.Equivalence.functor.{u1, u3, u2, u4} J _inst_1 K _inst_2 e) j)) (CategoryTheory.Functor.obj.{u1, u5, u2, u6} J _inst_1 C _inst_3 F j) (CategoryTheory.Limits.limit.œÄ.{u3, u4, u5, u6} K _inst_2 C _inst_3 G _inst_5 (CategoryTheory.Functor.obj.{u1, u3, u2, u4} J _inst_1 K _inst_2 (CategoryTheory.Equivalence.functor.{u1, u3, u2, u4} J _inst_1 K _inst_2 e) j)) (CategoryTheory.NatTrans.app.{u1, u5, u2, u6} J _inst_1 C _inst_3 (CategoryTheory.Functor.comp.{u1, u3, u5, u2, u4, u6} J _inst_1 K _inst_2 C _inst_3 (CategoryTheory.Equivalence.functor.{u1, u3, u2, u4} J _inst_1 K _inst_2 e) G) F (CategoryTheory.Iso.hom.{max u2 u5, max u1 u5 u2 u6} (CategoryTheory.Functor.{u1, u5, u2, u6} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u5, u2, u6} J _inst_1 C _inst_3) (CategoryTheory.Functor.comp.{u1, u3, u5, u2, u4, u6} J _inst_1 K _inst_2 C _inst_3 (CategoryTheory.Equivalence.functor.{u1, u3, u2, u4} J _inst_1 K _inst_2 e) G) F w) j))
but is expected to have type
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {K : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u3, u4} K] {C : Type.{u6}} [_inst_3 : CategoryTheory.Category.{u5, u6} C] {F : CategoryTheory.Functor.{u1, u5, u2, u6} J _inst_1 C _inst_3} [_inst_4 : CategoryTheory.Limits.HasLimit.{u1, u2, u5, u6} J _inst_1 C _inst_3 F] {G : CategoryTheory.Functor.{u3, u5, u4, u6} K _inst_2 C _inst_3} [_inst_5 : CategoryTheory.Limits.HasLimit.{u3, u4, u5, u6} K _inst_2 C _inst_3 G] (e : CategoryTheory.Equivalence.{u1, u3, u2, u4} J K _inst_1 _inst_2) (w : CategoryTheory.Iso.{max u2 u5, max (max (max u6 u2) u5) u1} (CategoryTheory.Functor.{u1, u5, u2, u6} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u5, u2, u6} J _inst_1 C _inst_3) (CategoryTheory.Functor.comp.{u1, u3, u5, u2, u4, u6} J _inst_1 K _inst_2 C _inst_3 (CategoryTheory.Equivalence.functor.{u1, u3, u2, u4} J K _inst_1 _inst_2 e) G) F) (j : J), Eq.{succ u5} (Quiver.Hom.{succ u5, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u5, u6} C (CategoryTheory.Category.toCategoryStruct.{u5, u6} C _inst_3)) (CategoryTheory.Limits.limit.{u3, u4, u5, u6} K _inst_2 C _inst_3 G _inst_5) (Prefunctor.obj.{succ u1, succ u5, u2, u6} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u5, u6} C (CategoryTheory.Category.toCategoryStruct.{u5, u6} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u5, u2, u6} J _inst_1 C _inst_3 F) j)) (CategoryTheory.CategoryStruct.comp.{u5, u6} C (CategoryTheory.Category.toCategoryStruct.{u5, u6} C _inst_3) (CategoryTheory.Limits.limit.{u3, u4, u5, u6} K _inst_2 C _inst_3 G _inst_5) (CategoryTheory.Limits.limit.{u1, u2, u5, u6} J _inst_1 C _inst_3 F _inst_4) (Prefunctor.obj.{succ u1, succ u5, u2, u6} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u5, u6} C (CategoryTheory.Category.toCategoryStruct.{u5, u6} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u5, u2, u6} J _inst_1 C _inst_3 F) j) (CategoryTheory.Iso.inv.{u5, u6} C _inst_3 (CategoryTheory.Limits.limit.{u1, u2, u5, u6} J _inst_1 C _inst_3 F _inst_4) (CategoryTheory.Limits.limit.{u3, u4, u5, u6} K _inst_2 C _inst_3 G _inst_5) (CategoryTheory.Limits.HasLimit.isoOfEquivalence.{u1, u2, u3, u4, u5, u6} J _inst_1 K _inst_2 C _inst_3 F _inst_4 G _inst_5 e w)) (CategoryTheory.Limits.limit.œÄ.{u1, u2, u5, u6} J _inst_1 C _inst_3 F _inst_4 j)) (CategoryTheory.CategoryStruct.comp.{u5, u6} C (CategoryTheory.Category.toCategoryStruct.{u5, u6} C _inst_3) (CategoryTheory.Limits.limit.{u3, u4, u5, u6} K _inst_2 C _inst_3 G _inst_5) (Prefunctor.obj.{succ u3, succ u5, u4, u6} K (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} K (CategoryTheory.Category.toCategoryStruct.{u3, u4} K _inst_2)) C (CategoryTheory.CategoryStruct.toQuiver.{u5, u6} C (CategoryTheory.Category.toCategoryStruct.{u5, u6} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u3, u5, u4, u6} K _inst_2 C _inst_3 G) (Prefunctor.obj.{succ u1, succ u3, u2, u4} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) K (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} K (CategoryTheory.Category.toCategoryStruct.{u3, u4} K _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, u4} J _inst_1 K _inst_2 (CategoryTheory.Equivalence.functor.{u1, u3, u2, u4} J K _inst_1 _inst_2 e)) j)) (Prefunctor.obj.{succ u1, succ u5, u2, u6} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u5, u6} C (CategoryTheory.Category.toCategoryStruct.{u5, u6} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u5, u2, u6} J _inst_1 C _inst_3 F) j) (CategoryTheory.Limits.limit.œÄ.{u3, u4, u5, u6} K _inst_2 C _inst_3 G _inst_5 (Prefunctor.obj.{succ u1, succ u3, u2, u4} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) K (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} K (CategoryTheory.Category.toCategoryStruct.{u3, u4} K _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, u4} J _inst_1 K _inst_2 (CategoryTheory.Equivalence.functor.{u1, u3, u2, u4} J K _inst_1 _inst_2 e)) j)) (CategoryTheory.NatTrans.app.{u1, u5, u2, u6} J _inst_1 C _inst_3 (CategoryTheory.Functor.comp.{u1, u3, u5, u2, u4, u6} J _inst_1 K _inst_2 C _inst_3 (CategoryTheory.Equivalence.functor.{u1, u3, u2, u4} J K _inst_1 _inst_2 e) G) F (CategoryTheory.Iso.hom.{max u2 u5, max (max (max u6 u2) u5) u1} (CategoryTheory.Functor.{u1, u5, u2, u6} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u5, u2, u6} J _inst_1 C _inst_3) (CategoryTheory.Functor.comp.{u1, u3, u5, u2, u4, u6} J _inst_1 K _inst_2 C _inst_3 (CategoryTheory.Equivalence.functor.{u1, u3, u2, u4} J K _inst_1 _inst_2 e) G) F w) j))
Case conversion may be inaccurate. Consider using '#align category_theory.limits.has_limit.iso_of_equivalence_inv_œÄ CategoryTheory.Limits.HasLimit.isoOfEquivalence_inv_œÄ‚Çì'. -/
@[simp]
theorem HasLimit.isoOfEquivalence_inv_œÄ {F : J ‚•§ C} [HasLimit F] {G : K ‚•§ C} [HasLimit G]
    (e : J ‚âå K) (w : e.Functor ‚ãô G ‚âÖ F) (j : J) :
    (HasLimit.isoOfEquivalence e w).inv ‚â´ limit.œÄ F j = limit.œÄ G (e.Functor.obj j) ‚â´ w.Hom.app j :=
  by
  simp only [has_limit.iso_of_equivalence, is_limit.cone_points_iso_of_equivalence_hom]
  dsimp
  simp
#align category_theory.limits.has_limit.iso_of_equivalence_inv_œÄ CategoryTheory.Limits.HasLimit.isoOfEquivalence_inv_œÄ

section Pre

variable (F) [HasLimit F] (E : K ‚•§ J) [HasLimit (E ‚ãô F)]

#print CategoryTheory.Limits.limit.pre /-
/-- The canonical morphism from the limit of `F` to the limit of `E ‚ãô F`.
-/
def limit.pre : limit F ‚ü∂ limit (E ‚ãô F) :=
  limit.lift (E ‚ãô F) ((limit.cone F).whisker E)
#align category_theory.limits.limit.pre CategoryTheory.Limits.limit.pre
-/

/- warning: category_theory.limits.limit.pre_œÄ -> CategoryTheory.Limits.limit.pre_œÄ is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {K : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u3, u4} K] {C : Type.{u6}} [_inst_3 : CategoryTheory.Category.{u5, u6} C] (F : CategoryTheory.Functor.{u1, u5, u2, u6} J _inst_1 C _inst_3) [_inst_4 : CategoryTheory.Limits.HasLimit.{u1, u2, u5, u6} J _inst_1 C _inst_3 F] (E : CategoryTheory.Functor.{u3, u1, u4, u2} K _inst_2 J _inst_1) [_inst_5 : CategoryTheory.Limits.HasLimit.{u3, u4, u5, u6} K _inst_2 C _inst_3 (CategoryTheory.Functor.comp.{u3, u1, u5, u4, u2, u6} K _inst_2 J _inst_1 C _inst_3 E F)] (k : K), Eq.{succ u5} (Quiver.Hom.{succ u5, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u5, u6} C (CategoryTheory.Category.toCategoryStruct.{u5, u6} C _inst_3)) (CategoryTheory.Limits.limit.{u1, u2, u5, u6} J _inst_1 C _inst_3 F _inst_4) (CategoryTheory.Functor.obj.{u3, u5, u4, u6} K _inst_2 C _inst_3 (CategoryTheory.Functor.comp.{u3, u1, u5, u4, u2, u6} K _inst_2 J _inst_1 C _inst_3 E F) k)) (CategoryTheory.CategoryStruct.comp.{u5, u6} C (CategoryTheory.Category.toCategoryStruct.{u5, u6} C _inst_3) (CategoryTheory.Limits.limit.{u1, u2, u5, u6} J _inst_1 C _inst_3 F _inst_4) (CategoryTheory.Limits.limit.{u3, u4, u5, u6} K _inst_2 C _inst_3 (CategoryTheory.Functor.comp.{u3, u1, u5, u4, u2, u6} K _inst_2 J _inst_1 C _inst_3 E F) _inst_5) (CategoryTheory.Functor.obj.{u3, u5, u4, u6} K _inst_2 C _inst_3 (CategoryTheory.Functor.comp.{u3, u1, u5, u4, u2, u6} K _inst_2 J _inst_1 C _inst_3 E F) k) (CategoryTheory.Limits.limit.pre.{u1, u2, u3, u4, u5, u6} J _inst_1 K _inst_2 C _inst_3 F _inst_4 E _inst_5) (CategoryTheory.Limits.limit.œÄ.{u3, u4, u5, u6} K _inst_2 C _inst_3 (CategoryTheory.Functor.comp.{u3, u1, u5, u4, u2, u6} K _inst_2 J _inst_1 C _inst_3 E F) _inst_5 k)) (CategoryTheory.Limits.limit.œÄ.{u1, u2, u5, u6} J _inst_1 C _inst_3 F _inst_4 (CategoryTheory.Functor.obj.{u3, u1, u4, u2} K _inst_2 J _inst_1 E k))
but is expected to have type
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {K : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u3, u4} K] {C : Type.{u6}} [_inst_3 : CategoryTheory.Category.{u5, u6} C] (F : CategoryTheory.Functor.{u1, u5, u2, u6} J _inst_1 C _inst_3) [_inst_4 : CategoryTheory.Limits.HasLimit.{u1, u2, u5, u6} J _inst_1 C _inst_3 F] (E : CategoryTheory.Functor.{u3, u1, u4, u2} K _inst_2 J _inst_1) [_inst_5 : CategoryTheory.Limits.HasLimit.{u3, u4, u5, u6} K _inst_2 C _inst_3 (CategoryTheory.Functor.comp.{u3, u1, u5, u4, u2, u6} K _inst_2 J _inst_1 C _inst_3 E F)] (k : K), Eq.{succ u5} (Quiver.Hom.{succ u5, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u5, u6} C (CategoryTheory.Category.toCategoryStruct.{u5, u6} C _inst_3)) (CategoryTheory.Limits.limit.{u1, u2, u5, u6} J _inst_1 C _inst_3 F _inst_4) (Prefunctor.obj.{succ u3, succ u5, u4, u6} K (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} K (CategoryTheory.Category.toCategoryStruct.{u3, u4} K _inst_2)) C (CategoryTheory.CategoryStruct.toQuiver.{u5, u6} C (CategoryTheory.Category.toCategoryStruct.{u5, u6} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u3, u5, u4, u6} K _inst_2 C _inst_3 (CategoryTheory.Functor.comp.{u3, u1, u5, u4, u2, u6} K _inst_2 J _inst_1 C _inst_3 E F)) k)) (CategoryTheory.CategoryStruct.comp.{u5, u6} C (CategoryTheory.Category.toCategoryStruct.{u5, u6} C _inst_3) (CategoryTheory.Limits.limit.{u1, u2, u5, u6} J _inst_1 C _inst_3 F _inst_4) (CategoryTheory.Limits.limit.{u3, u4, u5, u6} K _inst_2 C _inst_3 (CategoryTheory.Functor.comp.{u3, u1, u5, u4, u2, u6} K _inst_2 J _inst_1 C _inst_3 E F) _inst_5) (Prefunctor.obj.{succ u3, succ u5, u4, u6} K (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} K (CategoryTheory.Category.toCategoryStruct.{u3, u4} K _inst_2)) C (CategoryTheory.CategoryStruct.toQuiver.{u5, u6} C (CategoryTheory.Category.toCategoryStruct.{u5, u6} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u3, u5, u4, u6} K _inst_2 C _inst_3 (CategoryTheory.Functor.comp.{u3, u1, u5, u4, u2, u6} K _inst_2 J _inst_1 C _inst_3 E F)) k) (CategoryTheory.Limits.limit.pre.{u1, u2, u3, u4, u5, u6} J _inst_1 K _inst_2 C _inst_3 F _inst_4 E _inst_5) (CategoryTheory.Limits.limit.œÄ.{u3, u4, u5, u6} K _inst_2 C _inst_3 (CategoryTheory.Functor.comp.{u3, u1, u5, u4, u2, u6} K _inst_2 J _inst_1 C _inst_3 E F) _inst_5 k)) (CategoryTheory.Limits.limit.œÄ.{u1, u2, u5, u6} J _inst_1 C _inst_3 F _inst_4 (Prefunctor.obj.{succ u3, succ u1, u4, u2} K (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} K (CategoryTheory.Category.toCategoryStruct.{u3, u4} K _inst_2)) J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u3, u1, u4, u2} K _inst_2 J _inst_1 E) k))
Case conversion may be inaccurate. Consider using '#align category_theory.limits.limit.pre_œÄ CategoryTheory.Limits.limit.pre_œÄ‚Çì'. -/
@[simp, reassoc.1]
theorem limit.pre_œÄ (k : K) : limit.pre F E ‚â´ limit.œÄ (E ‚ãô F) k = limit.œÄ F (E.obj k) :=
  by
  erw [is_limit.fac]
  rfl
#align category_theory.limits.limit.pre_œÄ CategoryTheory.Limits.limit.pre_œÄ

#print CategoryTheory.Limits.limit.lift_pre /-
@[simp]
theorem limit.lift_pre (c : Cone F) :
    limit.lift F c ‚â´ limit.pre F E = limit.lift (E ‚ãô F) (c.whisker E) := by ext <;> simp
#align category_theory.limits.limit.lift_pre CategoryTheory.Limits.limit.lift_pre
-/

variable {L : Type u‚ÇÉ} [Category.{v‚ÇÉ} L]

variable (D : L ‚•§ K) [HasLimit (D ‚ãô E ‚ãô F)]

#print CategoryTheory.Limits.limit.pre_pre /-
@[simp]
theorem limit.pre_pre : limit.pre F E ‚â´ limit.pre (E ‚ãô F) D = limit.pre F (D ‚ãô E) := by
  ext j <;> erw [assoc, limit.pre_œÄ, limit.pre_œÄ, limit.pre_œÄ] <;> rfl
#align category_theory.limits.limit.pre_pre CategoryTheory.Limits.limit.pre_pre
-/

variable {E F}

#print CategoryTheory.Limits.limit.pre_eq /-
/-- -
If we have particular limit cones available for `E ‚ãô F` and for `F`,
we obtain a formula for `limit.pre F E`.
-/
theorem limit.pre_eq (s : LimitCone (E ‚ãô F)) (t : LimitCone F) :
    limit.pre F E =
      (limit.isoLimitCone t).Hom ‚â´ s.IsLimit.lift (t.Cone.whisker E) ‚â´ (limit.isoLimitCone s).inv :=
  by tidy
#align category_theory.limits.limit.pre_eq CategoryTheory.Limits.limit.pre_eq
-/

end Pre

section Post

variable {D : Type u'} [Category.{v'} D]

variable (F) [HasLimit F] (G : C ‚•§ D) [HasLimit (F ‚ãô G)]

/- warning: category_theory.limits.limit.post -> CategoryTheory.Limits.limit.post is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {C : Type.{u5}} [_inst_3 : CategoryTheory.Category.{u3, u5} C] (F : CategoryTheory.Functor.{u1, u3, u2, u5} J _inst_1 C _inst_3) {D : Type.{u6}} [_inst_4 : CategoryTheory.Category.{u4, u6} D] [_inst_5 : CategoryTheory.Limits.HasLimit.{u1, u2, u3, u5} J _inst_1 C _inst_3 F] (G : CategoryTheory.Functor.{u3, u4, u5, u6} C _inst_3 D _inst_4) [_inst_6 : CategoryTheory.Limits.HasLimit.{u1, u2, u4, u6} J _inst_1 D _inst_4 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_1 C _inst_3 D _inst_4 F G)], Quiver.Hom.{succ u4, u6} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} D (CategoryTheory.Category.toCategoryStruct.{u4, u6} D _inst_4)) (CategoryTheory.Functor.obj.{u3, u4, u5, u6} C _inst_3 D _inst_4 G (CategoryTheory.Limits.limit.{u1, u2, u3, u5} J _inst_1 C _inst_3 F _inst_5)) (CategoryTheory.Limits.limit.{u1, u2, u4, u6} J _inst_1 D _inst_4 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_1 C _inst_3 D _inst_4 F G) _inst_6)
but is expected to have type
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {C : Type.{u5}} [_inst_3 : CategoryTheory.Category.{u3, u5} C] (F : CategoryTheory.Functor.{u1, u3, u2, u5} J _inst_1 C _inst_3) {D : Type.{u6}} [_inst_4 : CategoryTheory.Category.{u4, u6} D] [_inst_5 : CategoryTheory.Limits.HasLimit.{u1, u2, u3, u5} J _inst_1 C _inst_3 F] (G : CategoryTheory.Functor.{u3, u4, u5, u6} C _inst_3 D _inst_4) [_inst_6 : CategoryTheory.Limits.HasLimit.{u1, u2, u4, u6} J _inst_1 D _inst_4 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_1 C _inst_3 D _inst_4 F G)], Quiver.Hom.{succ u4, u6} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} D (CategoryTheory.Category.toCategoryStruct.{u4, u6} D _inst_4)) (Prefunctor.obj.{succ u3, succ u4, u5, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} C (CategoryTheory.Category.toCategoryStruct.{u3, u5} C _inst_3)) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} D (CategoryTheory.Category.toCategoryStruct.{u4, u6} D _inst_4)) (CategoryTheory.Functor.toPrefunctor.{u3, u4, u5, u6} C _inst_3 D _inst_4 G) (CategoryTheory.Limits.limit.{u1, u2, u3, u5} J _inst_1 C _inst_3 F _inst_5)) (CategoryTheory.Limits.limit.{u1, u2, u4, u6} J _inst_1 D _inst_4 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_1 C _inst_3 D _inst_4 F G) _inst_6)
Case conversion may be inaccurate. Consider using '#align category_theory.limits.limit.post CategoryTheory.Limits.limit.post‚Çì'. -/
/-- The canonical morphism from `G` applied to the limit of `F` to the limit of `F ‚ãô G`.
-/
def limit.post : G.obj (limit F) ‚ü∂ limit (F ‚ãô G) :=
  limit.lift (F ‚ãô G) (G.mapCone (limit.cone F))
#align category_theory.limits.limit.post CategoryTheory.Limits.limit.post

/- warning: category_theory.limits.limit.post_œÄ -> CategoryTheory.Limits.limit.post_œÄ is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {C : Type.{u5}} [_inst_3 : CategoryTheory.Category.{u3, u5} C] (F : CategoryTheory.Functor.{u1, u3, u2, u5} J _inst_1 C _inst_3) {D : Type.{u6}} [_inst_4 : CategoryTheory.Category.{u4, u6} D] [_inst_5 : CategoryTheory.Limits.HasLimit.{u1, u2, u3, u5} J _inst_1 C _inst_3 F] (G : CategoryTheory.Functor.{u3, u4, u5, u6} C _inst_3 D _inst_4) [_inst_6 : CategoryTheory.Limits.HasLimit.{u1, u2, u4, u6} J _inst_1 D _inst_4 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_1 C _inst_3 D _inst_4 F G)] (j : J), Eq.{succ u4} (Quiver.Hom.{succ u4, u6} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} D (CategoryTheory.Category.toCategoryStruct.{u4, u6} D _inst_4)) (CategoryTheory.Functor.obj.{u3, u4, u5, u6} C _inst_3 D _inst_4 G (CategoryTheory.Limits.limit.{u1, u2, u3, u5} J _inst_1 C _inst_3 F _inst_5)) (CategoryTheory.Functor.obj.{u1, u4, u2, u6} J _inst_1 D _inst_4 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_1 C _inst_3 D _inst_4 F G) j)) (CategoryTheory.CategoryStruct.comp.{u4, u6} D (CategoryTheory.Category.toCategoryStruct.{u4, u6} D _inst_4) (CategoryTheory.Functor.obj.{u3, u4, u5, u6} C _inst_3 D _inst_4 G (CategoryTheory.Limits.limit.{u1, u2, u3, u5} J _inst_1 C _inst_3 F _inst_5)) (CategoryTheory.Limits.limit.{u1, u2, u4, u6} J _inst_1 D _inst_4 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_1 C _inst_3 D _inst_4 F G) _inst_6) (CategoryTheory.Functor.obj.{u1, u4, u2, u6} J _inst_1 D _inst_4 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_1 C _inst_3 D _inst_4 F G) j) (CategoryTheory.Limits.limit.post.{u1, u2, u3, u4, u5, u6} J _inst_1 C _inst_3 F D _inst_4 _inst_5 G _inst_6) (CategoryTheory.Limits.limit.œÄ.{u1, u2, u4, u6} J _inst_1 D _inst_4 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_1 C _inst_3 D _inst_4 F G) _inst_6 j)) (CategoryTheory.Functor.map.{u3, u4, u5, u6} C _inst_3 D _inst_4 G (CategoryTheory.Limits.limit.{u1, u2, u3, u5} J _inst_1 C _inst_3 F _inst_5) (CategoryTheory.Functor.obj.{u1, u3, u2, u5} J _inst_1 C _inst_3 F j) (CategoryTheory.Limits.limit.œÄ.{u1, u2, u3, u5} J _inst_1 C _inst_3 F _inst_5 j))
but is expected to have type
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {C : Type.{u5}} [_inst_3 : CategoryTheory.Category.{u3, u5} C] (F : CategoryTheory.Functor.{u1, u3, u2, u5} J _inst_1 C _inst_3) {D : Type.{u6}} [_inst_4 : CategoryTheory.Category.{u4, u6} D] [_inst_5 : CategoryTheory.Limits.HasLimit.{u1, u2, u3, u5} J _inst_1 C _inst_3 F] (G : CategoryTheory.Functor.{u3, u4, u5, u6} C _inst_3 D _inst_4) [_inst_6 : CategoryTheory.Limits.HasLimit.{u1, u2, u4, u6} J _inst_1 D _inst_4 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_1 C _inst_3 D _inst_4 F G)] (j : J), Eq.{succ u4} (Quiver.Hom.{succ u4, u6} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} D (CategoryTheory.Category.toCategoryStruct.{u4, u6} D _inst_4)) (Prefunctor.obj.{succ u3, succ u4, u5, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} C (CategoryTheory.Category.toCategoryStruct.{u3, u5} C _inst_3)) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} D (CategoryTheory.Category.toCategoryStruct.{u4, u6} D _inst_4)) (CategoryTheory.Functor.toPrefunctor.{u3, u4, u5, u6} C _inst_3 D _inst_4 G) (CategoryTheory.Limits.limit.{u1, u2, u3, u5} J _inst_1 C _inst_3 F _inst_5)) (Prefunctor.obj.{succ u1, succ u4, u2, u6} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} D (CategoryTheory.Category.toCategoryStruct.{u4, u6} D _inst_4)) (CategoryTheory.Functor.toPrefunctor.{u1, u4, u2, u6} J _inst_1 D _inst_4 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_1 C _inst_3 D _inst_4 F G)) j)) (CategoryTheory.CategoryStruct.comp.{u4, u6} D (CategoryTheory.Category.toCategoryStruct.{u4, u6} D _inst_4) (Prefunctor.obj.{succ u3, succ u4, u5, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} C (CategoryTheory.Category.toCategoryStruct.{u3, u5} C _inst_3)) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} D (CategoryTheory.Category.toCategoryStruct.{u4, u6} D _inst_4)) (CategoryTheory.Functor.toPrefunctor.{u3, u4, u5, u6} C _inst_3 D _inst_4 G) (CategoryTheory.Limits.limit.{u1, u2, u3, u5} J _inst_1 C _inst_3 F _inst_5)) (CategoryTheory.Limits.limit.{u1, u2, u4, u6} J _inst_1 D _inst_4 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_1 C _inst_3 D _inst_4 F G) _inst_6) (Prefunctor.obj.{succ u1, succ u4, u2, u6} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} D (CategoryTheory.Category.toCategoryStruct.{u4, u6} D _inst_4)) (CategoryTheory.Functor.toPrefunctor.{u1, u4, u2, u6} J _inst_1 D _inst_4 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_1 C _inst_3 D _inst_4 F G)) j) (CategoryTheory.Limits.limit.post.{u1, u2, u3, u4, u5, u6} J _inst_1 C _inst_3 F D _inst_4 _inst_5 G _inst_6) (CategoryTheory.Limits.limit.œÄ.{u1, u2, u4, u6} J _inst_1 D _inst_4 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_1 C _inst_3 D _inst_4 F G) _inst_6 j)) (Prefunctor.map.{succ u3, succ u4, u5, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} C (CategoryTheory.Category.toCategoryStruct.{u3, u5} C _inst_3)) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} D (CategoryTheory.Category.toCategoryStruct.{u4, u6} D _inst_4)) (CategoryTheory.Functor.toPrefunctor.{u3, u4, u5, u6} C _inst_3 D _inst_4 G) (CategoryTheory.Limits.limit.{u1, u2, u3, u5} J _inst_1 C _inst_3 F _inst_5) (Prefunctor.obj.{succ u1, succ u3, u2, u5} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} C (CategoryTheory.Category.toCategoryStruct.{u3, u5} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, u5} J _inst_1 C _inst_3 F) j) (CategoryTheory.Limits.limit.œÄ.{u1, u2, u3, u5} J _inst_1 C _inst_3 F _inst_5 j))
Case conversion may be inaccurate. Consider using '#align category_theory.limits.limit.post_œÄ CategoryTheory.Limits.limit.post_œÄ‚Çì'. -/
@[simp, reassoc.1]
theorem limit.post_œÄ (j : J) : limit.post F G ‚â´ limit.œÄ (F ‚ãô G) j = G.map (limit.œÄ F j) :=
  by
  erw [is_limit.fac]
  rfl
#align category_theory.limits.limit.post_œÄ CategoryTheory.Limits.limit.post_œÄ

/- warning: category_theory.limits.limit.lift_post -> CategoryTheory.Limits.limit.lift_post is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {C : Type.{u5}} [_inst_3 : CategoryTheory.Category.{u3, u5} C] (F : CategoryTheory.Functor.{u1, u3, u2, u5} J _inst_1 C _inst_3) {D : Type.{u6}} [_inst_4 : CategoryTheory.Category.{u4, u6} D] [_inst_5 : CategoryTheory.Limits.HasLimit.{u1, u2, u3, u5} J _inst_1 C _inst_3 F] (G : CategoryTheory.Functor.{u3, u4, u5, u6} C _inst_3 D _inst_4) [_inst_6 : CategoryTheory.Limits.HasLimit.{u1, u2, u4, u6} J _inst_1 D _inst_4 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_1 C _inst_3 D _inst_4 F G)] (c : CategoryTheory.Limits.Cone.{u1, u3, u2, u5} J _inst_1 C _inst_3 F), Eq.{succ u4} (Quiver.Hom.{succ u4, u6} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} D (CategoryTheory.Category.toCategoryStruct.{u4, u6} D _inst_4)) (CategoryTheory.Functor.obj.{u3, u4, u5, u6} C _inst_3 D _inst_4 G (CategoryTheory.Limits.Cone.pt.{u1, u3, u2, u5} J _inst_1 C _inst_3 F c)) (CategoryTheory.Limits.limit.{u1, u2, u4, u6} J _inst_1 D _inst_4 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_1 C _inst_3 D _inst_4 F G) _inst_6)) (CategoryTheory.CategoryStruct.comp.{u4, u6} D (CategoryTheory.Category.toCategoryStruct.{u4, u6} D _inst_4) (CategoryTheory.Functor.obj.{u3, u4, u5, u6} C _inst_3 D _inst_4 G (CategoryTheory.Limits.Cone.pt.{u1, u3, u2, u5} J _inst_1 C _inst_3 F c)) (CategoryTheory.Functor.obj.{u3, u4, u5, u6} C _inst_3 D _inst_4 G (CategoryTheory.Limits.limit.{u1, u2, u3, u5} J _inst_1 C _inst_3 F _inst_5)) (CategoryTheory.Limits.limit.{u1, u2, u4, u6} J _inst_1 D _inst_4 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_1 C _inst_3 D _inst_4 F G) _inst_6) (CategoryTheory.Functor.map.{u3, u4, u5, u6} C _inst_3 D _inst_4 G (CategoryTheory.Limits.Cone.pt.{u1, u3, u2, u5} J _inst_1 C _inst_3 F c) (CategoryTheory.Limits.limit.{u1, u2, u3, u5} J _inst_1 C _inst_3 F _inst_5) (CategoryTheory.Limits.limit.lift.{u1, u2, u3, u5} J _inst_1 C _inst_3 F _inst_5 c)) (CategoryTheory.Limits.limit.post.{u1, u2, u3, u4, u5, u6} J _inst_1 C _inst_3 F D _inst_4 _inst_5 G _inst_6)) (CategoryTheory.Limits.limit.lift.{u1, u2, u4, u6} J _inst_1 D _inst_4 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_1 C _inst_3 D _inst_4 F G) _inst_6 (CategoryTheory.Functor.mapCone.{u1, u3, u4, u2, u5, u6} J _inst_1 C _inst_3 D _inst_4 F G c))
but is expected to have type
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {C : Type.{u5}} [_inst_3 : CategoryTheory.Category.{u3, u5} C] (F : CategoryTheory.Functor.{u1, u3, u2, u5} J _inst_1 C _inst_3) {D : Type.{u6}} [_inst_4 : CategoryTheory.Category.{u4, u6} D] [_inst_5 : CategoryTheory.Limits.HasLimit.{u1, u2, u3, u5} J _inst_1 C _inst_3 F] (G : CategoryTheory.Functor.{u3, u4, u5, u6} C _inst_3 D _inst_4) [_inst_6 : CategoryTheory.Limits.HasLimit.{u1, u2, u4, u6} J _inst_1 D _inst_4 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_1 C _inst_3 D _inst_4 F G)] (c : CategoryTheory.Limits.Cone.{u1, u3, u2, u5} J _inst_1 C _inst_3 F), Eq.{succ u4} (Quiver.Hom.{succ u4, u6} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} D (CategoryTheory.Category.toCategoryStruct.{u4, u6} D _inst_4)) (Prefunctor.obj.{succ u3, succ u4, u5, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} C (CategoryTheory.Category.toCategoryStruct.{u3, u5} C _inst_3)) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} D (CategoryTheory.Category.toCategoryStruct.{u4, u6} D _inst_4)) (CategoryTheory.Functor.toPrefunctor.{u3, u4, u5, u6} C _inst_3 D _inst_4 G) (CategoryTheory.Limits.Cone.pt.{u1, u3, u2, u5} J _inst_1 C _inst_3 F c)) (CategoryTheory.Limits.limit.{u1, u2, u4, u6} J _inst_1 D _inst_4 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_1 C _inst_3 D _inst_4 F G) _inst_6)) (CategoryTheory.CategoryStruct.comp.{u4, u6} D (CategoryTheory.Category.toCategoryStruct.{u4, u6} D _inst_4) (Prefunctor.obj.{succ u3, succ u4, u5, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} C (CategoryTheory.Category.toCategoryStruct.{u3, u5} C _inst_3)) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} D (CategoryTheory.Category.toCategoryStruct.{u4, u6} D _inst_4)) (CategoryTheory.Functor.toPrefunctor.{u3, u4, u5, u6} C _inst_3 D _inst_4 G) (CategoryTheory.Limits.Cone.pt.{u1, u3, u2, u5} J _inst_1 C _inst_3 F c)) (Prefunctor.obj.{succ u3, succ u4, u5, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} C (CategoryTheory.Category.toCategoryStruct.{u3, u5} C _inst_3)) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} D (CategoryTheory.Category.toCategoryStruct.{u4, u6} D _inst_4)) (CategoryTheory.Functor.toPrefunctor.{u3, u4, u5, u6} C _inst_3 D _inst_4 G) (CategoryTheory.Limits.limit.{u1, u2, u3, u5} J _inst_1 C _inst_3 F _inst_5)) (CategoryTheory.Limits.limit.{u1, u2, u4, u6} J _inst_1 D _inst_4 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_1 C _inst_3 D _inst_4 F G) _inst_6) (Prefunctor.map.{succ u3, succ u4, u5, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} C (CategoryTheory.Category.toCategoryStruct.{u3, u5} C _inst_3)) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} D (CategoryTheory.Category.toCategoryStruct.{u4, u6} D _inst_4)) (CategoryTheory.Functor.toPrefunctor.{u3, u4, u5, u6} C _inst_3 D _inst_4 G) (CategoryTheory.Limits.Cone.pt.{u1, u3, u2, u5} J _inst_1 C _inst_3 F c) (CategoryTheory.Limits.limit.{u1, u2, u3, u5} J _inst_1 C _inst_3 F _inst_5) (CategoryTheory.Limits.limit.lift.{u1, u2, u3, u5} J _inst_1 C _inst_3 F _inst_5 c)) (CategoryTheory.Limits.limit.post.{u1, u2, u3, u4, u5, u6} J _inst_1 C _inst_3 F D _inst_4 _inst_5 G _inst_6)) (CategoryTheory.Limits.limit.lift.{u1, u2, u4, u6} J _inst_1 D _inst_4 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_1 C _inst_3 D _inst_4 F G) _inst_6 (CategoryTheory.Functor.mapCone.{u1, u3, u4, u2, u5, u6} J _inst_1 C _inst_3 D _inst_4 F G c))
Case conversion may be inaccurate. Consider using '#align category_theory.limits.limit.lift_post CategoryTheory.Limits.limit.lift_post‚Çì'. -/
@[simp]
theorem limit.lift_post (c : Cone F) :
    G.map (limit.lift F c) ‚â´ limit.post F G = limit.lift (F ‚ãô G) (G.mapCone c) :=
  by
  ext
  rw [assoc, limit.post_œÄ, ‚Üê G.map_comp, limit.lift_œÄ, limit.lift_œÄ]
  rfl
#align category_theory.limits.limit.lift_post CategoryTheory.Limits.limit.lift_post

/- warning: category_theory.limits.limit.post_post -> CategoryTheory.Limits.limit.post_post is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {C : Type.{u6}} [_inst_3 : CategoryTheory.Category.{u3, u6} C] (F : CategoryTheory.Functor.{u1, u3, u2, u6} J _inst_1 C _inst_3) {D : Type.{u7}} [_inst_4 : CategoryTheory.Category.{u4, u7} D] [_inst_5 : CategoryTheory.Limits.HasLimit.{u1, u2, u3, u6} J _inst_1 C _inst_3 F] (G : CategoryTheory.Functor.{u3, u4, u6, u7} C _inst_3 D _inst_4) [_inst_6 : CategoryTheory.Limits.HasLimit.{u1, u2, u4, u7} J _inst_1 D _inst_4 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u6, u7} J _inst_1 C _inst_3 D _inst_4 F G)] {E : Type.{u8}} [_inst_7 : CategoryTheory.Category.{u5, u8} E] (H : CategoryTheory.Functor.{u4, u5, u7, u8} D _inst_4 E _inst_7) [_inst_8 : CategoryTheory.Limits.HasLimit.{u1, u2, u5, u8} J _inst_1 E _inst_7 (CategoryTheory.Functor.comp.{u1, u4, u5, u2, u7, u8} J _inst_1 D _inst_4 E _inst_7 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u6, u7} J _inst_1 C _inst_3 D _inst_4 F G) H)], Eq.{succ u5} (Quiver.Hom.{succ u5, u8} E (CategoryTheory.CategoryStruct.toQuiver.{u5, u8} E (CategoryTheory.Category.toCategoryStruct.{u5, u8} E _inst_7)) (CategoryTheory.Functor.obj.{u4, u5, u7, u8} D _inst_4 E _inst_7 H (CategoryTheory.Functor.obj.{u3, u4, u6, u7} C _inst_3 D _inst_4 G (CategoryTheory.Limits.limit.{u1, u2, u3, u6} J _inst_1 C _inst_3 F _inst_5))) (CategoryTheory.Limits.limit.{u1, u2, u5, u8} J _inst_1 E _inst_7 (CategoryTheory.Functor.comp.{u1, u4, u5, u2, u7, u8} J _inst_1 D _inst_4 E _inst_7 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u6, u7} J _inst_1 C _inst_3 D _inst_4 F G) H) _inst_8)) (CategoryTheory.CategoryStruct.comp.{u5, u8} E (CategoryTheory.Category.toCategoryStruct.{u5, u8} E _inst_7) (CategoryTheory.Functor.obj.{u4, u5, u7, u8} D _inst_4 E _inst_7 H (CategoryTheory.Functor.obj.{u3, u4, u6, u7} C _inst_3 D _inst_4 G (CategoryTheory.Limits.limit.{u1, u2, u3, u6} J _inst_1 C _inst_3 F _inst_5))) (CategoryTheory.Functor.obj.{u4, u5, u7, u8} D _inst_4 E _inst_7 H (CategoryTheory.Limits.limit.{u1, u2, u4, u7} J _inst_1 D _inst_4 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u6, u7} J _inst_1 C _inst_3 D _inst_4 F G) _inst_6)) (CategoryTheory.Limits.limit.{u1, u2, u5, u8} J _inst_1 E _inst_7 (CategoryTheory.Functor.comp.{u1, u4, u5, u2, u7, u8} J _inst_1 D _inst_4 E _inst_7 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u6, u7} J _inst_1 C _inst_3 D _inst_4 F G) H) _inst_8) (CategoryTheory.Functor.map.{u4, u5, u7, u8} D _inst_4 E _inst_7 H (CategoryTheory.Functor.obj.{u3, u4, u6, u7} C _inst_3 D _inst_4 G (CategoryTheory.Limits.limit.{u1, u2, u3, u6} J _inst_1 C _inst_3 F _inst_5)) (CategoryTheory.Limits.limit.{u1, u2, u4, u7} J _inst_1 D _inst_4 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u6, u7} J _inst_1 C _inst_3 D _inst_4 F G) _inst_6) (CategoryTheory.Limits.limit.post.{u1, u2, u3, u4, u6, u7} J _inst_1 C _inst_3 F D _inst_4 _inst_5 G _inst_6)) (CategoryTheory.Limits.limit.post.{u1, u2, u4, u5, u7, u8} J _inst_1 D _inst_4 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u6, u7} J _inst_1 C _inst_3 D _inst_4 F G) E _inst_7 _inst_6 H _inst_8)) (CategoryTheory.Limits.limit.post.{u1, u2, u3, u5, u6, u8} J _inst_1 C _inst_3 F E _inst_7 _inst_5 (CategoryTheory.Functor.comp.{u3, u4, u5, u6, u7, u8} C _inst_3 D _inst_4 E _inst_7 G H) _inst_8)
but is expected to have type
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {C : Type.{u6}} [_inst_3 : CategoryTheory.Category.{u3, u6} C] (F : CategoryTheory.Functor.{u1, u3, u2, u6} J _inst_1 C _inst_3) {D : Type.{u7}} [_inst_4 : CategoryTheory.Category.{u4, u7} D] [_inst_5 : CategoryTheory.Limits.HasLimit.{u1, u2, u3, u6} J _inst_1 C _inst_3 F] (G : CategoryTheory.Functor.{u3, u4, u6, u7} C _inst_3 D _inst_4) [_inst_6 : CategoryTheory.Limits.HasLimit.{u1, u2, u4, u7} J _inst_1 D _inst_4 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u6, u7} J _inst_1 C _inst_3 D _inst_4 F G)] {E : Type.{u8}} [_inst_7 : CategoryTheory.Category.{u5, u8} E] (H : CategoryTheory.Functor.{u4, u5, u7, u8} D _inst_4 E _inst_7) [_inst_8 : CategoryTheory.Limits.HasLimit.{u1, u2, u5, u8} J _inst_1 E _inst_7 (CategoryTheory.Functor.comp.{u1, u4, u5, u2, u7, u8} J _inst_1 D _inst_4 E _inst_7 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u6, u7} J _inst_1 C _inst_3 D _inst_4 F G) H)], Eq.{succ u5} (Quiver.Hom.{succ u5, u8} E (CategoryTheory.CategoryStruct.toQuiver.{u5, u8} E (CategoryTheory.Category.toCategoryStruct.{u5, u8} E _inst_7)) (Prefunctor.obj.{succ u4, succ u5, u7, u8} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u7} D (CategoryTheory.Category.toCategoryStruct.{u4, u7} D _inst_4)) E (CategoryTheory.CategoryStruct.toQuiver.{u5, u8} E (CategoryTheory.Category.toCategoryStruct.{u5, u8} E _inst_7)) (CategoryTheory.Functor.toPrefunctor.{u4, u5, u7, u8} D _inst_4 E _inst_7 H) (Prefunctor.obj.{succ u3, succ u4, u6, u7} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u6} C (CategoryTheory.Category.toCategoryStruct.{u3, u6} C _inst_3)) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u7} D (CategoryTheory.Category.toCategoryStruct.{u4, u7} D _inst_4)) (CategoryTheory.Functor.toPrefunctor.{u3, u4, u6, u7} C _inst_3 D _inst_4 G) (CategoryTheory.Limits.limit.{u1, u2, u3, u6} J _inst_1 C _inst_3 F _inst_5))) (CategoryTheory.Limits.limit.{u1, u2, u5, u8} J _inst_1 E _inst_7 (CategoryTheory.Functor.comp.{u1, u4, u5, u2, u7, u8} J _inst_1 D _inst_4 E _inst_7 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u6, u7} J _inst_1 C _inst_3 D _inst_4 F G) H) _inst_8)) (CategoryTheory.CategoryStruct.comp.{u5, u8} E (CategoryTheory.Category.toCategoryStruct.{u5, u8} E _inst_7) (Prefunctor.obj.{succ u4, succ u5, u7, u8} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u7} D (CategoryTheory.Category.toCategoryStruct.{u4, u7} D _inst_4)) E (CategoryTheory.CategoryStruct.toQuiver.{u5, u8} E (CategoryTheory.Category.toCategoryStruct.{u5, u8} E _inst_7)) (CategoryTheory.Functor.toPrefunctor.{u4, u5, u7, u8} D _inst_4 E _inst_7 H) (Prefunctor.obj.{succ u3, succ u4, u6, u7} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u6} C (CategoryTheory.Category.toCategoryStruct.{u3, u6} C _inst_3)) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u7} D (CategoryTheory.Category.toCategoryStruct.{u4, u7} D _inst_4)) (CategoryTheory.Functor.toPrefunctor.{u3, u4, u6, u7} C _inst_3 D _inst_4 G) (CategoryTheory.Limits.limit.{u1, u2, u3, u6} J _inst_1 C _inst_3 F _inst_5))) (Prefunctor.obj.{succ u4, succ u5, u7, u8} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u7} D (CategoryTheory.Category.toCategoryStruct.{u4, u7} D _inst_4)) E (CategoryTheory.CategoryStruct.toQuiver.{u5, u8} E (CategoryTheory.Category.toCategoryStruct.{u5, u8} E _inst_7)) (CategoryTheory.Functor.toPrefunctor.{u4, u5, u7, u8} D _inst_4 E _inst_7 H) (CategoryTheory.Limits.limit.{u1, u2, u4, u7} J _inst_1 D _inst_4 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u6, u7} J _inst_1 C _inst_3 D _inst_4 F G) _inst_6)) (CategoryTheory.Limits.limit.{u1, u2, u5, u8} J _inst_1 E _inst_7 (CategoryTheory.Functor.comp.{u1, u4, u5, u2, u7, u8} J _inst_1 D _inst_4 E _inst_7 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u6, u7} J _inst_1 C _inst_3 D _inst_4 F G) H) _inst_8) (Prefunctor.map.{succ u4, succ u5, u7, u8} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u7} D (CategoryTheory.Category.toCategoryStruct.{u4, u7} D _inst_4)) E (CategoryTheory.CategoryStruct.toQuiver.{u5, u8} E (CategoryTheory.Category.toCategoryStruct.{u5, u8} E _inst_7)) (CategoryTheory.Functor.toPrefunctor.{u4, u5, u7, u8} D _inst_4 E _inst_7 H) (Prefunctor.obj.{succ u3, succ u4, u6, u7} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u6} C (CategoryTheory.Category.toCategoryStruct.{u3, u6} C _inst_3)) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u7} D (CategoryTheory.Category.toCategoryStruct.{u4, u7} D _inst_4)) (CategoryTheory.Functor.toPrefunctor.{u3, u4, u6, u7} C _inst_3 D _inst_4 G) (CategoryTheory.Limits.limit.{u1, u2, u3, u6} J _inst_1 C _inst_3 F _inst_5)) (CategoryTheory.Limits.limit.{u1, u2, u4, u7} J _inst_1 D _inst_4 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u6, u7} J _inst_1 C _inst_3 D _inst_4 F G) _inst_6) (CategoryTheory.Limits.limit.post.{u1, u2, u3, u4, u6, u7} J _inst_1 C _inst_3 F D _inst_4 _inst_5 G _inst_6)) (CategoryTheory.Limits.limit.post.{u1, u2, u4, u5, u7, u8} J _inst_1 D _inst_4 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u6, u7} J _inst_1 C _inst_3 D _inst_4 F G) E _inst_7 _inst_6 H _inst_8)) (CategoryTheory.Limits.limit.post.{u1, u2, u3, u5, u6, u8} J _inst_1 C _inst_3 F E _inst_7 _inst_5 (CategoryTheory.Functor.comp.{u3, u4, u5, u6, u7, u8} C _inst_3 D _inst_4 E _inst_7 G H) _inst_8)
Case conversion may be inaccurate. Consider using '#align category_theory.limits.limit.post_post CategoryTheory.Limits.limit.post_post‚Çì'. -/
@[simp]
theorem limit.post_post {E : Type u''} [Category.{v''} E] (H : D ‚•§ E)
    [HasLimit ((F ‚ãô G) ‚ãô H)] :-- H G (limit F) ‚ü∂ H (limit (F ‚ãô G)) ‚ü∂ limit ((F ‚ãô G) ‚ãô H) equals 
            -- H G (limit F) ‚ü∂ limit (F ‚ãô (G ‚ãô H))
            H.map
          (limit.post F G) ‚â´
        limit.post (F ‚ãô G) H =
      limit.post F (G ‚ãô H) :=
  by ext <;> erw [assoc, limit.post_œÄ, ‚Üê H.map_comp, limit.post_œÄ, limit.post_œÄ] <;> rfl
#align category_theory.limits.limit.post_post CategoryTheory.Limits.limit.post_post

end Post

/- warning: category_theory.limits.limit.pre_post -> CategoryTheory.Limits.limit.pre_post is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {K : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u3, u4} K] {C : Type.{u7}} [_inst_3 : CategoryTheory.Category.{u5, u7} C] {D : Type.{u8}} [_inst_4 : CategoryTheory.Category.{u6, u8} D] (E : CategoryTheory.Functor.{u3, u1, u4, u2} K _inst_2 J _inst_1) (F : CategoryTheory.Functor.{u1, u5, u2, u7} J _inst_1 C _inst_3) (G : CategoryTheory.Functor.{u5, u6, u7, u8} C _inst_3 D _inst_4) [_inst_5 : CategoryTheory.Limits.HasLimit.{u1, u2, u5, u7} J _inst_1 C _inst_3 F] [_inst_6 : CategoryTheory.Limits.HasLimit.{u3, u4, u5, u7} K _inst_2 C _inst_3 (CategoryTheory.Functor.comp.{u3, u1, u5, u4, u2, u7} K _inst_2 J _inst_1 C _inst_3 E F)] [_inst_7 : CategoryTheory.Limits.HasLimit.{u1, u2, u6, u8} J _inst_1 D _inst_4 (CategoryTheory.Functor.comp.{u1, u5, u6, u2, u7, u8} J _inst_1 C _inst_3 D _inst_4 F G)] [_inst_8 : CategoryTheory.Limits.HasLimit.{u3, u4, u6, u8} K _inst_2 D _inst_4 (CategoryTheory.Functor.comp.{u3, u5, u6, u4, u7, u8} K _inst_2 C _inst_3 D _inst_4 (CategoryTheory.Functor.comp.{u3, u1, u5, u4, u2, u7} K _inst_2 J _inst_1 C _inst_3 E F) G)], Eq.{succ u6} (Quiver.Hom.{succ u6, u8} D (CategoryTheory.CategoryStruct.toQuiver.{u6, u8} D (CategoryTheory.Category.toCategoryStruct.{u6, u8} D _inst_4)) (CategoryTheory.Functor.obj.{u5, u6, u7, u8} C _inst_3 D _inst_4 G (CategoryTheory.Limits.limit.{u1, u2, u5, u7} J _inst_1 C _inst_3 F _inst_5)) (CategoryTheory.Limits.limit.{u3, u4, u6, u8} K _inst_2 D _inst_4 (CategoryTheory.Functor.comp.{u3, u5, u6, u4, u7, u8} K _inst_2 C _inst_3 D _inst_4 (CategoryTheory.Functor.comp.{u3, u1, u5, u4, u2, u7} K _inst_2 J _inst_1 C _inst_3 E F) G) _inst_8)) (CategoryTheory.CategoryStruct.comp.{u6, u8} D (CategoryTheory.Category.toCategoryStruct.{u6, u8} D _inst_4) (CategoryTheory.Functor.obj.{u5, u6, u7, u8} C _inst_3 D _inst_4 G (CategoryTheory.Limits.limit.{u1, u2, u5, u7} J _inst_1 C _inst_3 F _inst_5)) (CategoryTheory.Functor.obj.{u5, u6, u7, u8} C _inst_3 D _inst_4 G (CategoryTheory.Limits.limit.{u3, u4, u5, u7} K _inst_2 C _inst_3 (CategoryTheory.Functor.comp.{u3, u1, u5, u4, u2, u7} K _inst_2 J _inst_1 C _inst_3 E F) _inst_6)) (CategoryTheory.Limits.limit.{u3, u4, u6, u8} K _inst_2 D _inst_4 (CategoryTheory.Functor.comp.{u3, u5, u6, u4, u7, u8} K _inst_2 C _inst_3 D _inst_4 (CategoryTheory.Functor.comp.{u3, u1, u5, u4, u2, u7} K _inst_2 J _inst_1 C _inst_3 E F) G) _inst_8) (CategoryTheory.Functor.map.{u5, u6, u7, u8} C _inst_3 D _inst_4 G (CategoryTheory.Limits.limit.{u1, u2, u5, u7} J _inst_1 C _inst_3 F _inst_5) (CategoryTheory.Limits.limit.{u3, u4, u5, u7} K _inst_2 C _inst_3 (CategoryTheory.Functor.comp.{u3, u1, u5, u4, u2, u7} K _inst_2 J _inst_1 C _inst_3 E F) _inst_6) (CategoryTheory.Limits.limit.pre.{u1, u2, u3, u4, u5, u7} J _inst_1 K _inst_2 C _inst_3 F _inst_5 E _inst_6)) (CategoryTheory.Limits.limit.post.{u3, u4, u5, u6, u7, u8} K _inst_2 C _inst_3 (CategoryTheory.Functor.comp.{u3, u1, u5, u4, u2, u7} K _inst_2 J _inst_1 C _inst_3 E F) D _inst_4 _inst_6 G _inst_8)) (CategoryTheory.CategoryStruct.comp.{u6, u8} D (CategoryTheory.Category.toCategoryStruct.{u6, u8} D _inst_4) (CategoryTheory.Functor.obj.{u5, u6, u7, u8} C _inst_3 D _inst_4 G (CategoryTheory.Limits.limit.{u1, u2, u5, u7} J _inst_1 C _inst_3 F _inst_5)) (CategoryTheory.Limits.limit.{u1, u2, u6, u8} J _inst_1 D _inst_4 (CategoryTheory.Functor.comp.{u1, u5, u6, u2, u7, u8} J _inst_1 C _inst_3 D _inst_4 F G) _inst_7) (CategoryTheory.Limits.limit.{u3, u4, u6, u8} K _inst_2 D _inst_4 (CategoryTheory.Functor.comp.{u3, u5, u6, u4, u7, u8} K _inst_2 C _inst_3 D _inst_4 (CategoryTheory.Functor.comp.{u3, u1, u5, u4, u2, u7} K _inst_2 J _inst_1 C _inst_3 E F) G) _inst_8) (CategoryTheory.Limits.limit.post.{u1, u2, u5, u6, u7, u8} J _inst_1 C _inst_3 F D _inst_4 _inst_5 G _inst_7) (CategoryTheory.Limits.limit.pre.{u1, u2, u3, u4, u6, u8} J _inst_1 K _inst_2 D _inst_4 (CategoryTheory.Functor.comp.{u1, u5, u6, u2, u7, u8} J _inst_1 C _inst_3 D _inst_4 F G) _inst_7 E _inst_8))
but is expected to have type
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {K : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u3, u4} K] {C : Type.{u7}} [_inst_3 : CategoryTheory.Category.{u5, u7} C] {D : Type.{u8}} [_inst_4 : CategoryTheory.Category.{u6, u8} D] (E : CategoryTheory.Functor.{u3, u1, u4, u2} K _inst_2 J _inst_1) (F : CategoryTheory.Functor.{u1, u5, u2, u7} J _inst_1 C _inst_3) (G : CategoryTheory.Functor.{u5, u6, u7, u8} C _inst_3 D _inst_4) [_inst_5 : CategoryTheory.Limits.HasLimit.{u1, u2, u5, u7} J _inst_1 C _inst_3 F] [_inst_6 : CategoryTheory.Limits.HasLimit.{u3, u4, u5, u7} K _inst_2 C _inst_3 (CategoryTheory.Functor.comp.{u3, u1, u5, u4, u2, u7} K _inst_2 J _inst_1 C _inst_3 E F)] [_inst_7 : CategoryTheory.Limits.HasLimit.{u1, u2, u6, u8} J _inst_1 D _inst_4 (CategoryTheory.Functor.comp.{u1, u5, u6, u2, u7, u8} J _inst_1 C _inst_3 D _inst_4 F G)] [_inst_8 : CategoryTheory.Limits.HasLimit.{u3, u4, u6, u8} K _inst_2 D _inst_4 (CategoryTheory.Functor.comp.{u3, u5, u6, u4, u7, u8} K _inst_2 C _inst_3 D _inst_4 (CategoryTheory.Functor.comp.{u3, u1, u5, u4, u2, u7} K _inst_2 J _inst_1 C _inst_3 E F) G)], Eq.{succ u6} (Quiver.Hom.{succ u6, u8} D (CategoryTheory.CategoryStruct.toQuiver.{u6, u8} D (CategoryTheory.Category.toCategoryStruct.{u6, u8} D _inst_4)) (Prefunctor.obj.{succ u5, succ u6, u7, u8} C (CategoryTheory.CategoryStruct.toQuiver.{u5, u7} C (CategoryTheory.Category.toCategoryStruct.{u5, u7} C _inst_3)) D (CategoryTheory.CategoryStruct.toQuiver.{u6, u8} D (CategoryTheory.Category.toCategoryStruct.{u6, u8} D _inst_4)) (CategoryTheory.Functor.toPrefunctor.{u5, u6, u7, u8} C _inst_3 D _inst_4 G) (CategoryTheory.Limits.limit.{u1, u2, u5, u7} J _inst_1 C _inst_3 F _inst_5)) (CategoryTheory.Limits.limit.{u3, u4, u6, u8} K _inst_2 D _inst_4 (CategoryTheory.Functor.comp.{u3, u5, u6, u4, u7, u8} K _inst_2 C _inst_3 D _inst_4 (CategoryTheory.Functor.comp.{u3, u1, u5, u4, u2, u7} K _inst_2 J _inst_1 C _inst_3 E F) G) _inst_8)) (CategoryTheory.CategoryStruct.comp.{u6, u8} D (CategoryTheory.Category.toCategoryStruct.{u6, u8} D _inst_4) (Prefunctor.obj.{succ u5, succ u6, u7, u8} C (CategoryTheory.CategoryStruct.toQuiver.{u5, u7} C (CategoryTheory.Category.toCategoryStruct.{u5, u7} C _inst_3)) D (CategoryTheory.CategoryStruct.toQuiver.{u6, u8} D (CategoryTheory.Category.toCategoryStruct.{u6, u8} D _inst_4)) (CategoryTheory.Functor.toPrefunctor.{u5, u6, u7, u8} C _inst_3 D _inst_4 G) (CategoryTheory.Limits.limit.{u1, u2, u5, u7} J _inst_1 C _inst_3 F _inst_5)) (Prefunctor.obj.{succ u5, succ u6, u7, u8} C (CategoryTheory.CategoryStruct.toQuiver.{u5, u7} C (CategoryTheory.Category.toCategoryStruct.{u5, u7} C _inst_3)) D (CategoryTheory.CategoryStruct.toQuiver.{u6, u8} D (CategoryTheory.Category.toCategoryStruct.{u6, u8} D _inst_4)) (CategoryTheory.Functor.toPrefunctor.{u5, u6, u7, u8} C _inst_3 D _inst_4 G) (CategoryTheory.Limits.limit.{u3, u4, u5, u7} K _inst_2 C _inst_3 (CategoryTheory.Functor.comp.{u3, u1, u5, u4, u2, u7} K _inst_2 J _inst_1 C _inst_3 E F) _inst_6)) (CategoryTheory.Limits.limit.{u3, u4, u6, u8} K _inst_2 D _inst_4 (CategoryTheory.Functor.comp.{u3, u5, u6, u4, u7, u8} K _inst_2 C _inst_3 D _inst_4 (CategoryTheory.Functor.comp.{u3, u1, u5, u4, u2, u7} K _inst_2 J _inst_1 C _inst_3 E F) G) _inst_8) (Prefunctor.map.{succ u5, succ u6, u7, u8} C (CategoryTheory.CategoryStruct.toQuiver.{u5, u7} C (CategoryTheory.Category.toCategoryStruct.{u5, u7} C _inst_3)) D (CategoryTheory.CategoryStruct.toQuiver.{u6, u8} D (CategoryTheory.Category.toCategoryStruct.{u6, u8} D _inst_4)) (CategoryTheory.Functor.toPrefunctor.{u5, u6, u7, u8} C _inst_3 D _inst_4 G) (CategoryTheory.Limits.limit.{u1, u2, u5, u7} J _inst_1 C _inst_3 F _inst_5) (CategoryTheory.Limits.limit.{u3, u4, u5, u7} K _inst_2 C _inst_3 (CategoryTheory.Functor.comp.{u3, u1, u5, u4, u2, u7} K _inst_2 J _inst_1 C _inst_3 E F) _inst_6) (CategoryTheory.Limits.limit.pre.{u1, u2, u3, u4, u5, u7} J _inst_1 K _inst_2 C _inst_3 F _inst_5 E _inst_6)) (CategoryTheory.Limits.limit.post.{u3, u4, u5, u6, u7, u8} K _inst_2 C _inst_3 (CategoryTheory.Functor.comp.{u3, u1, u5, u4, u2, u7} K _inst_2 J _inst_1 C _inst_3 E F) D _inst_4 _inst_6 G _inst_8)) (CategoryTheory.CategoryStruct.comp.{u6, u8} D (CategoryTheory.Category.toCategoryStruct.{u6, u8} D _inst_4) (Prefunctor.obj.{succ u5, succ u6, u7, u8} C (CategoryTheory.CategoryStruct.toQuiver.{u5, u7} C (CategoryTheory.Category.toCategoryStruct.{u5, u7} C _inst_3)) D (CategoryTheory.CategoryStruct.toQuiver.{u6, u8} D (CategoryTheory.Category.toCategoryStruct.{u6, u8} D _inst_4)) (CategoryTheory.Functor.toPrefunctor.{u5, u6, u7, u8} C _inst_3 D _inst_4 G) (CategoryTheory.Limits.limit.{u1, u2, u5, u7} J _inst_1 C _inst_3 F _inst_5)) (CategoryTheory.Limits.limit.{u1, u2, u6, u8} J _inst_1 D _inst_4 (CategoryTheory.Functor.comp.{u1, u5, u6, u2, u7, u8} J _inst_1 C _inst_3 D _inst_4 F G) _inst_7) (CategoryTheory.Limits.limit.{u3, u4, u6, u8} K _inst_2 D _inst_4 (CategoryTheory.Functor.comp.{u3, u1, u6, u4, u2, u8} K _inst_2 J _inst_1 D _inst_4 E (CategoryTheory.Functor.comp.{u1, u5, u6, u2, u7, u8} J _inst_1 C _inst_3 D _inst_4 F G)) _inst_8) (CategoryTheory.Limits.limit.post.{u1, u2, u5, u6, u7, u8} J _inst_1 C _inst_3 F D _inst_4 _inst_5 G _inst_7) (CategoryTheory.Limits.limit.pre.{u1, u2, u3, u4, u6, u8} J _inst_1 K _inst_2 D _inst_4 (CategoryTheory.Functor.comp.{u1, u5, u6, u2, u7, u8} J _inst_1 C _inst_3 D _inst_4 F G) _inst_7 E _inst_8))
Case conversion may be inaccurate. Consider using '#align category_theory.limits.limit.pre_post CategoryTheory.Limits.limit.pre_post‚Çì'. -/
theorem limit.pre_post {D : Type u'} [Category.{v'} D] (E : K ‚•§ J) (F : J ‚•§ C) (G : C ‚•§ D)
    [HasLimit F] [HasLimit (E ‚ãô F)] [HasLimit (F ‚ãô G)]
    [HasLimit ((E ‚ãô F) ‚ãô G)] :-- G (limit F) ‚ü∂ G (limit (E ‚ãô F)) ‚ü∂ limit ((E ‚ãô F) ‚ãô G) vs 
            -- G (limit F) ‚ü∂ limit F ‚ãô G ‚ü∂ limit (E ‚ãô (F ‚ãô G)) or
            G.map
          (limit.pre F E) ‚â´
        limit.post (E ‚ãô F) G =
      limit.post F G ‚â´ limit.pre (F ‚ãô G) E :=
  by
  ext <;> erw [assoc, limit.post_œÄ, ‚Üê G.map_comp, limit.pre_œÄ, assoc, limit.pre_œÄ, limit.post_œÄ] <;>
    rfl
#align category_theory.limits.limit.pre_post CategoryTheory.Limits.limit.pre_post

open CategoryTheory.Equivalence

/- warning: category_theory.limits.has_limit_equivalence_comp -> CategoryTheory.Limits.hasLimitEquivalenceComp is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {K : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u3, u4} K] {C : Type.{u6}} [_inst_3 : CategoryTheory.Category.{u5, u6} C] {F : CategoryTheory.Functor.{u1, u5, u2, u6} J _inst_1 C _inst_3} (e : CategoryTheory.Equivalence.{u3, u1, u4, u2} K _inst_2 J _inst_1) [_inst_4 : CategoryTheory.Limits.HasLimit.{u1, u2, u5, u6} J _inst_1 C _inst_3 F], CategoryTheory.Limits.HasLimit.{u3, u4, u5, u6} K _inst_2 C _inst_3 (CategoryTheory.Functor.comp.{u3, u1, u5, u4, u2, u6} K _inst_2 J _inst_1 C _inst_3 (CategoryTheory.Equivalence.functor.{u3, u1, u4, u2} K _inst_2 J _inst_1 e) F)
but is expected to have type
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {K : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u3, u4} K] {C : Type.{u6}} [_inst_3 : CategoryTheory.Category.{u5, u6} C] {F : CategoryTheory.Functor.{u1, u5, u2, u6} J _inst_1 C _inst_3} (e : CategoryTheory.Equivalence.{u3, u1, u4, u2} K J _inst_2 _inst_1) [_inst_4 : CategoryTheory.Limits.HasLimit.{u1, u2, u5, u6} J _inst_1 C _inst_3 F], CategoryTheory.Limits.HasLimit.{u3, u4, u5, u6} K _inst_2 C _inst_3 (CategoryTheory.Functor.comp.{u3, u1, u5, u4, u2, u6} K _inst_2 J _inst_1 C _inst_3 (CategoryTheory.Equivalence.functor.{u3, u1, u4, u2} K J _inst_2 _inst_1 e) F)
Case conversion may be inaccurate. Consider using '#align category_theory.limits.has_limit_equivalence_comp CategoryTheory.Limits.hasLimitEquivalenceComp‚Çì'. -/
instance hasLimitEquivalenceComp (e : K ‚âå J) [HasLimit F] : HasLimit (e.Functor ‚ãô F) :=
  HasLimit.mk
    { Cone := Cone.whisker e.Functor (limit.cone F)
      IsLimit := IsLimit.whiskerEquivalence (limit.isLimit F) e }
#align category_theory.limits.has_limit_equivalence_comp CategoryTheory.Limits.hasLimitEquivalenceComp

attribute [local elab_without_expected_type] inv_fun_id_assoc

/- warning: category_theory.limits.has_limit_of_equivalence_comp -> CategoryTheory.Limits.hasLimitOfEquivalenceComp is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {K : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u3, u4} K] {C : Type.{u6}} [_inst_3 : CategoryTheory.Category.{u5, u6} C] {F : CategoryTheory.Functor.{u1, u5, u2, u6} J _inst_1 C _inst_3} (e : CategoryTheory.Equivalence.{u3, u1, u4, u2} K _inst_2 J _inst_1) [_inst_4 : CategoryTheory.Limits.HasLimit.{u3, u4, u5, u6} K _inst_2 C _inst_3 (CategoryTheory.Functor.comp.{u3, u1, u5, u4, u2, u6} K _inst_2 J _inst_1 C _inst_3 (CategoryTheory.Equivalence.functor.{u3, u1, u4, u2} K _inst_2 J _inst_1 e) F)], CategoryTheory.Limits.HasLimit.{u1, u2, u5, u6} J _inst_1 C _inst_3 F
but is expected to have type
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {K : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u3, u4} K] {C : Type.{u6}} [_inst_3 : CategoryTheory.Category.{u5, u6} C] {F : CategoryTheory.Functor.{u1, u5, u2, u6} J _inst_1 C _inst_3} (e : CategoryTheory.Equivalence.{u3, u1, u4, u2} K J _inst_2 _inst_1) [_inst_4 : CategoryTheory.Limits.HasLimit.{u3, u4, u5, u6} K _inst_2 C _inst_3 (CategoryTheory.Functor.comp.{u3, u1, u5, u4, u2, u6} K _inst_2 J _inst_1 C _inst_3 (CategoryTheory.Equivalence.functor.{u3, u1, u4, u2} K J _inst_2 _inst_1 e) F)], CategoryTheory.Limits.HasLimit.{u1, u2, u5, u6} J _inst_1 C _inst_3 F
Case conversion may be inaccurate. Consider using '#align category_theory.limits.has_limit_of_equivalence_comp CategoryTheory.Limits.hasLimitOfEquivalenceComp‚Çì'. -/
-- not entirely sure why this is needed
/-- If a `E ‚ãô F` has a limit, and `E` is an equivalence, we can construct a limit of `F`.
-/
theorem hasLimitOfEquivalenceComp (e : K ‚âå J) [HasLimit (e.Functor ‚ãô F)] : HasLimit F :=
  by
  haveI : has_limit (e.inverse ‚ãô e.functor ‚ãô F) := limits.has_limit_equivalence_comp e.symm
  apply has_limit_of_iso (e.inv_fun_id_assoc F)
#align category_theory.limits.has_limit_of_equivalence_comp CategoryTheory.Limits.hasLimitOfEquivalenceComp

-- `has_limit_comp_equivalence` and `has_limit_of_comp_equivalence`
-- are proved in `category_theory/adjunction/limits.lean`.
section LimFunctor

variable [HasLimitsOfShape J C]

section

#print CategoryTheory.Limits.lim /-
/-- `limit F` is functorial in `F`, when `C` has all limits of shape `J`. -/
@[simps obj]
def lim : (J ‚•§ C) ‚•§ C where
  obj F := limit F
  map F G Œ± := limMap Œ±
  map_id' F := by
    ext
    erw [lim_map_œÄ, category.id_comp, category.comp_id]
  map_comp' F G H Œ± Œ≤ := by
    ext <;> erw [assoc, is_limit.fac, is_limit.fac, ‚Üê assoc, is_limit.fac, assoc] <;> rfl
#align category_theory.limits.lim CategoryTheory.Limits.lim
-/

end

variable {F} {G : J ‚•§ C} (Œ± : F ‚ü∂ G)

-- We generate this manually since `simps` gives it a weird name.
@[simp]
theorem limMap_eq_limMap : lim.map Œ± = limMap Œ± :=
  rfl
#align category_theory.limits.lim_map_eq_lim_map CategoryTheory.Limits.limMap_eq_limMap

/- warning: category_theory.limits.limit.map_pre -> CategoryTheory.Limits.limit.map_pre is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {K : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u3, u4} K] {C : Type.{u6}} [_inst_3 : CategoryTheory.Category.{u5, u6} C] {F : CategoryTheory.Functor.{u1, u5, u2, u6} J _inst_1 C _inst_3} [_inst_4 : CategoryTheory.Limits.HasLimitsOfShape.{u1, u2, u5, u6} J _inst_1 C _inst_3] {G : CategoryTheory.Functor.{u1, u5, u2, u6} J _inst_1 C _inst_3} (Œ± : Quiver.Hom.{succ (max u2 u5), max u1 u5 u2 u6} (CategoryTheory.Functor.{u1, u5, u2, u6} J _inst_1 C _inst_3) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u5, max u1 u5 u2 u6} (CategoryTheory.Functor.{u1, u5, u2, u6} J _inst_1 C _inst_3) (CategoryTheory.Category.toCategoryStruct.{max u2 u5, max u1 u5 u2 u6} (CategoryTheory.Functor.{u1, u5, u2, u6} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u5, u2, u6} J _inst_1 C _inst_3))) F G) [_inst_5 : CategoryTheory.Limits.HasLimitsOfShape.{u3, u4, u5, u6} K _inst_2 C _inst_3] (E : CategoryTheory.Functor.{u3, u1, u4, u2} K _inst_2 J _inst_1), Eq.{succ u5} (Quiver.Hom.{succ u5, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u5, u6} C (CategoryTheory.Category.toCategoryStruct.{u5, u6} C _inst_3)) (CategoryTheory.Functor.obj.{max u2 u5, u5, max u1 u5 u2 u6, u6} (CategoryTheory.Functor.{u1, u5, u2, u6} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u5, u2, u6} J _inst_1 C _inst_3) C _inst_3 (CategoryTheory.Limits.lim.{u1, u2, u5, u6} J _inst_1 C _inst_3 _inst_4) F) (CategoryTheory.Limits.limit.{u3, u4, u5, u6} K _inst_2 C _inst_3 (CategoryTheory.Functor.comp.{u3, u1, u5, u4, u2, u6} K _inst_2 J _inst_1 C _inst_3 E G) (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u3, u4, u5, u6} C _inst_3 K _inst_2 _inst_5 (CategoryTheory.Functor.comp.{u3, u1, u5, u4, u2, u6} K _inst_2 J _inst_1 C _inst_3 E G)))) (CategoryTheory.CategoryStruct.comp.{u5, u6} C (CategoryTheory.Category.toCategoryStruct.{u5, u6} C _inst_3) (CategoryTheory.Functor.obj.{max u2 u5, u5, max u1 u5 u2 u6, u6} (CategoryTheory.Functor.{u1, u5, u2, u6} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u5, u2, u6} J _inst_1 C _inst_3) C _inst_3 (CategoryTheory.Limits.lim.{u1, u2, u5, u6} J _inst_1 C _inst_3 _inst_4) F) (CategoryTheory.Functor.obj.{max u2 u5, u5, max u1 u5 u2 u6, u6} (CategoryTheory.Functor.{u1, u5, u2, u6} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u5, u2, u6} J _inst_1 C _inst_3) C _inst_3 (CategoryTheory.Limits.lim.{u1, u2, u5, u6} J _inst_1 C _inst_3 _inst_4) G) (CategoryTheory.Limits.limit.{u3, u4, u5, u6} K _inst_2 C _inst_3 (CategoryTheory.Functor.comp.{u3, u1, u5, u4, u2, u6} K _inst_2 J _inst_1 C _inst_3 E G) (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u3, u4, u5, u6} C _inst_3 K _inst_2 _inst_5 (CategoryTheory.Functor.comp.{u3, u1, u5, u4, u2, u6} K _inst_2 J _inst_1 C _inst_3 E G))) (CategoryTheory.Functor.map.{max u2 u5, u5, max u1 u5 u2 u6, u6} (CategoryTheory.Functor.{u1, u5, u2, u6} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u5, u2, u6} J _inst_1 C _inst_3) C _inst_3 (CategoryTheory.Limits.lim.{u1, u2, u5, u6} J _inst_1 C _inst_3 _inst_4) F G Œ±) (CategoryTheory.Limits.limit.pre.{u1, u2, u3, u4, u5, u6} J _inst_1 K _inst_2 C _inst_3 G (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u2, u5, u6} C _inst_3 J _inst_1 _inst_4 G) E (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u3, u4, u5, u6} C _inst_3 K _inst_2 _inst_5 (CategoryTheory.Functor.comp.{u3, u1, u5, u4, u2, u6} K _inst_2 J _inst_1 C _inst_3 E G)))) (CategoryTheory.CategoryStruct.comp.{u5, u6} C (CategoryTheory.Category.toCategoryStruct.{u5, u6} C _inst_3) (CategoryTheory.Functor.obj.{max u2 u5, u5, max u1 u5 u2 u6, u6} (CategoryTheory.Functor.{u1, u5, u2, u6} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u5, u2, u6} J _inst_1 C _inst_3) C _inst_3 (CategoryTheory.Limits.lim.{u1, u2, u5, u6} J _inst_1 C _inst_3 _inst_4) F) (CategoryTheory.Limits.limit.{u3, u4, u5, u6} K _inst_2 C _inst_3 (CategoryTheory.Functor.comp.{u3, u1, u5, u4, u2, u6} K _inst_2 J _inst_1 C _inst_3 E F) (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u3, u4, u5, u6} C _inst_3 K _inst_2 _inst_5 (CategoryTheory.Functor.comp.{u3, u1, u5, u4, u2, u6} K _inst_2 J _inst_1 C _inst_3 E F))) (CategoryTheory.Limits.limit.{u3, u4, u5, u6} K _inst_2 C _inst_3 (CategoryTheory.Functor.comp.{u3, u1, u5, u4, u2, u6} K _inst_2 J _inst_1 C _inst_3 E G) (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u3, u4, u5, u6} C _inst_3 K _inst_2 _inst_5 (CategoryTheory.Functor.comp.{u3, u1, u5, u4, u2, u6} K _inst_2 J _inst_1 C _inst_3 E G))) (CategoryTheory.Limits.limit.pre.{u1, u2, u3, u4, u5, u6} J _inst_1 K _inst_2 C _inst_3 F (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u2, u5, u6} C _inst_3 J _inst_1 _inst_4 F) E (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u3, u4, u5, u6} C _inst_3 K _inst_2 _inst_5 (CategoryTheory.Functor.comp.{u3, u1, u5, u4, u2, u6} K _inst_2 J _inst_1 C _inst_3 E F))) (CategoryTheory.Functor.map.{max u4 u5, u5, max u3 u5 u4 u6, u6} (CategoryTheory.Functor.{u3, u5, u4, u6} K _inst_2 C _inst_3) (CategoryTheory.Functor.category.{u3, u5, u4, u6} K _inst_2 C _inst_3) C _inst_3 (CategoryTheory.Limits.lim.{u3, u4, u5, u6} K _inst_2 C _inst_3 _inst_5) (CategoryTheory.Functor.comp.{u3, u1, u5, u4, u2, u6} K _inst_2 J _inst_1 C _inst_3 E F) (CategoryTheory.Functor.comp.{u3, u1, u5, u4, u2, u6} K _inst_2 J _inst_1 C _inst_3 E G) (CategoryTheory.whiskerLeft.{u4, u3, u2, u1, u6, u5} K _inst_2 J _inst_1 C _inst_3 E F G Œ±)))
but is expected to have type
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {K : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u3, u4} K] {C : Type.{u6}} [_inst_3 : CategoryTheory.Category.{u5, u6} C] {F : CategoryTheory.Functor.{u1, u5, u2, u6} J _inst_1 C _inst_3} [_inst_4 : CategoryTheory.Limits.HasLimitsOfShape.{u1, u2, u5, u6} J _inst_1 C _inst_3] {G : CategoryTheory.Functor.{u1, u5, u2, u6} J _inst_1 C _inst_3} (Œ± : Quiver.Hom.{max (succ u2) (succ u5), max (max (max u6 u2) u5) u1} (CategoryTheory.Functor.{u1, u5, u2, u6} J _inst_1 C _inst_3) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u5, max (max (max u6 u2) u5) u1} (CategoryTheory.Functor.{u1, u5, u2, u6} J _inst_1 C _inst_3) (CategoryTheory.Category.toCategoryStruct.{max u2 u5, max (max (max u6 u2) u5) u1} (CategoryTheory.Functor.{u1, u5, u2, u6} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u5, u2, u6} J _inst_1 C _inst_3))) F G) [_inst_5 : CategoryTheory.Limits.HasLimitsOfShape.{u3, u4, u5, u6} K _inst_2 C _inst_3] (E : CategoryTheory.Functor.{u3, u1, u4, u2} K _inst_2 J _inst_1), Eq.{succ u5} (Quiver.Hom.{succ u5, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u5, u6} C (CategoryTheory.Category.toCategoryStruct.{u5, u6} C _inst_3)) (Prefunctor.obj.{max (succ u2) (succ u5), succ u5, max (max (max u2 u1) u6) u5, u6} (CategoryTheory.Functor.{u1, u5, u2, u6} J _inst_1 C _inst_3) (CategoryTheory.CategoryStruct.toQuiver.{max u5 u2, max (max (max u6 u5) u2) u1} (CategoryTheory.Functor.{u1, u5, u2, u6} J _inst_1 C _inst_3) (CategoryTheory.Category.toCategoryStruct.{max u5 u2, max (max (max u6 u5) u2) u1} (CategoryTheory.Functor.{u1, u5, u2, u6} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u5, u2, u6} J _inst_1 C _inst_3))) C (CategoryTheory.CategoryStruct.toQuiver.{u5, u6} C (CategoryTheory.Category.toCategoryStruct.{u5, u6} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{max u5 u2, u5, max (max (max u6 u5) u2) u1, u6} (CategoryTheory.Functor.{u1, u5, u2, u6} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u5, u2, u6} J _inst_1 C _inst_3) C _inst_3 (CategoryTheory.Limits.lim.{u1, u2, u5, u6} J _inst_1 C _inst_3 _inst_4)) F) (CategoryTheory.Limits.limit.{u3, u4, u5, u6} K _inst_2 C _inst_3 (CategoryTheory.Functor.comp.{u3, u1, u5, u4, u2, u6} K _inst_2 J _inst_1 C _inst_3 E G) (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u3, u4, u5, u6} C _inst_3 K _inst_2 _inst_5 (CategoryTheory.Functor.comp.{u3, u1, u5, u4, u2, u6} K _inst_2 J _inst_1 C _inst_3 E G)))) (CategoryTheory.CategoryStruct.comp.{u5, u6} C (CategoryTheory.Category.toCategoryStruct.{u5, u6} C _inst_3) (Prefunctor.obj.{max (succ u2) (succ u5), succ u5, max (max (max u2 u1) u6) u5, u6} (CategoryTheory.Functor.{u1, u5, u2, u6} J _inst_1 C _inst_3) (CategoryTheory.CategoryStruct.toQuiver.{max u5 u2, max (max (max u6 u5) u2) u1} (CategoryTheory.Functor.{u1, u5, u2, u6} J _inst_1 C _inst_3) (CategoryTheory.Category.toCategoryStruct.{max u5 u2, max (max (max u6 u5) u2) u1} (CategoryTheory.Functor.{u1, u5, u2, u6} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u5, u2, u6} J _inst_1 C _inst_3))) C (CategoryTheory.CategoryStruct.toQuiver.{u5, u6} C (CategoryTheory.Category.toCategoryStruct.{u5, u6} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{max u5 u2, u5, max (max (max u6 u5) u2) u1, u6} (CategoryTheory.Functor.{u1, u5, u2, u6} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u5, u2, u6} J _inst_1 C _inst_3) C _inst_3 (CategoryTheory.Limits.lim.{u1, u2, u5, u6} J _inst_1 C _inst_3 _inst_4)) F) (Prefunctor.obj.{max (succ u2) (succ u5), succ u5, max (max (max u2 u1) u6) u5, u6} (CategoryTheory.Functor.{u1, u5, u2, u6} J _inst_1 C _inst_3) (CategoryTheory.CategoryStruct.toQuiver.{max u5 u2, max (max (max u6 u5) u2) u1} (CategoryTheory.Functor.{u1, u5, u2, u6} J _inst_1 C _inst_3) (CategoryTheory.Category.toCategoryStruct.{max u5 u2, max (max (max u6 u5) u2) u1} (CategoryTheory.Functor.{u1, u5, u2, u6} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u5, u2, u6} J _inst_1 C _inst_3))) C (CategoryTheory.CategoryStruct.toQuiver.{u5, u6} C (CategoryTheory.Category.toCategoryStruct.{u5, u6} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{max u5 u2, u5, max (max (max u6 u5) u2) u1, u6} (CategoryTheory.Functor.{u1, u5, u2, u6} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u5, u2, u6} J _inst_1 C _inst_3) C _inst_3 (CategoryTheory.Limits.lim.{u1, u2, u5, u6} J _inst_1 C _inst_3 _inst_4)) G) (CategoryTheory.Limits.limit.{u3, u4, u5, u6} K _inst_2 C _inst_3 (CategoryTheory.Functor.comp.{u3, u1, u5, u4, u2, u6} K _inst_2 J _inst_1 C _inst_3 E G) (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u3, u4, u5, u6} C _inst_3 K _inst_2 _inst_5 (CategoryTheory.Functor.comp.{u3, u1, u5, u4, u2, u6} K _inst_2 J _inst_1 C _inst_3 E G))) (Prefunctor.map.{max (succ u2) (succ u5), succ u5, max (max (max u2 u1) u6) u5, u6} (CategoryTheory.Functor.{u1, u5, u2, u6} J _inst_1 C _inst_3) (CategoryTheory.CategoryStruct.toQuiver.{max u5 u2, max (max (max u6 u5) u2) u1} (CategoryTheory.Functor.{u1, u5, u2, u6} J _inst_1 C _inst_3) (CategoryTheory.Category.toCategoryStruct.{max u5 u2, max (max (max u6 u5) u2) u1} (CategoryTheory.Functor.{u1, u5, u2, u6} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u5, u2, u6} J _inst_1 C _inst_3))) C (CategoryTheory.CategoryStruct.toQuiver.{u5, u6} C (CategoryTheory.Category.toCategoryStruct.{u5, u6} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{max u5 u2, u5, max (max (max u6 u5) u2) u1, u6} (CategoryTheory.Functor.{u1, u5, u2, u6} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u5, u2, u6} J _inst_1 C _inst_3) C _inst_3 (CategoryTheory.Limits.lim.{u1, u2, u5, u6} J _inst_1 C _inst_3 _inst_4)) F G Œ±) (CategoryTheory.Limits.limit.pre.{u1, u2, u3, u4, u5, u6} J _inst_1 K _inst_2 C _inst_3 G (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u2, u5, u6} C _inst_3 J _inst_1 _inst_4 G) E (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u3, u4, u5, u6} C _inst_3 K _inst_2 _inst_5 (CategoryTheory.Functor.comp.{u3, u1, u5, u4, u2, u6} K _inst_2 J _inst_1 C _inst_3 E G)))) (CategoryTheory.CategoryStruct.comp.{u5, u6} C (CategoryTheory.Category.toCategoryStruct.{u5, u6} C _inst_3) (CategoryTheory.Limits.limit.{u1, u2, u5, u6} J _inst_1 C _inst_3 F (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u2, u5, u6} C _inst_3 J _inst_1 _inst_4 F)) (CategoryTheory.Limits.limit.{u3, u4, u5, u6} K _inst_2 C _inst_3 (CategoryTheory.Functor.comp.{u3, u1, u5, u4, u2, u6} K _inst_2 J _inst_1 C _inst_3 E F) (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u3, u4, u5, u6} C _inst_3 K _inst_2 _inst_5 (CategoryTheory.Functor.comp.{u3, u1, u5, u4, u2, u6} K _inst_2 J _inst_1 C _inst_3 E F))) (Prefunctor.obj.{max (succ u4) (succ u5), succ u5, max (max (max u4 u3) u6) u5, u6} (CategoryTheory.Functor.{u3, u5, u4, u6} K _inst_2 C _inst_3) (CategoryTheory.CategoryStruct.toQuiver.{max u5 u4, max (max (max u6 u5) u4) u3} (CategoryTheory.Functor.{u3, u5, u4, u6} K _inst_2 C _inst_3) (CategoryTheory.Category.toCategoryStruct.{max u5 u4, max (max (max u6 u5) u4) u3} (CategoryTheory.Functor.{u3, u5, u4, u6} K _inst_2 C _inst_3) (CategoryTheory.Functor.category.{u3, u5, u4, u6} K _inst_2 C _inst_3))) C (CategoryTheory.CategoryStruct.toQuiver.{u5, u6} C (CategoryTheory.Category.toCategoryStruct.{u5, u6} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{max u5 u4, u5, max (max (max u6 u5) u4) u3, u6} (CategoryTheory.Functor.{u3, u5, u4, u6} K _inst_2 C _inst_3) (CategoryTheory.Functor.category.{u3, u5, u4, u6} K _inst_2 C _inst_3) C _inst_3 (CategoryTheory.Limits.lim.{u3, u4, u5, u6} K _inst_2 C _inst_3 _inst_5)) (CategoryTheory.Functor.comp.{u3, u1, u5, u4, u2, u6} K _inst_2 J _inst_1 C _inst_3 E G)) (CategoryTheory.Limits.limit.pre.{u1, u2, u3, u4, u5, u6} J _inst_1 K _inst_2 C _inst_3 F (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u2, u5, u6} C _inst_3 J _inst_1 _inst_4 F) E (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u3, u4, u5, u6} C _inst_3 K _inst_2 _inst_5 (CategoryTheory.Functor.comp.{u3, u1, u5, u4, u2, u6} K _inst_2 J _inst_1 C _inst_3 E F))) (Prefunctor.map.{max (succ u4) (succ u5), succ u5, max (max (max u4 u3) u6) u5, u6} (CategoryTheory.Functor.{u3, u5, u4, u6} K _inst_2 C _inst_3) (CategoryTheory.CategoryStruct.toQuiver.{max u5 u4, max (max (max u6 u5) u4) u3} (CategoryTheory.Functor.{u3, u5, u4, u6} K _inst_2 C _inst_3) (CategoryTheory.Category.toCategoryStruct.{max u5 u4, max (max (max u6 u5) u4) u3} (CategoryTheory.Functor.{u3, u5, u4, u6} K _inst_2 C _inst_3) (CategoryTheory.Functor.category.{u3, u5, u4, u6} K _inst_2 C _inst_3))) C (CategoryTheory.CategoryStruct.toQuiver.{u5, u6} C (CategoryTheory.Category.toCategoryStruct.{u5, u6} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{max u5 u4, u5, max (max (max u6 u5) u4) u3, u6} (CategoryTheory.Functor.{u3, u5, u4, u6} K _inst_2 C _inst_3) (CategoryTheory.Functor.category.{u3, u5, u4, u6} K _inst_2 C _inst_3) C _inst_3 (CategoryTheory.Limits.lim.{u3, u4, u5, u6} K _inst_2 C _inst_3 _inst_5)) (CategoryTheory.Functor.comp.{u3, u1, u5, u4, u2, u6} K _inst_2 J _inst_1 C _inst_3 E F) (CategoryTheory.Functor.comp.{u3, u1, u5, u4, u2, u6} K _inst_2 J _inst_1 C _inst_3 E G) (CategoryTheory.whiskerLeft.{u4, u3, u2, u1, u6, u5} K _inst_2 J _inst_1 C _inst_3 E F G Œ±)))
Case conversion may be inaccurate. Consider using '#align category_theory.limits.limit.map_pre CategoryTheory.Limits.limit.map_pre‚Çì'. -/
theorem limit.map_pre [HasLimitsOfShape K C] (E : K ‚•§ J) :
    lim.map Œ± ‚â´ limit.pre G E = limit.pre F E ‚â´ lim.map (whiskerLeft E Œ±) :=
  by
  ext
  simp
#align category_theory.limits.limit.map_pre CategoryTheory.Limits.limit.map_pre

/- warning: category_theory.limits.limit.map_pre' -> CategoryTheory.Limits.limit.map_pre' is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {K : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u3, u4} K] {C : Type.{u6}} [_inst_3 : CategoryTheory.Category.{u5, u6} C] [_inst_4 : CategoryTheory.Limits.HasLimitsOfShape.{u1, u2, u5, u6} J _inst_1 C _inst_3] [_inst_5 : CategoryTheory.Limits.HasLimitsOfShape.{u3, u4, u5, u6} K _inst_2 C _inst_3] (F : CategoryTheory.Functor.{u1, u5, u2, u6} J _inst_1 C _inst_3) {E‚ÇÅ : CategoryTheory.Functor.{u3, u1, u4, u2} K _inst_2 J _inst_1} {E‚ÇÇ : CategoryTheory.Functor.{u3, u1, u4, u2} K _inst_2 J _inst_1} (Œ± : Quiver.Hom.{succ (max u4 u1), max u3 u1 u4 u2} (CategoryTheory.Functor.{u3, u1, u4, u2} K _inst_2 J _inst_1) (CategoryTheory.CategoryStruct.toQuiver.{max u4 u1, max u3 u1 u4 u2} (CategoryTheory.Functor.{u3, u1, u4, u2} K _inst_2 J _inst_1) (CategoryTheory.Category.toCategoryStruct.{max u4 u1, max u3 u1 u4 u2} (CategoryTheory.Functor.{u3, u1, u4, u2} K _inst_2 J _inst_1) (CategoryTheory.Functor.category.{u3, u1, u4, u2} K _inst_2 J _inst_1))) E‚ÇÅ E‚ÇÇ), Eq.{succ u5} (Quiver.Hom.{succ u5, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u5, u6} C (CategoryTheory.Category.toCategoryStruct.{u5, u6} C _inst_3)) (CategoryTheory.Limits.limit.{u1, u2, u5, u6} J _inst_1 C _inst_3 F (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u2, u5, u6} C _inst_3 J _inst_1 _inst_4 F)) (CategoryTheory.Limits.limit.{u3, u4, u5, u6} K _inst_2 C _inst_3 (CategoryTheory.Functor.comp.{u3, u1, u5, u4, u2, u6} K _inst_2 J _inst_1 C _inst_3 E‚ÇÇ F) (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u3, u4, u5, u6} C _inst_3 K _inst_2 _inst_5 (CategoryTheory.Functor.comp.{u3, u1, u5, u4, u2, u6} K _inst_2 J _inst_1 C _inst_3 E‚ÇÇ F)))) (CategoryTheory.Limits.limit.pre.{u1, u2, u3, u4, u5, u6} J _inst_1 K _inst_2 C _inst_3 F (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u2, u5, u6} C _inst_3 J _inst_1 _inst_4 F) E‚ÇÇ (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u3, u4, u5, u6} C _inst_3 K _inst_2 _inst_5 (CategoryTheory.Functor.comp.{u3, u1, u5, u4, u2, u6} K _inst_2 J _inst_1 C _inst_3 E‚ÇÇ F))) (CategoryTheory.CategoryStruct.comp.{u5, u6} C (CategoryTheory.Category.toCategoryStruct.{u5, u6} C _inst_3) (CategoryTheory.Limits.limit.{u1, u2, u5, u6} J _inst_1 C _inst_3 F (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u2, u5, u6} C _inst_3 J _inst_1 _inst_4 F)) (CategoryTheory.Limits.limit.{u3, u4, u5, u6} K _inst_2 C _inst_3 (CategoryTheory.Functor.comp.{u3, u1, u5, u4, u2, u6} K _inst_2 J _inst_1 C _inst_3 E‚ÇÅ F) (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u3, u4, u5, u6} C _inst_3 K _inst_2 _inst_5 (CategoryTheory.Functor.comp.{u3, u1, u5, u4, u2, u6} K _inst_2 J _inst_1 C _inst_3 E‚ÇÅ F))) (CategoryTheory.Limits.limit.{u3, u4, u5, u6} K _inst_2 C _inst_3 (CategoryTheory.Functor.comp.{u3, u1, u5, u4, u2, u6} K _inst_2 J _inst_1 C _inst_3 E‚ÇÇ F) (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u3, u4, u5, u6} C _inst_3 K _inst_2 _inst_5 (CategoryTheory.Functor.comp.{u3, u1, u5, u4, u2, u6} K _inst_2 J _inst_1 C _inst_3 E‚ÇÇ F))) (CategoryTheory.Limits.limit.pre.{u1, u2, u3, u4, u5, u6} J _inst_1 K _inst_2 C _inst_3 F (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u2, u5, u6} C _inst_3 J _inst_1 _inst_4 F) E‚ÇÅ (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u3, u4, u5, u6} C _inst_3 K _inst_2 _inst_5 (CategoryTheory.Functor.comp.{u3, u1, u5, u4, u2, u6} K _inst_2 J _inst_1 C _inst_3 E‚ÇÅ F))) (CategoryTheory.Functor.map.{max u4 u5, u5, max u3 u5 u4 u6, u6} (CategoryTheory.Functor.{u3, u5, u4, u6} K _inst_2 C _inst_3) (CategoryTheory.Functor.category.{u3, u5, u4, u6} K _inst_2 C _inst_3) C _inst_3 (CategoryTheory.Limits.lim.{u3, u4, u5, u6} K _inst_2 C _inst_3 _inst_5) (CategoryTheory.Functor.comp.{u3, u1, u5, u4, u2, u6} K _inst_2 J _inst_1 C _inst_3 E‚ÇÅ F) (CategoryTheory.Functor.comp.{u3, u1, u5, u4, u2, u6} K _inst_2 J _inst_1 C _inst_3 E‚ÇÇ F) (CategoryTheory.whiskerRight.{u4, u3, u2, u1, u6, u5} K _inst_2 J _inst_1 C _inst_3 E‚ÇÅ E‚ÇÇ Œ± F)))
but is expected to have type
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {K : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u3, u4} K] {C : Type.{u6}} [_inst_3 : CategoryTheory.Category.{u5, u6} C] [_inst_4 : CategoryTheory.Limits.HasLimitsOfShape.{u1, u2, u5, u6} J _inst_1 C _inst_3] [_inst_5 : CategoryTheory.Limits.HasLimitsOfShape.{u3, u4, u5, u6} K _inst_2 C _inst_3] (F : CategoryTheory.Functor.{u1, u5, u2, u6} J _inst_1 C _inst_3) {E‚ÇÅ : CategoryTheory.Functor.{u3, u1, u4, u2} K _inst_2 J _inst_1} {E‚ÇÇ : CategoryTheory.Functor.{u3, u1, u4, u2} K _inst_2 J _inst_1} (Œ± : Quiver.Hom.{max (succ u4) (succ u1), max (max (max u2 u4) u1) u3} (CategoryTheory.Functor.{u3, u1, u4, u2} K _inst_2 J _inst_1) (CategoryTheory.CategoryStruct.toQuiver.{max u4 u1, max (max (max u2 u4) u1) u3} (CategoryTheory.Functor.{u3, u1, u4, u2} K _inst_2 J _inst_1) (CategoryTheory.Category.toCategoryStruct.{max u4 u1, max (max (max u2 u4) u1) u3} (CategoryTheory.Functor.{u3, u1, u4, u2} K _inst_2 J _inst_1) (CategoryTheory.Functor.category.{u3, u1, u4, u2} K _inst_2 J _inst_1))) E‚ÇÅ E‚ÇÇ), Eq.{succ u5} (Quiver.Hom.{succ u5, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u5, u6} C (CategoryTheory.Category.toCategoryStruct.{u5, u6} C _inst_3)) (CategoryTheory.Limits.limit.{u1, u2, u5, u6} J _inst_1 C _inst_3 F (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u2, u5, u6} C _inst_3 J _inst_1 _inst_4 F)) (CategoryTheory.Limits.limit.{u3, u4, u5, u6} K _inst_2 C _inst_3 (CategoryTheory.Functor.comp.{u3, u1, u5, u4, u2, u6} K _inst_2 J _inst_1 C _inst_3 E‚ÇÇ F) (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u3, u4, u5, u6} C _inst_3 K _inst_2 _inst_5 (CategoryTheory.Functor.comp.{u3, u1, u5, u4, u2, u6} K _inst_2 J _inst_1 C _inst_3 E‚ÇÇ F)))) (CategoryTheory.Limits.limit.pre.{u1, u2, u3, u4, u5, u6} J _inst_1 K _inst_2 C _inst_3 F (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u2, u5, u6} C _inst_3 J _inst_1 _inst_4 F) E‚ÇÇ (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u3, u4, u5, u6} C _inst_3 K _inst_2 _inst_5 (CategoryTheory.Functor.comp.{u3, u1, u5, u4, u2, u6} K _inst_2 J _inst_1 C _inst_3 E‚ÇÇ F))) (CategoryTheory.CategoryStruct.comp.{u5, u6} C (CategoryTheory.Category.toCategoryStruct.{u5, u6} C _inst_3) (CategoryTheory.Limits.limit.{u1, u2, u5, u6} J _inst_1 C _inst_3 F (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u2, u5, u6} C _inst_3 J _inst_1 _inst_4 F)) (CategoryTheory.Limits.limit.{u3, u4, u5, u6} K _inst_2 C _inst_3 (CategoryTheory.Functor.comp.{u3, u1, u5, u4, u2, u6} K _inst_2 J _inst_1 C _inst_3 E‚ÇÅ F) (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u3, u4, u5, u6} C _inst_3 K _inst_2 _inst_5 (CategoryTheory.Functor.comp.{u3, u1, u5, u4, u2, u6} K _inst_2 J _inst_1 C _inst_3 E‚ÇÅ F))) (Prefunctor.obj.{max (succ u4) (succ u5), succ u5, max (max (max u4 u3) u6) u5, u6} (CategoryTheory.Functor.{u3, u5, u4, u6} K _inst_2 C _inst_3) (CategoryTheory.CategoryStruct.toQuiver.{max u5 u4, max (max (max u6 u5) u4) u3} (CategoryTheory.Functor.{u3, u5, u4, u6} K _inst_2 C _inst_3) (CategoryTheory.Category.toCategoryStruct.{max u5 u4, max (max (max u6 u5) u4) u3} (CategoryTheory.Functor.{u3, u5, u4, u6} K _inst_2 C _inst_3) (CategoryTheory.Functor.category.{u3, u5, u4, u6} K _inst_2 C _inst_3))) C (CategoryTheory.CategoryStruct.toQuiver.{u5, u6} C (CategoryTheory.Category.toCategoryStruct.{u5, u6} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{max u5 u4, u5, max (max (max u6 u5) u4) u3, u6} (CategoryTheory.Functor.{u3, u5, u4, u6} K _inst_2 C _inst_3) (CategoryTheory.Functor.category.{u3, u5, u4, u6} K _inst_2 C _inst_3) C _inst_3 (CategoryTheory.Limits.lim.{u3, u4, u5, u6} K _inst_2 C _inst_3 _inst_5)) (CategoryTheory.Functor.comp.{u3, u1, u5, u4, u2, u6} K _inst_2 J _inst_1 C _inst_3 E‚ÇÇ F)) (CategoryTheory.Limits.limit.pre.{u1, u2, u3, u4, u5, u6} J _inst_1 K _inst_2 C _inst_3 F (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u2, u5, u6} C _inst_3 J _inst_1 _inst_4 F) E‚ÇÅ (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u3, u4, u5, u6} C _inst_3 K _inst_2 _inst_5 (CategoryTheory.Functor.comp.{u3, u1, u5, u4, u2, u6} K _inst_2 J _inst_1 C _inst_3 E‚ÇÅ F))) (Prefunctor.map.{max (succ u4) (succ u5), succ u5, max (max (max u4 u3) u6) u5, u6} (CategoryTheory.Functor.{u3, u5, u4, u6} K _inst_2 C _inst_3) (CategoryTheory.CategoryStruct.toQuiver.{max u5 u4, max (max (max u6 u5) u4) u3} (CategoryTheory.Functor.{u3, u5, u4, u6} K _inst_2 C _inst_3) (CategoryTheory.Category.toCategoryStruct.{max u5 u4, max (max (max u6 u5) u4) u3} (CategoryTheory.Functor.{u3, u5, u4, u6} K _inst_2 C _inst_3) (CategoryTheory.Functor.category.{u3, u5, u4, u6} K _inst_2 C _inst_3))) C (CategoryTheory.CategoryStruct.toQuiver.{u5, u6} C (CategoryTheory.Category.toCategoryStruct.{u5, u6} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{max u5 u4, u5, max (max (max u6 u5) u4) u3, u6} (CategoryTheory.Functor.{u3, u5, u4, u6} K _inst_2 C _inst_3) (CategoryTheory.Functor.category.{u3, u5, u4, u6} K _inst_2 C _inst_3) C _inst_3 (CategoryTheory.Limits.lim.{u3, u4, u5, u6} K _inst_2 C _inst_3 _inst_5)) (CategoryTheory.Functor.comp.{u3, u1, u5, u4, u2, u6} K _inst_2 J _inst_1 C _inst_3 E‚ÇÅ F) (CategoryTheory.Functor.comp.{u3, u1, u5, u4, u2, u6} K _inst_2 J _inst_1 C _inst_3 E‚ÇÇ F) (CategoryTheory.whiskerRight.{u4, u3, u2, u1, u6, u5} K _inst_2 J _inst_1 C _inst_3 E‚ÇÅ E‚ÇÇ Œ± F)))
Case conversion may be inaccurate. Consider using '#align category_theory.limits.limit.map_pre' CategoryTheory.Limits.limit.map_pre'‚Çì'. -/
theorem limit.map_pre' [HasLimitsOfShape K C] (F : J ‚•§ C) {E‚ÇÅ E‚ÇÇ : K ‚•§ J} (Œ± : E‚ÇÅ ‚ü∂ E‚ÇÇ) :
    limit.pre F E‚ÇÇ = limit.pre F E‚ÇÅ ‚â´ lim.map (whiskerRight Œ± F) := by
  ext1 <;> simp [‚Üê category.assoc]
#align category_theory.limits.limit.map_pre' CategoryTheory.Limits.limit.map_pre'

/- warning: category_theory.limits.limit.id_pre -> CategoryTheory.Limits.limit.id_pre is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {C : Type.{u4}} [_inst_3 : CategoryTheory.Category.{u3, u4} C] [_inst_4 : CategoryTheory.Limits.HasLimitsOfShape.{u1, u2, u3, u4} J _inst_1 C _inst_3] (F : CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3), Eq.{succ u3} (Quiver.Hom.{succ u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Limits.limit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u2, u3, u4} C _inst_3 J _inst_1 _inst_4 F)) (CategoryTheory.Limits.limit.{u1, u2, u3, u4} J _inst_1 C _inst_3 (CategoryTheory.Functor.comp.{u1, u1, u3, u2, u2, u4} J _inst_1 J _inst_1 C _inst_3 (CategoryTheory.Functor.id.{u1, u2} J _inst_1) F) (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u2, u3, u4} C _inst_3 J _inst_1 _inst_4 (CategoryTheory.Functor.comp.{u1, u1, u3, u2, u2, u4} J _inst_1 J _inst_1 C _inst_3 (CategoryTheory.Functor.id.{u1, u2} J _inst_1) F)))) (CategoryTheory.Limits.limit.pre.{u1, u2, u1, u2, u3, u4} J _inst_1 J _inst_1 C _inst_3 F (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u2, u3, u4} C _inst_3 J _inst_1 _inst_4 F) (CategoryTheory.Functor.id.{u1, u2} J _inst_1) (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u2, u3, u4} C _inst_3 J _inst_1 _inst_4 (CategoryTheory.Functor.comp.{u1, u1, u3, u2, u2, u4} J _inst_1 J _inst_1 C _inst_3 (CategoryTheory.Functor.id.{u1, u2} J _inst_1) F))) (CategoryTheory.Functor.map.{max u2 u3, u3, max u1 u3 u2 u4, u4} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3) C _inst_3 (CategoryTheory.Limits.lim.{u1, u2, u3, u4} J _inst_1 C _inst_3 _inst_4) F (CategoryTheory.Functor.comp.{u1, u1, u3, u2, u2, u4} J _inst_1 J _inst_1 C _inst_3 (CategoryTheory.Functor.id.{u1, u2} J _inst_1) F) (CategoryTheory.Iso.inv.{max u2 u3, max u1 u3 u2 u4} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.comp.{u1, u1, u3, u2, u2, u4} J _inst_1 J _inst_1 C _inst_3 (CategoryTheory.Functor.id.{u1, u2} J _inst_1) F) F (CategoryTheory.Functor.leftUnitor.{u2, u1, u4, u3} J _inst_1 C _inst_3 F)))
but is expected to have type
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {C : Type.{u4}} [_inst_3 : CategoryTheory.Category.{u3, u4} C] [_inst_4 : CategoryTheory.Limits.HasLimitsOfShape.{u1, u2, u3, u4} J _inst_1 C _inst_3] (F : CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3), Eq.{succ u3} (Quiver.Hom.{succ u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Limits.limit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u2, u3, u4} C _inst_3 J _inst_1 _inst_4 F)) (CategoryTheory.Limits.limit.{u1, u2, u3, u4} J _inst_1 C _inst_3 (CategoryTheory.Functor.comp.{u1, u1, u3, u2, u2, u4} J _inst_1 J _inst_1 C _inst_3 (CategoryTheory.Functor.id.{u1, u2} J _inst_1) F) (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u2, u3, u4} C _inst_3 J _inst_1 _inst_4 (CategoryTheory.Functor.comp.{u1, u1, u3, u2, u2, u4} J _inst_1 J _inst_1 C _inst_3 (CategoryTheory.Functor.id.{u1, u2} J _inst_1) F)))) (CategoryTheory.Limits.limit.pre.{u1, u2, u1, u2, u3, u4} J _inst_1 J _inst_1 C _inst_3 F (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u2, u3, u4} C _inst_3 J _inst_1 _inst_4 F) (CategoryTheory.Functor.id.{u1, u2} J _inst_1) (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u2, u3, u4} C _inst_3 J _inst_1 _inst_4 (CategoryTheory.Functor.comp.{u1, u1, u3, u2, u2, u4} J _inst_1 J _inst_1 C _inst_3 (CategoryTheory.Functor.id.{u1, u2} J _inst_1) F))) (Prefunctor.map.{max (succ u2) (succ u3), succ u3, max (max (max u2 u1) u4) u3, u4} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max (max (max u4 u3) u2) u1} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max (max (max u4 u3) u2) u1} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3))) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, u3, max (max (max u4 u3) u2) u1, u4} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3) C _inst_3 (CategoryTheory.Limits.lim.{u1, u2, u3, u4} J _inst_1 C _inst_3 _inst_4)) F (CategoryTheory.Functor.comp.{u1, u1, u3, u2, u2, u4} J _inst_1 J _inst_1 C _inst_3 (CategoryTheory.Functor.id.{u1, u2} J _inst_1) F) (CategoryTheory.Iso.inv.{max u2 u3, max (max (max u4 u2) u3) u1} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.comp.{u1, u1, u3, u2, u2, u4} J _inst_1 J _inst_1 C _inst_3 (CategoryTheory.Functor.id.{u1, u2} J _inst_1) F) F (CategoryTheory.Functor.leftUnitor.{u2, u1, u4, u3} J _inst_1 C _inst_3 F)))
Case conversion may be inaccurate. Consider using '#align category_theory.limits.limit.id_pre CategoryTheory.Limits.limit.id_pre‚Çì'. -/
theorem limit.id_pre (F : J ‚•§ C) : limit.pre F (ùü≠ _) = lim.map (Functor.leftUnitor F).inv := by tidy
#align category_theory.limits.limit.id_pre CategoryTheory.Limits.limit.id_pre

/- warning: category_theory.limits.limit.map_post -> CategoryTheory.Limits.limit.map_post is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {C : Type.{u5}} [_inst_3 : CategoryTheory.Category.{u3, u5} C] {F : CategoryTheory.Functor.{u1, u3, u2, u5} J _inst_1 C _inst_3} [_inst_4 : CategoryTheory.Limits.HasLimitsOfShape.{u1, u2, u3, u5} J _inst_1 C _inst_3] {G : CategoryTheory.Functor.{u1, u3, u2, u5} J _inst_1 C _inst_3} (Œ± : Quiver.Hom.{succ (max u2 u3), max u1 u3 u2 u5} (CategoryTheory.Functor.{u1, u3, u2, u5} J _inst_1 C _inst_3) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u3, max u1 u3 u2 u5} (CategoryTheory.Functor.{u1, u3, u2, u5} J _inst_1 C _inst_3) (CategoryTheory.Category.toCategoryStruct.{max u2 u3, max u1 u3 u2 u5} (CategoryTheory.Functor.{u1, u3, u2, u5} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u5} J _inst_1 C _inst_3))) F G) {D : Type.{u6}} [_inst_5 : CategoryTheory.Category.{u4, u6} D] [_inst_6 : CategoryTheory.Limits.HasLimitsOfShape.{u1, u2, u4, u6} J _inst_1 D _inst_5] (H : CategoryTheory.Functor.{u3, u4, u5, u6} C _inst_3 D _inst_5), Eq.{succ u4} (Quiver.Hom.{succ u4, u6} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} D (CategoryTheory.Category.toCategoryStruct.{u4, u6} D _inst_5)) (CategoryTheory.Functor.obj.{u3, u4, u5, u6} C _inst_3 D _inst_5 H (CategoryTheory.Limits.limit.{u1, u2, u3, u5} J _inst_1 C _inst_3 F (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u2, u3, u5} C _inst_3 J _inst_1 _inst_4 F))) (CategoryTheory.Limits.limit.{u1, u2, u4, u6} J _inst_1 D _inst_5 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_1 C _inst_3 D _inst_5 G H) (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u2, u4, u6} D _inst_5 J _inst_1 _inst_6 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_1 C _inst_3 D _inst_5 G H)))) (CategoryTheory.CategoryStruct.comp.{u4, u6} D (CategoryTheory.Category.toCategoryStruct.{u4, u6} D _inst_5) (CategoryTheory.Functor.obj.{u3, u4, u5, u6} C _inst_3 D _inst_5 H (CategoryTheory.Limits.limit.{u1, u2, u3, u5} J _inst_1 C _inst_3 F (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u2, u3, u5} C _inst_3 J _inst_1 _inst_4 F))) (CategoryTheory.Functor.obj.{u3, u4, u5, u6} C _inst_3 D _inst_5 H (CategoryTheory.Limits.limit.{u1, u2, u3, u5} J _inst_1 C _inst_3 G (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u2, u3, u5} C _inst_3 J _inst_1 _inst_4 G))) (CategoryTheory.Limits.limit.{u1, u2, u4, u6} J _inst_1 D _inst_5 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_1 C _inst_3 D _inst_5 G H) (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u2, u4, u6} D _inst_5 J _inst_1 _inst_6 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_1 C _inst_3 D _inst_5 G H))) (CategoryTheory.Functor.map.{u3, u4, u5, u6} C _inst_3 D _inst_5 H (CategoryTheory.Limits.limit.{u1, u2, u3, u5} J _inst_1 C _inst_3 F (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u2, u3, u5} C _inst_3 J _inst_1 _inst_4 F)) (CategoryTheory.Limits.limit.{u1, u2, u3, u5} J _inst_1 C _inst_3 G (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u2, u3, u5} C _inst_3 J _inst_1 _inst_4 G)) (CategoryTheory.Limits.limMap.{u1, u2, u3, u5} J _inst_1 C _inst_3 F G (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u2, u3, u5} C _inst_3 J _inst_1 _inst_4 F) (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u2, u3, u5} C _inst_3 J _inst_1 _inst_4 G) Œ±)) (CategoryTheory.Limits.limit.post.{u1, u2, u3, u4, u5, u6} J _inst_1 C _inst_3 G D _inst_5 (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u2, u3, u5} C _inst_3 J _inst_1 _inst_4 G) H (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u2, u4, u6} D _inst_5 J _inst_1 _inst_6 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_1 C _inst_3 D _inst_5 G H)))) (CategoryTheory.CategoryStruct.comp.{u4, u6} D (CategoryTheory.Category.toCategoryStruct.{u4, u6} D _inst_5) (CategoryTheory.Functor.obj.{u3, u4, u5, u6} C _inst_3 D _inst_5 H (CategoryTheory.Limits.limit.{u1, u2, u3, u5} J _inst_1 C _inst_3 F (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u2, u3, u5} C _inst_3 J _inst_1 _inst_4 F))) (CategoryTheory.Limits.limit.{u1, u2, u4, u6} J _inst_1 D _inst_5 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_1 C _inst_3 D _inst_5 F H) (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u2, u4, u6} D _inst_5 J _inst_1 _inst_6 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_1 C _inst_3 D _inst_5 F H))) (CategoryTheory.Limits.limit.{u1, u2, u4, u6} J _inst_1 D _inst_5 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_1 C _inst_3 D _inst_5 G H) (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u2, u4, u6} D _inst_5 J _inst_1 _inst_6 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_1 C _inst_3 D _inst_5 G H))) (CategoryTheory.Limits.limit.post.{u1, u2, u3, u4, u5, u6} J _inst_1 C _inst_3 F D _inst_5 (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u2, u3, u5} C _inst_3 J _inst_1 _inst_4 F) H (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u2, u4, u6} D _inst_5 J _inst_1 _inst_6 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_1 C _inst_3 D _inst_5 F H))) (CategoryTheory.Limits.limMap.{u1, u2, u4, u6} J _inst_1 D _inst_5 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_1 C _inst_3 D _inst_5 F H) (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_1 C _inst_3 D _inst_5 G H) (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u2, u4, u6} D _inst_5 J _inst_1 _inst_6 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_1 C _inst_3 D _inst_5 F H)) (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u2, u4, u6} D _inst_5 J _inst_1 _inst_6 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_1 C _inst_3 D _inst_5 G H)) (CategoryTheory.whiskerRight.{u2, u1, u5, u3, u6, u4} J _inst_1 C _inst_3 D _inst_5 F G Œ± H)))
but is expected to have type
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {C : Type.{u5}} [_inst_3 : CategoryTheory.Category.{u3, u5} C] {F : CategoryTheory.Functor.{u1, u3, u2, u5} J _inst_1 C _inst_3} [_inst_4 : CategoryTheory.Limits.HasLimitsOfShape.{u1, u2, u3, u5} J _inst_1 C _inst_3] {G : CategoryTheory.Functor.{u1, u3, u2, u5} J _inst_1 C _inst_3} (Œ± : Quiver.Hom.{max (succ u2) (succ u3), max (max (max u5 u2) u3) u1} (CategoryTheory.Functor.{u1, u3, u2, u5} J _inst_1 C _inst_3) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u3, max (max (max u5 u2) u3) u1} (CategoryTheory.Functor.{u1, u3, u2, u5} J _inst_1 C _inst_3) (CategoryTheory.Category.toCategoryStruct.{max u2 u3, max (max (max u5 u2) u3) u1} (CategoryTheory.Functor.{u1, u3, u2, u5} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u5} J _inst_1 C _inst_3))) F G) {D : Type.{u6}} [_inst_5 : CategoryTheory.Category.{u4, u6} D] [_inst_6 : CategoryTheory.Limits.HasLimitsOfShape.{u1, u2, u4, u6} J _inst_1 D _inst_5] (H : CategoryTheory.Functor.{u3, u4, u5, u6} C _inst_3 D _inst_5), Eq.{succ u4} (Quiver.Hom.{succ u4, u6} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} D (CategoryTheory.Category.toCategoryStruct.{u4, u6} D _inst_5)) (Prefunctor.obj.{succ u3, succ u4, u5, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} C (CategoryTheory.Category.toCategoryStruct.{u3, u5} C _inst_3)) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} D (CategoryTheory.Category.toCategoryStruct.{u4, u6} D _inst_5)) (CategoryTheory.Functor.toPrefunctor.{u3, u4, u5, u6} C _inst_3 D _inst_5 H) (CategoryTheory.Limits.limit.{u1, u2, u3, u5} J _inst_1 C _inst_3 F (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u2, u3, u5} C _inst_3 J _inst_1 _inst_4 F))) (CategoryTheory.Limits.limit.{u1, u2, u4, u6} J _inst_1 D _inst_5 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_1 C _inst_3 D _inst_5 G H) (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u2, u4, u6} D _inst_5 J _inst_1 _inst_6 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_1 C _inst_3 D _inst_5 G H)))) (CategoryTheory.CategoryStruct.comp.{u4, u6} D (CategoryTheory.Category.toCategoryStruct.{u4, u6} D _inst_5) (Prefunctor.obj.{succ u3, succ u4, u5, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} C (CategoryTheory.Category.toCategoryStruct.{u3, u5} C _inst_3)) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} D (CategoryTheory.Category.toCategoryStruct.{u4, u6} D _inst_5)) (CategoryTheory.Functor.toPrefunctor.{u3, u4, u5, u6} C _inst_3 D _inst_5 H) (CategoryTheory.Limits.limit.{u1, u2, u3, u5} J _inst_1 C _inst_3 F (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u2, u3, u5} C _inst_3 J _inst_1 _inst_4 F))) (Prefunctor.obj.{succ u3, succ u4, u5, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} C (CategoryTheory.Category.toCategoryStruct.{u3, u5} C _inst_3)) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} D (CategoryTheory.Category.toCategoryStruct.{u4, u6} D _inst_5)) (CategoryTheory.Functor.toPrefunctor.{u3, u4, u5, u6} C _inst_3 D _inst_5 H) (CategoryTheory.Limits.limit.{u1, u2, u3, u5} J _inst_1 C _inst_3 G (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u2, u3, u5} C _inst_3 J _inst_1 _inst_4 G))) (CategoryTheory.Limits.limit.{u1, u2, u4, u6} J _inst_1 D _inst_5 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_1 C _inst_3 D _inst_5 G H) (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u2, u4, u6} D _inst_5 J _inst_1 _inst_6 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_1 C _inst_3 D _inst_5 G H))) (Prefunctor.map.{succ u3, succ u4, u5, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} C (CategoryTheory.Category.toCategoryStruct.{u3, u5} C _inst_3)) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} D (CategoryTheory.Category.toCategoryStruct.{u4, u6} D _inst_5)) (CategoryTheory.Functor.toPrefunctor.{u3, u4, u5, u6} C _inst_3 D _inst_5 H) (CategoryTheory.Limits.limit.{u1, u2, u3, u5} J _inst_1 C _inst_3 F (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u2, u3, u5} C _inst_3 J _inst_1 _inst_4 F)) (CategoryTheory.Limits.limit.{u1, u2, u3, u5} J _inst_1 C _inst_3 G (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u2, u3, u5} C _inst_3 J _inst_1 _inst_4 G)) (CategoryTheory.Limits.limMap.{u1, u2, u3, u5} J _inst_1 C _inst_3 F G (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u2, u3, u5} C _inst_3 J _inst_1 _inst_4 F) (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u2, u3, u5} C _inst_3 J _inst_1 _inst_4 G) Œ±)) (CategoryTheory.Limits.limit.post.{u1, u2, u3, u4, u5, u6} J _inst_1 C _inst_3 G D _inst_5 (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u2, u3, u5} C _inst_3 J _inst_1 _inst_4 G) H (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u2, u4, u6} D _inst_5 J _inst_1 _inst_6 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_1 C _inst_3 D _inst_5 G H)))) (CategoryTheory.CategoryStruct.comp.{u4, u6} D (CategoryTheory.Category.toCategoryStruct.{u4, u6} D _inst_5) (Prefunctor.obj.{succ u3, succ u4, u5, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} C (CategoryTheory.Category.toCategoryStruct.{u3, u5} C _inst_3)) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} D (CategoryTheory.Category.toCategoryStruct.{u4, u6} D _inst_5)) (CategoryTheory.Functor.toPrefunctor.{u3, u4, u5, u6} C _inst_3 D _inst_5 H) (CategoryTheory.Limits.limit.{u1, u2, u3, u5} J _inst_1 C _inst_3 F (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u2, u3, u5} C _inst_3 J _inst_1 _inst_4 F))) (CategoryTheory.Limits.limit.{u1, u2, u4, u6} J _inst_1 D _inst_5 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_1 C _inst_3 D _inst_5 F H) (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u2, u4, u6} D _inst_5 J _inst_1 _inst_6 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_1 C _inst_3 D _inst_5 F H))) (CategoryTheory.Limits.limit.{u1, u2, u4, u6} J _inst_1 D _inst_5 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_1 C _inst_3 D _inst_5 G H) (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u2, u4, u6} D _inst_5 J _inst_1 _inst_6 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_1 C _inst_3 D _inst_5 G H))) (CategoryTheory.Limits.limit.post.{u1, u2, u3, u4, u5, u6} J _inst_1 C _inst_3 F D _inst_5 (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u2, u3, u5} C _inst_3 J _inst_1 _inst_4 F) H (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u2, u4, u6} D _inst_5 J _inst_1 _inst_6 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_1 C _inst_3 D _inst_5 F H))) (CategoryTheory.Limits.limMap.{u1, u2, u4, u6} J _inst_1 D _inst_5 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_1 C _inst_3 D _inst_5 F H) (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_1 C _inst_3 D _inst_5 G H) (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u2, u4, u6} D _inst_5 J _inst_1 _inst_6 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_1 C _inst_3 D _inst_5 F H)) (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u2, u4, u6} D _inst_5 J _inst_1 _inst_6 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_1 C _inst_3 D _inst_5 G H)) (CategoryTheory.whiskerRight.{u2, u1, u5, u3, u6, u4} J _inst_1 C _inst_3 D _inst_5 F G Œ± H)))
Case conversion may be inaccurate. Consider using '#align category_theory.limits.limit.map_post CategoryTheory.Limits.limit.map_post‚Çì'. -/
theorem limit.map_post {D : Type u'} [Category.{v'} D] [HasLimitsOfShape J D]
    (H : C ‚•§ D) :/- H (limit F) ‚ü∂ H (limit G) ‚ü∂ limit (G ‚ãô H) vs
               H (limit F) ‚ü∂ limit (F ‚ãô H) ‚ü∂ limit (G ‚ãô H) -/
            H.map
          (limMap Œ±) ‚â´
        limit.post G H =
      limit.post F H ‚â´ limMap (whiskerRight Œ± H) :=
  by
  ext
  simp only [whisker_right_app, lim_map_œÄ, assoc, limit.post_œÄ_assoc, limit.post_œÄ, ‚Üê H.map_comp]
#align category_theory.limits.limit.map_post CategoryTheory.Limits.limit.map_post

/- warning: category_theory.limits.lim_yoneda -> CategoryTheory.Limits.limYoneda is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {C : Type.{u4}} [_inst_3 : CategoryTheory.Category.{u3, u4} C] [_inst_4 : CategoryTheory.Limits.HasLimitsOfShape.{u1, u2, u3, u4} J _inst_1 C _inst_3], CategoryTheory.Iso.{max (max u1 u3 u2 u4) u4 u3 u2, max (max u2 u3) (max u4 u3 u2) (max u1 u3 u2 u4) u3 (max u3 u2) u4 (succ (max u3 u2))} (CategoryTheory.Functor.{max u2 u3, max u4 u3 u2, max u1 u3 u2 u4, max u3 (max u3 u2) u4 (succ (max u3 u2))} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.{u3, max u3 u2, u4, succ (max u3 u2)} (Opposite.{succ u4} C) (CategoryTheory.Category.opposite.{u3, u4} C _inst_3) Type.{max u3 u2} CategoryTheory.types.{max u3 u2}) (CategoryTheory.Functor.category.{u3, max u3 u2, u4, succ (max u3 u2)} (Opposite.{succ u4} C) (CategoryTheory.Category.opposite.{u3, u4} C _inst_3) Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.Functor.category.{max u2 u3, max u4 u3 u2, max u1 u3 u2 u4, max u3 (max u3 u2) u4 (succ (max u3 u2))} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.{u3, max u3 u2, u4, succ (max u3 u2)} (Opposite.{succ u4} C) (CategoryTheory.Category.opposite.{u3, u4} C _inst_3) Type.{max u3 u2} CategoryTheory.types.{max u3 u2}) (CategoryTheory.Functor.category.{u3, max u3 u2, u4, succ (max u3 u2)} (Opposite.{succ u4} C) (CategoryTheory.Category.opposite.{u3, u4} C _inst_3) Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.Functor.comp.{max u2 u3, u3, max u4 u3 u2, max u1 u3 u2 u4, u4, max u3 (max u3 u2) u4 (succ (max u3 u2))} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3) C _inst_3 (CategoryTheory.Functor.{u3, max u3 u2, u4, succ (max u3 u2)} (Opposite.{succ u4} C) (CategoryTheory.Category.opposite.{u3, u4} C _inst_3) Type.{max u3 u2} CategoryTheory.types.{max u3 u2}) (CategoryTheory.Functor.category.{u3, max u3 u2, u4, succ (max u3 u2)} (Opposite.{succ u4} C) (CategoryTheory.Category.opposite.{u3, u4} C _inst_3) Type.{max u3 u2} CategoryTheory.types.{max u3 u2}) (CategoryTheory.Limits.lim.{u1, u2, u3, u4} J _inst_1 C _inst_3 _inst_4) (CategoryTheory.Functor.comp.{u3, max u4 u3, max u4 u3 u2, u4, max u3 u4 (succ u3), max u3 (max u3 u2) u4 (succ (max u3 u2))} C _inst_3 (CategoryTheory.Functor.{u3, u3, u4, succ u3} (Opposite.{succ u4} C) (CategoryTheory.Category.opposite.{u3, u4} C _inst_3) Type.{u3} CategoryTheory.types.{u3}) (CategoryTheory.Functor.category.{u3, u3, u4, succ u3} (Opposite.{succ u4} C) (CategoryTheory.Category.opposite.{u3, u4} C _inst_3) Type.{u3} CategoryTheory.types.{u3}) (CategoryTheory.Functor.{u3, max u3 u2, u4, succ (max u3 u2)} (Opposite.{succ u4} C) (CategoryTheory.Category.opposite.{u3, u4} C _inst_3) Type.{max u3 u2} CategoryTheory.types.{max u3 u2}) (CategoryTheory.Functor.category.{u3, max u3 u2, u4, succ (max u3 u2)} (Opposite.{succ u4} C) (CategoryTheory.Category.opposite.{u3, u4} C _inst_3) Type.{max u3 u2} CategoryTheory.types.{max u3 u2}) (CategoryTheory.yoneda.{u3, u4} C _inst_3) (CategoryTheory.Functor.obj.{max (succ u3) u3 u2, max (max u3 u4 (succ u3)) u4 u3 u2, max u3 (max u3 u2) (succ u3) (succ (max u3 u2)), max (max u4 u3) (max u4 u3 u2) (max u3 u4 (succ u3)) u3 (max u3 u2) u4 (succ (max u3 u2))} (CategoryTheory.Functor.{u3, max u3 u2, succ u3, succ (max u3 u2)} Type.{u3} CategoryTheory.types.{u3} Type.{max u3 u2} CategoryTheory.types.{max u3 u2}) (CategoryTheory.Functor.category.{u3, max u3 u2, succ u3, succ (max u3 u2)} Type.{u3} CategoryTheory.types.{u3} Type.{max u3 u2} CategoryTheory.types.{max u3 u2}) (CategoryTheory.Functor.{max u4 u3, max u4 u3 u2, max u3 u4 (succ u3), max u3 (max u3 u2) u4 (succ (max u3 u2))} (CategoryTheory.Functor.{u3, u3, u4, succ u3} (Opposite.{succ u4} C) (CategoryTheory.Category.opposite.{u3, u4} C _inst_3) Type.{u3} CategoryTheory.types.{u3}) (CategoryTheory.Functor.category.{u3, u3, u4, succ u3} (Opposite.{succ u4} C) (CategoryTheory.Category.opposite.{u3, u4} C _inst_3) Type.{u3} CategoryTheory.types.{u3}) (CategoryTheory.Functor.{u3, max u3 u2, u4, succ (max u3 u2)} (Opposite.{succ u4} C) (CategoryTheory.Category.opposite.{u3, u4} C _inst_3) Type.{max u3 u2} CategoryTheory.types.{max u3 u2}) (CategoryTheory.Functor.category.{u3, max u3 u2, u4, succ (max u3 u2)} (Opposite.{succ u4} C) (CategoryTheory.Category.opposite.{u3, u4} C _inst_3) Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.Functor.category.{max u4 u3, max u4 u3 u2, max u3 u4 (succ u3), max u3 (max u3 u2) u4 (succ (max u3 u2))} (CategoryTheory.Functor.{u3, u3, u4, succ u3} (Opposite.{succ u4} C) (CategoryTheory.Category.opposite.{u3, u4} C _inst_3) Type.{u3} CategoryTheory.types.{u3}) (CategoryTheory.Functor.category.{u3, u3, u4, succ u3} (Opposite.{succ u4} C) (CategoryTheory.Category.opposite.{u3, u4} C _inst_3) Type.{u3} CategoryTheory.types.{u3}) (CategoryTheory.Functor.{u3, max u3 u2, u4, succ (max u3 u2)} (Opposite.{succ u4} C) (CategoryTheory.Category.opposite.{u3, u4} C _inst_3) Type.{max u3 u2} CategoryTheory.types.{max u3 u2}) (CategoryTheory.Functor.category.{u3, max u3 u2, u4, succ (max u3 u2)} (Opposite.{succ u4} C) (CategoryTheory.Category.opposite.{u3, u4} C _inst_3) Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.whiskeringRight.{u4, u3, succ u3, u3, succ (max u3 u2), max u3 u2} (Opposite.{succ u4} C) (CategoryTheory.Category.opposite.{u3, u4} C _inst_3) Type.{u3} CategoryTheory.types.{u3} Type.{max u3 u2} CategoryTheory.types.{max u3 u2}) CategoryTheory.uliftFunctor.{u2, u3}))) (CategoryTheory.cones.{u1, u3, u2, u4} J _inst_1 C _inst_3)
but is expected to have type
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {C : Type.{u4}} [_inst_3 : CategoryTheory.Category.{u3, u4} C] [_inst_4 : CategoryTheory.Limits.HasLimitsOfShape.{u1, u2, u3, u4} J _inst_1 C _inst_3], CategoryTheory.Iso.{max (max (max u4 u2) u3) u1, max (max (max (max (max (max u4 u3) u2 u3) (succ u2) (succ u3)) (max (max u4 u3) u2) u1) u4 u2 u3) u3 u2} (CategoryTheory.Functor.{max u3 u2, max u4 u2 u3, max (max (max u4 u3) u2) u1, max (max (max u4 u3) u2 u3) (succ u2) (succ u3)} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.{u3, max u2 u3, u4, max (succ u2) (succ u3)} (Opposite.{succ u4} C) (CategoryTheory.Category.opposite.{u3, u4} C _inst_3) Type.{max u3 u2} CategoryTheory.types.{max u3 u2}) (CategoryTheory.Functor.category.{u3, max u2 u3, u4, max (succ u2) (succ u3)} (Opposite.{succ u4} C) (CategoryTheory.Category.opposite.{u3, u4} C _inst_3) Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.Functor.category.{max u2 u3, max (max u4 u2) u3, max (max (max u4 u2) u3) u1, max (max u4 (succ u2)) (succ u3)} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.{u3, max u2 u3, u4, max (succ u2) (succ u3)} (Opposite.{succ u4} C) (CategoryTheory.Category.opposite.{u3, u4} C _inst_3) Type.{max u3 u2} CategoryTheory.types.{max u3 u2}) (CategoryTheory.Functor.category.{u3, max u2 u3, u4, max (succ u2) (succ u3)} (Opposite.{succ u4} C) (CategoryTheory.Category.opposite.{u3, u4} C _inst_3) Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.Functor.comp.{max u3 u2, u3, max u4 u2 u3, max (max (max u4 u3) u2) u1, u4, max (max (max u4 u3) u2 u3) (succ u2) (succ u3)} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3) C _inst_3 (CategoryTheory.Functor.{u3, max u2 u3, u4, max (succ u2) (succ u3)} (Opposite.{succ u4} C) (CategoryTheory.Category.opposite.{u3, u4} C _inst_3) Type.{max u3 u2} CategoryTheory.types.{max u3 u2}) (CategoryTheory.Functor.category.{u3, max u2 u3, u4, max (succ u2) (succ u3)} (Opposite.{succ u4} C) (CategoryTheory.Category.opposite.{u3, u4} C _inst_3) Type.{max u3 u2} CategoryTheory.types.{max u3 u2}) (CategoryTheory.Limits.lim.{u1, u2, u3, u4} J _inst_1 C _inst_3 _inst_4) (CategoryTheory.Functor.comp.{u3, max u4 u3, max u4 u2 u3, u4, max u4 (succ u3), max (max (max u4 u3) u2 u3) (succ u2) (succ u3)} C _inst_3 (CategoryTheory.Functor.{u3, u3, u4, succ u3} (Opposite.{succ u4} C) (CategoryTheory.Category.opposite.{u3, u4} C _inst_3) Type.{u3} CategoryTheory.types.{u3}) (CategoryTheory.Functor.category.{u3, u3, u4, succ u3} (Opposite.{succ u4} C) (CategoryTheory.Category.opposite.{u3, u4} C _inst_3) Type.{u3} CategoryTheory.types.{u3}) (CategoryTheory.Functor.{u3, max u2 u3, u4, max (succ u2) (succ u3)} (Opposite.{succ u4} C) (CategoryTheory.Category.opposite.{u3, u4} C _inst_3) Type.{max u3 u2} CategoryTheory.types.{max u3 u2}) (CategoryTheory.Functor.category.{u3, max u2 u3, u4, max (succ u2) (succ u3)} (Opposite.{succ u4} C) (CategoryTheory.Category.opposite.{u3, u4} C _inst_3) Type.{max u3 u2} CategoryTheory.types.{max u3 u2}) (CategoryTheory.yoneda.{u3, u4} C _inst_3) (Prefunctor.obj.{max (succ (max u2 u3)) (succ (succ u3)), max (max (max (max (succ (max u2 u3)) (succ u3)) (succ (succ u3))) (succ u3)) (succ u4), max (max (max (max u2 u3) (succ u2) (succ u3)) u3) (succ u3), max (max (max (max (max (max u2 u3) (succ u2) (succ u3)) u3) (succ u3)) u3) u4} (CategoryTheory.Functor.{u3, max u2 u3, succ u3, max (succ u2) (succ u3)} Type.{u3} CategoryTheory.types.{u3} Type.{max u3 u2} CategoryTheory.types.{max u3 u2}) (CategoryTheory.CategoryStruct.toQuiver.{max (max u2 u3) (succ u3), max (max (max (max u2 u3) (succ u2) (succ u3)) u3) (succ u3)} (CategoryTheory.Functor.{u3, max u2 u3, succ u3, max (succ u2) (succ u3)} Type.{u3} CategoryTheory.types.{u3} Type.{max u3 u2} CategoryTheory.types.{max u3 u2}) (CategoryTheory.Category.toCategoryStruct.{max (max u2 u3) (succ u3), max (max (max (max u2 u3) (succ u2) (succ u3)) u3) (succ u3)} (CategoryTheory.Functor.{u3, max u2 u3, succ u3, max (succ u2) (succ u3)} Type.{u3} CategoryTheory.types.{u3} Type.{max u3 u2} CategoryTheory.types.{max u3 u2}) (CategoryTheory.Functor.category.{u3, max u2 u3, succ u3, max (succ u2) (succ u3)} Type.{u3} CategoryTheory.types.{u3} Type.{max u3 u2} CategoryTheory.types.{max u3 u2}))) (CategoryTheory.Functor.{max u4 u3, max u4 u2 u3, max (max (succ u3) u4) u3, max (max (max (max (succ u2) (succ u3)) u4) u2 u3) u3} (CategoryTheory.Functor.{u3, u3, u4, succ u3} (Opposite.{succ u4} C) (CategoryTheory.Category.opposite.{u3, u4} C _inst_3) Type.{u3} CategoryTheory.types.{u3}) (CategoryTheory.Functor.category.{u3, u3, u4, succ u3} (Opposite.{succ u4} C) (CategoryTheory.Category.opposite.{u3, u4} C _inst_3) Type.{u3} CategoryTheory.types.{u3}) (CategoryTheory.Functor.{u3, max u2 u3, u4, max (succ u2) (succ u3)} (Opposite.{succ u4} C) (CategoryTheory.Category.opposite.{u3, u4} C _inst_3) Type.{max u3 u2} CategoryTheory.types.{max u3 u2}) (CategoryTheory.Functor.category.{u3, max u2 u3, u4, max (succ u2) (succ u3)} (Opposite.{succ u4} C) (CategoryTheory.Category.opposite.{u3, u4} C _inst_3) Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.CategoryStruct.toQuiver.{max (max (max (max u2 u3) (succ u3)) u3) u4, max (max (max (max (max (max u2 u3) (succ u2) (succ u3)) u3) (succ u3)) u3) u4} (CategoryTheory.Functor.{max u4 u3, max u4 u2 u3, max (max (succ u3) u4) u3, max (max (max (max (succ u2) (succ u3)) u4) u2 u3) u3} (CategoryTheory.Functor.{u3, u3, u4, succ u3} (Opposite.{succ u4} C) (CategoryTheory.Category.opposite.{u3, u4} C _inst_3) Type.{u3} CategoryTheory.types.{u3}) (CategoryTheory.Functor.category.{u3, u3, u4, succ u3} (Opposite.{succ u4} C) (CategoryTheory.Category.opposite.{u3, u4} C _inst_3) Type.{u3} CategoryTheory.types.{u3}) (CategoryTheory.Functor.{u3, max u2 u3, u4, max (succ u2) (succ u3)} (Opposite.{succ u4} C) (CategoryTheory.Category.opposite.{u3, u4} C _inst_3) Type.{max u3 u2} CategoryTheory.types.{max u3 u2}) (CategoryTheory.Functor.category.{u3, max u2 u3, u4, max (succ u2) (succ u3)} (Opposite.{succ u4} C) (CategoryTheory.Category.opposite.{u3, u4} C _inst_3) Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.Category.toCategoryStruct.{max (max (max (max u2 u3) (succ u3)) u3) u4, max (max (max (max (max (max u2 u3) (succ u2) (succ u3)) u3) (succ u3)) u3) u4} (CategoryTheory.Functor.{max u4 u3, max u4 u2 u3, max (max (succ u3) u4) u3, max (max (max (max (succ u2) (succ u3)) u4) u2 u3) u3} (CategoryTheory.Functor.{u3, u3, u4, succ u3} (Opposite.{succ u4} C) (CategoryTheory.Category.opposite.{u3, u4} C _inst_3) Type.{u3} CategoryTheory.types.{u3}) (CategoryTheory.Functor.category.{u3, u3, u4, succ u3} (Opposite.{succ u4} C) (CategoryTheory.Category.opposite.{u3, u4} C _inst_3) Type.{u3} CategoryTheory.types.{u3}) (CategoryTheory.Functor.{u3, max u2 u3, u4, max (succ u2) (succ u3)} (Opposite.{succ u4} C) (CategoryTheory.Category.opposite.{u3, u4} C _inst_3) Type.{max u3 u2} CategoryTheory.types.{max u3 u2}) (CategoryTheory.Functor.category.{u3, max u2 u3, u4, max (succ u2) (succ u3)} (Opposite.{succ u4} C) (CategoryTheory.Category.opposite.{u3, u4} C _inst_3) Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.Functor.category.{max u4 u3, max u4 u2 u3, max (max u4 (succ u3)) u3, max (max (max u4 (succ u2) (succ u3)) u3) u2 u3} (CategoryTheory.Functor.{u3, u3, u4, succ u3} (Opposite.{succ u4} C) (CategoryTheory.Category.opposite.{u3, u4} C _inst_3) Type.{u3} CategoryTheory.types.{u3}) (CategoryTheory.Functor.category.{u3, u3, u4, succ u3} (Opposite.{succ u4} C) (CategoryTheory.Category.opposite.{u3, u4} C _inst_3) Type.{u3} CategoryTheory.types.{u3}) (CategoryTheory.Functor.{u3, max u2 u3, u4, max (succ u2) (succ u3)} (Opposite.{succ u4} C) (CategoryTheory.Category.opposite.{u3, u4} C _inst_3) Type.{max u3 u2} CategoryTheory.types.{max u3 u2}) (CategoryTheory.Functor.category.{u3, max u2 u3, u4, max (succ u2) (succ u3)} (Opposite.{succ u4} C) (CategoryTheory.Category.opposite.{u3, u4} C _inst_3) Type.{max u3 u2} CategoryTheory.types.{max u3 u2})))) (CategoryTheory.Functor.toPrefunctor.{max (max u2 u3) (succ u3), max (max (max (max u2 u3) (succ u3)) u3) u4, max (max (max (max u2 u3) (succ u2) (succ u3)) u3) (succ u3), max (max (max (max (max (max u2 u3) (succ u2) (succ u3)) u3) (succ u3)) u3) u4} (CategoryTheory.Functor.{u3, max u2 u3, succ u3, max (succ u2) (succ u3)} Type.{u3} CategoryTheory.types.{u3} Type.{max u3 u2} CategoryTheory.types.{max u3 u2}) (CategoryTheory.Functor.category.{u3, max u2 u3, succ u3, max (succ u2) (succ u3)} Type.{u3} CategoryTheory.types.{u3} Type.{max u3 u2} CategoryTheory.types.{max u3 u2}) (CategoryTheory.Functor.{max u4 u3, max u4 u2 u3, max (max (succ u3) u4) u3, max (max (max (max (succ u2) (succ u3)) u4) u2 u3) u3} (CategoryTheory.Functor.{u3, u3, u4, succ u3} (Opposite.{succ u4} C) (CategoryTheory.Category.opposite.{u3, u4} C _inst_3) Type.{u3} CategoryTheory.types.{u3}) (CategoryTheory.Functor.category.{u3, u3, u4, succ u3} (Opposite.{succ u4} C) (CategoryTheory.Category.opposite.{u3, u4} C _inst_3) Type.{u3} CategoryTheory.types.{u3}) (CategoryTheory.Functor.{u3, max u2 u3, u4, max (succ u2) (succ u3)} (Opposite.{succ u4} C) (CategoryTheory.Category.opposite.{u3, u4} C _inst_3) Type.{max u3 u2} CategoryTheory.types.{max u3 u2}) (CategoryTheory.Functor.category.{u3, max u2 u3, u4, max (succ u2) (succ u3)} (Opposite.{succ u4} C) (CategoryTheory.Category.opposite.{u3, u4} C _inst_3) Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.Functor.category.{max u4 u3, max u4 u2 u3, max (max u4 (succ u3)) u3, max (max (max u4 (succ u2) (succ u3)) u3) u2 u3} (CategoryTheory.Functor.{u3, u3, u4, succ u3} (Opposite.{succ u4} C) (CategoryTheory.Category.opposite.{u3, u4} C _inst_3) Type.{u3} CategoryTheory.types.{u3}) (CategoryTheory.Functor.category.{u3, u3, u4, succ u3} (Opposite.{succ u4} C) (CategoryTheory.Category.opposite.{u3, u4} C _inst_3) Type.{u3} CategoryTheory.types.{u3}) (CategoryTheory.Functor.{u3, max u2 u3, u4, max (succ u2) (succ u3)} (Opposite.{succ u4} C) (CategoryTheory.Category.opposite.{u3, u4} C _inst_3) Type.{max u3 u2} CategoryTheory.types.{max u3 u2}) (CategoryTheory.Functor.category.{u3, max u2 u3, u4, max (succ u2) (succ u3)} (Opposite.{succ u4} C) (CategoryTheory.Category.opposite.{u3, u4} C _inst_3) Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.whiskeringRight.{u4, u3, succ u3, u3, max (succ u2) (succ u3), max u2 u3} (Opposite.{succ u4} C) (CategoryTheory.Category.opposite.{u3, u4} C _inst_3) Type.{u3} CategoryTheory.types.{u3} Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) CategoryTheory.uliftFunctor.{u2, u3}))) (CategoryTheory.cones.{u1, u3, u2, u4} J _inst_1 C _inst_3)
Case conversion may be inaccurate. Consider using '#align category_theory.limits.lim_yoneda CategoryTheory.Limits.limYoneda‚Çì'. -/
/-- The isomorphism between
morphisms from `W` to the cone point of the limit cone for `F`
and cones over `F` with cone point `W`
is natural in `F`.
-/
def limYoneda :
    lim ‚ãô yoneda ‚ãô (whiskeringRight _ _ _).obj uliftFunctor.{u‚ÇÅ} ‚âÖ CategoryTheory.cones J C :=
  NatIso.ofComponents (fun F => NatIso.ofComponents (fun W => limit.homIso F (unop W)) (by tidy))
    (by tidy)
#align category_theory.limits.lim_yoneda CategoryTheory.Limits.limYoneda

#print CategoryTheory.Limits.constLimAdj /-
/-- The constant functor and limit functor are adjoint to each other-/
def constLimAdj : (const J : C ‚•§ J ‚•§ C) ‚ä£ lim
    where
  homEquiv c g :=
    { toFun := fun f => limit.lift _ ‚ü®c, f‚ü©
      invFun := fun f =>
        { app := fun j => f ‚â´ limit.œÄ _ _
          naturality' := by tidy }
      left_inv := fun _ => NatTrans.ext _ _ <| funext fun j => limit.lift_œÄ _ _
      right_inv := fun Œ± => limit.hom_ext fun j => limit.lift_œÄ _ _ }
  Unit :=
    { app := fun c => limit.lift _ ‚ü®_, ùüô _‚ü©
      naturality' := fun _ _ _ => by tidy }
  counit :=
    { app := fun g =>
        { app := limit.œÄ _
          naturality' := by tidy }
      naturality' := fun _ _ _ => by tidy }
  homEquiv_unit c g f := limit.hom_ext fun j => by simp
  homEquiv_counit c g f := NatTrans.ext _ _ <| funext fun j => rfl
#align category_theory.limits.const_lim_adj CategoryTheory.Limits.constLimAdj
-/

instance : IsRightAdjoint (lim : (J ‚•§ C) ‚•§ C) :=
  ‚ü®_, constLimAdj‚ü©

end LimFunctor

#print CategoryTheory.Limits.limMap_mono' /-
instance limMap_mono' {F G : J ‚•§ C} [HasLimitsOfShape J C] (Œ± : F ‚ü∂ G) [Mono Œ±] : Mono (limMap Œ±) :=
  (lim : (J ‚•§ C) ‚•§ C).map_mono Œ±
#align category_theory.limits.lim_map_mono' CategoryTheory.Limits.limMap_mono'
-/

/- warning: category_theory.limits.lim_map_mono -> CategoryTheory.Limits.limMap_mono is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {C : Type.{u4}} [_inst_3 : CategoryTheory.Category.{u3, u4} C] {F : CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3} {G : CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3} [_inst_4 : CategoryTheory.Limits.HasLimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F] [_inst_5 : CategoryTheory.Limits.HasLimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 G] (Œ± : Quiver.Hom.{succ (max u2 u3), max u1 u3 u2 u4} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u3, max u1 u3 u2 u4} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Category.toCategoryStruct.{max u2 u3, max u1 u3 u2 u4} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3))) F G) [_inst_6 : forall (j : J), CategoryTheory.Mono.{u3, u4} C _inst_3 (CategoryTheory.Functor.obj.{u1, u3, u2, u4} J _inst_1 C _inst_3 F j) (CategoryTheory.Functor.obj.{u1, u3, u2, u4} J _inst_1 C _inst_3 G j) (CategoryTheory.NatTrans.app.{u1, u3, u2, u4} J _inst_1 C _inst_3 F G Œ± j)], CategoryTheory.Mono.{u3, u4} C _inst_3 (CategoryTheory.Limits.limit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4) (CategoryTheory.Limits.limit.{u1, u2, u3, u4} J _inst_1 C _inst_3 G _inst_5) (CategoryTheory.Limits.limMap.{u1, u2, u3, u4} J _inst_1 C _inst_3 F G _inst_4 _inst_5 Œ±)
but is expected to have type
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {C : Type.{u4}} [_inst_3 : CategoryTheory.Category.{u3, u4} C] {F : CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3} {G : CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3} [_inst_4 : CategoryTheory.Limits.HasLimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F] [_inst_5 : CategoryTheory.Limits.HasLimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 G] (Œ± : Quiver.Hom.{max (succ u2) (succ u3), max (max (max u4 u2) u3) u1} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u3, max (max (max u4 u2) u3) u1} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Category.toCategoryStruct.{max u2 u3, max (max (max u4 u2) u3) u1} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3))) F G) [_inst_6 : forall (j : J), CategoryTheory.Mono.{u3, u4} C _inst_3 (Prefunctor.obj.{succ u1, succ u3, u2, u4} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, u4} J _inst_1 C _inst_3 F) j) (Prefunctor.obj.{succ u1, succ u3, u2, u4} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, u4} J _inst_1 C _inst_3 G) j) (CategoryTheory.NatTrans.app.{u1, u3, u2, u4} J _inst_1 C _inst_3 F G Œ± j)], CategoryTheory.Mono.{u3, u4} C _inst_3 (CategoryTheory.Limits.limit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4) (CategoryTheory.Limits.limit.{u1, u2, u3, u4} J _inst_1 C _inst_3 G _inst_5) (CategoryTheory.Limits.limMap.{u1, u2, u3, u4} J _inst_1 C _inst_3 F G _inst_4 _inst_5 Œ±)
Case conversion may be inaccurate. Consider using '#align category_theory.limits.lim_map_mono CategoryTheory.Limits.limMap_mono‚Çì'. -/
instance limMap_mono {F G : J ‚•§ C} [HasLimit F] [HasLimit G] (Œ± : F ‚ü∂ G) [‚àÄ j, Mono (Œ±.app j)] :
    Mono (limMap Œ±) :=
  ‚ü®fun Z u v h =>
    limit.hom_ext fun j => (cancel_mono (Œ±.app j)).1 <| by simpa using h =‚â´ limit.œÄ _ j‚ü©
#align category_theory.limits.lim_map_mono CategoryTheory.Limits.limMap_mono

/- warning: category_theory.limits.has_limits_of_shape_of_equivalence -> CategoryTheory.Limits.hasLimitsOfShapeOfEquivalence is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {C : Type.{u6}} [_inst_3 : CategoryTheory.Category.{u5, u6} C] {J' : Type.{u4}} [_inst_4 : CategoryTheory.Category.{u3, u4} J'], (CategoryTheory.Equivalence.{u1, u3, u2, u4} J _inst_1 J' _inst_4) -> (forall [_inst_5 : CategoryTheory.Limits.HasLimitsOfShape.{u1, u2, u5, u6} J _inst_1 C _inst_3], CategoryTheory.Limits.HasLimitsOfShape.{u3, u4, u5, u6} J' _inst_4 C _inst_3)
but is expected to have type
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {C : Type.{u6}} [_inst_3 : CategoryTheory.Category.{u5, u6} C] {J' : Type.{u4}} [_inst_4 : CategoryTheory.Category.{u3, u4} J'], (CategoryTheory.Equivalence.{u1, u3, u2, u4} J J' _inst_1 _inst_4) -> (forall [_inst_5 : CategoryTheory.Limits.HasLimitsOfShape.{u1, u2, u5, u6} J _inst_1 C _inst_3], CategoryTheory.Limits.HasLimitsOfShape.{u3, u4, u5, u6} J' _inst_4 C _inst_3)
Case conversion may be inaccurate. Consider using '#align category_theory.limits.has_limits_of_shape_of_equivalence CategoryTheory.Limits.hasLimitsOfShapeOfEquivalence‚Çì'. -/
/-- We can transport limits of shape `J` along an equivalence `J ‚âå J'`.
-/
theorem hasLimitsOfShapeOfEquivalence {J' : Type u‚ÇÇ} [Category.{v‚ÇÇ} J'] (e : J ‚âå J')
    [HasLimitsOfShape J C] : HasLimitsOfShape J' C :=
  by
  constructor
  intro F
  apply has_limit_of_equivalence_comp e
  infer_instance
#align category_theory.limits.has_limits_of_shape_of_equivalence CategoryTheory.Limits.hasLimitsOfShapeOfEquivalence

variable (C)

#print CategoryTheory.Limits.hasLimitsOfSizeShrink /-
/-- `has_limits_of_size_shrink.{v u} C` tries to obtain `has_limits_of_size.{v u} C`
from some other `has_limits_of_size C`.
-/
theorem hasLimitsOfSizeShrink [HasLimitsOfSize.{max v‚ÇÅ v‚ÇÇ, max u‚ÇÅ u‚ÇÇ} C] :
    HasLimitsOfSize.{v‚ÇÅ, u‚ÇÅ} C :=
  ‚ü®fun J hJ => has_limits_of_shape_of_equivalence (ULiftHomULiftCategory.equiv.{v‚ÇÇ, u‚ÇÇ} J).symm‚ü©
#align category_theory.limits.has_limits_of_size_shrink CategoryTheory.Limits.hasLimitsOfSizeShrink
-/

#print CategoryTheory.Limits.hasSmallestLimitsOfHasLimits /-
instance (priority := 100) hasSmallestLimitsOfHasLimits [HasLimits C] : HasLimitsOfSize.{0, 0} C :=
  hasLimitsOfSizeShrink.{0, 0} C
#align category_theory.limits.has_smallest_limits_of_has_limits CategoryTheory.Limits.hasSmallestLimitsOfHasLimits
-/

end Limit

section Colimit

#print CategoryTheory.Limits.ColimitCocone /-
/-- `colimit_cocone F` contains a cocone over `F` together with the information that it is a
    colimit. -/
@[nolint has_nonempty_instance]
structure ColimitCocone (F : J ‚•§ C) where
  Cocone : Cocone F
  IsColimit : IsColimit cocone
#align category_theory.limits.colimit_cocone CategoryTheory.Limits.ColimitCocone
-/

#print CategoryTheory.Limits.HasColimit /-
/-- `has_colimit F` represents the mere existence of a colimit for `F`. -/
class HasColimit (F : J ‚•§ C) : Prop where mk' ::
  exists_colimit : Nonempty (ColimitCocone F)
#align category_theory.limits.has_colimit CategoryTheory.Limits.HasColimit
-/

#print CategoryTheory.Limits.HasColimit.mk /-
theorem HasColimit.mk {F : J ‚•§ C} (d : ColimitCocone F) : HasColimit F :=
  ‚ü®Nonempty.intro d‚ü©
#align category_theory.limits.has_colimit.mk CategoryTheory.Limits.HasColimit.mk
-/

#print CategoryTheory.Limits.getColimitCocone /-
/-- Use the axiom of choice to extract explicit `colimit_cocone F` from `has_colimit F`. -/
def getColimitCocone (F : J ‚•§ C) [HasColimit F] : ColimitCocone F :=
  Classical.choice <| HasColimit.exists_colimit
#align category_theory.limits.get_colimit_cocone CategoryTheory.Limits.getColimitCocone
-/

variable (J C)

#print CategoryTheory.Limits.HasColimitsOfShape /-
/-- `C` has colimits of shape `J` if there exists a colimit for every functor `F : J ‚•§ C`. -/
class HasColimitsOfShape : Prop where
  HasColimit : ‚àÄ F : J ‚•§ C, HasColimit F := by infer_instance
#align category_theory.limits.has_colimits_of_shape CategoryTheory.Limits.HasColimitsOfShape
-/

#print CategoryTheory.Limits.HasColimitsOfSize /-
/-- `C` has all colimits of size `v‚ÇÅ u‚ÇÅ` (`has_colimits_of_size.{v‚ÇÅ u‚ÇÅ} C`)
if it has colimits of every shape `J : Type u‚ÇÅ` with `[category.{v‚ÇÅ} J]`.
-/
class HasColimitsOfSize (C : Type u) [Category.{v} C] : Prop where
  HasColimitsOfShape : ‚àÄ (J : Type u‚ÇÅ) [ùí• : Category.{v‚ÇÅ} J], HasColimitsOfShape J C := by
    infer_instance
#align category_theory.limits.has_colimits_of_size CategoryTheory.Limits.HasColimitsOfSize
-/

#print CategoryTheory.Limits.HasColimits /-
/-- `C` has all (small) colimits if it has colimits of every shape that is as big as its hom-sets.
-/
abbrev HasColimits (C : Type u) [Category.{v} C] : Prop :=
  HasColimitsOfSize.{v, v} C
#align category_theory.limits.has_colimits CategoryTheory.Limits.HasColimits
-/

#print CategoryTheory.Limits.HasColimits.hasColimitsOfShape /-
theorem HasColimits.hasColimitsOfShape {C : Type u} [Category.{v} C] [HasColimits C] (J : Type v)
    [Category.{v} J] : HasColimitsOfShape J C :=
  HasColimitsOfSize.hasColimitsOfShape J
#align category_theory.limits.has_colimits.has_colimits_of_shape CategoryTheory.Limits.HasColimits.hasColimitsOfShape
-/

variable {J C}

#print CategoryTheory.Limits.hasColimitOfHasColimitsOfShape /-
-- see Note [lower instance priority]
instance (priority := 100) hasColimitOfHasColimitsOfShape {J : Type u‚ÇÅ} [Category.{v‚ÇÅ} J]
    [H : HasColimitsOfShape J C] (F : J ‚•§ C) : HasColimit F :=
  HasColimitsOfShape.hasColimit F
#align category_theory.limits.has_colimit_of_has_colimits_of_shape CategoryTheory.Limits.hasColimitOfHasColimitsOfShape
-/

#print CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize /-
-- see Note [lower instance priority]
instance (priority := 100) hasColimitsOfShapeOfHasColimitsOfSize {J : Type u‚ÇÅ} [Category.{v‚ÇÅ} J]
    [H : HasColimitsOfSize.{v‚ÇÅ, u‚ÇÅ} C] : HasColimitsOfShape J C :=
  HasColimitsOfSize.hasColimitsOfShape J
#align category_theory.limits.has_colimits_of_shape_of_has_colimits_of_size CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize
-/

#print CategoryTheory.Limits.colimit.cocone /-
-- Interface to the `has_colimit` class.
/-- An arbitrary choice of colimit cocone of a functor. -/
def colimit.cocone (F : J ‚•§ C) [HasColimit F] : Cocone F :=
  (getColimitCocone F).Cocone
#align category_theory.limits.colimit.cocone CategoryTheory.Limits.colimit.cocone
-/

#print CategoryTheory.Limits.colimit /-
/-- An arbitrary choice of colimit object of a functor. -/
def colimit (F : J ‚•§ C) [HasColimit F] :=
  (colimit.cocone F).pt
#align category_theory.limits.colimit CategoryTheory.Limits.colimit
-/

/- warning: category_theory.limits.colimit.Œπ -> CategoryTheory.Limits.colimit.Œπ is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {C : Type.{u4}} [_inst_3 : CategoryTheory.Category.{u3, u4} C] (F : CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) [_inst_4 : CategoryTheory.Limits.HasColimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F] (j : J), Quiver.Hom.{succ u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Functor.obj.{u1, u3, u2, u4} J _inst_1 C _inst_3 F j) (CategoryTheory.Limits.colimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4)
but is expected to have type
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {C : Type.{u4}} [_inst_3 : CategoryTheory.Category.{u3, u4} C] (F : CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) [_inst_4 : CategoryTheory.Limits.HasColimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F] (j : J), Quiver.Hom.{succ u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (Prefunctor.obj.{succ u1, succ u3, u2, u4} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, u4} J _inst_1 C _inst_3 F) j) (CategoryTheory.Limits.colimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4)
Case conversion may be inaccurate. Consider using '#align category_theory.limits.colimit.Œπ CategoryTheory.Limits.colimit.Œπ‚Çì'. -/
/-- The coprojection from a value of the functor to the colimit object. -/
def colimit.Œπ (F : J ‚•§ C) [HasColimit F] (j : J) : F.obj j ‚ü∂ colimit F :=
  (colimit.cocone F).Œπ.app j
#align category_theory.limits.colimit.Œπ CategoryTheory.Limits.colimit.Œπ

/- warning: category_theory.limits.colimit.cocone_Œπ -> CategoryTheory.Limits.colimit.cocone_Œπ is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {C : Type.{u4}} [_inst_3 : CategoryTheory.Category.{u3, u4} C] {F : CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3} [_inst_4 : CategoryTheory.Limits.HasColimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F] (j : J), Eq.{succ u3} (Quiver.Hom.{succ u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Functor.obj.{u1, u3, u2, u4} J _inst_1 C _inst_3 F j) (CategoryTheory.Functor.obj.{u1, u3, u2, u4} J _inst_1 C _inst_3 (CategoryTheory.Functor.obj.{u3, max u2 u3, u4, max u1 u3 u2 u4} C _inst_3 (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.const.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Limits.Cocone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 F (CategoryTheory.Limits.colimit.cocone.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4))) j)) (CategoryTheory.NatTrans.app.{u1, u3, u2, u4} J _inst_1 C _inst_3 F (CategoryTheory.Functor.obj.{u3, max u2 u3, u4, max u1 u3 u2 u4} C _inst_3 (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.const.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Limits.Cocone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 F (CategoryTheory.Limits.colimit.cocone.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4))) (CategoryTheory.Limits.Cocone.Œπ.{u1, u3, u2, u4} J _inst_1 C _inst_3 F (CategoryTheory.Limits.colimit.cocone.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4)) j) (CategoryTheory.Limits.colimit.Œπ.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4 j)
but is expected to have type
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {C : Type.{u4}} [_inst_3 : CategoryTheory.Category.{u3, u4} C] {F : CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3} [_inst_4 : CategoryTheory.Limits.HasColimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F] (j : J), Eq.{succ u3} (Quiver.Hom.{succ u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (Prefunctor.obj.{succ u1, succ u3, u2, u4} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, u4} J _inst_1 C _inst_3 F) j) (Prefunctor.obj.{succ u1, succ u3, u2, u4} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, u4} J _inst_1 C _inst_3 (Prefunctor.obj.{succ u3, max (succ u2) (succ u3), u4, max (max (max u2 u1) u3) u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u3, max (max (max u2 u1) u4) u3} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Category.toCategoryStruct.{max u2 u3, max (max (max u2 u1) u4) u3} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3))) (CategoryTheory.Functor.toPrefunctor.{u3, max u2 u3, u4, max (max (max u2 u1) u4) u3} C _inst_3 (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.const.{u1, u3, u2, u4} J _inst_1 C _inst_3)) (CategoryTheory.Limits.Cocone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 F (CategoryTheory.Limits.colimit.cocone.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4)))) j)) (CategoryTheory.NatTrans.app.{u1, u3, u2, u4} J _inst_1 C _inst_3 F (Prefunctor.obj.{succ u3, max (succ u2) (succ u3), u4, max (max (max u2 u1) u3) u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u3, max (max (max u2 u1) u4) u3} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Category.toCategoryStruct.{max u2 u3, max (max (max u2 u1) u4) u3} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3))) (CategoryTheory.Functor.toPrefunctor.{u3, max u2 u3, u4, max (max (max u2 u1) u4) u3} C _inst_3 (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.const.{u1, u3, u2, u4} J _inst_1 C _inst_3)) (CategoryTheory.Limits.Cocone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 F (CategoryTheory.Limits.colimit.cocone.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4))) (CategoryTheory.Limits.Cocone.Œπ.{u1, u3, u2, u4} J _inst_1 C _inst_3 F (CategoryTheory.Limits.colimit.cocone.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4)) j) (CategoryTheory.Limits.colimit.Œπ.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4 j)
Case conversion may be inaccurate. Consider using '#align category_theory.limits.colimit.cocone_Œπ CategoryTheory.Limits.colimit.cocone_Œπ‚Çì'. -/
@[simp]
theorem colimit.cocone_Œπ {F : J ‚•§ C} [HasColimit F] (j : J) :
    (colimit.cocone F).Œπ.app j = colimit.Œπ _ j :=
  rfl
#align category_theory.limits.colimit.cocone_Œπ CategoryTheory.Limits.colimit.cocone_Œπ

#print CategoryTheory.Limits.colimit.cocone_x /-
@[simp]
theorem colimit.cocone_x {F : J ‚•§ C} [HasColimit F] : (colimit.cocone F).pt = colimit F :=
  rfl
#align category_theory.limits.colimit.cocone_X CategoryTheory.Limits.colimit.cocone_x
-/

/- warning: category_theory.limits.colimit.w -> CategoryTheory.Limits.colimit.w is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {C : Type.{u4}} [_inst_3 : CategoryTheory.Category.{u3, u4} C] (F : CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) [_inst_4 : CategoryTheory.Limits.HasColimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F] {j : J} {j' : J} (f : Quiver.Hom.{succ u1, u2} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) j j'), Eq.{succ u3} (Quiver.Hom.{succ u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Functor.obj.{u1, u3, u2, u4} J _inst_1 C _inst_3 F j) (CategoryTheory.Limits.colimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4)) (CategoryTheory.CategoryStruct.comp.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3) (CategoryTheory.Functor.obj.{u1, u3, u2, u4} J _inst_1 C _inst_3 F j) (CategoryTheory.Functor.obj.{u1, u3, u2, u4} J _inst_1 C _inst_3 F j') (CategoryTheory.Limits.colimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4) (CategoryTheory.Functor.map.{u1, u3, u2, u4} J _inst_1 C _inst_3 F j j' f) (CategoryTheory.Limits.colimit.Œπ.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4 j')) (CategoryTheory.Limits.colimit.Œπ.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4 j)
but is expected to have type
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {C : Type.{u4}} [_inst_3 : CategoryTheory.Category.{u3, u4} C] (F : CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) [_inst_4 : CategoryTheory.Limits.HasColimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F] {j : J} {j' : J} (f : Quiver.Hom.{succ u1, u2} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) j j'), Eq.{succ u3} (Quiver.Hom.{succ u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (Prefunctor.obj.{succ u1, succ u3, u2, u4} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, u4} J _inst_1 C _inst_3 F) j) (CategoryTheory.Limits.colimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4)) (CategoryTheory.CategoryStruct.comp.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3) (Prefunctor.obj.{succ u1, succ u3, u2, u4} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, u4} J _inst_1 C _inst_3 F) j) (Prefunctor.obj.{succ u1, succ u3, u2, u4} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, u4} J _inst_1 C _inst_3 F) j') (CategoryTheory.Limits.colimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4) (Prefunctor.map.{succ u1, succ u3, u2, u4} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, u4} J _inst_1 C _inst_3 F) j j' f) (CategoryTheory.Limits.colimit.Œπ.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4 j')) (CategoryTheory.Limits.colimit.Œπ.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4 j)
Case conversion may be inaccurate. Consider using '#align category_theory.limits.colimit.w CategoryTheory.Limits.colimit.w‚Çì'. -/
@[simp, reassoc.1]
theorem colimit.w (F : J ‚•§ C) [HasColimit F] {j j' : J} (f : j ‚ü∂ j') :
    F.map f ‚â´ colimit.Œπ F j' = colimit.Œπ F j :=
  (colimit.cocone F).w f
#align category_theory.limits.colimit.w CategoryTheory.Limits.colimit.w

#print CategoryTheory.Limits.colimit.isColimit /-
/-- Evidence that the arbitrary choice of cocone is a colimit cocone. -/
def colimit.isColimit (F : J ‚•§ C) [HasColimit F] : IsColimit (colimit.cocone F) :=
  (getColimitCocone F).IsColimit
#align category_theory.limits.colimit.is_colimit CategoryTheory.Limits.colimit.isColimit
-/

#print CategoryTheory.Limits.colimit.desc /-
/-- The morphism from the colimit object to the cone point of any other cocone. -/
def colimit.desc (F : J ‚•§ C) [HasColimit F] (c : Cocone F) : colimit F ‚ü∂ c.pt :=
  (colimit.isColimit F).desc c
#align category_theory.limits.colimit.desc CategoryTheory.Limits.colimit.desc
-/

#print CategoryTheory.Limits.colimit.isColimit_desc /-
@[simp]
theorem colimit.isColimit_desc {F : J ‚•§ C} [HasColimit F] (c : Cocone F) :
    (colimit.isColimit F).desc c = colimit.desc F c :=
  rfl
#align category_theory.limits.colimit.is_colimit_desc CategoryTheory.Limits.colimit.isColimit_desc
-/

/- warning: category_theory.limits.colimit.Œπ_desc -> CategoryTheory.Limits.colimit.Œπ_desc is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {C : Type.{u4}} [_inst_3 : CategoryTheory.Category.{u3, u4} C] {F : CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3} [_inst_4 : CategoryTheory.Limits.HasColimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F] (c : CategoryTheory.Limits.Cocone.{u1, u3, u2, u4} J _inst_1 C _inst_3 F) (j : J), Eq.{succ u3} (Quiver.Hom.{succ u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Functor.obj.{u1, u3, u2, u4} J _inst_1 C _inst_3 F j) (CategoryTheory.Limits.Cocone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 F c)) (CategoryTheory.CategoryStruct.comp.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3) (CategoryTheory.Functor.obj.{u1, u3, u2, u4} J _inst_1 C _inst_3 F j) (CategoryTheory.Limits.colimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4) (CategoryTheory.Limits.Cocone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 F c) (CategoryTheory.Limits.colimit.Œπ.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4 j) (CategoryTheory.Limits.colimit.desc.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4 c)) (CategoryTheory.NatTrans.app.{u1, u3, u2, u4} J _inst_1 C _inst_3 F (CategoryTheory.Functor.obj.{u3, max u2 u3, u4, max u1 u3 u2 u4} C _inst_3 (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.const.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Limits.Cocone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 F c)) (CategoryTheory.Limits.Cocone.Œπ.{u1, u3, u2, u4} J _inst_1 C _inst_3 F c) j)
but is expected to have type
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {C : Type.{u4}} [_inst_3 : CategoryTheory.Category.{u3, u4} C] {F : CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3} [_inst_4 : CategoryTheory.Limits.HasColimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F] (c : CategoryTheory.Limits.Cocone.{u1, u3, u2, u4} J _inst_1 C _inst_3 F) (j : J), Eq.{succ u3} (Quiver.Hom.{succ u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (Prefunctor.obj.{succ u1, succ u3, u2, u4} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, u4} J _inst_1 C _inst_3 F) j) (CategoryTheory.Limits.Cocone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 F c)) (CategoryTheory.CategoryStruct.comp.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3) (Prefunctor.obj.{succ u1, succ u3, u2, u4} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, u4} J _inst_1 C _inst_3 F) j) (CategoryTheory.Limits.colimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4) (CategoryTheory.Limits.Cocone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 F c) (CategoryTheory.Limits.colimit.Œπ.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4 j) (CategoryTheory.Limits.colimit.desc.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4 c)) (CategoryTheory.NatTrans.app.{u1, u3, u2, u4} J _inst_1 C _inst_3 F (Prefunctor.obj.{succ u3, max (succ u2) (succ u3), u4, max (max (max u2 u1) u3) u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u3, max (max (max u2 u1) u4) u3} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Category.toCategoryStruct.{max u2 u3, max (max (max u2 u1) u4) u3} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3))) (CategoryTheory.Functor.toPrefunctor.{u3, max u2 u3, u4, max (max (max u2 u1) u4) u3} C _inst_3 (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.const.{u1, u3, u2, u4} J _inst_1 C _inst_3)) (CategoryTheory.Limits.Cocone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 F c)) (CategoryTheory.Limits.Cocone.Œπ.{u1, u3, u2, u4} J _inst_1 C _inst_3 F c) j)
Case conversion may be inaccurate. Consider using '#align category_theory.limits.colimit.Œπ_desc CategoryTheory.Limits.colimit.Œπ_desc‚Çì'. -/
/-- We have lots of lemmas describing how to simplify `colimit.Œπ F j ‚â´ _`,
and combined with `colimit.ext` we rely on these lemmas for many calculations.

However, since `category.assoc` is a `@[simp]` lemma, often expressions are
right associated, and it's hard to apply these lemmas about `colimit.Œπ`.

We thus use `reassoc` to define additional `@[simp]` lemmas, with an arbitrary extra morphism.
(see `tactic/reassoc_axiom.lean`)
 -/
@[simp, reassoc.1]
theorem colimit.Œπ_desc {F : J ‚•§ C} [HasColimit F] (c : Cocone F) (j : J) :
    colimit.Œπ F j ‚â´ colimit.desc F c = c.Œπ.app j :=
  IsColimit.fac _ c j
#align category_theory.limits.colimit.Œπ_desc CategoryTheory.Limits.colimit.Œπ_desc

#print CategoryTheory.Limits.colimMap /-
/-- Functoriality of colimits.

Usually this morphism should be accessed through `colim.map`,
but may be needed separately when you have specified colimits for the source and target functors,
but not necessarily for all functors of shape `J`.
-/
def colimMap {F G : J ‚•§ C} [HasColimit F] [HasColimit G] (Œ± : F ‚ü∂ G) : colimit F ‚ü∂ colimit G :=
  IsColimit.map (colimit.isColimit F) _ Œ±
#align category_theory.limits.colim_map CategoryTheory.Limits.colimMap
-/

/- warning: category_theory.limits.Œπ_colim_map -> CategoryTheory.Limits.Œπ_colimMap is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {C : Type.{u4}} [_inst_3 : CategoryTheory.Category.{u3, u4} C] {F : CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3} {G : CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3} [_inst_4 : CategoryTheory.Limits.HasColimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F] [_inst_5 : CategoryTheory.Limits.HasColimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 G] (Œ± : Quiver.Hom.{succ (max u2 u3), max u1 u3 u2 u4} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u3, max u1 u3 u2 u4} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Category.toCategoryStruct.{max u2 u3, max u1 u3 u2 u4} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3))) F G) (j : J), Eq.{succ u3} (Quiver.Hom.{succ u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Functor.obj.{u1, u3, u2, u4} J _inst_1 C _inst_3 F j) (CategoryTheory.Limits.colimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 G _inst_5)) (CategoryTheory.CategoryStruct.comp.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3) (CategoryTheory.Functor.obj.{u1, u3, u2, u4} J _inst_1 C _inst_3 F j) (CategoryTheory.Limits.colimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4) (CategoryTheory.Limits.colimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 G _inst_5) (CategoryTheory.Limits.colimit.Œπ.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4 j) (CategoryTheory.Limits.colimMap.{u1, u2, u3, u4} J _inst_1 C _inst_3 F G _inst_4 _inst_5 Œ±)) (CategoryTheory.CategoryStruct.comp.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3) (CategoryTheory.Functor.obj.{u1, u3, u2, u4} J _inst_1 C _inst_3 F j) (CategoryTheory.Functor.obj.{u1, u3, u2, u4} J _inst_1 C _inst_3 G j) (CategoryTheory.Limits.colimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 G _inst_5) (CategoryTheory.NatTrans.app.{u1, u3, u2, u4} J _inst_1 C _inst_3 F G Œ± j) (CategoryTheory.Limits.colimit.Œπ.{u1, u2, u3, u4} J _inst_1 C _inst_3 G _inst_5 j))
but is expected to have type
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {C : Type.{u4}} [_inst_3 : CategoryTheory.Category.{u3, u4} C] {F : CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3} {G : CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3} [_inst_4 : CategoryTheory.Limits.HasColimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F] [_inst_5 : CategoryTheory.Limits.HasColimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 G] (Œ± : Quiver.Hom.{max (succ u2) (succ u3), max (max (max u4 u2) u3) u1} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u3, max (max (max u4 u2) u3) u1} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Category.toCategoryStruct.{max u2 u3, max (max (max u4 u2) u3) u1} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3))) F G) (j : J), Eq.{succ u3} (Quiver.Hom.{succ u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (Prefunctor.obj.{succ u1, succ u3, u2, u4} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, u4} J _inst_1 C _inst_3 F) j) (CategoryTheory.Limits.colimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 G _inst_5)) (CategoryTheory.CategoryStruct.comp.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3) (Prefunctor.obj.{succ u1, succ u3, u2, u4} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, u4} J _inst_1 C _inst_3 F) j) (CategoryTheory.Limits.colimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4) (CategoryTheory.Limits.colimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 G _inst_5) (CategoryTheory.Limits.colimit.Œπ.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4 j) (CategoryTheory.Limits.colimMap.{u1, u2, u3, u4} J _inst_1 C _inst_3 F G _inst_4 _inst_5 Œ±)) (CategoryTheory.CategoryStruct.comp.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3) (Prefunctor.obj.{succ u1, succ u3, u2, u4} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, u4} J _inst_1 C _inst_3 F) j) (Prefunctor.obj.{succ u1, succ u3, u2, u4} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, u4} J _inst_1 C _inst_3 G) j) (CategoryTheory.Limits.colimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 G _inst_5) (CategoryTheory.NatTrans.app.{u1, u3, u2, u4} J _inst_1 C _inst_3 F G Œ± j) (CategoryTheory.Limits.colimit.Œπ.{u1, u2, u3, u4} J _inst_1 C _inst_3 G _inst_5 j))
Case conversion may be inaccurate. Consider using '#align category_theory.limits.Œπ_colim_map CategoryTheory.Limits.Œπ_colimMap‚Çì'. -/
@[simp, reassoc.1]
theorem Œπ_colimMap {F G : J ‚•§ C} [HasColimit F] [HasColimit G] (Œ± : F ‚ü∂ G) (j : J) :
    colimit.Œπ F j ‚â´ colimMap Œ± = Œ±.app j ‚â´ colimit.Œπ G j :=
  colimit.Œπ_desc _ j
#align category_theory.limits.Œπ_colim_map CategoryTheory.Limits.Œπ_colimMap

#print CategoryTheory.Limits.colimit.coconeMorphism /-
/-- The cocone morphism from the arbitrary choice of colimit cocone to any cocone. -/
def colimit.coconeMorphism {F : J ‚•§ C} [HasColimit F] (c : Cocone F) : colimit.cocone F ‚ü∂ c :=
  (colimit.isColimit F).descCoconeMorphism c
#align category_theory.limits.colimit.cocone_morphism CategoryTheory.Limits.colimit.coconeMorphism
-/

#print CategoryTheory.Limits.colimit.coconeMorphism_hom /-
@[simp]
theorem colimit.coconeMorphism_hom {F : J ‚•§ C} [HasColimit F] (c : Cocone F) :
    (colimit.coconeMorphism c).Hom = colimit.desc F c :=
  rfl
#align category_theory.limits.colimit.cocone_morphism_hom CategoryTheory.Limits.colimit.coconeMorphism_hom
-/

/- warning: category_theory.limits.colimit.Œπ_cocone_morphism -> CategoryTheory.Limits.colimit.Œπ_coconeMorphism is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {C : Type.{u4}} [_inst_3 : CategoryTheory.Category.{u3, u4} C] {F : CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3} [_inst_4 : CategoryTheory.Limits.HasColimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F] (c : CategoryTheory.Limits.Cocone.{u1, u3, u2, u4} J _inst_1 C _inst_3 F) (j : J), Eq.{succ u3} (Quiver.Hom.{succ u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Functor.obj.{u1, u3, u2, u4} J _inst_1 C _inst_3 F j) (CategoryTheory.Limits.Cocone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 F c)) (CategoryTheory.CategoryStruct.comp.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3) (CategoryTheory.Functor.obj.{u1, u3, u2, u4} J _inst_1 C _inst_3 F j) (CategoryTheory.Limits.colimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4) (CategoryTheory.Limits.Cocone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 F c) (CategoryTheory.Limits.colimit.Œπ.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4 j) (CategoryTheory.Limits.CoconeMorphism.hom.{u1, u3, u2, u4} J _inst_1 C _inst_3 F (CategoryTheory.Limits.colimit.cocone.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4) c (CategoryTheory.Limits.colimit.coconeMorphism.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4 c))) (CategoryTheory.NatTrans.app.{u1, u3, u2, u4} J _inst_1 C _inst_3 F (CategoryTheory.Functor.obj.{u3, max u2 u3, u4, max u1 u3 u2 u4} C _inst_3 (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.const.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Limits.Cocone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 F c)) (CategoryTheory.Limits.Cocone.Œπ.{u1, u3, u2, u4} J _inst_1 C _inst_3 F c) j)
but is expected to have type
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {C : Type.{u4}} [_inst_3 : CategoryTheory.Category.{u3, u4} C] {F : CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3} [_inst_4 : CategoryTheory.Limits.HasColimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F] (c : CategoryTheory.Limits.Cocone.{u1, u3, u2, u4} J _inst_1 C _inst_3 F) (j : J), Eq.{succ u3} (Quiver.Hom.{succ u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (Prefunctor.obj.{succ u1, succ u3, u2, u4} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, u4} J _inst_1 C _inst_3 F) j) (CategoryTheory.Limits.Cocone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 F c)) (CategoryTheory.CategoryStruct.comp.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3) (Prefunctor.obj.{succ u1, succ u3, u2, u4} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, u4} J _inst_1 C _inst_3 F) j) (CategoryTheory.Limits.colimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4) (CategoryTheory.Limits.Cocone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 F c) (CategoryTheory.Limits.colimit.Œπ.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4 j) (CategoryTheory.Limits.CoconeMorphism.Hom.{u1, u3, u2, u4} J _inst_1 C _inst_3 F (CategoryTheory.Limits.colimit.cocone.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4) c (CategoryTheory.Limits.colimit.coconeMorphism.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4 c))) (CategoryTheory.NatTrans.app.{u1, u3, u2, u4} J _inst_1 C _inst_3 F (Prefunctor.obj.{succ u3, max (succ u2) (succ u3), u4, max (max (max u2 u1) u3) u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u3, max (max (max u2 u1) u4) u3} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Category.toCategoryStruct.{max u2 u3, max (max (max u2 u1) u4) u3} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3))) (CategoryTheory.Functor.toPrefunctor.{u3, max u2 u3, u4, max (max (max u2 u1) u4) u3} C _inst_3 (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.const.{u1, u3, u2, u4} J _inst_1 C _inst_3)) (CategoryTheory.Limits.Cocone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 F c)) (CategoryTheory.Limits.Cocone.Œπ.{u1, u3, u2, u4} J _inst_1 C _inst_3 F c) j)
Case conversion may be inaccurate. Consider using '#align category_theory.limits.colimit.Œπ_cocone_morphism CategoryTheory.Limits.colimit.Œπ_coconeMorphism‚Çì'. -/
theorem colimit.Œπ_coconeMorphism {F : J ‚•§ C} [HasColimit F] (c : Cocone F) (j : J) :
    colimit.Œπ F j ‚â´ (colimit.coconeMorphism c).Hom = c.Œπ.app j := by simp
#align category_theory.limits.colimit.Œπ_cocone_morphism CategoryTheory.Limits.colimit.Œπ_coconeMorphism

/- warning: category_theory.limits.colimit.comp_cocone_point_unique_up_to_iso_hom -> CategoryTheory.Limits.colimit.comp_coconePointUniqueUpToIso_hom is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {C : Type.{u4}} [_inst_3 : CategoryTheory.Category.{u3, u4} C] {F : CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3} [_inst_4 : CategoryTheory.Limits.HasColimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F] {c : CategoryTheory.Limits.Cocone.{u1, u3, u2, u4} J _inst_1 C _inst_3 F} (hc : CategoryTheory.Limits.IsColimit.{u1, u3, u2, u4} J _inst_1 C _inst_3 F c) (j : J), Eq.{succ u3} (Quiver.Hom.{succ u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Functor.obj.{u1, u3, u2, u4} J _inst_1 C _inst_3 F j) (CategoryTheory.Limits.Cocone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 F c)) (CategoryTheory.CategoryStruct.comp.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3) (CategoryTheory.Functor.obj.{u1, u3, u2, u4} J _inst_1 C _inst_3 F j) (CategoryTheory.Limits.colimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4) (CategoryTheory.Limits.Cocone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 F c) (CategoryTheory.Limits.colimit.Œπ.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4 j) (CategoryTheory.Iso.hom.{u3, u4} C _inst_3 (CategoryTheory.Limits.Cocone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 F (CategoryTheory.Limits.colimit.cocone.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4)) (CategoryTheory.Limits.Cocone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 F c) (CategoryTheory.Limits.IsColimit.coconePointUniqueUpToIso.{u1, u3, u2, u4} J _inst_1 C _inst_3 F (CategoryTheory.Limits.colimit.cocone.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4) c (CategoryTheory.Limits.colimit.isColimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4) hc))) (CategoryTheory.NatTrans.app.{u1, u3, u2, u4} J _inst_1 C _inst_3 F (CategoryTheory.Functor.obj.{u3, max u2 u3, u4, max u1 u3 u2 u4} C _inst_3 (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.const.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Limits.Cocone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 F c)) (CategoryTheory.Limits.Cocone.Œπ.{u1, u3, u2, u4} J _inst_1 C _inst_3 F c) j)
but is expected to have type
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {C : Type.{u4}} [_inst_3 : CategoryTheory.Category.{u3, u4} C] {F : CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3} [_inst_4 : CategoryTheory.Limits.HasColimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F] {c : CategoryTheory.Limits.Cocone.{u1, u3, u2, u4} J _inst_1 C _inst_3 F} (hc : CategoryTheory.Limits.IsColimit.{u1, u3, u2, u4} J _inst_1 C _inst_3 F c) (j : J), Eq.{succ u3} (Quiver.Hom.{succ u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (Prefunctor.obj.{succ u1, succ u3, u2, u4} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, u4} J _inst_1 C _inst_3 F) j) (CategoryTheory.Limits.Cocone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 F c)) (CategoryTheory.CategoryStruct.comp.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3) (Prefunctor.obj.{succ u1, succ u3, u2, u4} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, u4} J _inst_1 C _inst_3 F) j) (CategoryTheory.Limits.colimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4) (CategoryTheory.Limits.Cocone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 F c) (CategoryTheory.Limits.colimit.Œπ.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4 j) (CategoryTheory.Iso.hom.{u3, u4} C _inst_3 (CategoryTheory.Limits.Cocone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 F (CategoryTheory.Limits.colimit.cocone.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4)) (CategoryTheory.Limits.Cocone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 F c) (CategoryTheory.Limits.IsColimit.coconePointUniqueUpToIso.{u1, u3, u2, u4} J _inst_1 C _inst_3 F (CategoryTheory.Limits.colimit.cocone.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4) c (CategoryTheory.Limits.colimit.isColimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4) hc))) (CategoryTheory.NatTrans.app.{u1, u3, u2, u4} J _inst_1 C _inst_3 F (Prefunctor.obj.{succ u3, max (succ u2) (succ u3), u4, max (max (max u2 u1) u3) u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u3, max (max (max u2 u1) u4) u3} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Category.toCategoryStruct.{max u2 u3, max (max (max u2 u1) u4) u3} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3))) (CategoryTheory.Functor.toPrefunctor.{u3, max u2 u3, u4, max (max (max u2 u1) u4) u3} C _inst_3 (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.const.{u1, u3, u2, u4} J _inst_1 C _inst_3)) (CategoryTheory.Limits.Cocone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 F c)) (CategoryTheory.Limits.Cocone.Œπ.{u1, u3, u2, u4} J _inst_1 C _inst_3 F c) j)
Case conversion may be inaccurate. Consider using '#align category_theory.limits.colimit.comp_cocone_point_unique_up_to_iso_hom CategoryTheory.Limits.colimit.comp_coconePointUniqueUpToIso_hom‚Çì'. -/
@[simp, reassoc.1]
theorem colimit.comp_coconePointUniqueUpToIso_hom {F : J ‚•§ C} [HasColimit F] {c : Cocone F}
    (hc : IsColimit c) (j : J) :
    colimit.Œπ F j ‚â´ (IsColimit.coconePointUniqueUpToIso (colimit.isColimit _) hc).Hom = c.Œπ.app j :=
  IsColimit.comp_coconePointUniqueUpToIso_hom _ _ _
#align category_theory.limits.colimit.comp_cocone_point_unique_up_to_iso_hom CategoryTheory.Limits.colimit.comp_coconePointUniqueUpToIso_hom

/- warning: category_theory.limits.colimit.comp_cocone_point_unique_up_to_iso_inv -> CategoryTheory.Limits.colimit.comp_coconePointUniqueUpToIso_inv is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {C : Type.{u4}} [_inst_3 : CategoryTheory.Category.{u3, u4} C] {F : CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3} [_inst_4 : CategoryTheory.Limits.HasColimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F] {c : CategoryTheory.Limits.Cocone.{u1, u3, u2, u4} J _inst_1 C _inst_3 F} (hc : CategoryTheory.Limits.IsColimit.{u1, u3, u2, u4} J _inst_1 C _inst_3 F c) (j : J), Eq.{succ u3} (Quiver.Hom.{succ u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Functor.obj.{u1, u3, u2, u4} J _inst_1 C _inst_3 F j) (CategoryTheory.Limits.Cocone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 F c)) (CategoryTheory.CategoryStruct.comp.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3) (CategoryTheory.Functor.obj.{u1, u3, u2, u4} J _inst_1 C _inst_3 F j) (CategoryTheory.Limits.colimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4) (CategoryTheory.Limits.Cocone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 F c) (CategoryTheory.Limits.colimit.Œπ.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4 j) (CategoryTheory.Iso.inv.{u3, u4} C _inst_3 (CategoryTheory.Limits.Cocone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 F c) (CategoryTheory.Limits.Cocone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 F (CategoryTheory.Limits.colimit.cocone.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4)) (CategoryTheory.Limits.IsColimit.coconePointUniqueUpToIso.{u1, u3, u2, u4} J _inst_1 C _inst_3 F c (CategoryTheory.Limits.colimit.cocone.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4) hc (CategoryTheory.Limits.colimit.isColimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4)))) (CategoryTheory.NatTrans.app.{u1, u3, u2, u4} J _inst_1 C _inst_3 F (CategoryTheory.Functor.obj.{u3, max u2 u3, u4, max u1 u3 u2 u4} C _inst_3 (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.const.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Limits.Cocone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 F c)) (CategoryTheory.Limits.Cocone.Œπ.{u1, u3, u2, u4} J _inst_1 C _inst_3 F c) j)
but is expected to have type
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {C : Type.{u4}} [_inst_3 : CategoryTheory.Category.{u3, u4} C] {F : CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3} [_inst_4 : CategoryTheory.Limits.HasColimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F] {c : CategoryTheory.Limits.Cocone.{u1, u3, u2, u4} J _inst_1 C _inst_3 F} (hc : CategoryTheory.Limits.IsColimit.{u1, u3, u2, u4} J _inst_1 C _inst_3 F c) (j : J), Eq.{succ u3} (Quiver.Hom.{succ u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (Prefunctor.obj.{succ u1, succ u3, u2, u4} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, u4} J _inst_1 C _inst_3 F) j) (CategoryTheory.Limits.Cocone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 F c)) (CategoryTheory.CategoryStruct.comp.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3) (Prefunctor.obj.{succ u1, succ u3, u2, u4} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, u4} J _inst_1 C _inst_3 F) j) (CategoryTheory.Limits.colimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4) (CategoryTheory.Limits.Cocone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 F c) (CategoryTheory.Limits.colimit.Œπ.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4 j) (CategoryTheory.Iso.inv.{u3, u4} C _inst_3 (CategoryTheory.Limits.Cocone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 F c) (CategoryTheory.Limits.Cocone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 F (CategoryTheory.Limits.colimit.cocone.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4)) (CategoryTheory.Limits.IsColimit.coconePointUniqueUpToIso.{u1, u3, u2, u4} J _inst_1 C _inst_3 F c (CategoryTheory.Limits.colimit.cocone.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4) hc (CategoryTheory.Limits.colimit.isColimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4)))) (CategoryTheory.NatTrans.app.{u1, u3, u2, u4} J _inst_1 C _inst_3 F (Prefunctor.obj.{succ u3, max (succ u2) (succ u3), u4, max (max (max u2 u1) u3) u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u3, max (max (max u2 u1) u4) u3} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Category.toCategoryStruct.{max u2 u3, max (max (max u2 u1) u4) u3} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3))) (CategoryTheory.Functor.toPrefunctor.{u3, max u2 u3, u4, max (max (max u2 u1) u4) u3} C _inst_3 (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.const.{u1, u3, u2, u4} J _inst_1 C _inst_3)) (CategoryTheory.Limits.Cocone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 F c)) (CategoryTheory.Limits.Cocone.Œπ.{u1, u3, u2, u4} J _inst_1 C _inst_3 F c) j)
Case conversion may be inaccurate. Consider using '#align category_theory.limits.colimit.comp_cocone_point_unique_up_to_iso_inv CategoryTheory.Limits.colimit.comp_coconePointUniqueUpToIso_inv‚Çì'. -/
@[simp, reassoc.1]
theorem colimit.comp_coconePointUniqueUpToIso_inv {F : J ‚•§ C} [HasColimit F] {c : Cocone F}
    (hc : IsColimit c) (j : J) :
    colimit.Œπ F j ‚â´ (IsColimit.coconePointUniqueUpToIso hc (colimit.isColimit _)).inv = c.Œπ.app j :=
  IsColimit.comp_coconePointUniqueUpToIso_inv _ _ _
#align category_theory.limits.colimit.comp_cocone_point_unique_up_to_iso_inv CategoryTheory.Limits.colimit.comp_coconePointUniqueUpToIso_inv

/- warning: category_theory.limits.colimit.exists_unique -> CategoryTheory.Limits.colimit.existsUnique is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {C : Type.{u4}} [_inst_3 : CategoryTheory.Category.{u3, u4} C] {F : CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3} [_inst_4 : CategoryTheory.Limits.HasColimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F] (t : CategoryTheory.Limits.Cocone.{u1, u3, u2, u4} J _inst_1 C _inst_3 F), ExistsUnique.{succ u3} (Quiver.Hom.{succ u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Limits.colimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4) (CategoryTheory.Limits.Cocone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 F t)) (fun (d : Quiver.Hom.{succ u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Limits.colimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4) (CategoryTheory.Limits.Cocone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 F t)) => forall (j : J), Eq.{succ u3} (Quiver.Hom.{succ u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Functor.obj.{u1, u3, u2, u4} J _inst_1 C _inst_3 F j) (CategoryTheory.Limits.Cocone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 F t)) (CategoryTheory.CategoryStruct.comp.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3) (CategoryTheory.Functor.obj.{u1, u3, u2, u4} J _inst_1 C _inst_3 F j) (CategoryTheory.Limits.colimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4) (CategoryTheory.Limits.Cocone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 F t) (CategoryTheory.Limits.colimit.Œπ.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4 j) d) (CategoryTheory.NatTrans.app.{u1, u3, u2, u4} J _inst_1 C _inst_3 F (CategoryTheory.Functor.obj.{u3, max u2 u3, u4, max u1 u3 u2 u4} C _inst_3 (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.const.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Limits.Cocone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 F t)) (CategoryTheory.Limits.Cocone.Œπ.{u1, u3, u2, u4} J _inst_1 C _inst_3 F t) j))
but is expected to have type
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {C : Type.{u4}} [_inst_3 : CategoryTheory.Category.{u3, u4} C] {F : CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3} [_inst_4 : CategoryTheory.Limits.HasColimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F] (t : CategoryTheory.Limits.Cocone.{u1, u3, u2, u4} J _inst_1 C _inst_3 F), ExistsUnique.{succ u3} (Quiver.Hom.{succ u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Limits.colimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4) (CategoryTheory.Limits.Cocone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 F t)) (fun (d : Quiver.Hom.{succ u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Limits.colimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4) (CategoryTheory.Limits.Cocone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 F t)) => forall (j : J), Eq.{succ u3} (Quiver.Hom.{succ u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (Prefunctor.obj.{succ u1, succ u3, u2, u4} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, u4} J _inst_1 C _inst_3 F) j) (CategoryTheory.Limits.Cocone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 F t)) (CategoryTheory.CategoryStruct.comp.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3) (Prefunctor.obj.{succ u1, succ u3, u2, u4} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, u4} J _inst_1 C _inst_3 F) j) (CategoryTheory.Limits.colimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4) (CategoryTheory.Limits.Cocone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 F t) (CategoryTheory.Limits.colimit.Œπ.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4 j) d) (CategoryTheory.NatTrans.app.{u1, u3, u2, u4} J _inst_1 C _inst_3 F (Prefunctor.obj.{succ u3, max (succ u2) (succ u3), u4, max (max (max u2 u1) u3) u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u3, max (max (max u2 u1) u4) u3} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Category.toCategoryStruct.{max u2 u3, max (max (max u2 u1) u4) u3} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3))) (CategoryTheory.Functor.toPrefunctor.{u3, max u2 u3, u4, max (max (max u2 u1) u4) u3} C _inst_3 (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.const.{u1, u3, u2, u4} J _inst_1 C _inst_3)) (CategoryTheory.Limits.Cocone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 F t)) (CategoryTheory.Limits.Cocone.Œπ.{u1, u3, u2, u4} J _inst_1 C _inst_3 F t) j))
Case conversion may be inaccurate. Consider using '#align category_theory.limits.colimit.exists_unique CategoryTheory.Limits.colimit.existsUnique‚Çì'. -/
theorem colimit.existsUnique {F : J ‚•§ C} [HasColimit F] (t : Cocone F) :
    ‚àÉ! d : colimit F ‚ü∂ t.pt, ‚àÄ j, colimit.Œπ F j ‚â´ d = t.Œπ.app j :=
  (colimit.isColimit F).ExistsUnique _
#align category_theory.limits.colimit.exists_unique CategoryTheory.Limits.colimit.existsUnique

#print CategoryTheory.Limits.colimit.isoColimitCocone /-
/--
Given any other colimit cocone for `F`, the chosen `colimit F` is isomorphic to the cocone point.
-/
def colimit.isoColimitCocone {F : J ‚•§ C} [HasColimit F] (t : ColimitCocone F) :
    colimit F ‚âÖ t.Cocone.pt :=
  IsColimit.coconePointUniqueUpToIso (colimit.isColimit F) t.IsColimit
#align category_theory.limits.colimit.iso_colimit_cocone CategoryTheory.Limits.colimit.isoColimitCocone
-/

/- warning: category_theory.limits.colimit.iso_colimit_cocone_Œπ_hom -> CategoryTheory.Limits.colimit.isoColimitCocone_Œπ_hom is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {C : Type.{u4}} [_inst_3 : CategoryTheory.Category.{u3, u4} C] {F : CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3} [_inst_4 : CategoryTheory.Limits.HasColimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F] (t : CategoryTheory.Limits.ColimitCocone.{u1, u2, u3, u4} J _inst_1 C _inst_3 F) (j : J), Eq.{succ u3} (Quiver.Hom.{succ u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Functor.obj.{u1, u3, u2, u4} J _inst_1 C _inst_3 F j) (CategoryTheory.Limits.Cocone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 F (CategoryTheory.Limits.ColimitCocone.cocone.{u1, u2, u3, u4} J _inst_1 C _inst_3 F t))) (CategoryTheory.CategoryStruct.comp.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3) (CategoryTheory.Functor.obj.{u1, u3, u2, u4} J _inst_1 C _inst_3 F j) (CategoryTheory.Limits.colimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4) (CategoryTheory.Limits.Cocone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 F (CategoryTheory.Limits.ColimitCocone.cocone.{u1, u2, u3, u4} J _inst_1 C _inst_3 F t)) (CategoryTheory.Limits.colimit.Œπ.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4 j) (CategoryTheory.Iso.hom.{u3, u4} C _inst_3 (CategoryTheory.Limits.colimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4) (CategoryTheory.Limits.Cocone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 F (CategoryTheory.Limits.ColimitCocone.cocone.{u1, u2, u3, u4} J _inst_1 C _inst_3 F t)) (CategoryTheory.Limits.colimit.isoColimitCocone.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4 t))) (CategoryTheory.NatTrans.app.{u1, u3, u2, u4} J _inst_1 C _inst_3 F (CategoryTheory.Functor.obj.{u3, max u2 u3, u4, max u1 u3 u2 u4} C _inst_3 (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.const.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Limits.Cocone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 F (CategoryTheory.Limits.ColimitCocone.cocone.{u1, u2, u3, u4} J _inst_1 C _inst_3 F t))) (CategoryTheory.Limits.Cocone.Œπ.{u1, u3, u2, u4} J _inst_1 C _inst_3 F (CategoryTheory.Limits.ColimitCocone.cocone.{u1, u2, u3, u4} J _inst_1 C _inst_3 F t)) j)
but is expected to have type
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {C : Type.{u4}} [_inst_3 : CategoryTheory.Category.{u3, u4} C] {F : CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3} [_inst_4 : CategoryTheory.Limits.HasColimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F] (t : CategoryTheory.Limits.ColimitCocone.{u1, u2, u3, u4} J _inst_1 C _inst_3 F) (j : J), Eq.{succ u3} (Quiver.Hom.{succ u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (Prefunctor.obj.{succ u1, succ u3, u2, u4} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, u4} J _inst_1 C _inst_3 F) j) (CategoryTheory.Limits.Cocone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 F (CategoryTheory.Limits.ColimitCocone.cocone.{u1, u2, u3, u4} J _inst_1 C _inst_3 F t))) (CategoryTheory.CategoryStruct.comp.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3) (Prefunctor.obj.{succ u1, succ u3, u2, u4} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, u4} J _inst_1 C _inst_3 F) j) (CategoryTheory.Limits.colimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4) (CategoryTheory.Limits.Cocone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 F (CategoryTheory.Limits.ColimitCocone.cocone.{u1, u2, u3, u4} J _inst_1 C _inst_3 F t)) (CategoryTheory.Limits.colimit.Œπ.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4 j) (CategoryTheory.Iso.hom.{u3, u4} C _inst_3 (CategoryTheory.Limits.colimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4) (CategoryTheory.Limits.Cocone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 F (CategoryTheory.Limits.ColimitCocone.cocone.{u1, u2, u3, u4} J _inst_1 C _inst_3 F t)) (CategoryTheory.Limits.colimit.isoColimitCocone.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4 t))) (CategoryTheory.NatTrans.app.{u1, u3, u2, u4} J _inst_1 C _inst_3 F (Prefunctor.obj.{succ u3, max (succ u2) (succ u3), u4, max (max (max u2 u1) u3) u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u3, max (max (max u2 u1) u4) u3} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Category.toCategoryStruct.{max u2 u3, max (max (max u2 u1) u4) u3} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3))) (CategoryTheory.Functor.toPrefunctor.{u3, max u2 u3, u4, max (max (max u2 u1) u4) u3} C _inst_3 (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.const.{u1, u3, u2, u4} J _inst_1 C _inst_3)) (CategoryTheory.Limits.Cocone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 F (CategoryTheory.Limits.ColimitCocone.cocone.{u1, u2, u3, u4} J _inst_1 C _inst_3 F t))) (CategoryTheory.Limits.Cocone.Œπ.{u1, u3, u2, u4} J _inst_1 C _inst_3 F (CategoryTheory.Limits.ColimitCocone.cocone.{u1, u2, u3, u4} J _inst_1 C _inst_3 F t)) j)
Case conversion may be inaccurate. Consider using '#align category_theory.limits.colimit.iso_colimit_cocone_Œπ_hom CategoryTheory.Limits.colimit.isoColimitCocone_Œπ_hom‚Çì'. -/
@[simp, reassoc.1]
theorem colimit.isoColimitCocone_Œπ_hom {F : J ‚•§ C} [HasColimit F] (t : ColimitCocone F) (j : J) :
    colimit.Œπ F j ‚â´ (colimit.isoColimitCocone t).Hom = t.Cocone.Œπ.app j :=
  by
  dsimp [colimit.iso_colimit_cocone, is_colimit.cocone_point_unique_up_to_iso]
  tidy
#align category_theory.limits.colimit.iso_colimit_cocone_Œπ_hom CategoryTheory.Limits.colimit.isoColimitCocone_Œπ_hom

/- warning: category_theory.limits.colimit.iso_colimit_cocone_Œπ_inv -> CategoryTheory.Limits.colimit.isoColimitCocone_Œπ_inv is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {C : Type.{u4}} [_inst_3 : CategoryTheory.Category.{u3, u4} C] {F : CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3} [_inst_4 : CategoryTheory.Limits.HasColimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F] (t : CategoryTheory.Limits.ColimitCocone.{u1, u2, u3, u4} J _inst_1 C _inst_3 F) (j : J), Eq.{succ u3} (Quiver.Hom.{succ u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Functor.obj.{u1, u3, u2, u4} J _inst_1 C _inst_3 F j) (CategoryTheory.Limits.colimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4)) (CategoryTheory.CategoryStruct.comp.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3) (CategoryTheory.Functor.obj.{u1, u3, u2, u4} J _inst_1 C _inst_3 F j) (CategoryTheory.Functor.obj.{u1, u3, u2, u4} J _inst_1 C _inst_3 (CategoryTheory.Functor.obj.{u3, max u2 u3, u4, max u1 u3 u2 u4} C _inst_3 (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.const.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Limits.Cocone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 F (CategoryTheory.Limits.ColimitCocone.cocone.{u1, u2, u3, u4} J _inst_1 C _inst_3 F t))) j) (CategoryTheory.Limits.colimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4) (CategoryTheory.NatTrans.app.{u1, u3, u2, u4} J _inst_1 C _inst_3 F (CategoryTheory.Functor.obj.{u3, max u2 u3, u4, max u1 u3 u2 u4} C _inst_3 (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.const.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Limits.Cocone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 F (CategoryTheory.Limits.ColimitCocone.cocone.{u1, u2, u3, u4} J _inst_1 C _inst_3 F t))) (CategoryTheory.Limits.Cocone.Œπ.{u1, u3, u2, u4} J _inst_1 C _inst_3 F (CategoryTheory.Limits.ColimitCocone.cocone.{u1, u2, u3, u4} J _inst_1 C _inst_3 F t)) j) (CategoryTheory.Iso.inv.{u3, u4} C _inst_3 (CategoryTheory.Limits.colimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4) (CategoryTheory.Limits.Cocone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 F (CategoryTheory.Limits.ColimitCocone.cocone.{u1, u2, u3, u4} J _inst_1 C _inst_3 F t)) (CategoryTheory.Limits.colimit.isoColimitCocone.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4 t))) (CategoryTheory.Limits.colimit.Œπ.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4 j)
but is expected to have type
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {C : Type.{u4}} [_inst_3 : CategoryTheory.Category.{u3, u4} C] {F : CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3} [_inst_4 : CategoryTheory.Limits.HasColimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F] (t : CategoryTheory.Limits.ColimitCocone.{u1, u2, u3, u4} J _inst_1 C _inst_3 F) (j : J), Eq.{succ u3} (Quiver.Hom.{succ u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (Prefunctor.obj.{succ u1, succ u3, u2, u4} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, u4} J _inst_1 C _inst_3 F) j) (CategoryTheory.Limits.colimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4)) (CategoryTheory.CategoryStruct.comp.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3) (Prefunctor.obj.{succ u1, succ u3, u2, u4} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, u4} J _inst_1 C _inst_3 F) j) (Prefunctor.obj.{succ u1, succ u3, u2, u4} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, u4} J _inst_1 C _inst_3 (Prefunctor.obj.{succ u3, max (succ u2) (succ u3), u4, max (max (max u2 u1) u3) u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u3, max (max (max u2 u1) u4) u3} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Category.toCategoryStruct.{max u2 u3, max (max (max u2 u1) u4) u3} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3))) (CategoryTheory.Functor.toPrefunctor.{u3, max u2 u3, u4, max (max (max u2 u1) u4) u3} C _inst_3 (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.const.{u1, u3, u2, u4} J _inst_1 C _inst_3)) (CategoryTheory.Limits.Cocone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 F (CategoryTheory.Limits.ColimitCocone.cocone.{u1, u2, u3, u4} J _inst_1 C _inst_3 F t)))) j) (CategoryTheory.Limits.colimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4) (CategoryTheory.NatTrans.app.{u1, u3, u2, u4} J _inst_1 C _inst_3 F (Prefunctor.obj.{succ u3, max (succ u2) (succ u3), u4, max (max (max u2 u1) u3) u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u3, max (max (max u2 u1) u4) u3} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Category.toCategoryStruct.{max u2 u3, max (max (max u2 u1) u4) u3} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3))) (CategoryTheory.Functor.toPrefunctor.{u3, max u2 u3, u4, max (max (max u2 u1) u4) u3} C _inst_3 (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.const.{u1, u3, u2, u4} J _inst_1 C _inst_3)) (CategoryTheory.Limits.Cocone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 F (CategoryTheory.Limits.ColimitCocone.cocone.{u1, u2, u3, u4} J _inst_1 C _inst_3 F t))) (CategoryTheory.Limits.Cocone.Œπ.{u1, u3, u2, u4} J _inst_1 C _inst_3 F (CategoryTheory.Limits.ColimitCocone.cocone.{u1, u2, u3, u4} J _inst_1 C _inst_3 F t)) j) (CategoryTheory.Iso.inv.{u3, u4} C _inst_3 (CategoryTheory.Limits.colimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4) (CategoryTheory.Limits.Cocone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 F (CategoryTheory.Limits.ColimitCocone.cocone.{u1, u2, u3, u4} J _inst_1 C _inst_3 F t)) (CategoryTheory.Limits.colimit.isoColimitCocone.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4 t))) (CategoryTheory.Limits.colimit.Œπ.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4 j)
Case conversion may be inaccurate. Consider using '#align category_theory.limits.colimit.iso_colimit_cocone_Œπ_inv CategoryTheory.Limits.colimit.isoColimitCocone_Œπ_inv‚Çì'. -/
@[simp, reassoc.1]
theorem colimit.isoColimitCocone_Œπ_inv {F : J ‚•§ C} [HasColimit F] (t : ColimitCocone F) (j : J) :
    t.Cocone.Œπ.app j ‚â´ (colimit.isoColimitCocone t).inv = colimit.Œπ F j :=
  by
  dsimp [colimit.iso_colimit_cocone, is_colimit.cocone_point_unique_up_to_iso]
  tidy
#align category_theory.limits.colimit.iso_colimit_cocone_Œπ_inv CategoryTheory.Limits.colimit.isoColimitCocone_Œπ_inv

/- warning: category_theory.limits.colimit.hom_ext -> CategoryTheory.Limits.colimit.hom_ext is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {C : Type.{u4}} [_inst_3 : CategoryTheory.Category.{u3, u4} C] {F : CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3} [_inst_4 : CategoryTheory.Limits.HasColimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F] {X : C} {f : Quiver.Hom.{succ u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Limits.colimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4) X} {f' : Quiver.Hom.{succ u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Limits.colimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4) X}, (forall (j : J), Eq.{succ u3} (Quiver.Hom.{succ u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Functor.obj.{u1, u3, u2, u4} J _inst_1 C _inst_3 F j) X) (CategoryTheory.CategoryStruct.comp.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3) (CategoryTheory.Functor.obj.{u1, u3, u2, u4} J _inst_1 C _inst_3 F j) (CategoryTheory.Limits.colimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4) X (CategoryTheory.Limits.colimit.Œπ.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4 j) f) (CategoryTheory.CategoryStruct.comp.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3) (CategoryTheory.Functor.obj.{u1, u3, u2, u4} J _inst_1 C _inst_3 F j) (CategoryTheory.Limits.colimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4) X (CategoryTheory.Limits.colimit.Œπ.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4 j) f')) -> (Eq.{succ u3} (Quiver.Hom.{succ u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Limits.colimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4) X) f f')
but is expected to have type
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {C : Type.{u4}} [_inst_3 : CategoryTheory.Category.{u3, u4} C] {F : CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3} [_inst_4 : CategoryTheory.Limits.HasColimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F] {X : C} {f : Quiver.Hom.{succ u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Limits.colimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4) X} {f' : Quiver.Hom.{succ u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Limits.colimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4) X}, (forall (j : J), Eq.{succ u3} (Quiver.Hom.{succ u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (Prefunctor.obj.{succ u1, succ u3, u2, u4} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, u4} J _inst_1 C _inst_3 F) j) X) (CategoryTheory.CategoryStruct.comp.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3) (Prefunctor.obj.{succ u1, succ u3, u2, u4} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, u4} J _inst_1 C _inst_3 F) j) (CategoryTheory.Limits.colimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4) X (CategoryTheory.Limits.colimit.Œπ.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4 j) f) (CategoryTheory.CategoryStruct.comp.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3) (Prefunctor.obj.{succ u1, succ u3, u2, u4} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, u4} J _inst_1 C _inst_3 F) j) (CategoryTheory.Limits.colimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4) X (CategoryTheory.Limits.colimit.Œπ.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4 j) f')) -> (Eq.{succ u3} (Quiver.Hom.{succ u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Limits.colimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4) X) f f')
Case conversion may be inaccurate. Consider using '#align category_theory.limits.colimit.hom_ext CategoryTheory.Limits.colimit.hom_ext‚Çì'. -/
@[ext]
theorem colimit.hom_ext {F : J ‚•§ C} [HasColimit F] {X : C} {f f' : colimit F ‚ü∂ X}
    (w : ‚àÄ j, colimit.Œπ F j ‚â´ f = colimit.Œπ F j ‚â´ f') : f = f' :=
  (colimit.isColimit F).hom_ext w
#align category_theory.limits.colimit.hom_ext CategoryTheory.Limits.colimit.hom_ext

#print CategoryTheory.Limits.colimit.desc_cocone /-
@[simp]
theorem colimit.desc_cocone {F : J ‚•§ C} [HasColimit F] :
    colimit.desc F (colimit.cocone F) = ùüô (colimit F) :=
  (colimit.isColimit _).desc_self
#align category_theory.limits.colimit.desc_cocone CategoryTheory.Limits.colimit.desc_cocone
-/

/- warning: category_theory.limits.colimit.hom_iso -> CategoryTheory.Limits.colimit.homIso is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {C : Type.{u4}} [_inst_3 : CategoryTheory.Category.{u3, u4} C] (F : CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) [_inst_4 : CategoryTheory.Limits.HasColimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F] (W : C), CategoryTheory.Iso.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (ULift.{u2, u3} (Quiver.Hom.{succ u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Limits.colimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4) W)) (CategoryTheory.Functor.obj.{u3, max u2 u3, u4, succ (max u2 u3)} C _inst_3 Type.{max u2 u3} CategoryTheory.types.{max u2 u3} (CategoryTheory.Functor.cocones.{u1, u3, u2, u4} J _inst_1 C _inst_3 F) W)
but is expected to have type
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {C : Type.{u4}} [_inst_3 : CategoryTheory.Category.{u3, u4} C] (F : CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) [_inst_4 : CategoryTheory.Limits.HasColimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F] (W : C), CategoryTheory.Iso.{max u2 u3, max (succ u2) (succ u3)} Type.{max u3 u2} CategoryTheory.types.{max u2 u3} (ULift.{u2, u3} (Quiver.Hom.{succ u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Limits.colimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4) W)) (Prefunctor.obj.{succ u3, max (succ u2) (succ u3), u4, max (succ u2) (succ u3)} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) Type.{max u2 u3} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u3, max (succ u2) (succ u3)} Type.{max u2 u3} (CategoryTheory.Category.toCategoryStruct.{max u2 u3, max (succ u2) (succ u3)} Type.{max u2 u3} CategoryTheory.types.{max u2 u3})) (CategoryTheory.Functor.toPrefunctor.{u3, max u2 u3, u4, max (succ u2) (succ u3)} C _inst_3 Type.{max u2 u3} CategoryTheory.types.{max u2 u3} (CategoryTheory.Functor.cocones.{u1, u3, u2, u4} J _inst_1 C _inst_3 F)) W)
Case conversion may be inaccurate. Consider using '#align category_theory.limits.colimit.hom_iso CategoryTheory.Limits.colimit.homIso‚Çì'. -/
/-- The isomorphism (in `Type`) between
morphisms from the colimit object to a specified object `W`,
and cocones with cone point `W`.
-/
def colimit.homIso (F : J ‚•§ C) [HasColimit F] (W : C) :
    ULift.{u‚ÇÅ} (colimit F ‚ü∂ W : Type v) ‚âÖ F.cocones.obj W :=
  (colimit.isColimit F).homIso W
#align category_theory.limits.colimit.hom_iso CategoryTheory.Limits.colimit.homIso

/- warning: category_theory.limits.colimit.hom_iso_hom -> CategoryTheory.Limits.colimit.homIso_hom is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {C : Type.{u4}} [_inst_3 : CategoryTheory.Category.{u3, u4} C] (F : CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) [_inst_4 : CategoryTheory.Limits.HasColimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F] {W : C} (f : ULift.{u2, u3} (Quiver.Hom.{succ u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Limits.colimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4) W)), Eq.{succ (max u2 u3)} (CategoryTheory.Functor.obj.{u3, max u2 u3, u4, succ (max u2 u3)} C _inst_3 Type.{max u2 u3} CategoryTheory.types.{max u2 u3} (CategoryTheory.Functor.cocones.{u1, u3, u2, u4} J _inst_1 C _inst_3 F) W) (CategoryTheory.Iso.hom.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (ULift.{u2, u3} (Quiver.Hom.{succ u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Limits.colimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4) W)) (CategoryTheory.Functor.obj.{u3, max u2 u3, u4, succ (max u2 u3)} C _inst_3 Type.{max u2 u3} CategoryTheory.types.{max u2 u3} (CategoryTheory.Functor.cocones.{u1, u3, u2, u4} J _inst_1 C _inst_3 F) W) (CategoryTheory.Limits.colimit.homIso.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4 W) f) (CategoryTheory.CategoryStruct.comp.{max u2 u3, max u1 u3 u2 u4} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Category.toCategoryStruct.{max u2 u3, max u1 u3 u2 u4} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3)) (Opposite.unop.{succ (max u1 u3 u2 u4)} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (Opposite.op.{succ (max u1 u3 u2 u4)} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) F)) (CategoryTheory.Functor.obj.{u3, max u2 u3, u4, max u1 u3 u2 u4} C _inst_3 (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.const.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Limits.Cocone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 F (CategoryTheory.Limits.colimit.cocone.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4))) (CategoryTheory.Functor.obj.{u3, max u2 u3, u4, max u1 u3 u2 u4} C _inst_3 (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.const.{u1, u3, u2, u4} J _inst_1 C _inst_3) W) (CategoryTheory.Limits.Cocone.Œπ.{u1, u3, u2, u4} J _inst_1 C _inst_3 F (CategoryTheory.Limits.colimit.cocone.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4)) (CategoryTheory.Functor.map.{u3, max u2 u3, u4, max u1 u3 u2 u4} C _inst_3 (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.const.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Limits.Cocone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 F (CategoryTheory.Limits.colimit.cocone.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4)) W (ULift.down.{u2, u3} (Quiver.Hom.{succ u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Limits.colimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4) W) f)))
but is expected to have type
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {C : Type.{u4}} [_inst_3 : CategoryTheory.Category.{u3, u4} C] (F : CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) [_inst_4 : CategoryTheory.Limits.HasColimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F] {W : C} (f : ULift.{u2, u3} (Quiver.Hom.{succ u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Limits.colimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4) W)), Eq.{max (succ u2) (succ u3)} (Prefunctor.obj.{succ u3, max (succ u2) (succ u3), u4, max (succ u2) (succ u3)} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) Type.{max u2 u3} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u3, max (succ u2) (succ u3)} Type.{max u2 u3} (CategoryTheory.Category.toCategoryStruct.{max u2 u3, max (succ u2) (succ u3)} Type.{max u2 u3} CategoryTheory.types.{max u2 u3})) (CategoryTheory.Functor.toPrefunctor.{u3, max u2 u3, u4, max (succ u2) (succ u3)} C _inst_3 Type.{max u2 u3} CategoryTheory.types.{max u2 u3} (CategoryTheory.Functor.cocones.{u1, u3, u2, u4} J _inst_1 C _inst_3 F)) W) (CategoryTheory.Iso.hom.{max u2 u3, max (succ u2) (succ u3)} Type.{max u3 u2} CategoryTheory.types.{max u2 u3} (ULift.{u2, u3} (Quiver.Hom.{succ u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Limits.colimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4) W)) (Prefunctor.obj.{succ u3, max (succ u2) (succ u3), u4, max (succ u2) (succ u3)} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) Type.{max u2 u3} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u3, max (succ u2) (succ u3)} Type.{max u2 u3} (CategoryTheory.Category.toCategoryStruct.{max u2 u3, max (succ u2) (succ u3)} Type.{max u2 u3} CategoryTheory.types.{max u2 u3})) (CategoryTheory.Functor.toPrefunctor.{u3, max u2 u3, u4, max (succ u2) (succ u3)} C _inst_3 Type.{max u2 u3} CategoryTheory.types.{max u2 u3} (CategoryTheory.Functor.cocones.{u1, u3, u2, u4} J _inst_1 C _inst_3 F)) W) (CategoryTheory.Limits.colimit.homIso.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4 W) f) (CategoryTheory.CategoryStruct.comp.{max u2 u3, max (max (max u4 u2) u3) u1} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Category.toCategoryStruct.{max u2 u3, max (max (max u4 u2) u3) u1} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3)) F (Prefunctor.obj.{succ u3, max (succ u2) (succ u3), u4, max (max (max u2 u1) u3) u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u3, max (max (max u2 u1) u4) u3} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Category.toCategoryStruct.{max u2 u3, max (max (max u2 u1) u4) u3} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3))) (CategoryTheory.Functor.toPrefunctor.{u3, max u2 u3, u4, max (max (max u2 u1) u4) u3} C _inst_3 (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.const.{u1, u3, u2, u4} J _inst_1 C _inst_3)) (CategoryTheory.Limits.Cocone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 F (CategoryTheory.Limits.colimit.cocone.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4))) (Prefunctor.obj.{succ u3, max (succ u2) (succ u3), u4, max (max (max u2 u1) u3) u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u3, max (max (max u2 u1) u4) u3} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Category.toCategoryStruct.{max u2 u3, max (max (max u2 u1) u4) u3} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3))) (CategoryTheory.Functor.toPrefunctor.{u3, max u2 u3, u4, max (max (max u2 u1) u4) u3} C _inst_3 (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.const.{u1, u3, u2, u4} J _inst_1 C _inst_3)) W) (CategoryTheory.Limits.Cocone.Œπ.{u1, u3, u2, u4} J _inst_1 C _inst_3 F (CategoryTheory.Limits.colimit.cocone.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4)) (Prefunctor.map.{succ u3, max (succ u2) (succ u3), u4, max (max (max u2 u1) u3) u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u3, max (max (max u2 u1) u4) u3} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Category.toCategoryStruct.{max u2 u3, max (max (max u2 u1) u4) u3} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3))) (CategoryTheory.Functor.toPrefunctor.{u3, max u2 u3, u4, max (max (max u2 u1) u4) u3} C _inst_3 (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.const.{u1, u3, u2, u4} J _inst_1 C _inst_3)) (CategoryTheory.Limits.Cocone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 F (CategoryTheory.Limits.colimit.cocone.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4)) W (ULift.down.{u2, u3} (Quiver.Hom.{succ u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Limits.colimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4) W) f)))
Case conversion may be inaccurate. Consider using '#align category_theory.limits.colimit.hom_iso_hom CategoryTheory.Limits.colimit.homIso_hom‚Çì'. -/
@[simp]
theorem colimit.homIso_hom (F : J ‚•§ C) [HasColimit F] {W : C} (f : ULift (colimit F ‚ü∂ W)) :
    (colimit.homIso F W).Hom f = (colimit.cocone F).Œπ ‚â´ (const J).map f.down :=
  (colimit.isColimit F).homIso_hom f
#align category_theory.limits.colimit.hom_iso_hom CategoryTheory.Limits.colimit.homIso_hom

/- warning: category_theory.limits.colimit.hom_iso' -> CategoryTheory.Limits.colimit.homIso' is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {C : Type.{u4}} [_inst_3 : CategoryTheory.Category.{u3, u4} C] (F : CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) [_inst_4 : CategoryTheory.Limits.HasColimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F] (W : C), CategoryTheory.Iso.{max u3 u2, succ (max u3 u2)} Type.{max u3 u2} CategoryTheory.types.{max u3 u2} (ULift.{u2, u3} (Quiver.Hom.{succ u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Limits.colimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4) W)) (Subtype.{max (succ u2) (succ u3)} (forall (j : J), Quiver.Hom.{succ u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Functor.obj.{u1, u3, u2, u4} J _inst_1 C _inst_3 F j) W) (fun (p : forall (j : J), Quiver.Hom.{succ u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Functor.obj.{u1, u3, u2, u4} J _inst_1 C _inst_3 F j) W) => forall {j : J} {j' : J} (f : Quiver.Hom.{succ u1, u2} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) j j'), Eq.{succ u3} (Quiver.Hom.{succ u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Functor.obj.{u1, u3, u2, u4} J _inst_1 C _inst_3 F j) W) (CategoryTheory.CategoryStruct.comp.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3) (CategoryTheory.Functor.obj.{u1, u3, u2, u4} J _inst_1 C _inst_3 F j) (CategoryTheory.Functor.obj.{u1, u3, u2, u4} J _inst_1 C _inst_3 F j') W (CategoryTheory.Functor.map.{u1, u3, u2, u4} J _inst_1 C _inst_3 F j j' f) (p j')) (p j)))
but is expected to have type
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {C : Type.{u4}} [_inst_3 : CategoryTheory.Category.{u3, u4} C] (F : CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) [_inst_4 : CategoryTheory.Limits.HasColimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F] (W : C), CategoryTheory.Iso.{max u2 u3, max (succ u2) (succ u3)} Type.{max u3 u2} CategoryTheory.types.{max u2 u3} (ULift.{u2, u3} (Quiver.Hom.{succ u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Limits.colimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4) W)) (Subtype.{max (succ u2) (succ u3)} (forall (j : J), Quiver.Hom.{succ u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (Prefunctor.obj.{succ u1, succ u3, u2, u4} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, u4} J _inst_1 C _inst_3 F) j) W) (fun (p : forall (j : J), Quiver.Hom.{succ u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (Prefunctor.obj.{succ u1, succ u3, u2, u4} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, u4} J _inst_1 C _inst_3 F) j) W) => forall {j : J} {j' : J} (f : Quiver.Hom.{succ u1, u2} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) j j'), Eq.{succ u3} (Quiver.Hom.{succ u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (Prefunctor.obj.{succ u1, succ u3, u2, u4} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, u4} J _inst_1 C _inst_3 F) j) W) (CategoryTheory.CategoryStruct.comp.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3) (Prefunctor.obj.{succ u1, succ u3, u2, u4} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, u4} J _inst_1 C _inst_3 F) j) (Prefunctor.obj.{succ u1, succ u3, u2, u4} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, u4} J _inst_1 C _inst_3 F) j') W (Prefunctor.map.{succ u1, succ u3, u2, u4} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, u4} J _inst_1 C _inst_3 F) j j' f) (p j')) (p j)))
Case conversion may be inaccurate. Consider using '#align category_theory.limits.colimit.hom_iso' CategoryTheory.Limits.colimit.homIso'‚Çì'. -/
/-- The isomorphism (in `Type`) between
morphisms from the colimit object to a specified object `W`,
and an explicit componentwise description of cocones with cone point `W`.
-/
def colimit.homIso' (F : J ‚•§ C) [HasColimit F] (W : C) :
    ULift.{u‚ÇÅ} (colimit F ‚ü∂ W : Type v) ‚âÖ
      { p : ‚àÄ j, F.obj j ‚ü∂ W // ‚àÄ {j j'} (f : j ‚ü∂ j'), F.map f ‚â´ p j' = p j } :=
  (colimit.isColimit F).homIso' W
#align category_theory.limits.colimit.hom_iso' CategoryTheory.Limits.colimit.homIso'

#print CategoryTheory.Limits.colimit.desc_extend /-
theorem colimit.desc_extend (F : J ‚•§ C) [HasColimit F] (c : Cocone F) {X : C} (f : c.pt ‚ü∂ X) :
    colimit.desc F (c.extend f) = colimit.desc F c ‚â´ f := by ext1; rw [‚Üê category.assoc]; simp
#align category_theory.limits.colimit.desc_extend CategoryTheory.Limits.colimit.desc_extend
-/

#print CategoryTheory.Limits.hasColimitOfIso /-
-- This has the isomorphism pointing in the opposite direction than in `has_limit_of_iso`.
-- This is intentional; it seems to help with elaboration.
/-- If `F` has a colimit, so does any naturally isomorphic functor.
-/
theorem hasColimitOfIso {F G : J ‚•§ C} [HasColimit F] (Œ± : G ‚âÖ F) : HasColimit G :=
  HasColimit.mk
    { Cocone := (Cocones.precompose Œ±.Hom).obj (colimit.cocone F)
      IsColimit :=
        { desc := fun s => colimit.desc F ((Cocones.precompose Œ±.inv).obj s)
          fac := fun s j =>
            by
            rw [cocones.precompose_obj_Œπ, nat_trans.comp_app, colimit.cocone_Œπ]
            rw [category.assoc, colimit.Œπ_desc, ‚Üê nat_iso.app_hom, ‚Üê iso.eq_inv_comp]; rfl
          uniq := fun s m w => by
            apply colimit.hom_ext; intro j
            rw [colimit.Œπ_desc, cocones.precompose_obj_Œπ, nat_trans.comp_app, ‚Üê nat_iso.app_inv,
              iso.eq_inv_comp]
            simpa using w j } }
#align category_theory.limits.has_colimit_of_iso CategoryTheory.Limits.hasColimitOfIso
-/

#print CategoryTheory.Limits.HasColimit.ofCoconesIso /-
/-- If a functor `G` has the same collection of cocones as a functor `F`
which has a colimit, then `G` also has a colimit. -/
theorem HasColimit.ofCoconesIso {K : Type u‚ÇÅ} [Category.{v‚ÇÇ} K] (F : J ‚•§ C) (G : K ‚•§ C)
    (h : F.cocones ‚âÖ G.cocones) [HasColimit F] : HasColimit G :=
  HasColimit.mk ‚ü®_, IsColimit.ofNatIso (IsColimit.natIso (colimit.isColimit F) ‚â™‚â´ h)‚ü©
#align category_theory.limits.has_colimit.of_cocones_iso CategoryTheory.Limits.HasColimit.ofCoconesIso
-/

#print CategoryTheory.Limits.HasColimit.isoOfNatIso /-
/-- The colimits of `F : J ‚•§ C` and `G : J ‚•§ C` are isomorphic,
if the functors are naturally isomorphic.
-/
def HasColimit.isoOfNatIso {F G : J ‚•§ C} [HasColimit F] [HasColimit G] (w : F ‚âÖ G) :
    colimit F ‚âÖ colimit G :=
  IsColimit.coconePointsIsoOfNatIso (colimit.isColimit F) (colimit.isColimit G) w
#align category_theory.limits.has_colimit.iso_of_nat_iso CategoryTheory.Limits.HasColimit.isoOfNatIso
-/

/- warning: category_theory.limits.has_colimit.iso_of_nat_iso_Œπ_hom -> CategoryTheory.Limits.HasColimit.isoOfNatIso_Œπ_hom is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {C : Type.{u4}} [_inst_3 : CategoryTheory.Category.{u3, u4} C] {F : CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3} {G : CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3} [_inst_4 : CategoryTheory.Limits.HasColimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F] [_inst_5 : CategoryTheory.Limits.HasColimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 G] (w : CategoryTheory.Iso.{max u2 u3, max u1 u3 u2 u4} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3) F G) (j : J), Eq.{succ u3} (Quiver.Hom.{succ u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Functor.obj.{u1, u3, u2, u4} J _inst_1 C _inst_3 F j) (CategoryTheory.Limits.colimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 G _inst_5)) (CategoryTheory.CategoryStruct.comp.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3) (CategoryTheory.Functor.obj.{u1, u3, u2, u4} J _inst_1 C _inst_3 F j) (CategoryTheory.Limits.colimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4) (CategoryTheory.Limits.colimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 G _inst_5) (CategoryTheory.Limits.colimit.Œπ.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4 j) (CategoryTheory.Iso.hom.{u3, u4} C _inst_3 (CategoryTheory.Limits.colimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4) (CategoryTheory.Limits.colimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 G _inst_5) (CategoryTheory.Limits.HasColimit.isoOfNatIso.{u1, u2, u3, u4} J _inst_1 C _inst_3 F G _inst_4 _inst_5 w))) (CategoryTheory.CategoryStruct.comp.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3) (CategoryTheory.Functor.obj.{u1, u3, u2, u4} J _inst_1 C _inst_3 F j) (CategoryTheory.Functor.obj.{u1, u3, u2, u4} J _inst_1 C _inst_3 G j) (CategoryTheory.Limits.colimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 G _inst_5) (CategoryTheory.NatTrans.app.{u1, u3, u2, u4} J _inst_1 C _inst_3 F G (CategoryTheory.Iso.hom.{max u2 u3, max u1 u3 u2 u4} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3) F G w) j) (CategoryTheory.Limits.colimit.Œπ.{u1, u2, u3, u4} J _inst_1 C _inst_3 G _inst_5 j))
but is expected to have type
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {C : Type.{u4}} [_inst_3 : CategoryTheory.Category.{u3, u4} C] {F : CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3} {G : CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3} [_inst_4 : CategoryTheory.Limits.HasColimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F] [_inst_5 : CategoryTheory.Limits.HasColimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 G] (w : CategoryTheory.Iso.{max u2 u3, max (max (max u4 u2) u3) u1} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3) F G) (j : J), Eq.{succ u3} (Quiver.Hom.{succ u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (Prefunctor.obj.{succ u1, succ u3, u2, u4} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, u4} J _inst_1 C _inst_3 F) j) (CategoryTheory.Limits.colimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 G _inst_5)) (CategoryTheory.CategoryStruct.comp.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3) (Prefunctor.obj.{succ u1, succ u3, u2, u4} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, u4} J _inst_1 C _inst_3 F) j) (CategoryTheory.Limits.colimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4) (CategoryTheory.Limits.colimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 G _inst_5) (CategoryTheory.Limits.colimit.Œπ.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4 j) (CategoryTheory.Iso.hom.{u3, u4} C _inst_3 (CategoryTheory.Limits.colimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4) (CategoryTheory.Limits.colimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 G _inst_5) (CategoryTheory.Limits.HasColimit.isoOfNatIso.{u1, u2, u3, u4} J _inst_1 C _inst_3 F G _inst_4 _inst_5 w))) (CategoryTheory.CategoryStruct.comp.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3) (Prefunctor.obj.{succ u1, succ u3, u2, u4} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, u4} J _inst_1 C _inst_3 F) j) (Prefunctor.obj.{succ u1, succ u3, u2, u4} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, u4} J _inst_1 C _inst_3 G) j) (CategoryTheory.Limits.colimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 G _inst_5) (CategoryTheory.NatTrans.app.{u1, u3, u2, u4} J _inst_1 C _inst_3 F G (CategoryTheory.Iso.hom.{max u2 u3, max (max (max u4 u2) u3) u1} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3) F G w) j) (CategoryTheory.Limits.colimit.Œπ.{u1, u2, u3, u4} J _inst_1 C _inst_3 G _inst_5 j))
Case conversion may be inaccurate. Consider using '#align category_theory.limits.has_colimit.iso_of_nat_iso_Œπ_hom CategoryTheory.Limits.HasColimit.isoOfNatIso_Œπ_hom‚Çì'. -/
@[simp, reassoc.1]
theorem HasColimit.isoOfNatIso_Œπ_hom {F G : J ‚•§ C} [HasColimit F] [HasColimit G] (w : F ‚âÖ G)
    (j : J) : colimit.Œπ F j ‚â´ (HasColimit.isoOfNatIso w).Hom = w.Hom.app j ‚â´ colimit.Œπ G j :=
  IsColimit.comp_coconePointsIsoOfNatIso_hom _ _ _ _
#align category_theory.limits.has_colimit.iso_of_nat_iso_Œπ_hom CategoryTheory.Limits.HasColimit.isoOfNatIso_Œπ_hom

/- warning: category_theory.limits.has_colimit.iso_of_nat_iso_Œπ_inv -> CategoryTheory.Limits.HasColimit.isoOfNatIso_Œπ_inv is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {C : Type.{u4}} [_inst_3 : CategoryTheory.Category.{u3, u4} C] {F : CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3} {G : CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3} [_inst_4 : CategoryTheory.Limits.HasColimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F] [_inst_5 : CategoryTheory.Limits.HasColimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 G] (w : CategoryTheory.Iso.{max u2 u3, max u1 u3 u2 u4} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3) F G) (j : J), Eq.{succ u3} (Quiver.Hom.{succ u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Functor.obj.{u1, u3, u2, u4} J _inst_1 C _inst_3 G j) (CategoryTheory.Limits.colimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4)) (CategoryTheory.CategoryStruct.comp.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3) (CategoryTheory.Functor.obj.{u1, u3, u2, u4} J _inst_1 C _inst_3 G j) (CategoryTheory.Limits.colimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 G _inst_5) (CategoryTheory.Limits.colimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4) (CategoryTheory.Limits.colimit.Œπ.{u1, u2, u3, u4} J _inst_1 C _inst_3 G _inst_5 j) (CategoryTheory.Iso.inv.{u3, u4} C _inst_3 (CategoryTheory.Limits.colimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4) (CategoryTheory.Limits.colimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 G _inst_5) (CategoryTheory.Limits.HasColimit.isoOfNatIso.{u1, u2, u3, u4} J _inst_1 C _inst_3 F G _inst_4 _inst_5 w))) (CategoryTheory.CategoryStruct.comp.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3) (CategoryTheory.Functor.obj.{u1, u3, u2, u4} J _inst_1 C _inst_3 G j) (CategoryTheory.Functor.obj.{u1, u3, u2, u4} J _inst_1 C _inst_3 F j) (CategoryTheory.Limits.colimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4) (CategoryTheory.NatTrans.app.{u1, u3, u2, u4} J _inst_1 C _inst_3 G F (CategoryTheory.Iso.inv.{max u2 u3, max u1 u3 u2 u4} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3) F G w) j) (CategoryTheory.Limits.colimit.Œπ.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4 j))
but is expected to have type
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {C : Type.{u4}} [_inst_3 : CategoryTheory.Category.{u3, u4} C] {F : CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3} {G : CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3} [_inst_4 : CategoryTheory.Limits.HasColimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F] [_inst_5 : CategoryTheory.Limits.HasColimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 G] (w : CategoryTheory.Iso.{max u2 u3, max (max (max u4 u2) u3) u1} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3) F G) (j : J), Eq.{succ u3} (Quiver.Hom.{succ u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (Prefunctor.obj.{succ u1, succ u3, u2, u4} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, u4} J _inst_1 C _inst_3 G) j) (CategoryTheory.Limits.colimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4)) (CategoryTheory.CategoryStruct.comp.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3) (Prefunctor.obj.{succ u1, succ u3, u2, u4} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, u4} J _inst_1 C _inst_3 G) j) (CategoryTheory.Limits.colimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 G _inst_5) (CategoryTheory.Limits.colimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4) (CategoryTheory.Limits.colimit.Œπ.{u1, u2, u3, u4} J _inst_1 C _inst_3 G _inst_5 j) (CategoryTheory.Iso.inv.{u3, u4} C _inst_3 (CategoryTheory.Limits.colimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4) (CategoryTheory.Limits.colimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 G _inst_5) (CategoryTheory.Limits.HasColimit.isoOfNatIso.{u1, u2, u3, u4} J _inst_1 C _inst_3 F G _inst_4 _inst_5 w))) (CategoryTheory.CategoryStruct.comp.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3) (Prefunctor.obj.{succ u1, succ u3, u2, u4} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, u4} J _inst_1 C _inst_3 G) j) (Prefunctor.obj.{succ u1, succ u3, u2, u4} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, u4} J _inst_1 C _inst_3 F) j) (CategoryTheory.Limits.colimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4) (CategoryTheory.NatTrans.app.{u1, u3, u2, u4} J _inst_1 C _inst_3 G F (CategoryTheory.Iso.inv.{max u2 u3, max (max (max u4 u2) u3) u1} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3) F G w) j) (CategoryTheory.Limits.colimit.Œπ.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4 j))
Case conversion may be inaccurate. Consider using '#align category_theory.limits.has_colimit.iso_of_nat_iso_Œπ_inv CategoryTheory.Limits.HasColimit.isoOfNatIso_Œπ_inv‚Çì'. -/
@[simp, reassoc.1]
theorem HasColimit.isoOfNatIso_Œπ_inv {F G : J ‚•§ C} [HasColimit F] [HasColimit G] (w : F ‚âÖ G)
    (j : J) : colimit.Œπ G j ‚â´ (HasColimit.isoOfNatIso w).inv = w.inv.app j ‚â´ colimit.Œπ F j :=
  IsColimit.comp_coconePointsIsoOfNatIso_inv _ _ _ _
#align category_theory.limits.has_colimit.iso_of_nat_iso_Œπ_inv CategoryTheory.Limits.HasColimit.isoOfNatIso_Œπ_inv

/- warning: category_theory.limits.has_colimit.iso_of_nat_iso_hom_desc -> CategoryTheory.Limits.HasColimit.isoOfNatIso_hom_desc is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {C : Type.{u4}} [_inst_3 : CategoryTheory.Category.{u3, u4} C] {F : CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3} {G : CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3} [_inst_4 : CategoryTheory.Limits.HasColimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F] [_inst_5 : CategoryTheory.Limits.HasColimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 G] (t : CategoryTheory.Limits.Cocone.{u1, u3, u2, u4} J _inst_1 C _inst_3 G) (w : CategoryTheory.Iso.{max u2 u3, max u1 u3 u2 u4} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3) F G), Eq.{succ u3} (Quiver.Hom.{succ u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Limits.colimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4) (CategoryTheory.Limits.Cocone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 G t)) (CategoryTheory.CategoryStruct.comp.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3) (CategoryTheory.Limits.colimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4) (CategoryTheory.Limits.colimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 G _inst_5) (CategoryTheory.Limits.Cocone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 G t) (CategoryTheory.Iso.hom.{u3, u4} C _inst_3 (CategoryTheory.Limits.colimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4) (CategoryTheory.Limits.colimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 G _inst_5) (CategoryTheory.Limits.HasColimit.isoOfNatIso.{u1, u2, u3, u4} J _inst_1 C _inst_3 F G _inst_4 _inst_5 w)) (CategoryTheory.Limits.colimit.desc.{u1, u2, u3, u4} J _inst_1 C _inst_3 G _inst_5 t)) (CategoryTheory.Limits.colimit.desc.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4 (CategoryTheory.Functor.obj.{u3, u3, max u2 u4 u3, max u2 u4 u3} (CategoryTheory.Limits.Cocone.{u1, u3, u2, u4} J _inst_1 C _inst_3 G) (CategoryTheory.Limits.Cocone.category.{u1, u3, u2, u4} J _inst_1 C _inst_3 G) (CategoryTheory.Limits.Cocone.{u1, u3, u2, u4} J _inst_1 C _inst_3 F) (CategoryTheory.Limits.Cocone.category.{u1, u3, u2, u4} J _inst_1 C _inst_3 F) (CategoryTheory.Limits.Cocones.precompose.{u1, u3, u2, u4} J _inst_1 C _inst_3 G F (CategoryTheory.Iso.hom.{max u2 u3, max u1 u3 u2 u4} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3) F G w)) t))
but is expected to have type
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {C : Type.{u4}} [_inst_3 : CategoryTheory.Category.{u3, u4} C] {F : CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3} {G : CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3} [_inst_4 : CategoryTheory.Limits.HasColimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F] [_inst_5 : CategoryTheory.Limits.HasColimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 G] (t : CategoryTheory.Limits.Cocone.{u1, u3, u2, u4} J _inst_1 C _inst_3 G) (w : CategoryTheory.Iso.{max u2 u3, max (max (max u4 u2) u3) u1} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3) F G), Eq.{succ u3} (Quiver.Hom.{succ u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Limits.colimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4) (CategoryTheory.Limits.Cocone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 G t)) (CategoryTheory.CategoryStruct.comp.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3) (CategoryTheory.Limits.colimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4) (CategoryTheory.Limits.colimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 G _inst_5) (CategoryTheory.Limits.Cocone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 G t) (CategoryTheory.Iso.hom.{u3, u4} C _inst_3 (CategoryTheory.Limits.colimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4) (CategoryTheory.Limits.colimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 G _inst_5) (CategoryTheory.Limits.HasColimit.isoOfNatIso.{u1, u2, u3, u4} J _inst_1 C _inst_3 F G _inst_4 _inst_5 w)) (CategoryTheory.Limits.colimit.desc.{u1, u2, u3, u4} J _inst_1 C _inst_3 G _inst_5 t)) (CategoryTheory.Limits.colimit.desc.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4 (Prefunctor.obj.{succ u3, succ u3, max (max u4 u2) u3, max (max u4 u2) u3} (CategoryTheory.Limits.Cocone.{u1, u3, u2, u4} J _inst_1 C _inst_3 G) (CategoryTheory.CategoryStruct.toQuiver.{u3, max (max u4 u2) u3} (CategoryTheory.Limits.Cocone.{u1, u3, u2, u4} J _inst_1 C _inst_3 G) (CategoryTheory.Category.toCategoryStruct.{u3, max (max u4 u2) u3} (CategoryTheory.Limits.Cocone.{u1, u3, u2, u4} J _inst_1 C _inst_3 G) (CategoryTheory.Limits.Cocone.category.{u1, u3, u2, u4} J _inst_1 C _inst_3 G))) (CategoryTheory.Limits.Cocone.{u1, u3, u2, u4} J _inst_1 C _inst_3 F) (CategoryTheory.CategoryStruct.toQuiver.{u3, max (max u4 u2) u3} (CategoryTheory.Limits.Cocone.{u1, u3, u2, u4} J _inst_1 C _inst_3 F) (CategoryTheory.Category.toCategoryStruct.{u3, max (max u4 u2) u3} (CategoryTheory.Limits.Cocone.{u1, u3, u2, u4} J _inst_1 C _inst_3 F) (CategoryTheory.Limits.Cocone.category.{u1, u3, u2, u4} J _inst_1 C _inst_3 F))) (CategoryTheory.Functor.toPrefunctor.{u3, u3, max (max u4 u2) u3, max (max u4 u2) u3} (CategoryTheory.Limits.Cocone.{u1, u3, u2, u4} J _inst_1 C _inst_3 G) (CategoryTheory.Limits.Cocone.category.{u1, u3, u2, u4} J _inst_1 C _inst_3 G) (CategoryTheory.Limits.Cocone.{u1, u3, u2, u4} J _inst_1 C _inst_3 F) (CategoryTheory.Limits.Cocone.category.{u1, u3, u2, u4} J _inst_1 C _inst_3 F) (CategoryTheory.Limits.Cocones.precompose.{u1, u3, u2, u4} J _inst_1 C _inst_3 G F (CategoryTheory.Iso.hom.{max u2 u3, max (max (max u4 u2) u3) u1} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3) F G w))) t))
Case conversion may be inaccurate. Consider using '#align category_theory.limits.has_colimit.iso_of_nat_iso_hom_desc CategoryTheory.Limits.HasColimit.isoOfNatIso_hom_desc‚Çì'. -/
@[simp, reassoc.1]
theorem HasColimit.isoOfNatIso_hom_desc {F G : J ‚•§ C} [HasColimit F] [HasColimit G] (t : Cocone G)
    (w : F ‚âÖ G) :
    (HasColimit.isoOfNatIso w).Hom ‚â´ colimit.desc G t =
      colimit.desc F ((Cocones.precompose w.Hom).obj _) :=
  IsColimit.coconePointsIsoOfNatIso_hom_desc _ _ _
#align category_theory.limits.has_colimit.iso_of_nat_iso_hom_desc CategoryTheory.Limits.HasColimit.isoOfNatIso_hom_desc

/- warning: category_theory.limits.has_colimit.iso_of_nat_iso_inv_desc -> CategoryTheory.Limits.HasColimit.isoOfNatIso_inv_desc is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {C : Type.{u4}} [_inst_3 : CategoryTheory.Category.{u3, u4} C] {F : CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3} {G : CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3} [_inst_4 : CategoryTheory.Limits.HasColimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F] [_inst_5 : CategoryTheory.Limits.HasColimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 G] (t : CategoryTheory.Limits.Cocone.{u1, u3, u2, u4} J _inst_1 C _inst_3 F) (w : CategoryTheory.Iso.{max u2 u3, max u1 u3 u2 u4} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3) F G), Eq.{succ u3} (Quiver.Hom.{succ u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Limits.colimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 G _inst_5) (CategoryTheory.Limits.Cocone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 F t)) (CategoryTheory.CategoryStruct.comp.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3) (CategoryTheory.Limits.colimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 G _inst_5) (CategoryTheory.Limits.colimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4) (CategoryTheory.Limits.Cocone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 F t) (CategoryTheory.Iso.inv.{u3, u4} C _inst_3 (CategoryTheory.Limits.colimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4) (CategoryTheory.Limits.colimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 G _inst_5) (CategoryTheory.Limits.HasColimit.isoOfNatIso.{u1, u2, u3, u4} J _inst_1 C _inst_3 F G _inst_4 _inst_5 w)) (CategoryTheory.Limits.colimit.desc.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4 t)) (CategoryTheory.Limits.colimit.desc.{u1, u2, u3, u4} J _inst_1 C _inst_3 G _inst_5 (CategoryTheory.Functor.obj.{u3, u3, max u2 u4 u3, max u2 u4 u3} (CategoryTheory.Limits.Cocone.{u1, u3, u2, u4} J _inst_1 C _inst_3 F) (CategoryTheory.Limits.Cocone.category.{u1, u3, u2, u4} J _inst_1 C _inst_3 F) (CategoryTheory.Limits.Cocone.{u1, u3, u2, u4} J _inst_1 C _inst_3 G) (CategoryTheory.Limits.Cocone.category.{u1, u3, u2, u4} J _inst_1 C _inst_3 G) (CategoryTheory.Limits.Cocones.precompose.{u1, u3, u2, u4} J _inst_1 C _inst_3 F G (CategoryTheory.Iso.inv.{max u2 u3, max u1 u3 u2 u4} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3) F G w)) t))
but is expected to have type
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {C : Type.{u4}} [_inst_3 : CategoryTheory.Category.{u3, u4} C] {F : CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3} {G : CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3} [_inst_4 : CategoryTheory.Limits.HasColimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F] [_inst_5 : CategoryTheory.Limits.HasColimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 G] (t : CategoryTheory.Limits.Cocone.{u1, u3, u2, u4} J _inst_1 C _inst_3 F) (w : CategoryTheory.Iso.{max u2 u3, max (max (max u4 u2) u3) u1} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3) F G), Eq.{succ u3} (Quiver.Hom.{succ u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Limits.colimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 G _inst_5) (CategoryTheory.Limits.Cocone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 F t)) (CategoryTheory.CategoryStruct.comp.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3) (CategoryTheory.Limits.colimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 G _inst_5) (CategoryTheory.Limits.colimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4) (CategoryTheory.Limits.Cocone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 F t) (CategoryTheory.Iso.inv.{u3, u4} C _inst_3 (CategoryTheory.Limits.colimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4) (CategoryTheory.Limits.colimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 G _inst_5) (CategoryTheory.Limits.HasColimit.isoOfNatIso.{u1, u2, u3, u4} J _inst_1 C _inst_3 F G _inst_4 _inst_5 w)) (CategoryTheory.Limits.colimit.desc.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4 t)) (CategoryTheory.Limits.colimit.desc.{u1, u2, u3, u4} J _inst_1 C _inst_3 G _inst_5 (Prefunctor.obj.{succ u3, succ u3, max (max u4 u2) u3, max (max u4 u2) u3} (CategoryTheory.Limits.Cocone.{u1, u3, u2, u4} J _inst_1 C _inst_3 F) (CategoryTheory.CategoryStruct.toQuiver.{u3, max (max u4 u2) u3} (CategoryTheory.Limits.Cocone.{u1, u3, u2, u4} J _inst_1 C _inst_3 F) (CategoryTheory.Category.toCategoryStruct.{u3, max (max u4 u2) u3} (CategoryTheory.Limits.Cocone.{u1, u3, u2, u4} J _inst_1 C _inst_3 F) (CategoryTheory.Limits.Cocone.category.{u1, u3, u2, u4} J _inst_1 C _inst_3 F))) (CategoryTheory.Limits.Cocone.{u1, u3, u2, u4} J _inst_1 C _inst_3 G) (CategoryTheory.CategoryStruct.toQuiver.{u3, max (max u4 u2) u3} (CategoryTheory.Limits.Cocone.{u1, u3, u2, u4} J _inst_1 C _inst_3 G) (CategoryTheory.Category.toCategoryStruct.{u3, max (max u4 u2) u3} (CategoryTheory.Limits.Cocone.{u1, u3, u2, u4} J _inst_1 C _inst_3 G) (CategoryTheory.Limits.Cocone.category.{u1, u3, u2, u4} J _inst_1 C _inst_3 G))) (CategoryTheory.Functor.toPrefunctor.{u3, u3, max (max u4 u2) u3, max (max u4 u2) u3} (CategoryTheory.Limits.Cocone.{u1, u3, u2, u4} J _inst_1 C _inst_3 F) (CategoryTheory.Limits.Cocone.category.{u1, u3, u2, u4} J _inst_1 C _inst_3 F) (CategoryTheory.Limits.Cocone.{u1, u3, u2, u4} J _inst_1 C _inst_3 G) (CategoryTheory.Limits.Cocone.category.{u1, u3, u2, u4} J _inst_1 C _inst_3 G) (CategoryTheory.Limits.Cocones.precompose.{u1, u3, u2, u4} J _inst_1 C _inst_3 F G (CategoryTheory.Iso.inv.{max u2 u3, max (max (max u4 u2) u3) u1} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3) F G w))) t))
Case conversion may be inaccurate. Consider using '#align category_theory.limits.has_colimit.iso_of_nat_iso_inv_desc CategoryTheory.Limits.HasColimit.isoOfNatIso_inv_desc‚Çì'. -/
@[simp, reassoc.1]
theorem HasColimit.isoOfNatIso_inv_desc {F G : J ‚•§ C} [HasColimit F] [HasColimit G] (t : Cocone F)
    (w : F ‚âÖ G) :
    (HasColimit.isoOfNatIso w).inv ‚â´ colimit.desc F t =
      colimit.desc G ((Cocones.precompose w.inv).obj _) :=
  IsColimit.coconePointsIsoOfNatIso_inv_desc _ _ _
#align category_theory.limits.has_colimit.iso_of_nat_iso_inv_desc CategoryTheory.Limits.HasColimit.isoOfNatIso_inv_desc

/- warning: category_theory.limits.has_colimit.iso_of_equivalence -> CategoryTheory.Limits.HasColimit.isoOfEquivalence is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {K : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u3, u4} K] {C : Type.{u6}} [_inst_3 : CategoryTheory.Category.{u5, u6} C] {F : CategoryTheory.Functor.{u1, u5, u2, u6} J _inst_1 C _inst_3} [_inst_4 : CategoryTheory.Limits.HasColimit.{u1, u2, u5, u6} J _inst_1 C _inst_3 F] {G : CategoryTheory.Functor.{u3, u5, u4, u6} K _inst_2 C _inst_3} [_inst_5 : CategoryTheory.Limits.HasColimit.{u3, u4, u5, u6} K _inst_2 C _inst_3 G] (e : CategoryTheory.Equivalence.{u1, u3, u2, u4} J _inst_1 K _inst_2), (CategoryTheory.Iso.{max u2 u5, max u1 u5 u2 u6} (CategoryTheory.Functor.{u1, u5, u2, u6} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u5, u2, u6} J _inst_1 C _inst_3) (CategoryTheory.Functor.comp.{u1, u3, u5, u2, u4, u6} J _inst_1 K _inst_2 C _inst_3 (CategoryTheory.Equivalence.functor.{u1, u3, u2, u4} J _inst_1 K _inst_2 e) G) F) -> (CategoryTheory.Iso.{u5, u6} C _inst_3 (CategoryTheory.Limits.colimit.{u1, u2, u5, u6} J _inst_1 C _inst_3 F _inst_4) (CategoryTheory.Limits.colimit.{u3, u4, u5, u6} K _inst_2 C _inst_3 G _inst_5))
but is expected to have type
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {K : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u3, u4} K] {C : Type.{u6}} [_inst_3 : CategoryTheory.Category.{u5, u6} C] {F : CategoryTheory.Functor.{u1, u5, u2, u6} J _inst_1 C _inst_3} [_inst_4 : CategoryTheory.Limits.HasColimit.{u1, u2, u5, u6} J _inst_1 C _inst_3 F] {G : CategoryTheory.Functor.{u3, u5, u4, u6} K _inst_2 C _inst_3} [_inst_5 : CategoryTheory.Limits.HasColimit.{u3, u4, u5, u6} K _inst_2 C _inst_3 G] (e : CategoryTheory.Equivalence.{u1, u3, u2, u4} J K _inst_1 _inst_2), (CategoryTheory.Iso.{max u2 u5, max (max (max u6 u2) u5) u1} (CategoryTheory.Functor.{u1, u5, u2, u6} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u5, u2, u6} J _inst_1 C _inst_3) (CategoryTheory.Functor.comp.{u1, u3, u5, u2, u4, u6} J _inst_1 K _inst_2 C _inst_3 (CategoryTheory.Equivalence.functor.{u1, u3, u2, u4} J K _inst_1 _inst_2 e) G) F) -> (CategoryTheory.Iso.{u5, u6} C _inst_3 (CategoryTheory.Limits.colimit.{u1, u2, u5, u6} J _inst_1 C _inst_3 F _inst_4) (CategoryTheory.Limits.colimit.{u3, u4, u5, u6} K _inst_2 C _inst_3 G _inst_5))
Case conversion may be inaccurate. Consider using '#align category_theory.limits.has_colimit.iso_of_equivalence CategoryTheory.Limits.HasColimit.isoOfEquivalence‚Çì'. -/
/-- The colimits of `F : J ‚•§ C` and `G : K ‚•§ C` are isomorphic,
if there is an equivalence `e : J ‚âå K` making the triangle commute up to natural isomorphism.
-/
def HasColimit.isoOfEquivalence {F : J ‚•§ C} [HasColimit F] {G : K ‚•§ C} [HasColimit G] (e : J ‚âå K)
    (w : e.Functor ‚ãô G ‚âÖ F) : colimit F ‚âÖ colimit G :=
  IsColimit.coconePointsIsoOfEquivalence (colimit.isColimit F) (colimit.isColimit G) e w
#align category_theory.limits.has_colimit.iso_of_equivalence CategoryTheory.Limits.HasColimit.isoOfEquivalence

/- warning: category_theory.limits.has_colimit.iso_of_equivalence_hom_œÄ -> CategoryTheory.Limits.HasColimit.isoOfEquivalence_hom_œÄ is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {K : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u3, u4} K] {C : Type.{u6}} [_inst_3 : CategoryTheory.Category.{u5, u6} C] {F : CategoryTheory.Functor.{u1, u5, u2, u6} J _inst_1 C _inst_3} [_inst_4 : CategoryTheory.Limits.HasColimit.{u1, u2, u5, u6} J _inst_1 C _inst_3 F] {G : CategoryTheory.Functor.{u3, u5, u4, u6} K _inst_2 C _inst_3} [_inst_5 : CategoryTheory.Limits.HasColimit.{u3, u4, u5, u6} K _inst_2 C _inst_3 G] (e : CategoryTheory.Equivalence.{u1, u3, u2, u4} J _inst_1 K _inst_2) (w : CategoryTheory.Iso.{max u2 u5, max u1 u5 u2 u6} (CategoryTheory.Functor.{u1, u5, u2, u6} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u5, u2, u6} J _inst_1 C _inst_3) (CategoryTheory.Functor.comp.{u1, u3, u5, u2, u4, u6} J _inst_1 K _inst_2 C _inst_3 (CategoryTheory.Equivalence.functor.{u1, u3, u2, u4} J _inst_1 K _inst_2 e) G) F) (j : J), Eq.{succ u5} (Quiver.Hom.{succ u5, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u5, u6} C (CategoryTheory.Category.toCategoryStruct.{u5, u6} C _inst_3)) (CategoryTheory.Functor.obj.{u1, u5, u2, u6} J _inst_1 C _inst_3 F j) (CategoryTheory.Limits.colimit.{u3, u4, u5, u6} K _inst_2 C _inst_3 G _inst_5)) (CategoryTheory.CategoryStruct.comp.{u5, u6} C (CategoryTheory.Category.toCategoryStruct.{u5, u6} C _inst_3) (CategoryTheory.Functor.obj.{u1, u5, u2, u6} J _inst_1 C _inst_3 F j) (CategoryTheory.Limits.colimit.{u1, u2, u5, u6} J _inst_1 C _inst_3 F _inst_4) (CategoryTheory.Limits.colimit.{u3, u4, u5, u6} K _inst_2 C _inst_3 G _inst_5) (CategoryTheory.Limits.colimit.Œπ.{u1, u2, u5, u6} J _inst_1 C _inst_3 F _inst_4 j) (CategoryTheory.Iso.hom.{u5, u6} C _inst_3 (CategoryTheory.Limits.colimit.{u1, u2, u5, u6} J _inst_1 C _inst_3 F _inst_4) (CategoryTheory.Limits.colimit.{u3, u4, u5, u6} K _inst_2 C _inst_3 G _inst_5) (CategoryTheory.Limits.HasColimit.isoOfEquivalence.{u1, u2, u3, u4, u5, u6} J _inst_1 K _inst_2 C _inst_3 F _inst_4 G _inst_5 e w))) (CategoryTheory.CategoryStruct.comp.{u5, u6} C (CategoryTheory.Category.toCategoryStruct.{u5, u6} C _inst_3) (CategoryTheory.Functor.obj.{u1, u5, u2, u6} J _inst_1 C _inst_3 F j) (CategoryTheory.Functor.obj.{u1, u5, u2, u6} J _inst_1 C _inst_3 F (CategoryTheory.Functor.obj.{u1, u1, u2, u2} J _inst_1 J _inst_1 (CategoryTheory.Functor.comp.{u1, u3, u1, u2, u4, u2} J _inst_1 K _inst_2 J _inst_1 (CategoryTheory.Equivalence.functor.{u1, u3, u2, u4} J _inst_1 K _inst_2 e) (CategoryTheory.Equivalence.inverse.{u1, u3, u2, u4} J _inst_1 K _inst_2 e)) j)) (CategoryTheory.Limits.colimit.{u3, u4, u5, u6} K _inst_2 C _inst_3 G _inst_5) (CategoryTheory.Functor.map.{u1, u5, u2, u6} J _inst_1 C _inst_3 F j (CategoryTheory.Functor.obj.{u1, u1, u2, u2} J _inst_1 J _inst_1 (CategoryTheory.Functor.comp.{u1, u3, u1, u2, u4, u2} J _inst_1 K _inst_2 J _inst_1 (CategoryTheory.Equivalence.functor.{u1, u3, u2, u4} J _inst_1 K _inst_2 e) (CategoryTheory.Equivalence.inverse.{u1, u3, u2, u4} J _inst_1 K _inst_2 e)) j) (CategoryTheory.NatTrans.app.{u1, u1, u2, u2} J _inst_1 J _inst_1 (CategoryTheory.Functor.id.{u1, u2} J _inst_1) (CategoryTheory.Functor.comp.{u1, u3, u1, u2, u4, u2} J _inst_1 K _inst_2 J _inst_1 (CategoryTheory.Equivalence.functor.{u1, u3, u2, u4} J _inst_1 K _inst_2 e) (CategoryTheory.Equivalence.inverse.{u1, u3, u2, u4} J _inst_1 K _inst_2 e)) (CategoryTheory.Equivalence.unit.{u1, u3, u2, u4} J _inst_1 K _inst_2 e) j)) (CategoryTheory.CategoryStruct.comp.{u5, u6} C (CategoryTheory.Category.toCategoryStruct.{u5, u6} C _inst_3) (CategoryTheory.Functor.obj.{u1, u5, u2, u6} J _inst_1 C _inst_3 F (CategoryTheory.Functor.obj.{u1, u1, u2, u2} J _inst_1 J _inst_1 (CategoryTheory.Functor.comp.{u1, u3, u1, u2, u4, u2} J _inst_1 K _inst_2 J _inst_1 (CategoryTheory.Equivalence.functor.{u1, u3, u2, u4} J _inst_1 K _inst_2 e) (CategoryTheory.Equivalence.inverse.{u1, u3, u2, u4} J _inst_1 K _inst_2 e)) j)) (CategoryTheory.Functor.obj.{u1, u5, u2, u6} J _inst_1 C _inst_3 (CategoryTheory.Functor.comp.{u1, u3, u5, u2, u4, u6} J _inst_1 K _inst_2 C _inst_3 (CategoryTheory.Equivalence.functor.{u1, u3, u2, u4} J _inst_1 K _inst_2 e) G) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} J _inst_1 J _inst_1 (CategoryTheory.Functor.comp.{u1, u3, u1, u2, u4, u2} J _inst_1 K _inst_2 J _inst_1 (CategoryTheory.Equivalence.functor.{u1, u3, u2, u4} J _inst_1 K _inst_2 e) (CategoryTheory.Equivalence.inverse.{u1, u3, u2, u4} J _inst_1 K _inst_2 e)) j)) (CategoryTheory.Limits.colimit.{u3, u4, u5, u6} K _inst_2 C _inst_3 G _inst_5) (CategoryTheory.NatTrans.app.{u1, u5, u2, u6} J _inst_1 C _inst_3 F (CategoryTheory.Functor.comp.{u1, u3, u5, u2, u4, u6} J _inst_1 K _inst_2 C _inst_3 (CategoryTheory.Equivalence.functor.{u1, u3, u2, u4} J _inst_1 K _inst_2 e) G) (CategoryTheory.Iso.inv.{max u2 u5, max u1 u5 u2 u6} (CategoryTheory.Functor.{u1, u5, u2, u6} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u5, u2, u6} J _inst_1 C _inst_3) (CategoryTheory.Functor.comp.{u1, u3, u5, u2, u4, u6} J _inst_1 K _inst_2 C _inst_3 (CategoryTheory.Equivalence.functor.{u1, u3, u2, u4} J _inst_1 K _inst_2 e) G) F w) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} J _inst_1 J _inst_1 (CategoryTheory.Functor.comp.{u1, u3, u1, u2, u4, u2} J _inst_1 K _inst_2 J _inst_1 (CategoryTheory.Equivalence.functor.{u1, u3, u2, u4} J _inst_1 K _inst_2 e) (CategoryTheory.Equivalence.inverse.{u1, u3, u2, u4} J _inst_1 K _inst_2 e)) j)) (CategoryTheory.Limits.colimit.Œπ.{u3, u4, u5, u6} K _inst_2 C _inst_3 G _inst_5 (CategoryTheory.Functor.obj.{u1, u3, u2, u4} J _inst_1 K _inst_2 (CategoryTheory.Equivalence.functor.{u1, u3, u2, u4} J _inst_1 K _inst_2 e) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} J _inst_1 J _inst_1 (CategoryTheory.Functor.comp.{u1, u3, u1, u2, u4, u2} J _inst_1 K _inst_2 J _inst_1 (CategoryTheory.Equivalence.functor.{u1, u3, u2, u4} J _inst_1 K _inst_2 e) (CategoryTheory.Equivalence.inverse.{u1, u3, u2, u4} J _inst_1 K _inst_2 e)) j)))))
but is expected to have type
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {K : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u3, u4} K] {C : Type.{u6}} [_inst_3 : CategoryTheory.Category.{u5, u6} C] {F : CategoryTheory.Functor.{u1, u5, u2, u6} J _inst_1 C _inst_3} [_inst_4 : CategoryTheory.Limits.HasColimit.{u1, u2, u5, u6} J _inst_1 C _inst_3 F] {G : CategoryTheory.Functor.{u3, u5, u4, u6} K _inst_2 C _inst_3} [_inst_5 : CategoryTheory.Limits.HasColimit.{u3, u4, u5, u6} K _inst_2 C _inst_3 G] (e : CategoryTheory.Equivalence.{u1, u3, u2, u4} J K _inst_1 _inst_2) (w : CategoryTheory.Iso.{max u2 u5, max (max (max u6 u2) u5) u1} (CategoryTheory.Functor.{u1, u5, u2, u6} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u5, u2, u6} J _inst_1 C _inst_3) (CategoryTheory.Functor.comp.{u1, u3, u5, u2, u4, u6} J _inst_1 K _inst_2 C _inst_3 (CategoryTheory.Equivalence.functor.{u1, u3, u2, u4} J K _inst_1 _inst_2 e) G) F) (j : J), Eq.{succ u5} (Quiver.Hom.{succ u5, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u5, u6} C (CategoryTheory.Category.toCategoryStruct.{u5, u6} C _inst_3)) (Prefunctor.obj.{succ u1, succ u5, u2, u6} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u5, u6} C (CategoryTheory.Category.toCategoryStruct.{u5, u6} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u5, u2, u6} J _inst_1 C _inst_3 F) j) (CategoryTheory.Limits.colimit.{u3, u4, u5, u6} K _inst_2 C _inst_3 G _inst_5)) (CategoryTheory.CategoryStruct.comp.{u5, u6} C (CategoryTheory.Category.toCategoryStruct.{u5, u6} C _inst_3) (Prefunctor.obj.{succ u1, succ u5, u2, u6} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u5, u6} C (CategoryTheory.Category.toCategoryStruct.{u5, u6} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u5, u2, u6} J _inst_1 C _inst_3 F) j) (CategoryTheory.Limits.colimit.{u1, u2, u5, u6} J _inst_1 C _inst_3 F _inst_4) (CategoryTheory.Limits.colimit.{u3, u4, u5, u6} K _inst_2 C _inst_3 G _inst_5) (CategoryTheory.Limits.colimit.Œπ.{u1, u2, u5, u6} J _inst_1 C _inst_3 F _inst_4 j) (CategoryTheory.Iso.hom.{u5, u6} C _inst_3 (CategoryTheory.Limits.colimit.{u1, u2, u5, u6} J _inst_1 C _inst_3 F _inst_4) (CategoryTheory.Limits.colimit.{u3, u4, u5, u6} K _inst_2 C _inst_3 G _inst_5) (CategoryTheory.Limits.HasColimit.isoOfEquivalence.{u1, u2, u3, u4, u5, u6} J _inst_1 K _inst_2 C _inst_3 F _inst_4 G _inst_5 e w))) (CategoryTheory.CategoryStruct.comp.{u5, u6} C (CategoryTheory.Category.toCategoryStruct.{u5, u6} C _inst_3) (Prefunctor.obj.{succ u1, succ u5, u2, u6} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u5, u6} C (CategoryTheory.Category.toCategoryStruct.{u5, u6} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u5, u2, u6} J _inst_1 C _inst_3 F) (Prefunctor.obj.{succ u1, succ u1, u2, u2} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} J _inst_1 J _inst_1 (CategoryTheory.Functor.id.{u1, u2} J _inst_1)) j)) (Prefunctor.obj.{succ u1, succ u5, u2, u6} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u5, u6} C (CategoryTheory.Category.toCategoryStruct.{u5, u6} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u5, u2, u6} J _inst_1 C _inst_3 F) (Prefunctor.obj.{succ u1, succ u1, u2, u2} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} J _inst_1 J _inst_1 (CategoryTheory.Functor.comp.{u1, u3, u1, u2, u4, u2} J _inst_1 K _inst_2 J _inst_1 (CategoryTheory.Equivalence.functor.{u1, u3, u2, u4} J K _inst_1 _inst_2 e) (CategoryTheory.Equivalence.inverse.{u1, u3, u2, u4} J K _inst_1 _inst_2 e))) j)) (CategoryTheory.Limits.colimit.{u3, u4, u5, u6} K _inst_2 C _inst_3 G _inst_5) (Prefunctor.map.{succ u1, succ u5, u2, u6} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u5, u6} C (CategoryTheory.Category.toCategoryStruct.{u5, u6} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u5, u2, u6} J _inst_1 C _inst_3 F) (Prefunctor.obj.{succ u1, succ u1, u2, u2} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} J _inst_1 J _inst_1 (CategoryTheory.Functor.id.{u1, u2} J _inst_1)) j) (Prefunctor.obj.{succ u1, succ u1, u2, u2} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} J _inst_1 J _inst_1 (CategoryTheory.Functor.comp.{u1, u3, u1, u2, u4, u2} J _inst_1 K _inst_2 J _inst_1 (CategoryTheory.Equivalence.functor.{u1, u3, u2, u4} J K _inst_1 _inst_2 e) (CategoryTheory.Equivalence.inverse.{u1, u3, u2, u4} J K _inst_1 _inst_2 e))) j) (CategoryTheory.NatTrans.app.{u1, u1, u2, u2} J _inst_1 J _inst_1 (CategoryTheory.Functor.id.{u1, u2} J _inst_1) (CategoryTheory.Functor.comp.{u1, u3, u1, u2, u4, u2} J _inst_1 K _inst_2 J _inst_1 (CategoryTheory.Equivalence.functor.{u1, u3, u2, u4} J K _inst_1 _inst_2 e) (CategoryTheory.Equivalence.inverse.{u1, u3, u2, u4} J K _inst_1 _inst_2 e)) (CategoryTheory.Equivalence.unit.{u1, u3, u2, u4} J _inst_1 K _inst_2 e) j)) (CategoryTheory.CategoryStruct.comp.{u5, u6} C (CategoryTheory.Category.toCategoryStruct.{u5, u6} C _inst_3) (Prefunctor.obj.{succ u1, succ u5, u2, u6} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u5, u6} C (CategoryTheory.Category.toCategoryStruct.{u5, u6} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u5, u2, u6} J _inst_1 C _inst_3 F) (Prefunctor.obj.{succ u1, succ u1, u2, u2} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} J _inst_1 J _inst_1 (CategoryTheory.Functor.comp.{u1, u3, u1, u2, u4, u2} J _inst_1 K _inst_2 J _inst_1 (CategoryTheory.Equivalence.functor.{u1, u3, u2, u4} J K _inst_1 _inst_2 e) (CategoryTheory.Equivalence.inverse.{u1, u3, u2, u4} J K _inst_1 _inst_2 e))) j)) (Prefunctor.obj.{succ u1, succ u5, u2, u6} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u5, u6} C (CategoryTheory.Category.toCategoryStruct.{u5, u6} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u5, u2, u6} J _inst_1 C _inst_3 (CategoryTheory.Functor.comp.{u1, u3, u5, u2, u4, u6} J _inst_1 K _inst_2 C _inst_3 (CategoryTheory.Equivalence.functor.{u1, u3, u2, u4} J K _inst_1 _inst_2 e) G)) (Prefunctor.obj.{succ u1, succ u1, u2, u2} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} J _inst_1 J _inst_1 (CategoryTheory.Functor.comp.{u1, u3, u1, u2, u4, u2} J _inst_1 K _inst_2 J _inst_1 (CategoryTheory.Equivalence.functor.{u1, u3, u2, u4} J K _inst_1 _inst_2 e) (CategoryTheory.Equivalence.inverse.{u1, u3, u2, u4} J K _inst_1 _inst_2 e))) j)) (CategoryTheory.Limits.colimit.{u3, u4, u5, u6} K _inst_2 C _inst_3 G _inst_5) (CategoryTheory.NatTrans.app.{u1, u5, u2, u6} J _inst_1 C _inst_3 F (CategoryTheory.Functor.comp.{u1, u3, u5, u2, u4, u6} J _inst_1 K _inst_2 C _inst_3 (CategoryTheory.Equivalence.functor.{u1, u3, u2, u4} J K _inst_1 _inst_2 e) G) (CategoryTheory.Iso.inv.{max u2 u5, max (max (max u6 u2) u5) u1} (CategoryTheory.Functor.{u1, u5, u2, u6} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u5, u2, u6} J _inst_1 C _inst_3) (CategoryTheory.Functor.comp.{u1, u3, u5, u2, u4, u6} J _inst_1 K _inst_2 C _inst_3 (CategoryTheory.Equivalence.functor.{u1, u3, u2, u4} J K _inst_1 _inst_2 e) G) F w) (Prefunctor.obj.{succ u1, succ u1, u2, u2} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} J _inst_1 J _inst_1 (CategoryTheory.Functor.comp.{u1, u3, u1, u2, u4, u2} J _inst_1 K _inst_2 J _inst_1 (CategoryTheory.Equivalence.functor.{u1, u3, u2, u4} J K _inst_1 _inst_2 e) (CategoryTheory.Equivalence.inverse.{u1, u3, u2, u4} J K _inst_1 _inst_2 e))) j)) (CategoryTheory.Limits.colimit.Œπ.{u3, u4, u5, u6} K _inst_2 C _inst_3 G _inst_5 (Prefunctor.obj.{succ u1, succ u3, u2, u4} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) K (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} K (CategoryTheory.Category.toCategoryStruct.{u3, u4} K _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, u4} J _inst_1 K _inst_2 (CategoryTheory.Equivalence.functor.{u1, u3, u2, u4} J K _inst_1 _inst_2 e)) (Prefunctor.obj.{succ u1, succ u1, u2, u2} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} J _inst_1 J _inst_1 (CategoryTheory.Functor.comp.{u1, u3, u1, u2, u4, u2} J _inst_1 K _inst_2 J _inst_1 (CategoryTheory.Equivalence.functor.{u1, u3, u2, u4} J K _inst_1 _inst_2 e) (CategoryTheory.Equivalence.inverse.{u1, u3, u2, u4} J K _inst_1 _inst_2 e))) j)))))
Case conversion may be inaccurate. Consider using '#align category_theory.limits.has_colimit.iso_of_equivalence_hom_œÄ CategoryTheory.Limits.HasColimit.isoOfEquivalence_hom_œÄ‚Çì'. -/
@[simp]
theorem HasColimit.isoOfEquivalence_hom_œÄ {F : J ‚•§ C} [HasColimit F] {G : K ‚•§ C} [HasColimit G]
    (e : J ‚âå K) (w : e.Functor ‚ãô G ‚âÖ F) (j : J) :
    colimit.Œπ F j ‚â´ (HasColimit.isoOfEquivalence e w).Hom =
      F.map (e.Unit.app j) ‚â´ w.inv.app _ ‚â´ colimit.Œπ G _ :=
  by
  simp [has_colimit.iso_of_equivalence, is_colimit.cocone_points_iso_of_equivalence_inv]
  dsimp
  simp
#align category_theory.limits.has_colimit.iso_of_equivalence_hom_œÄ CategoryTheory.Limits.HasColimit.isoOfEquivalence_hom_œÄ

/- warning: category_theory.limits.has_colimit.iso_of_equivalence_inv_œÄ -> CategoryTheory.Limits.HasColimit.isoOfEquivalence_inv_œÄ is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {K : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u3, u4} K] {C : Type.{u6}} [_inst_3 : CategoryTheory.Category.{u5, u6} C] {F : CategoryTheory.Functor.{u1, u5, u2, u6} J _inst_1 C _inst_3} [_inst_4 : CategoryTheory.Limits.HasColimit.{u1, u2, u5, u6} J _inst_1 C _inst_3 F] {G : CategoryTheory.Functor.{u3, u5, u4, u6} K _inst_2 C _inst_3} [_inst_5 : CategoryTheory.Limits.HasColimit.{u3, u4, u5, u6} K _inst_2 C _inst_3 G] (e : CategoryTheory.Equivalence.{u1, u3, u2, u4} J _inst_1 K _inst_2) (w : CategoryTheory.Iso.{max u2 u5, max u1 u5 u2 u6} (CategoryTheory.Functor.{u1, u5, u2, u6} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u5, u2, u6} J _inst_1 C _inst_3) (CategoryTheory.Functor.comp.{u1, u3, u5, u2, u4, u6} J _inst_1 K _inst_2 C _inst_3 (CategoryTheory.Equivalence.functor.{u1, u3, u2, u4} J _inst_1 K _inst_2 e) G) F) (k : K), Eq.{succ u5} (Quiver.Hom.{succ u5, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u5, u6} C (CategoryTheory.Category.toCategoryStruct.{u5, u6} C _inst_3)) (CategoryTheory.Functor.obj.{u3, u5, u4, u6} K _inst_2 C _inst_3 G k) (CategoryTheory.Limits.colimit.{u1, u2, u5, u6} J _inst_1 C _inst_3 F _inst_4)) (CategoryTheory.CategoryStruct.comp.{u5, u6} C (CategoryTheory.Category.toCategoryStruct.{u5, u6} C _inst_3) (CategoryTheory.Functor.obj.{u3, u5, u4, u6} K _inst_2 C _inst_3 G k) (CategoryTheory.Limits.colimit.{u3, u4, u5, u6} K _inst_2 C _inst_3 G _inst_5) (CategoryTheory.Limits.colimit.{u1, u2, u5, u6} J _inst_1 C _inst_3 F _inst_4) (CategoryTheory.Limits.colimit.Œπ.{u3, u4, u5, u6} K _inst_2 C _inst_3 G _inst_5 k) (CategoryTheory.Iso.inv.{u5, u6} C _inst_3 (CategoryTheory.Limits.colimit.{u1, u2, u5, u6} J _inst_1 C _inst_3 F _inst_4) (CategoryTheory.Limits.colimit.{u3, u4, u5, u6} K _inst_2 C _inst_3 G _inst_5) (CategoryTheory.Limits.HasColimit.isoOfEquivalence.{u1, u2, u3, u4, u5, u6} J _inst_1 K _inst_2 C _inst_3 F _inst_4 G _inst_5 e w))) (CategoryTheory.CategoryStruct.comp.{u5, u6} C (CategoryTheory.Category.toCategoryStruct.{u5, u6} C _inst_3) (CategoryTheory.Functor.obj.{u3, u5, u4, u6} K _inst_2 C _inst_3 G k) (CategoryTheory.Functor.obj.{u3, u5, u4, u6} K _inst_2 C _inst_3 G (CategoryTheory.Functor.obj.{u3, u3, u4, u4} K _inst_2 K _inst_2 (CategoryTheory.Functor.comp.{u3, u1, u3, u4, u2, u4} K _inst_2 J _inst_1 K _inst_2 (CategoryTheory.Equivalence.inverse.{u1, u3, u2, u4} J _inst_1 K _inst_2 e) (CategoryTheory.Equivalence.functor.{u1, u3, u2, u4} J _inst_1 K _inst_2 e)) k)) (CategoryTheory.Limits.colimit.{u1, u2, u5, u6} J _inst_1 C _inst_3 F _inst_4) (CategoryTheory.Functor.map.{u3, u5, u4, u6} K _inst_2 C _inst_3 G k (CategoryTheory.Functor.obj.{u3, u3, u4, u4} K _inst_2 K _inst_2 (CategoryTheory.Functor.comp.{u3, u1, u3, u4, u2, u4} K _inst_2 J _inst_1 K _inst_2 (CategoryTheory.Equivalence.inverse.{u1, u3, u2, u4} J _inst_1 K _inst_2 e) (CategoryTheory.Equivalence.functor.{u1, u3, u2, u4} J _inst_1 K _inst_2 e)) k) (CategoryTheory.NatTrans.app.{u3, u3, u4, u4} K _inst_2 K _inst_2 (CategoryTheory.Functor.id.{u3, u4} K _inst_2) (CategoryTheory.Functor.comp.{u3, u1, u3, u4, u2, u4} K _inst_2 J _inst_1 K _inst_2 (CategoryTheory.Equivalence.inverse.{u1, u3, u2, u4} J _inst_1 K _inst_2 e) (CategoryTheory.Equivalence.functor.{u1, u3, u2, u4} J _inst_1 K _inst_2 e)) (CategoryTheory.Equivalence.counitInv.{u1, u3, u2, u4} J _inst_1 K _inst_2 e) k)) (CategoryTheory.CategoryStruct.comp.{u5, u6} C (CategoryTheory.Category.toCategoryStruct.{u5, u6} C _inst_3) (CategoryTheory.Functor.obj.{u3, u5, u4, u6} K _inst_2 C _inst_3 G (CategoryTheory.Functor.obj.{u3, u3, u4, u4} K _inst_2 K _inst_2 (CategoryTheory.Functor.comp.{u3, u1, u3, u4, u2, u4} K _inst_2 J _inst_1 K _inst_2 (CategoryTheory.Equivalence.inverse.{u1, u3, u2, u4} J _inst_1 K _inst_2 e) (CategoryTheory.Equivalence.functor.{u1, u3, u2, u4} J _inst_1 K _inst_2 e)) k)) (CategoryTheory.Functor.obj.{u1, u5, u2, u6} J _inst_1 C _inst_3 F (CategoryTheory.Functor.obj.{u3, u1, u4, u2} K _inst_2 J _inst_1 (CategoryTheory.Equivalence.inverse.{u1, u3, u2, u4} J _inst_1 K _inst_2 e) k)) (CategoryTheory.Limits.colimit.{u1, u2, u5, u6} J _inst_1 C _inst_3 F _inst_4) (CategoryTheory.NatTrans.app.{u1, u5, u2, u6} J _inst_1 C _inst_3 (CategoryTheory.Functor.comp.{u1, u3, u5, u2, u4, u6} J _inst_1 K _inst_2 C _inst_3 (CategoryTheory.Equivalence.functor.{u1, u3, u2, u4} J _inst_1 K _inst_2 e) G) F (CategoryTheory.Iso.hom.{max u2 u5, max u1 u5 u2 u6} (CategoryTheory.Functor.{u1, u5, u2, u6} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u5, u2, u6} J _inst_1 C _inst_3) (CategoryTheory.Functor.comp.{u1, u3, u5, u2, u4, u6} J _inst_1 K _inst_2 C _inst_3 (CategoryTheory.Equivalence.functor.{u1, u3, u2, u4} J _inst_1 K _inst_2 e) G) F w) (CategoryTheory.Functor.obj.{u3, u1, u4, u2} K _inst_2 J _inst_1 (CategoryTheory.Equivalence.inverse.{u1, u3, u2, u4} J _inst_1 K _inst_2 e) k)) (CategoryTheory.Limits.colimit.Œπ.{u1, u2, u5, u6} J _inst_1 C _inst_3 F _inst_4 (CategoryTheory.Functor.obj.{u3, u1, u4, u2} K _inst_2 J _inst_1 (CategoryTheory.Equivalence.inverse.{u1, u3, u2, u4} J _inst_1 K _inst_2 e) k))))
but is expected to have type
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {K : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u3, u4} K] {C : Type.{u6}} [_inst_3 : CategoryTheory.Category.{u5, u6} C] {F : CategoryTheory.Functor.{u1, u5, u2, u6} J _inst_1 C _inst_3} [_inst_4 : CategoryTheory.Limits.HasColimit.{u1, u2, u5, u6} J _inst_1 C _inst_3 F] {G : CategoryTheory.Functor.{u3, u5, u4, u6} K _inst_2 C _inst_3} [_inst_5 : CategoryTheory.Limits.HasColimit.{u3, u4, u5, u6} K _inst_2 C _inst_3 G] (e : CategoryTheory.Equivalence.{u1, u3, u2, u4} J K _inst_1 _inst_2) (w : CategoryTheory.Iso.{max u2 u5, max (max (max u6 u2) u5) u1} (CategoryTheory.Functor.{u1, u5, u2, u6} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u5, u2, u6} J _inst_1 C _inst_3) (CategoryTheory.Functor.comp.{u1, u3, u5, u2, u4, u6} J _inst_1 K _inst_2 C _inst_3 (CategoryTheory.Equivalence.functor.{u1, u3, u2, u4} J K _inst_1 _inst_2 e) G) F) (k : K), Eq.{succ u5} (Quiver.Hom.{succ u5, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u5, u6} C (CategoryTheory.Category.toCategoryStruct.{u5, u6} C _inst_3)) (Prefunctor.obj.{succ u3, succ u5, u4, u6} K (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} K (CategoryTheory.Category.toCategoryStruct.{u3, u4} K _inst_2)) C (CategoryTheory.CategoryStruct.toQuiver.{u5, u6} C (CategoryTheory.Category.toCategoryStruct.{u5, u6} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u3, u5, u4, u6} K _inst_2 C _inst_3 G) k) (CategoryTheory.Limits.colimit.{u1, u2, u5, u6} J _inst_1 C _inst_3 F _inst_4)) (CategoryTheory.CategoryStruct.comp.{u5, u6} C (CategoryTheory.Category.toCategoryStruct.{u5, u6} C _inst_3) (Prefunctor.obj.{succ u3, succ u5, u4, u6} K (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} K (CategoryTheory.Category.toCategoryStruct.{u3, u4} K _inst_2)) C (CategoryTheory.CategoryStruct.toQuiver.{u5, u6} C (CategoryTheory.Category.toCategoryStruct.{u5, u6} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u3, u5, u4, u6} K _inst_2 C _inst_3 G) k) (CategoryTheory.Limits.colimit.{u3, u4, u5, u6} K _inst_2 C _inst_3 G _inst_5) (CategoryTheory.Limits.colimit.{u1, u2, u5, u6} J _inst_1 C _inst_3 F _inst_4) (CategoryTheory.Limits.colimit.Œπ.{u3, u4, u5, u6} K _inst_2 C _inst_3 G _inst_5 k) (CategoryTheory.Iso.inv.{u5, u6} C _inst_3 (CategoryTheory.Limits.colimit.{u1, u2, u5, u6} J _inst_1 C _inst_3 F _inst_4) (CategoryTheory.Limits.colimit.{u3, u4, u5, u6} K _inst_2 C _inst_3 G _inst_5) (CategoryTheory.Limits.HasColimit.isoOfEquivalence.{u1, u2, u3, u4, u5, u6} J _inst_1 K _inst_2 C _inst_3 F _inst_4 G _inst_5 e w))) (CategoryTheory.CategoryStruct.comp.{u5, u6} C (CategoryTheory.Category.toCategoryStruct.{u5, u6} C _inst_3) (Prefunctor.obj.{succ u3, succ u5, u4, u6} K (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} K (CategoryTheory.Category.toCategoryStruct.{u3, u4} K _inst_2)) C (CategoryTheory.CategoryStruct.toQuiver.{u5, u6} C (CategoryTheory.Category.toCategoryStruct.{u5, u6} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u3, u5, u4, u6} K _inst_2 C _inst_3 G) (Prefunctor.obj.{succ u3, succ u3, u4, u4} K (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} K (CategoryTheory.Category.toCategoryStruct.{u3, u4} K _inst_2)) K (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} K (CategoryTheory.Category.toCategoryStruct.{u3, u4} K _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u3, u4, u4} K _inst_2 K _inst_2 (CategoryTheory.Functor.id.{u3, u4} K _inst_2)) k)) (Prefunctor.obj.{succ u3, succ u5, u4, u6} K (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} K (CategoryTheory.Category.toCategoryStruct.{u3, u4} K _inst_2)) C (CategoryTheory.CategoryStruct.toQuiver.{u5, u6} C (CategoryTheory.Category.toCategoryStruct.{u5, u6} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u3, u5, u4, u6} K _inst_2 C _inst_3 G) (Prefunctor.obj.{succ u3, succ u3, u4, u4} K (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} K (CategoryTheory.Category.toCategoryStruct.{u3, u4} K _inst_2)) K (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} K (CategoryTheory.Category.toCategoryStruct.{u3, u4} K _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u3, u4, u4} K _inst_2 K _inst_2 (CategoryTheory.Functor.comp.{u3, u1, u3, u4, u2, u4} K _inst_2 J _inst_1 K _inst_2 (CategoryTheory.Equivalence.inverse.{u1, u3, u2, u4} J K _inst_1 _inst_2 e) (CategoryTheory.Equivalence.functor.{u1, u3, u2, u4} J K _inst_1 _inst_2 e))) k)) (CategoryTheory.Limits.colimit.{u1, u2, u5, u6} J _inst_1 C _inst_3 F _inst_4) (Prefunctor.map.{succ u3, succ u5, u4, u6} K (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} K (CategoryTheory.Category.toCategoryStruct.{u3, u4} K _inst_2)) C (CategoryTheory.CategoryStruct.toQuiver.{u5, u6} C (CategoryTheory.Category.toCategoryStruct.{u5, u6} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u3, u5, u4, u6} K _inst_2 C _inst_3 G) (Prefunctor.obj.{succ u3, succ u3, u4, u4} K (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} K (CategoryTheory.Category.toCategoryStruct.{u3, u4} K _inst_2)) K (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} K (CategoryTheory.Category.toCategoryStruct.{u3, u4} K _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u3, u4, u4} K _inst_2 K _inst_2 (CategoryTheory.Functor.id.{u3, u4} K _inst_2)) k) (Prefunctor.obj.{succ u3, succ u3, u4, u4} K (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} K (CategoryTheory.Category.toCategoryStruct.{u3, u4} K _inst_2)) K (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} K (CategoryTheory.Category.toCategoryStruct.{u3, u4} K _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u3, u4, u4} K _inst_2 K _inst_2 (CategoryTheory.Functor.comp.{u3, u1, u3, u4, u2, u4} K _inst_2 J _inst_1 K _inst_2 (CategoryTheory.Equivalence.inverse.{u1, u3, u2, u4} J K _inst_1 _inst_2 e) (CategoryTheory.Equivalence.functor.{u1, u3, u2, u4} J K _inst_1 _inst_2 e))) k) (CategoryTheory.NatTrans.app.{u3, u3, u4, u4} K _inst_2 K _inst_2 (CategoryTheory.Functor.id.{u3, u4} K _inst_2) (CategoryTheory.Functor.comp.{u3, u1, u3, u4, u2, u4} K _inst_2 J _inst_1 K _inst_2 (CategoryTheory.Equivalence.inverse.{u1, u3, u2, u4} J K _inst_1 _inst_2 e) (CategoryTheory.Equivalence.functor.{u1, u3, u2, u4} J K _inst_1 _inst_2 e)) (CategoryTheory.Equivalence.counitInv.{u1, u3, u2, u4} J _inst_1 K _inst_2 e) k)) (CategoryTheory.CategoryStruct.comp.{u5, u6} C (CategoryTheory.Category.toCategoryStruct.{u5, u6} C _inst_3) (Prefunctor.obj.{succ u3, succ u5, u4, u6} K (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} K (CategoryTheory.Category.toCategoryStruct.{u3, u4} K _inst_2)) C (CategoryTheory.CategoryStruct.toQuiver.{u5, u6} C (CategoryTheory.Category.toCategoryStruct.{u5, u6} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u3, u5, u4, u6} K _inst_2 C _inst_3 G) (Prefunctor.obj.{succ u3, succ u3, u4, u4} K (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} K (CategoryTheory.Category.toCategoryStruct.{u3, u4} K _inst_2)) K (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} K (CategoryTheory.Category.toCategoryStruct.{u3, u4} K _inst_2)) (CategoryTheory.Functor.toPrefunctor.{u3, u3, u4, u4} K _inst_2 K _inst_2 (CategoryTheory.Functor.comp.{u3, u1, u3, u4, u2, u4} K _inst_2 J _inst_1 K _inst_2 (CategoryTheory.Equivalence.inverse.{u1, u3, u2, u4} J K _inst_1 _inst_2 e) (CategoryTheory.Equivalence.functor.{u1, u3, u2, u4} J K _inst_1 _inst_2 e))) k)) (Prefunctor.obj.{succ u1, succ u5, u2, u6} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u5, u6} C (CategoryTheory.Category.toCategoryStruct.{u5, u6} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u5, u2, u6} J _inst_1 C _inst_3 F) (Prefunctor.obj.{succ u3, succ u1, u4, u2} K (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} K (CategoryTheory.Category.toCategoryStruct.{u3, u4} K _inst_2)) J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u3, u1, u4, u2} K _inst_2 J _inst_1 (CategoryTheory.Equivalence.inverse.{u1, u3, u2, u4} J K _inst_1 _inst_2 e)) k)) (CategoryTheory.Limits.colimit.{u1, u2, u5, u6} J _inst_1 C _inst_3 F _inst_4) (CategoryTheory.NatTrans.app.{u1, u5, u2, u6} J _inst_1 C _inst_3 (CategoryTheory.Functor.comp.{u1, u3, u5, u2, u4, u6} J _inst_1 K _inst_2 C _inst_3 (CategoryTheory.Equivalence.functor.{u1, u3, u2, u4} J K _inst_1 _inst_2 e) G) F (CategoryTheory.Iso.hom.{max u2 u5, max (max (max u6 u2) u5) u1} (CategoryTheory.Functor.{u1, u5, u2, u6} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u5, u2, u6} J _inst_1 C _inst_3) (CategoryTheory.Functor.comp.{u1, u3, u5, u2, u4, u6} J _inst_1 K _inst_2 C _inst_3 (CategoryTheory.Equivalence.functor.{u1, u3, u2, u4} J K _inst_1 _inst_2 e) G) F w) (Prefunctor.obj.{succ u3, succ u1, u4, u2} K (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} K (CategoryTheory.Category.toCategoryStruct.{u3, u4} K _inst_2)) J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u3, u1, u4, u2} K _inst_2 J _inst_1 (CategoryTheory.Equivalence.inverse.{u1, u3, u2, u4} J K _inst_1 _inst_2 e)) k)) (CategoryTheory.Limits.colimit.Œπ.{u1, u2, u5, u6} J _inst_1 C _inst_3 F _inst_4 (Prefunctor.obj.{succ u3, succ u1, u4, u2} K (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} K (CategoryTheory.Category.toCategoryStruct.{u3, u4} K _inst_2)) J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u3, u1, u4, u2} K _inst_2 J _inst_1 (CategoryTheory.Equivalence.inverse.{u1, u3, u2, u4} J K _inst_1 _inst_2 e)) k))))
Case conversion may be inaccurate. Consider using '#align category_theory.limits.has_colimit.iso_of_equivalence_inv_œÄ CategoryTheory.Limits.HasColimit.isoOfEquivalence_inv_œÄ‚Çì'. -/
@[simp]
theorem HasColimit.isoOfEquivalence_inv_œÄ {F : J ‚•§ C} [HasColimit F] {G : K ‚•§ C} [HasColimit G]
    (e : J ‚âå K) (w : e.Functor ‚ãô G ‚âÖ F) (k : K) :
    colimit.Œπ G k ‚â´ (HasColimit.isoOfEquivalence e w).inv =
      G.map (e.counitInv.app k) ‚â´ w.Hom.app (e.inverse.obj k) ‚â´ colimit.Œπ F (e.inverse.obj k) :=
  by
  simp [has_colimit.iso_of_equivalence, is_colimit.cocone_points_iso_of_equivalence_inv]
  dsimp
  simp
#align category_theory.limits.has_colimit.iso_of_equivalence_inv_œÄ CategoryTheory.Limits.HasColimit.isoOfEquivalence_inv_œÄ

section Pre

variable (F) [HasColimit F] (E : K ‚•§ J) [HasColimit (E ‚ãô F)]

#print CategoryTheory.Limits.colimit.pre /-
/-- The canonical morphism from the colimit of `E ‚ãô F` to the colimit of `F`.
-/
def colimit.pre : colimit (E ‚ãô F) ‚ü∂ colimit F :=
  colimit.desc (E ‚ãô F) ((colimit.cocone F).whisker E)
#align category_theory.limits.colimit.pre CategoryTheory.Limits.colimit.pre
-/

/- warning: category_theory.limits.colimit.Œπ_pre -> CategoryTheory.Limits.colimit.Œπ_pre is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {K : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u3, u4} K] {C : Type.{u6}} [_inst_3 : CategoryTheory.Category.{u5, u6} C] (F : CategoryTheory.Functor.{u1, u5, u2, u6} J _inst_1 C _inst_3) [_inst_4 : CategoryTheory.Limits.HasColimit.{u1, u2, u5, u6} J _inst_1 C _inst_3 F] (E : CategoryTheory.Functor.{u3, u1, u4, u2} K _inst_2 J _inst_1) [_inst_5 : CategoryTheory.Limits.HasColimit.{u3, u4, u5, u6} K _inst_2 C _inst_3 (CategoryTheory.Functor.comp.{u3, u1, u5, u4, u2, u6} K _inst_2 J _inst_1 C _inst_3 E F)] (k : K), Eq.{succ u5} (Quiver.Hom.{succ u5, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u5, u6} C (CategoryTheory.Category.toCategoryStruct.{u5, u6} C _inst_3)) (CategoryTheory.Functor.obj.{u3, u5, u4, u6} K _inst_2 C _inst_3 (CategoryTheory.Functor.comp.{u3, u1, u5, u4, u2, u6} K _inst_2 J _inst_1 C _inst_3 E F) k) (CategoryTheory.Limits.colimit.{u1, u2, u5, u6} J _inst_1 C _inst_3 F _inst_4)) (CategoryTheory.CategoryStruct.comp.{u5, u6} C (CategoryTheory.Category.toCategoryStruct.{u5, u6} C _inst_3) (CategoryTheory.Functor.obj.{u3, u5, u4, u6} K _inst_2 C _inst_3 (CategoryTheory.Functor.comp.{u3, u1, u5, u4, u2, u6} K _inst_2 J _inst_1 C _inst_3 E F) k) (CategoryTheory.Limits.colimit.{u3, u4, u5, u6} K _inst_2 C _inst_3 (CategoryTheory.Functor.comp.{u3, u1, u5, u4, u2, u6} K _inst_2 J _inst_1 C _inst_3 E F) _inst_5) (CategoryTheory.Limits.colimit.{u1, u2, u5, u6} J _inst_1 C _inst_3 F _inst_4) (CategoryTheory.Limits.colimit.Œπ.{u3, u4, u5, u6} K _inst_2 C _inst_3 (CategoryTheory.Functor.comp.{u3, u1, u5, u4, u2, u6} K _inst_2 J _inst_1 C _inst_3 E F) _inst_5 k) (CategoryTheory.Limits.colimit.pre.{u1, u2, u3, u4, u5, u6} J _inst_1 K _inst_2 C _inst_3 F _inst_4 E _inst_5)) (CategoryTheory.Limits.colimit.Œπ.{u1, u2, u5, u6} J _inst_1 C _inst_3 F _inst_4 (CategoryTheory.Functor.obj.{u3, u1, u4, u2} K _inst_2 J _inst_1 E k))
but is expected to have type
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {K : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u3, u4} K] {C : Type.{u6}} [_inst_3 : CategoryTheory.Category.{u5, u6} C] (F : CategoryTheory.Functor.{u1, u5, u2, u6} J _inst_1 C _inst_3) [_inst_4 : CategoryTheory.Limits.HasColimit.{u1, u2, u5, u6} J _inst_1 C _inst_3 F] (E : CategoryTheory.Functor.{u3, u1, u4, u2} K _inst_2 J _inst_1) [_inst_5 : CategoryTheory.Limits.HasColimit.{u3, u4, u5, u6} K _inst_2 C _inst_3 (CategoryTheory.Functor.comp.{u3, u1, u5, u4, u2, u6} K _inst_2 J _inst_1 C _inst_3 E F)] (k : K), Eq.{succ u5} (Quiver.Hom.{succ u5, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u5, u6} C (CategoryTheory.Category.toCategoryStruct.{u5, u6} C _inst_3)) (Prefunctor.obj.{succ u3, succ u5, u4, u6} K (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} K (CategoryTheory.Category.toCategoryStruct.{u3, u4} K _inst_2)) C (CategoryTheory.CategoryStruct.toQuiver.{u5, u6} C (CategoryTheory.Category.toCategoryStruct.{u5, u6} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u3, u5, u4, u6} K _inst_2 C _inst_3 (CategoryTheory.Functor.comp.{u3, u1, u5, u4, u2, u6} K _inst_2 J _inst_1 C _inst_3 E F)) k) (CategoryTheory.Limits.colimit.{u1, u2, u5, u6} J _inst_1 C _inst_3 F _inst_4)) (CategoryTheory.CategoryStruct.comp.{u5, u6} C (CategoryTheory.Category.toCategoryStruct.{u5, u6} C _inst_3) (Prefunctor.obj.{succ u3, succ u5, u4, u6} K (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} K (CategoryTheory.Category.toCategoryStruct.{u3, u4} K _inst_2)) C (CategoryTheory.CategoryStruct.toQuiver.{u5, u6} C (CategoryTheory.Category.toCategoryStruct.{u5, u6} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u3, u5, u4, u6} K _inst_2 C _inst_3 (CategoryTheory.Functor.comp.{u3, u1, u5, u4, u2, u6} K _inst_2 J _inst_1 C _inst_3 E F)) k) (CategoryTheory.Limits.colimit.{u3, u4, u5, u6} K _inst_2 C _inst_3 (CategoryTheory.Functor.comp.{u3, u1, u5, u4, u2, u6} K _inst_2 J _inst_1 C _inst_3 E F) _inst_5) (CategoryTheory.Limits.colimit.{u1, u2, u5, u6} J _inst_1 C _inst_3 F _inst_4) (CategoryTheory.Limits.colimit.Œπ.{u3, u4, u5, u6} K _inst_2 C _inst_3 (CategoryTheory.Functor.comp.{u3, u1, u5, u4, u2, u6} K _inst_2 J _inst_1 C _inst_3 E F) _inst_5 k) (CategoryTheory.Limits.colimit.pre.{u1, u2, u3, u4, u5, u6} J _inst_1 K _inst_2 C _inst_3 F _inst_4 E _inst_5)) (CategoryTheory.Limits.colimit.Œπ.{u1, u2, u5, u6} J _inst_1 C _inst_3 F _inst_4 (Prefunctor.obj.{succ u3, succ u1, u4, u2} K (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} K (CategoryTheory.Category.toCategoryStruct.{u3, u4} K _inst_2)) J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u3, u1, u4, u2} K _inst_2 J _inst_1 E) k))
Case conversion may be inaccurate. Consider using '#align category_theory.limits.colimit.Œπ_pre CategoryTheory.Limits.colimit.Œπ_pre‚Çì'. -/
@[simp, reassoc.1]
theorem colimit.Œπ_pre (k : K) : colimit.Œπ (E ‚ãô F) k ‚â´ colimit.pre F E = colimit.Œπ F (E.obj k) :=
  by
  erw [is_colimit.fac]
  rfl
#align category_theory.limits.colimit.Œπ_pre CategoryTheory.Limits.colimit.Œπ_pre

#print CategoryTheory.Limits.colimit.pre_desc /-
@[simp, reassoc.1]
theorem colimit.pre_desc (c : Cocone F) :
    colimit.pre F E ‚â´ colimit.desc F c = colimit.desc (E ‚ãô F) (c.whisker E) := by
  ext <;> rw [‚Üê assoc, colimit.Œπ_pre] <;> simp
#align category_theory.limits.colimit.pre_desc CategoryTheory.Limits.colimit.pre_desc
-/

variable {L : Type u‚ÇÉ} [Category.{v‚ÇÉ} L]

variable (D : L ‚•§ K) [HasColimit (D ‚ãô E ‚ãô F)]

#print CategoryTheory.Limits.colimit.pre_pre /-
@[simp]
theorem colimit.pre_pre : colimit.pre (E ‚ãô F) D ‚â´ colimit.pre F E = colimit.pre F (D ‚ãô E) :=
  by
  ext j
  rw [‚Üê assoc, colimit.Œπ_pre, colimit.Œπ_pre]
  letI : has_colimit ((D ‚ãô E) ‚ãô F) := show has_colimit (D ‚ãô E ‚ãô F) by infer_instance
  exact (colimit.Œπ_pre F (D ‚ãô E) j).symm
#align category_theory.limits.colimit.pre_pre CategoryTheory.Limits.colimit.pre_pre
-/

variable {E F}

#print CategoryTheory.Limits.colimit.pre_eq /-
/-- -
If we have particular colimit cocones available for `E ‚ãô F` and for `F`,
we obtain a formula for `colimit.pre F E`.
-/
theorem colimit.pre_eq (s : ColimitCocone (E ‚ãô F)) (t : ColimitCocone F) :
    colimit.pre F E =
      (colimit.isoColimitCocone s).Hom ‚â´
        s.IsColimit.desc (t.Cocone.whisker E) ‚â´ (colimit.isoColimitCocone t).inv :=
  by tidy
#align category_theory.limits.colimit.pre_eq CategoryTheory.Limits.colimit.pre_eq
-/

end Pre

section Post

variable {D : Type u'} [Category.{v'} D]

variable (F) [HasColimit F] (G : C ‚•§ D) [HasColimit (F ‚ãô G)]

/- warning: category_theory.limits.colimit.post -> CategoryTheory.Limits.colimit.post is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {C : Type.{u5}} [_inst_3 : CategoryTheory.Category.{u3, u5} C] (F : CategoryTheory.Functor.{u1, u3, u2, u5} J _inst_1 C _inst_3) {D : Type.{u6}} [_inst_4 : CategoryTheory.Category.{u4, u6} D] [_inst_5 : CategoryTheory.Limits.HasColimit.{u1, u2, u3, u5} J _inst_1 C _inst_3 F] (G : CategoryTheory.Functor.{u3, u4, u5, u6} C _inst_3 D _inst_4) [_inst_6 : CategoryTheory.Limits.HasColimit.{u1, u2, u4, u6} J _inst_1 D _inst_4 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_1 C _inst_3 D _inst_4 F G)], Quiver.Hom.{succ u4, u6} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} D (CategoryTheory.Category.toCategoryStruct.{u4, u6} D _inst_4)) (CategoryTheory.Limits.colimit.{u1, u2, u4, u6} J _inst_1 D _inst_4 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_1 C _inst_3 D _inst_4 F G) _inst_6) (CategoryTheory.Functor.obj.{u3, u4, u5, u6} C _inst_3 D _inst_4 G (CategoryTheory.Limits.colimit.{u1, u2, u3, u5} J _inst_1 C _inst_3 F _inst_5))
but is expected to have type
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {C : Type.{u5}} [_inst_3 : CategoryTheory.Category.{u3, u5} C] (F : CategoryTheory.Functor.{u1, u3, u2, u5} J _inst_1 C _inst_3) {D : Type.{u6}} [_inst_4 : CategoryTheory.Category.{u4, u6} D] [_inst_5 : CategoryTheory.Limits.HasColimit.{u1, u2, u3, u5} J _inst_1 C _inst_3 F] (G : CategoryTheory.Functor.{u3, u4, u5, u6} C _inst_3 D _inst_4) [_inst_6 : CategoryTheory.Limits.HasColimit.{u1, u2, u4, u6} J _inst_1 D _inst_4 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_1 C _inst_3 D _inst_4 F G)], Quiver.Hom.{succ u4, u6} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} D (CategoryTheory.Category.toCategoryStruct.{u4, u6} D _inst_4)) (CategoryTheory.Limits.colimit.{u1, u2, u4, u6} J _inst_1 D _inst_4 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_1 C _inst_3 D _inst_4 F G) _inst_6) (Prefunctor.obj.{succ u3, succ u4, u5, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} C (CategoryTheory.Category.toCategoryStruct.{u3, u5} C _inst_3)) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} D (CategoryTheory.Category.toCategoryStruct.{u4, u6} D _inst_4)) (CategoryTheory.Functor.toPrefunctor.{u3, u4, u5, u6} C _inst_3 D _inst_4 G) (CategoryTheory.Limits.colimit.{u1, u2, u3, u5} J _inst_1 C _inst_3 F _inst_5))
Case conversion may be inaccurate. Consider using '#align category_theory.limits.colimit.post CategoryTheory.Limits.colimit.post‚Çì'. -/
/-- The canonical morphism from `G` applied to the colimit of `F ‚ãô G`
to `G` applied to the colimit of `F`.
-/
def colimit.post : colimit (F ‚ãô G) ‚ü∂ G.obj (colimit F) :=
  colimit.desc (F ‚ãô G) (G.mapCocone (colimit.cocone F))
#align category_theory.limits.colimit.post CategoryTheory.Limits.colimit.post

/- warning: category_theory.limits.colimit.Œπ_post -> CategoryTheory.Limits.colimit.Œπ_post is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {C : Type.{u5}} [_inst_3 : CategoryTheory.Category.{u3, u5} C] (F : CategoryTheory.Functor.{u1, u3, u2, u5} J _inst_1 C _inst_3) {D : Type.{u6}} [_inst_4 : CategoryTheory.Category.{u4, u6} D] [_inst_5 : CategoryTheory.Limits.HasColimit.{u1, u2, u3, u5} J _inst_1 C _inst_3 F] (G : CategoryTheory.Functor.{u3, u4, u5, u6} C _inst_3 D _inst_4) [_inst_6 : CategoryTheory.Limits.HasColimit.{u1, u2, u4, u6} J _inst_1 D _inst_4 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_1 C _inst_3 D _inst_4 F G)] (j : J), Eq.{succ u4} (Quiver.Hom.{succ u4, u6} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} D (CategoryTheory.Category.toCategoryStruct.{u4, u6} D _inst_4)) (CategoryTheory.Functor.obj.{u1, u4, u2, u6} J _inst_1 D _inst_4 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_1 C _inst_3 D _inst_4 F G) j) (CategoryTheory.Functor.obj.{u3, u4, u5, u6} C _inst_3 D _inst_4 G (CategoryTheory.Limits.colimit.{u1, u2, u3, u5} J _inst_1 C _inst_3 F _inst_5))) (CategoryTheory.CategoryStruct.comp.{u4, u6} D (CategoryTheory.Category.toCategoryStruct.{u4, u6} D _inst_4) (CategoryTheory.Functor.obj.{u1, u4, u2, u6} J _inst_1 D _inst_4 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_1 C _inst_3 D _inst_4 F G) j) (CategoryTheory.Limits.colimit.{u1, u2, u4, u6} J _inst_1 D _inst_4 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_1 C _inst_3 D _inst_4 F G) _inst_6) (CategoryTheory.Functor.obj.{u3, u4, u5, u6} C _inst_3 D _inst_4 G (CategoryTheory.Limits.colimit.{u1, u2, u3, u5} J _inst_1 C _inst_3 F _inst_5)) (CategoryTheory.Limits.colimit.Œπ.{u1, u2, u4, u6} J _inst_1 D _inst_4 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_1 C _inst_3 D _inst_4 F G) _inst_6 j) (CategoryTheory.Limits.colimit.post.{u1, u2, u3, u4, u5, u6} J _inst_1 C _inst_3 F D _inst_4 _inst_5 G _inst_6)) (CategoryTheory.Functor.map.{u3, u4, u5, u6} C _inst_3 D _inst_4 G (CategoryTheory.Functor.obj.{u1, u3, u2, u5} J _inst_1 C _inst_3 F j) (CategoryTheory.Limits.colimit.{u1, u2, u3, u5} J _inst_1 C _inst_3 F _inst_5) (CategoryTheory.Limits.colimit.Œπ.{u1, u2, u3, u5} J _inst_1 C _inst_3 F _inst_5 j))
but is expected to have type
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {C : Type.{u5}} [_inst_3 : CategoryTheory.Category.{u3, u5} C] (F : CategoryTheory.Functor.{u1, u3, u2, u5} J _inst_1 C _inst_3) {D : Type.{u6}} [_inst_4 : CategoryTheory.Category.{u4, u6} D] [_inst_5 : CategoryTheory.Limits.HasColimit.{u1, u2, u3, u5} J _inst_1 C _inst_3 F] (G : CategoryTheory.Functor.{u3, u4, u5, u6} C _inst_3 D _inst_4) [_inst_6 : CategoryTheory.Limits.HasColimit.{u1, u2, u4, u6} J _inst_1 D _inst_4 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_1 C _inst_3 D _inst_4 F G)] (j : J), Eq.{succ u4} (Quiver.Hom.{succ u4, u6} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} D (CategoryTheory.Category.toCategoryStruct.{u4, u6} D _inst_4)) (Prefunctor.obj.{succ u1, succ u4, u2, u6} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} D (CategoryTheory.Category.toCategoryStruct.{u4, u6} D _inst_4)) (CategoryTheory.Functor.toPrefunctor.{u1, u4, u2, u6} J _inst_1 D _inst_4 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_1 C _inst_3 D _inst_4 F G)) j) (Prefunctor.obj.{succ u3, succ u4, u5, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} C (CategoryTheory.Category.toCategoryStruct.{u3, u5} C _inst_3)) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} D (CategoryTheory.Category.toCategoryStruct.{u4, u6} D _inst_4)) (CategoryTheory.Functor.toPrefunctor.{u3, u4, u5, u6} C _inst_3 D _inst_4 G) (CategoryTheory.Limits.colimit.{u1, u2, u3, u5} J _inst_1 C _inst_3 F _inst_5))) (CategoryTheory.CategoryStruct.comp.{u4, u6} D (CategoryTheory.Category.toCategoryStruct.{u4, u6} D _inst_4) (Prefunctor.obj.{succ u1, succ u4, u2, u6} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} D (CategoryTheory.Category.toCategoryStruct.{u4, u6} D _inst_4)) (CategoryTheory.Functor.toPrefunctor.{u1, u4, u2, u6} J _inst_1 D _inst_4 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_1 C _inst_3 D _inst_4 F G)) j) (CategoryTheory.Limits.colimit.{u1, u2, u4, u6} J _inst_1 D _inst_4 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_1 C _inst_3 D _inst_4 F G) _inst_6) (Prefunctor.obj.{succ u3, succ u4, u5, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} C (CategoryTheory.Category.toCategoryStruct.{u3, u5} C _inst_3)) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} D (CategoryTheory.Category.toCategoryStruct.{u4, u6} D _inst_4)) (CategoryTheory.Functor.toPrefunctor.{u3, u4, u5, u6} C _inst_3 D _inst_4 G) (CategoryTheory.Limits.colimit.{u1, u2, u3, u5} J _inst_1 C _inst_3 F _inst_5)) (CategoryTheory.Limits.colimit.Œπ.{u1, u2, u4, u6} J _inst_1 D _inst_4 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_1 C _inst_3 D _inst_4 F G) _inst_6 j) (CategoryTheory.Limits.colimit.post.{u1, u2, u3, u4, u5, u6} J _inst_1 C _inst_3 F D _inst_4 _inst_5 G _inst_6)) (Prefunctor.map.{succ u3, succ u4, u5, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} C (CategoryTheory.Category.toCategoryStruct.{u3, u5} C _inst_3)) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} D (CategoryTheory.Category.toCategoryStruct.{u4, u6} D _inst_4)) (CategoryTheory.Functor.toPrefunctor.{u3, u4, u5, u6} C _inst_3 D _inst_4 G) (Prefunctor.obj.{succ u1, succ u3, u2, u5} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} C (CategoryTheory.Category.toCategoryStruct.{u3, u5} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, u5} J _inst_1 C _inst_3 F) j) (CategoryTheory.Limits.colimit.{u1, u2, u3, u5} J _inst_1 C _inst_3 F _inst_5) (CategoryTheory.Limits.colimit.Œπ.{u1, u2, u3, u5} J _inst_1 C _inst_3 F _inst_5 j))
Case conversion may be inaccurate. Consider using '#align category_theory.limits.colimit.Œπ_post CategoryTheory.Limits.colimit.Œπ_post‚Çì'. -/
@[simp, reassoc.1]
theorem colimit.Œπ_post (j : J) : colimit.Œπ (F ‚ãô G) j ‚â´ colimit.post F G = G.map (colimit.Œπ F j) :=
  by
  erw [is_colimit.fac]
  rfl
#align category_theory.limits.colimit.Œπ_post CategoryTheory.Limits.colimit.Œπ_post

/- warning: category_theory.limits.colimit.post_desc -> CategoryTheory.Limits.colimit.post_desc is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {C : Type.{u5}} [_inst_3 : CategoryTheory.Category.{u3, u5} C] (F : CategoryTheory.Functor.{u1, u3, u2, u5} J _inst_1 C _inst_3) {D : Type.{u6}} [_inst_4 : CategoryTheory.Category.{u4, u6} D] [_inst_5 : CategoryTheory.Limits.HasColimit.{u1, u2, u3, u5} J _inst_1 C _inst_3 F] (G : CategoryTheory.Functor.{u3, u4, u5, u6} C _inst_3 D _inst_4) [_inst_6 : CategoryTheory.Limits.HasColimit.{u1, u2, u4, u6} J _inst_1 D _inst_4 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_1 C _inst_3 D _inst_4 F G)] (c : CategoryTheory.Limits.Cocone.{u1, u3, u2, u5} J _inst_1 C _inst_3 F), Eq.{succ u4} (Quiver.Hom.{succ u4, u6} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} D (CategoryTheory.Category.toCategoryStruct.{u4, u6} D _inst_4)) (CategoryTheory.Limits.colimit.{u1, u2, u4, u6} J _inst_1 D _inst_4 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_1 C _inst_3 D _inst_4 F G) _inst_6) (CategoryTheory.Functor.obj.{u3, u4, u5, u6} C _inst_3 D _inst_4 G (CategoryTheory.Limits.Cocone.pt.{u1, u3, u2, u5} J _inst_1 C _inst_3 F c))) (CategoryTheory.CategoryStruct.comp.{u4, u6} D (CategoryTheory.Category.toCategoryStruct.{u4, u6} D _inst_4) (CategoryTheory.Limits.colimit.{u1, u2, u4, u6} J _inst_1 D _inst_4 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_1 C _inst_3 D _inst_4 F G) _inst_6) (CategoryTheory.Functor.obj.{u3, u4, u5, u6} C _inst_3 D _inst_4 G (CategoryTheory.Limits.colimit.{u1, u2, u3, u5} J _inst_1 C _inst_3 F _inst_5)) (CategoryTheory.Functor.obj.{u3, u4, u5, u6} C _inst_3 D _inst_4 G (CategoryTheory.Limits.Cocone.pt.{u1, u3, u2, u5} J _inst_1 C _inst_3 F c)) (CategoryTheory.Limits.colimit.post.{u1, u2, u3, u4, u5, u6} J _inst_1 C _inst_3 F D _inst_4 _inst_5 G _inst_6) (CategoryTheory.Functor.map.{u3, u4, u5, u6} C _inst_3 D _inst_4 G (CategoryTheory.Limits.colimit.{u1, u2, u3, u5} J _inst_1 C _inst_3 F _inst_5) (CategoryTheory.Limits.Cocone.pt.{u1, u3, u2, u5} J _inst_1 C _inst_3 F c) (CategoryTheory.Limits.colimit.desc.{u1, u2, u3, u5} J _inst_1 C _inst_3 F _inst_5 c))) (CategoryTheory.Limits.colimit.desc.{u1, u2, u4, u6} J _inst_1 D _inst_4 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_1 C _inst_3 D _inst_4 F G) _inst_6 (CategoryTheory.Functor.mapCocone.{u1, u3, u4, u2, u5, u6} J _inst_1 C _inst_3 D _inst_4 F G c))
but is expected to have type
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {C : Type.{u5}} [_inst_3 : CategoryTheory.Category.{u3, u5} C] (F : CategoryTheory.Functor.{u1, u3, u2, u5} J _inst_1 C _inst_3) {D : Type.{u6}} [_inst_4 : CategoryTheory.Category.{u4, u6} D] [_inst_5 : CategoryTheory.Limits.HasColimit.{u1, u2, u3, u5} J _inst_1 C _inst_3 F] (G : CategoryTheory.Functor.{u3, u4, u5, u6} C _inst_3 D _inst_4) [_inst_6 : CategoryTheory.Limits.HasColimit.{u1, u2, u4, u6} J _inst_1 D _inst_4 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_1 C _inst_3 D _inst_4 F G)] (c : CategoryTheory.Limits.Cocone.{u1, u3, u2, u5} J _inst_1 C _inst_3 F), Eq.{succ u4} (Quiver.Hom.{succ u4, u6} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} D (CategoryTheory.Category.toCategoryStruct.{u4, u6} D _inst_4)) (CategoryTheory.Limits.colimit.{u1, u2, u4, u6} J _inst_1 D _inst_4 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_1 C _inst_3 D _inst_4 F G) _inst_6) (Prefunctor.obj.{succ u3, succ u4, u5, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} C (CategoryTheory.Category.toCategoryStruct.{u3, u5} C _inst_3)) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} D (CategoryTheory.Category.toCategoryStruct.{u4, u6} D _inst_4)) (CategoryTheory.Functor.toPrefunctor.{u3, u4, u5, u6} C _inst_3 D _inst_4 G) (CategoryTheory.Limits.Cocone.pt.{u1, u3, u2, u5} J _inst_1 C _inst_3 F c))) (CategoryTheory.CategoryStruct.comp.{u4, u6} D (CategoryTheory.Category.toCategoryStruct.{u4, u6} D _inst_4) (CategoryTheory.Limits.colimit.{u1, u2, u4, u6} J _inst_1 D _inst_4 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_1 C _inst_3 D _inst_4 F G) _inst_6) (Prefunctor.obj.{succ u3, succ u4, u5, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} C (CategoryTheory.Category.toCategoryStruct.{u3, u5} C _inst_3)) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} D (CategoryTheory.Category.toCategoryStruct.{u4, u6} D _inst_4)) (CategoryTheory.Functor.toPrefunctor.{u3, u4, u5, u6} C _inst_3 D _inst_4 G) (CategoryTheory.Limits.colimit.{u1, u2, u3, u5} J _inst_1 C _inst_3 F _inst_5)) (Prefunctor.obj.{succ u3, succ u4, u5, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} C (CategoryTheory.Category.toCategoryStruct.{u3, u5} C _inst_3)) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} D (CategoryTheory.Category.toCategoryStruct.{u4, u6} D _inst_4)) (CategoryTheory.Functor.toPrefunctor.{u3, u4, u5, u6} C _inst_3 D _inst_4 G) (CategoryTheory.Limits.Cocone.pt.{u1, u3, u2, u5} J _inst_1 C _inst_3 F c)) (CategoryTheory.Limits.colimit.post.{u1, u2, u3, u4, u5, u6} J _inst_1 C _inst_3 F D _inst_4 _inst_5 G _inst_6) (Prefunctor.map.{succ u3, succ u4, u5, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} C (CategoryTheory.Category.toCategoryStruct.{u3, u5} C _inst_3)) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} D (CategoryTheory.Category.toCategoryStruct.{u4, u6} D _inst_4)) (CategoryTheory.Functor.toPrefunctor.{u3, u4, u5, u6} C _inst_3 D _inst_4 G) (CategoryTheory.Limits.colimit.{u1, u2, u3, u5} J _inst_1 C _inst_3 F _inst_5) (CategoryTheory.Limits.Cocone.pt.{u1, u3, u2, u5} J _inst_1 C _inst_3 F c) (CategoryTheory.Limits.colimit.desc.{u1, u2, u3, u5} J _inst_1 C _inst_3 F _inst_5 c))) (CategoryTheory.Limits.colimit.desc.{u1, u2, u4, u6} J _inst_1 D _inst_4 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_1 C _inst_3 D _inst_4 F G) _inst_6 (CategoryTheory.Functor.mapCocone.{u1, u3, u4, u2, u5, u6} J _inst_1 C _inst_3 D _inst_4 F G c))
Case conversion may be inaccurate. Consider using '#align category_theory.limits.colimit.post_desc CategoryTheory.Limits.colimit.post_desc‚Çì'. -/
@[simp]
theorem colimit.post_desc (c : Cocone F) :
    colimit.post F G ‚â´ G.map (colimit.desc F c) = colimit.desc (F ‚ãô G) (G.mapCocone c) :=
  by
  ext
  rw [‚Üê assoc, colimit.Œπ_post, ‚Üê G.map_comp, colimit.Œπ_desc, colimit.Œπ_desc]
  rfl
#align category_theory.limits.colimit.post_desc CategoryTheory.Limits.colimit.post_desc

/- warning: category_theory.limits.colimit.post_post -> CategoryTheory.Limits.colimit.post_post is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {C : Type.{u6}} [_inst_3 : CategoryTheory.Category.{u3, u6} C] (F : CategoryTheory.Functor.{u1, u3, u2, u6} J _inst_1 C _inst_3) {D : Type.{u7}} [_inst_4 : CategoryTheory.Category.{u4, u7} D] [_inst_5 : CategoryTheory.Limits.HasColimit.{u1, u2, u3, u6} J _inst_1 C _inst_3 F] (G : CategoryTheory.Functor.{u3, u4, u6, u7} C _inst_3 D _inst_4) [_inst_6 : CategoryTheory.Limits.HasColimit.{u1, u2, u4, u7} J _inst_1 D _inst_4 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u6, u7} J _inst_1 C _inst_3 D _inst_4 F G)] {E : Type.{u8}} [_inst_7 : CategoryTheory.Category.{u5, u8} E] (H : CategoryTheory.Functor.{u4, u5, u7, u8} D _inst_4 E _inst_7) [_inst_8 : CategoryTheory.Limits.HasColimit.{u1, u2, u5, u8} J _inst_1 E _inst_7 (CategoryTheory.Functor.comp.{u1, u4, u5, u2, u7, u8} J _inst_1 D _inst_4 E _inst_7 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u6, u7} J _inst_1 C _inst_3 D _inst_4 F G) H)], Eq.{succ u5} (Quiver.Hom.{succ u5, u8} E (CategoryTheory.CategoryStruct.toQuiver.{u5, u8} E (CategoryTheory.Category.toCategoryStruct.{u5, u8} E _inst_7)) (CategoryTheory.Limits.colimit.{u1, u2, u5, u8} J _inst_1 E _inst_7 (CategoryTheory.Functor.comp.{u1, u4, u5, u2, u7, u8} J _inst_1 D _inst_4 E _inst_7 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u6, u7} J _inst_1 C _inst_3 D _inst_4 F G) H) _inst_8) (CategoryTheory.Functor.obj.{u4, u5, u7, u8} D _inst_4 E _inst_7 H (CategoryTheory.Functor.obj.{u3, u4, u6, u7} C _inst_3 D _inst_4 G (CategoryTheory.Limits.colimit.{u1, u2, u3, u6} J _inst_1 C _inst_3 F _inst_5)))) (CategoryTheory.CategoryStruct.comp.{u5, u8} E (CategoryTheory.Category.toCategoryStruct.{u5, u8} E _inst_7) (CategoryTheory.Limits.colimit.{u1, u2, u5, u8} J _inst_1 E _inst_7 (CategoryTheory.Functor.comp.{u1, u4, u5, u2, u7, u8} J _inst_1 D _inst_4 E _inst_7 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u6, u7} J _inst_1 C _inst_3 D _inst_4 F G) H) _inst_8) (CategoryTheory.Functor.obj.{u4, u5, u7, u8} D _inst_4 E _inst_7 H (CategoryTheory.Limits.colimit.{u1, u2, u4, u7} J _inst_1 D _inst_4 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u6, u7} J _inst_1 C _inst_3 D _inst_4 F G) _inst_6)) (CategoryTheory.Functor.obj.{u4, u5, u7, u8} D _inst_4 E _inst_7 H (CategoryTheory.Functor.obj.{u3, u4, u6, u7} C _inst_3 D _inst_4 G (CategoryTheory.Limits.colimit.{u1, u2, u3, u6} J _inst_1 C _inst_3 F _inst_5))) (CategoryTheory.Limits.colimit.post.{u1, u2, u4, u5, u7, u8} J _inst_1 D _inst_4 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u6, u7} J _inst_1 C _inst_3 D _inst_4 F G) E _inst_7 _inst_6 H _inst_8) (CategoryTheory.Functor.map.{u4, u5, u7, u8} D _inst_4 E _inst_7 H (CategoryTheory.Limits.colimit.{u1, u2, u4, u7} J _inst_1 D _inst_4 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u6, u7} J _inst_1 C _inst_3 D _inst_4 F G) _inst_6) (CategoryTheory.Functor.obj.{u3, u4, u6, u7} C _inst_3 D _inst_4 G (CategoryTheory.Limits.colimit.{u1, u2, u3, u6} J _inst_1 C _inst_3 F _inst_5)) (CategoryTheory.Limits.colimit.post.{u1, u2, u3, u4, u6, u7} J _inst_1 C _inst_3 F D _inst_4 _inst_5 G _inst_6))) (CategoryTheory.Limits.colimit.post.{u1, u2, u3, u5, u6, u8} J _inst_1 C _inst_3 F E _inst_7 _inst_5 (CategoryTheory.Functor.comp.{u3, u4, u5, u6, u7, u8} C _inst_3 D _inst_4 E _inst_7 G H) _inst_8)
but is expected to have type
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {C : Type.{u6}} [_inst_3 : CategoryTheory.Category.{u3, u6} C] (F : CategoryTheory.Functor.{u1, u3, u2, u6} J _inst_1 C _inst_3) {D : Type.{u7}} [_inst_4 : CategoryTheory.Category.{u4, u7} D] [_inst_5 : CategoryTheory.Limits.HasColimit.{u1, u2, u3, u6} J _inst_1 C _inst_3 F] (G : CategoryTheory.Functor.{u3, u4, u6, u7} C _inst_3 D _inst_4) [_inst_6 : CategoryTheory.Limits.HasColimit.{u1, u2, u4, u7} J _inst_1 D _inst_4 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u6, u7} J _inst_1 C _inst_3 D _inst_4 F G)] {E : Type.{u8}} [_inst_7 : CategoryTheory.Category.{u5, u8} E] (H : CategoryTheory.Functor.{u4, u5, u7, u8} D _inst_4 E _inst_7) [_inst_8 : CategoryTheory.Limits.HasColimit.{u1, u2, u5, u8} J _inst_1 E _inst_7 (CategoryTheory.Functor.comp.{u1, u4, u5, u2, u7, u8} J _inst_1 D _inst_4 E _inst_7 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u6, u7} J _inst_1 C _inst_3 D _inst_4 F G) H)], Eq.{succ u5} (Quiver.Hom.{succ u5, u8} E (CategoryTheory.CategoryStruct.toQuiver.{u5, u8} E (CategoryTheory.Category.toCategoryStruct.{u5, u8} E _inst_7)) (CategoryTheory.Limits.colimit.{u1, u2, u5, u8} J _inst_1 E _inst_7 (CategoryTheory.Functor.comp.{u1, u4, u5, u2, u7, u8} J _inst_1 D _inst_4 E _inst_7 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u6, u7} J _inst_1 C _inst_3 D _inst_4 F G) H) _inst_8) (Prefunctor.obj.{succ u4, succ u5, u7, u8} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u7} D (CategoryTheory.Category.toCategoryStruct.{u4, u7} D _inst_4)) E (CategoryTheory.CategoryStruct.toQuiver.{u5, u8} E (CategoryTheory.Category.toCategoryStruct.{u5, u8} E _inst_7)) (CategoryTheory.Functor.toPrefunctor.{u4, u5, u7, u8} D _inst_4 E _inst_7 H) (Prefunctor.obj.{succ u3, succ u4, u6, u7} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u6} C (CategoryTheory.Category.toCategoryStruct.{u3, u6} C _inst_3)) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u7} D (CategoryTheory.Category.toCategoryStruct.{u4, u7} D _inst_4)) (CategoryTheory.Functor.toPrefunctor.{u3, u4, u6, u7} C _inst_3 D _inst_4 G) (CategoryTheory.Limits.colimit.{u1, u2, u3, u6} J _inst_1 C _inst_3 F _inst_5)))) (CategoryTheory.CategoryStruct.comp.{u5, u8} E (CategoryTheory.Category.toCategoryStruct.{u5, u8} E _inst_7) (CategoryTheory.Limits.colimit.{u1, u2, u5, u8} J _inst_1 E _inst_7 (CategoryTheory.Functor.comp.{u1, u4, u5, u2, u7, u8} J _inst_1 D _inst_4 E _inst_7 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u6, u7} J _inst_1 C _inst_3 D _inst_4 F G) H) _inst_8) (Prefunctor.obj.{succ u4, succ u5, u7, u8} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u7} D (CategoryTheory.Category.toCategoryStruct.{u4, u7} D _inst_4)) E (CategoryTheory.CategoryStruct.toQuiver.{u5, u8} E (CategoryTheory.Category.toCategoryStruct.{u5, u8} E _inst_7)) (CategoryTheory.Functor.toPrefunctor.{u4, u5, u7, u8} D _inst_4 E _inst_7 H) (CategoryTheory.Limits.colimit.{u1, u2, u4, u7} J _inst_1 D _inst_4 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u6, u7} J _inst_1 C _inst_3 D _inst_4 F G) _inst_6)) (Prefunctor.obj.{succ u4, succ u5, u7, u8} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u7} D (CategoryTheory.Category.toCategoryStruct.{u4, u7} D _inst_4)) E (CategoryTheory.CategoryStruct.toQuiver.{u5, u8} E (CategoryTheory.Category.toCategoryStruct.{u5, u8} E _inst_7)) (CategoryTheory.Functor.toPrefunctor.{u4, u5, u7, u8} D _inst_4 E _inst_7 H) (Prefunctor.obj.{succ u3, succ u4, u6, u7} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u6} C (CategoryTheory.Category.toCategoryStruct.{u3, u6} C _inst_3)) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u7} D (CategoryTheory.Category.toCategoryStruct.{u4, u7} D _inst_4)) (CategoryTheory.Functor.toPrefunctor.{u3, u4, u6, u7} C _inst_3 D _inst_4 G) (CategoryTheory.Limits.colimit.{u1, u2, u3, u6} J _inst_1 C _inst_3 F _inst_5))) (CategoryTheory.Limits.colimit.post.{u1, u2, u4, u5, u7, u8} J _inst_1 D _inst_4 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u6, u7} J _inst_1 C _inst_3 D _inst_4 F G) E _inst_7 _inst_6 H _inst_8) (Prefunctor.map.{succ u4, succ u5, u7, u8} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u7} D (CategoryTheory.Category.toCategoryStruct.{u4, u7} D _inst_4)) E (CategoryTheory.CategoryStruct.toQuiver.{u5, u8} E (CategoryTheory.Category.toCategoryStruct.{u5, u8} E _inst_7)) (CategoryTheory.Functor.toPrefunctor.{u4, u5, u7, u8} D _inst_4 E _inst_7 H) (CategoryTheory.Limits.colimit.{u1, u2, u4, u7} J _inst_1 D _inst_4 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u6, u7} J _inst_1 C _inst_3 D _inst_4 F G) _inst_6) (Prefunctor.obj.{succ u3, succ u4, u6, u7} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u6} C (CategoryTheory.Category.toCategoryStruct.{u3, u6} C _inst_3)) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u7} D (CategoryTheory.Category.toCategoryStruct.{u4, u7} D _inst_4)) (CategoryTheory.Functor.toPrefunctor.{u3, u4, u6, u7} C _inst_3 D _inst_4 G) (CategoryTheory.Limits.colimit.{u1, u2, u3, u6} J _inst_1 C _inst_3 F _inst_5)) (CategoryTheory.Limits.colimit.post.{u1, u2, u3, u4, u6, u7} J _inst_1 C _inst_3 F D _inst_4 _inst_5 G _inst_6))) (CategoryTheory.Limits.colimit.post.{u1, u2, u3, u5, u6, u8} J _inst_1 C _inst_3 F E _inst_7 _inst_5 (CategoryTheory.Functor.comp.{u3, u4, u5, u6, u7, u8} C _inst_3 D _inst_4 E _inst_7 G H) _inst_8)
Case conversion may be inaccurate. Consider using '#align category_theory.limits.colimit.post_post CategoryTheory.Limits.colimit.post_post‚Çì'. -/
@[simp]
theorem colimit.post_post {E : Type u''} [Category.{v''} E] (H : D ‚•§ E)
    [HasColimit
        ((F ‚ãô G) ‚ãô H)] :-- H G (colimit F) ‚ü∂ H (colimit (F ‚ãô G)) ‚ü∂ colimit ((F ‚ãô G) ‚ãô H) equals 
          -- H G (colimit F) ‚ü∂ colimit (F ‚ãô (G ‚ãô H))
          colimit.post
          (F ‚ãô G) H ‚â´
        H.map (colimit.post F G) =
      colimit.post F (G ‚ãô H) :=
  by
  ext
  rw [‚Üê assoc, colimit.Œπ_post, ‚Üê H.map_comp, colimit.Œπ_post]
  exact (colimit.Œπ_post F (G ‚ãô H) j).symm
#align category_theory.limits.colimit.post_post CategoryTheory.Limits.colimit.post_post

end Post

/- warning: category_theory.limits.colimit.pre_post -> CategoryTheory.Limits.colimit.pre_post is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {K : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u3, u4} K] {C : Type.{u7}} [_inst_3 : CategoryTheory.Category.{u5, u7} C] {D : Type.{u8}} [_inst_4 : CategoryTheory.Category.{u6, u8} D] (E : CategoryTheory.Functor.{u3, u1, u4, u2} K _inst_2 J _inst_1) (F : CategoryTheory.Functor.{u1, u5, u2, u7} J _inst_1 C _inst_3) (G : CategoryTheory.Functor.{u5, u6, u7, u8} C _inst_3 D _inst_4) [_inst_5 : CategoryTheory.Limits.HasColimit.{u1, u2, u5, u7} J _inst_1 C _inst_3 F] [_inst_6 : CategoryTheory.Limits.HasColimit.{u3, u4, u5, u7} K _inst_2 C _inst_3 (CategoryTheory.Functor.comp.{u3, u1, u5, u4, u2, u7} K _inst_2 J _inst_1 C _inst_3 E F)] [_inst_7 : CategoryTheory.Limits.HasColimit.{u1, u2, u6, u8} J _inst_1 D _inst_4 (CategoryTheory.Functor.comp.{u1, u5, u6, u2, u7, u8} J _inst_1 C _inst_3 D _inst_4 F G)] [H : CategoryTheory.Limits.HasColimit.{u3, u4, u6, u8} K _inst_2 D _inst_4 (CategoryTheory.Functor.comp.{u3, u5, u6, u4, u7, u8} K _inst_2 C _inst_3 D _inst_4 (CategoryTheory.Functor.comp.{u3, u1, u5, u4, u2, u7} K _inst_2 J _inst_1 C _inst_3 E F) G)], Eq.{succ u6} (Quiver.Hom.{succ u6, u8} D (CategoryTheory.CategoryStruct.toQuiver.{u6, u8} D (CategoryTheory.Category.toCategoryStruct.{u6, u8} D _inst_4)) (CategoryTheory.Limits.colimit.{u3, u4, u6, u8} K _inst_2 D _inst_4 (CategoryTheory.Functor.comp.{u3, u5, u6, u4, u7, u8} K _inst_2 C _inst_3 D _inst_4 (CategoryTheory.Functor.comp.{u3, u1, u5, u4, u2, u7} K _inst_2 J _inst_1 C _inst_3 E F) G) H) (CategoryTheory.Functor.obj.{u5, u6, u7, u8} C _inst_3 D _inst_4 G (CategoryTheory.Limits.colimit.{u1, u2, u5, u7} J _inst_1 C _inst_3 F _inst_5))) (CategoryTheory.CategoryStruct.comp.{u6, u8} D (CategoryTheory.Category.toCategoryStruct.{u6, u8} D _inst_4) (CategoryTheory.Limits.colimit.{u3, u4, u6, u8} K _inst_2 D _inst_4 (CategoryTheory.Functor.comp.{u3, u5, u6, u4, u7, u8} K _inst_2 C _inst_3 D _inst_4 (CategoryTheory.Functor.comp.{u3, u1, u5, u4, u2, u7} K _inst_2 J _inst_1 C _inst_3 E F) G) H) (CategoryTheory.Functor.obj.{u5, u6, u7, u8} C _inst_3 D _inst_4 G (CategoryTheory.Limits.colimit.{u3, u4, u5, u7} K _inst_2 C _inst_3 (CategoryTheory.Functor.comp.{u3, u1, u5, u4, u2, u7} K _inst_2 J _inst_1 C _inst_3 E F) _inst_6)) (CategoryTheory.Functor.obj.{u5, u6, u7, u8} C _inst_3 D _inst_4 G (CategoryTheory.Limits.colimit.{u1, u2, u5, u7} J _inst_1 C _inst_3 F _inst_5)) (CategoryTheory.Limits.colimit.post.{u3, u4, u5, u6, u7, u8} K _inst_2 C _inst_3 (CategoryTheory.Functor.comp.{u3, u1, u5, u4, u2, u7} K _inst_2 J _inst_1 C _inst_3 E F) D _inst_4 _inst_6 G H) (CategoryTheory.Functor.map.{u5, u6, u7, u8} C _inst_3 D _inst_4 G (CategoryTheory.Limits.colimit.{u3, u4, u5, u7} K _inst_2 C _inst_3 (CategoryTheory.Functor.comp.{u3, u1, u5, u4, u2, u7} K _inst_2 J _inst_1 C _inst_3 E F) _inst_6) (CategoryTheory.Limits.colimit.{u1, u2, u5, u7} J _inst_1 C _inst_3 F _inst_5) (CategoryTheory.Limits.colimit.pre.{u1, u2, u3, u4, u5, u7} J _inst_1 K _inst_2 C _inst_3 F _inst_5 E _inst_6))) (CategoryTheory.CategoryStruct.comp.{u6, u8} D (CategoryTheory.Category.toCategoryStruct.{u6, u8} D _inst_4) (CategoryTheory.Limits.colimit.{u3, u4, u6, u8} K _inst_2 D _inst_4 (CategoryTheory.Functor.comp.{u3, u1, u6, u4, u2, u8} K _inst_2 J _inst_1 D _inst_4 E (CategoryTheory.Functor.comp.{u1, u5, u6, u2, u7, u8} J _inst_1 C _inst_3 D _inst_4 F G)) H) (CategoryTheory.Limits.colimit.{u1, u2, u6, u8} J _inst_1 D _inst_4 (CategoryTheory.Functor.comp.{u1, u5, u6, u2, u7, u8} J _inst_1 C _inst_3 D _inst_4 F G) _inst_7) (CategoryTheory.Functor.obj.{u5, u6, u7, u8} C _inst_3 D _inst_4 G (CategoryTheory.Limits.colimit.{u1, u2, u5, u7} J _inst_1 C _inst_3 F _inst_5)) (CategoryTheory.Limits.colimit.pre.{u1, u2, u3, u4, u6, u8} J _inst_1 K _inst_2 D _inst_4 (CategoryTheory.Functor.comp.{u1, u5, u6, u2, u7, u8} J _inst_1 C _inst_3 D _inst_4 F G) _inst_7 E H) (CategoryTheory.Limits.colimit.post.{u1, u2, u5, u6, u7, u8} J _inst_1 C _inst_3 F D _inst_4 _inst_5 G _inst_7))
but is expected to have type
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {K : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u3, u4} K] {C : Type.{u7}} [_inst_3 : CategoryTheory.Category.{u5, u7} C] {D : Type.{u8}} [_inst_4 : CategoryTheory.Category.{u6, u8} D] (E : CategoryTheory.Functor.{u3, u1, u4, u2} K _inst_2 J _inst_1) (F : CategoryTheory.Functor.{u1, u5, u2, u7} J _inst_1 C _inst_3) (G : CategoryTheory.Functor.{u5, u6, u7, u8} C _inst_3 D _inst_4) [_inst_5 : CategoryTheory.Limits.HasColimit.{u1, u2, u5, u7} J _inst_1 C _inst_3 F] [_inst_6 : CategoryTheory.Limits.HasColimit.{u3, u4, u5, u7} K _inst_2 C _inst_3 (CategoryTheory.Functor.comp.{u3, u1, u5, u4, u2, u7} K _inst_2 J _inst_1 C _inst_3 E F)] [_inst_7 : CategoryTheory.Limits.HasColimit.{u1, u2, u6, u8} J _inst_1 D _inst_4 (CategoryTheory.Functor.comp.{u1, u5, u6, u2, u7, u8} J _inst_1 C _inst_3 D _inst_4 F G)] [H : CategoryTheory.Limits.HasColimit.{u3, u4, u6, u8} K _inst_2 D _inst_4 (CategoryTheory.Functor.comp.{u3, u5, u6, u4, u7, u8} K _inst_2 C _inst_3 D _inst_4 (CategoryTheory.Functor.comp.{u3, u1, u5, u4, u2, u7} K _inst_2 J _inst_1 C _inst_3 E F) G)], Eq.{succ u6} (Quiver.Hom.{succ u6, u8} D (CategoryTheory.CategoryStruct.toQuiver.{u6, u8} D (CategoryTheory.Category.toCategoryStruct.{u6, u8} D _inst_4)) (CategoryTheory.Limits.colimit.{u3, u4, u6, u8} K _inst_2 D _inst_4 (CategoryTheory.Functor.comp.{u3, u5, u6, u4, u7, u8} K _inst_2 C _inst_3 D _inst_4 (CategoryTheory.Functor.comp.{u3, u1, u5, u4, u2, u7} K _inst_2 J _inst_1 C _inst_3 E F) G) H) (Prefunctor.obj.{succ u5, succ u6, u7, u8} C (CategoryTheory.CategoryStruct.toQuiver.{u5, u7} C (CategoryTheory.Category.toCategoryStruct.{u5, u7} C _inst_3)) D (CategoryTheory.CategoryStruct.toQuiver.{u6, u8} D (CategoryTheory.Category.toCategoryStruct.{u6, u8} D _inst_4)) (CategoryTheory.Functor.toPrefunctor.{u5, u6, u7, u8} C _inst_3 D _inst_4 G) (CategoryTheory.Limits.colimit.{u1, u2, u5, u7} J _inst_1 C _inst_3 F _inst_5))) (CategoryTheory.CategoryStruct.comp.{u6, u8} D (CategoryTheory.Category.toCategoryStruct.{u6, u8} D _inst_4) (CategoryTheory.Limits.colimit.{u3, u4, u6, u8} K _inst_2 D _inst_4 (CategoryTheory.Functor.comp.{u3, u5, u6, u4, u7, u8} K _inst_2 C _inst_3 D _inst_4 (CategoryTheory.Functor.comp.{u3, u1, u5, u4, u2, u7} K _inst_2 J _inst_1 C _inst_3 E F) G) H) (Prefunctor.obj.{succ u5, succ u6, u7, u8} C (CategoryTheory.CategoryStruct.toQuiver.{u5, u7} C (CategoryTheory.Category.toCategoryStruct.{u5, u7} C _inst_3)) D (CategoryTheory.CategoryStruct.toQuiver.{u6, u8} D (CategoryTheory.Category.toCategoryStruct.{u6, u8} D _inst_4)) (CategoryTheory.Functor.toPrefunctor.{u5, u6, u7, u8} C _inst_3 D _inst_4 G) (CategoryTheory.Limits.colimit.{u3, u4, u5, u7} K _inst_2 C _inst_3 (CategoryTheory.Functor.comp.{u3, u1, u5, u4, u2, u7} K _inst_2 J _inst_1 C _inst_3 E F) _inst_6)) (Prefunctor.obj.{succ u5, succ u6, u7, u8} C (CategoryTheory.CategoryStruct.toQuiver.{u5, u7} C (CategoryTheory.Category.toCategoryStruct.{u5, u7} C _inst_3)) D (CategoryTheory.CategoryStruct.toQuiver.{u6, u8} D (CategoryTheory.Category.toCategoryStruct.{u6, u8} D _inst_4)) (CategoryTheory.Functor.toPrefunctor.{u5, u6, u7, u8} C _inst_3 D _inst_4 G) (CategoryTheory.Limits.colimit.{u1, u2, u5, u7} J _inst_1 C _inst_3 F _inst_5)) (CategoryTheory.Limits.colimit.post.{u3, u4, u5, u6, u7, u8} K _inst_2 C _inst_3 (CategoryTheory.Functor.comp.{u3, u1, u5, u4, u2, u7} K _inst_2 J _inst_1 C _inst_3 E F) D _inst_4 _inst_6 G H) (Prefunctor.map.{succ u5, succ u6, u7, u8} C (CategoryTheory.CategoryStruct.toQuiver.{u5, u7} C (CategoryTheory.Category.toCategoryStruct.{u5, u7} C _inst_3)) D (CategoryTheory.CategoryStruct.toQuiver.{u6, u8} D (CategoryTheory.Category.toCategoryStruct.{u6, u8} D _inst_4)) (CategoryTheory.Functor.toPrefunctor.{u5, u6, u7, u8} C _inst_3 D _inst_4 G) (CategoryTheory.Limits.colimit.{u3, u4, u5, u7} K _inst_2 C _inst_3 (CategoryTheory.Functor.comp.{u3, u1, u5, u4, u2, u7} K _inst_2 J _inst_1 C _inst_3 E F) _inst_6) (CategoryTheory.Limits.colimit.{u1, u2, u5, u7} J _inst_1 C _inst_3 F _inst_5) (CategoryTheory.Limits.colimit.pre.{u1, u2, u3, u4, u5, u7} J _inst_1 K _inst_2 C _inst_3 F _inst_5 E _inst_6))) (CategoryTheory.CategoryStruct.comp.{u6, u8} D (CategoryTheory.Category.toCategoryStruct.{u6, u8} D _inst_4) (CategoryTheory.Limits.colimit.{u3, u4, u6, u8} K _inst_2 D _inst_4 (CategoryTheory.Functor.comp.{u3, u1, u6, u4, u2, u8} K _inst_2 J _inst_1 D _inst_4 E (CategoryTheory.Functor.comp.{u1, u5, u6, u2, u7, u8} J _inst_1 C _inst_3 D _inst_4 F G)) H) (CategoryTheory.Limits.colimit.{u1, u2, u6, u8} J _inst_1 D _inst_4 (CategoryTheory.Functor.comp.{u1, u5, u6, u2, u7, u8} J _inst_1 C _inst_3 D _inst_4 F G) _inst_7) (Prefunctor.obj.{succ u5, succ u6, u7, u8} C (CategoryTheory.CategoryStruct.toQuiver.{u5, u7} C (CategoryTheory.Category.toCategoryStruct.{u5, u7} C _inst_3)) D (CategoryTheory.CategoryStruct.toQuiver.{u6, u8} D (CategoryTheory.Category.toCategoryStruct.{u6, u8} D _inst_4)) (CategoryTheory.Functor.toPrefunctor.{u5, u6, u7, u8} C _inst_3 D _inst_4 G) (CategoryTheory.Limits.colimit.{u1, u2, u5, u7} J _inst_1 C _inst_3 F _inst_5)) (CategoryTheory.Limits.colimit.pre.{u1, u2, u3, u4, u6, u8} J _inst_1 K _inst_2 D _inst_4 (CategoryTheory.Functor.comp.{u1, u5, u6, u2, u7, u8} J _inst_1 C _inst_3 D _inst_4 F G) _inst_7 E H) (CategoryTheory.Limits.colimit.post.{u1, u2, u5, u6, u7, u8} J _inst_1 C _inst_3 F D _inst_4 _inst_5 G _inst_7))
Case conversion may be inaccurate. Consider using '#align category_theory.limits.colimit.pre_post CategoryTheory.Limits.colimit.pre_post‚Çì'. -/
theorem colimit.pre_post {D : Type u'} [Category.{v'} D] (E : K ‚•§ J) (F : J ‚•§ C) (G : C ‚•§ D)
    [HasColimit F] [HasColimit (E ‚ãô F)] [HasColimit (F ‚ãô G)]
    [H :
      HasColimit ((E ‚ãô F) ‚ãô G)] :-- G (colimit F) ‚ü∂ G (colimit (E ‚ãô F)) ‚ü∂ colimit ((E ‚ãô F) ‚ãô G) vs 
          -- G (colimit F) ‚ü∂ colimit F ‚ãô G ‚ü∂ colimit (E ‚ãô (F ‚ãô G)) or
          colimit.post
          (E ‚ãô F) G ‚â´
        G.map (colimit.pre F E) =
      (@colimit.pre _ _ _ (F ‚ãô G) _ E H ‚â´ colimit.post F G : _) :=
  by
  ext
  rw [‚Üê assoc, colimit.Œπ_post, ‚Üê G.map_comp, colimit.Œπ_pre, ‚Üê assoc]
  letI : has_colimit (E ‚ãô F ‚ãô G) := show has_colimit ((E ‚ãô F) ‚ãô G) by infer_instance
  erw [colimit.Œπ_pre (F ‚ãô G) E j, colimit.Œπ_post]
#align category_theory.limits.colimit.pre_post CategoryTheory.Limits.colimit.pre_post

open CategoryTheory.Equivalence

/- warning: category_theory.limits.has_colimit_equivalence_comp -> CategoryTheory.Limits.hasColimit_equivalence_comp is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {K : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u3, u4} K] {C : Type.{u6}} [_inst_3 : CategoryTheory.Category.{u5, u6} C] {F : CategoryTheory.Functor.{u1, u5, u2, u6} J _inst_1 C _inst_3} (e : CategoryTheory.Equivalence.{u3, u1, u4, u2} K _inst_2 J _inst_1) [_inst_4 : CategoryTheory.Limits.HasColimit.{u1, u2, u5, u6} J _inst_1 C _inst_3 F], CategoryTheory.Limits.HasColimit.{u3, u4, u5, u6} K _inst_2 C _inst_3 (CategoryTheory.Functor.comp.{u3, u1, u5, u4, u2, u6} K _inst_2 J _inst_1 C _inst_3 (CategoryTheory.Equivalence.functor.{u3, u1, u4, u2} K _inst_2 J _inst_1 e) F)
but is expected to have type
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {K : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u3, u4} K] {C : Type.{u6}} [_inst_3 : CategoryTheory.Category.{u5, u6} C] {F : CategoryTheory.Functor.{u1, u5, u2, u6} J _inst_1 C _inst_3} (e : CategoryTheory.Equivalence.{u3, u1, u4, u2} K J _inst_2 _inst_1) [_inst_4 : CategoryTheory.Limits.HasColimit.{u1, u2, u5, u6} J _inst_1 C _inst_3 F], CategoryTheory.Limits.HasColimit.{u3, u4, u5, u6} K _inst_2 C _inst_3 (CategoryTheory.Functor.comp.{u3, u1, u5, u4, u2, u6} K _inst_2 J _inst_1 C _inst_3 (CategoryTheory.Equivalence.functor.{u3, u1, u4, u2} K J _inst_2 _inst_1 e) F)
Case conversion may be inaccurate. Consider using '#align category_theory.limits.has_colimit_equivalence_comp CategoryTheory.Limits.hasColimit_equivalence_comp‚Çì'. -/
instance hasColimit_equivalence_comp (e : K ‚âå J) [HasColimit F] : HasColimit (e.Functor ‚ãô F) :=
  HasColimit.mk
    { Cocone := Cocone.whisker e.Functor (colimit.cocone F)
      IsColimit := IsColimit.whiskerEquivalence (colimit.isColimit F) e }
#align category_theory.limits.has_colimit_equivalence_comp CategoryTheory.Limits.hasColimit_equivalence_comp

/- warning: category_theory.limits.has_colimit_of_equivalence_comp -> CategoryTheory.Limits.hasColimit_of_equivalence_comp is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {K : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u3, u4} K] {C : Type.{u6}} [_inst_3 : CategoryTheory.Category.{u5, u6} C] {F : CategoryTheory.Functor.{u1, u5, u2, u6} J _inst_1 C _inst_3} (e : CategoryTheory.Equivalence.{u3, u1, u4, u2} K _inst_2 J _inst_1) [_inst_4 : CategoryTheory.Limits.HasColimit.{u3, u4, u5, u6} K _inst_2 C _inst_3 (CategoryTheory.Functor.comp.{u3, u1, u5, u4, u2, u6} K _inst_2 J _inst_1 C _inst_3 (CategoryTheory.Equivalence.functor.{u3, u1, u4, u2} K _inst_2 J _inst_1 e) F)], CategoryTheory.Limits.HasColimit.{u1, u2, u5, u6} J _inst_1 C _inst_3 F
but is expected to have type
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {K : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u3, u4} K] {C : Type.{u6}} [_inst_3 : CategoryTheory.Category.{u5, u6} C] {F : CategoryTheory.Functor.{u1, u5, u2, u6} J _inst_1 C _inst_3} (e : CategoryTheory.Equivalence.{u3, u1, u4, u2} K J _inst_2 _inst_1) [_inst_4 : CategoryTheory.Limits.HasColimit.{u3, u4, u5, u6} K _inst_2 C _inst_3 (CategoryTheory.Functor.comp.{u3, u1, u5, u4, u2, u6} K _inst_2 J _inst_1 C _inst_3 (CategoryTheory.Equivalence.functor.{u3, u1, u4, u2} K J _inst_2 _inst_1 e) F)], CategoryTheory.Limits.HasColimit.{u1, u2, u5, u6} J _inst_1 C _inst_3 F
Case conversion may be inaccurate. Consider using '#align category_theory.limits.has_colimit_of_equivalence_comp CategoryTheory.Limits.hasColimit_of_equivalence_comp‚Çì'. -/
/-- If a `E ‚ãô F` has a colimit, and `E` is an equivalence, we can construct a colimit of `F`.
-/
theorem hasColimit_of_equivalence_comp (e : K ‚âå J) [HasColimit (e.Functor ‚ãô F)] : HasColimit F :=
  by
  haveI : has_colimit (e.inverse ‚ãô e.functor ‚ãô F) := limits.has_colimit_equivalence_comp e.symm
  apply has_colimit_of_iso (e.inv_fun_id_assoc F).symm
#align category_theory.limits.has_colimit_of_equivalence_comp CategoryTheory.Limits.hasColimit_of_equivalence_comp

section ColimFunctor

variable [HasColimitsOfShape J C]

section

attribute [local simp] colim_map

#print CategoryTheory.Limits.colim /-
/-- `colimit F` is functorial in `F`, when `C` has all colimits of shape `J`. -/
@[simps obj]
def colim : (J ‚•§ C) ‚•§ C where
  obj F := colimit F
  map F G Œ± := colimMap Œ±
  map_id' F := by
    ext
    erw [Œπ_colim_map, id_comp, comp_id]
  map_comp' F G H Œ± Œ≤ := by
    ext
    erw [‚Üê assoc, is_colimit.fac, is_colimit.fac, assoc, is_colimit.fac, ‚Üê assoc]
    rfl
#align category_theory.limits.colim CategoryTheory.Limits.colim
-/

end

variable {F} {G : J ‚•§ C} (Œ± : F ‚ü∂ G)

/- warning: category_theory.limits.colimit.Œπ_map -> CategoryTheory.Limits.colimit.Œπ_map is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {C : Type.{u4}} [_inst_3 : CategoryTheory.Category.{u3, u4} C] {F : CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3} [_inst_4 : CategoryTheory.Limits.HasColimitsOfShape.{u1, u2, u3, u4} J _inst_1 C _inst_3] {G : CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3} (Œ± : Quiver.Hom.{succ (max u2 u3), max u1 u3 u2 u4} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u3, max u1 u3 u2 u4} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Category.toCategoryStruct.{max u2 u3, max u1 u3 u2 u4} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3))) F G) (j : J), Eq.{succ u3} (Quiver.Hom.{succ u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Functor.obj.{u1, u3, u2, u4} J _inst_1 C _inst_3 F j) (CategoryTheory.Functor.obj.{max u2 u3, u3, max u1 u3 u2 u4, u4} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3) C _inst_3 (CategoryTheory.Limits.colim.{u1, u2, u3, u4} J _inst_1 C _inst_3 _inst_4) G)) (CategoryTheory.CategoryStruct.comp.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3) (CategoryTheory.Functor.obj.{u1, u3, u2, u4} J _inst_1 C _inst_3 F j) (CategoryTheory.Limits.colimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u1, u2, u3, u4} C _inst_3 J _inst_1 _inst_4 F)) (CategoryTheory.Functor.obj.{max u2 u3, u3, max u1 u3 u2 u4, u4} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3) C _inst_3 (CategoryTheory.Limits.colim.{u1, u2, u3, u4} J _inst_1 C _inst_3 _inst_4) G) (CategoryTheory.Limits.colimit.Œπ.{u1, u2, u3, u4} J _inst_1 C _inst_3 F (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u1, u2, u3, u4} C _inst_3 J _inst_1 _inst_4 F) j) (CategoryTheory.Functor.map.{max u2 u3, u3, max u1 u3 u2 u4, u4} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3) C _inst_3 (CategoryTheory.Limits.colim.{u1, u2, u3, u4} J _inst_1 C _inst_3 _inst_4) F G Œ±)) (CategoryTheory.CategoryStruct.comp.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3) (CategoryTheory.Functor.obj.{u1, u3, u2, u4} J _inst_1 C _inst_3 F j) (CategoryTheory.Functor.obj.{u1, u3, u2, u4} J _inst_1 C _inst_3 G j) (CategoryTheory.Functor.obj.{max u2 u3, u3, max u1 u3 u2 u4, u4} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3) C _inst_3 (CategoryTheory.Limits.colim.{u1, u2, u3, u4} J _inst_1 C _inst_3 _inst_4) G) (CategoryTheory.NatTrans.app.{u1, u3, u2, u4} J _inst_1 C _inst_3 F G Œ± j) (CategoryTheory.Limits.colimit.Œπ.{u1, u2, u3, u4} J _inst_1 C _inst_3 G (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u1, u2, u3, u4} C _inst_3 J _inst_1 _inst_4 G) j))
but is expected to have type
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {C : Type.{u4}} [_inst_3 : CategoryTheory.Category.{u3, u4} C] {F : CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3} [_inst_4 : CategoryTheory.Limits.HasColimitsOfShape.{u1, u2, u3, u4} J _inst_1 C _inst_3] {G : CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3} (Œ± : Quiver.Hom.{max (succ u2) (succ u3), max (max (max u4 u2) u3) u1} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u3, max (max (max u4 u2) u3) u1} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Category.toCategoryStruct.{max u2 u3, max (max (max u4 u2) u3) u1} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3))) F G) (j : J), Eq.{succ u3} (Quiver.Hom.{succ u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (Prefunctor.obj.{succ u1, succ u3, u2, u4} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, u4} J _inst_1 C _inst_3 F) j) (Prefunctor.obj.{max (succ u2) (succ u3), succ u3, max (max (max u2 u1) u4) u3, u4} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max (max (max u4 u3) u2) u1} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max (max (max u4 u3) u2) u1} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3))) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, u3, max (max (max u4 u3) u2) u1, u4} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3) C _inst_3 (CategoryTheory.Limits.colim.{u1, u2, u3, u4} J _inst_1 C _inst_3 _inst_4)) G)) (CategoryTheory.CategoryStruct.comp.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3) (Prefunctor.obj.{succ u1, succ u3, u2, u4} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, u4} J _inst_1 C _inst_3 F) j) (CategoryTheory.Limits.colimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u1, u2, u3, u4} C _inst_3 J _inst_1 _inst_4 F)) (Prefunctor.obj.{max (succ u2) (succ u3), succ u3, max (max (max u2 u1) u4) u3, u4} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max (max (max u4 u3) u2) u1} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max (max (max u4 u3) u2) u1} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3))) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, u3, max (max (max u4 u3) u2) u1, u4} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3) C _inst_3 (CategoryTheory.Limits.colim.{u1, u2, u3, u4} J _inst_1 C _inst_3 _inst_4)) G) (CategoryTheory.Limits.colimit.Œπ.{u1, u2, u3, u4} J _inst_1 C _inst_3 F (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u1, u2, u3, u4} C _inst_3 J _inst_1 _inst_4 F) j) (Prefunctor.map.{max (succ u2) (succ u3), succ u3, max (max (max u2 u1) u4) u3, u4} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max (max (max u4 u3) u2) u1} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max (max (max u4 u3) u2) u1} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3))) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, u3, max (max (max u4 u3) u2) u1, u4} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3) C _inst_3 (CategoryTheory.Limits.colim.{u1, u2, u3, u4} J _inst_1 C _inst_3 _inst_4)) F G Œ±)) (CategoryTheory.CategoryStruct.comp.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3) (Prefunctor.obj.{succ u1, succ u3, u2, u4} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, u4} J _inst_1 C _inst_3 F) j) (Prefunctor.obj.{succ u1, succ u3, u2, u4} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, u4} J _inst_1 C _inst_3 G) j) (CategoryTheory.Limits.colimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 G (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u1, u2, u3, u4} C _inst_3 J _inst_1 _inst_4 G)) (CategoryTheory.NatTrans.app.{u1, u3, u2, u4} J _inst_1 C _inst_3 F G Œ± j) (CategoryTheory.Limits.colimit.Œπ.{u1, u2, u3, u4} J _inst_1 C _inst_3 G (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u1, u2, u3, u4} C _inst_3 J _inst_1 _inst_4 G) j))
Case conversion may be inaccurate. Consider using '#align category_theory.limits.colimit.Œπ_map CategoryTheory.Limits.colimit.Œπ_map‚Çì'. -/
@[simp, reassoc.1]
theorem colimit.Œπ_map (j : J) : colimit.Œπ F j ‚â´ colim.map Œ± = Œ±.app j ‚â´ colimit.Œπ G j := by
  apply is_colimit.fac
#align category_theory.limits.colimit.Œπ_map CategoryTheory.Limits.colimit.Œπ_map

/- warning: category_theory.limits.colimit.map_desc -> CategoryTheory.Limits.colimit.map_desc is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {C : Type.{u4}} [_inst_3 : CategoryTheory.Category.{u3, u4} C] {F : CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3} [_inst_4 : CategoryTheory.Limits.HasColimitsOfShape.{u1, u2, u3, u4} J _inst_1 C _inst_3] {G : CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3} (Œ± : Quiver.Hom.{succ (max u2 u3), max u1 u3 u2 u4} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u3, max u1 u3 u2 u4} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Category.toCategoryStruct.{max u2 u3, max u1 u3 u2 u4} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3))) F G) (c : CategoryTheory.Limits.Cocone.{u1, u3, u2, u4} J _inst_1 C _inst_3 G), Eq.{succ u3} (Quiver.Hom.{succ u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Functor.obj.{max u2 u3, u3, max u1 u3 u2 u4, u4} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3) C _inst_3 (CategoryTheory.Limits.colim.{u1, u2, u3, u4} J _inst_1 C _inst_3 _inst_4) F) (CategoryTheory.Limits.Cocone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 G c)) (CategoryTheory.CategoryStruct.comp.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3) (CategoryTheory.Functor.obj.{max u2 u3, u3, max u1 u3 u2 u4, u4} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3) C _inst_3 (CategoryTheory.Limits.colim.{u1, u2, u3, u4} J _inst_1 C _inst_3 _inst_4) F) (CategoryTheory.Functor.obj.{max u2 u3, u3, max u1 u3 u2 u4, u4} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3) C _inst_3 (CategoryTheory.Limits.colim.{u1, u2, u3, u4} J _inst_1 C _inst_3 _inst_4) G) (CategoryTheory.Limits.Cocone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 G c) (CategoryTheory.Functor.map.{max u2 u3, u3, max u1 u3 u2 u4, u4} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3) C _inst_3 (CategoryTheory.Limits.colim.{u1, u2, u3, u4} J _inst_1 C _inst_3 _inst_4) F G Œ±) (CategoryTheory.Limits.colimit.desc.{u1, u2, u3, u4} J _inst_1 C _inst_3 G (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u1, u2, u3, u4} C _inst_3 J _inst_1 _inst_4 G) c)) (CategoryTheory.Limits.colimit.desc.{u1, u2, u3, u4} J _inst_1 C _inst_3 F (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u1, u2, u3, u4} C _inst_3 J _inst_1 _inst_4 F) (CategoryTheory.Functor.obj.{u3, u3, max u2 u4 u3, max u2 u4 u3} (CategoryTheory.Limits.Cocone.{u1, u3, u2, u4} J _inst_1 C _inst_3 G) (CategoryTheory.Limits.Cocone.category.{u1, u3, u2, u4} J _inst_1 C _inst_3 G) (CategoryTheory.Limits.Cocone.{u1, u3, u2, u4} J _inst_1 C _inst_3 F) (CategoryTheory.Limits.Cocone.category.{u1, u3, u2, u4} J _inst_1 C _inst_3 F) (CategoryTheory.Limits.Cocones.precompose.{u1, u3, u2, u4} J _inst_1 C _inst_3 G F Œ±) c))
but is expected to have type
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {C : Type.{u4}} [_inst_3 : CategoryTheory.Category.{u3, u4} C] {F : CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3} [_inst_4 : CategoryTheory.Limits.HasColimitsOfShape.{u1, u2, u3, u4} J _inst_1 C _inst_3] {G : CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3} (Œ± : Quiver.Hom.{max (succ u2) (succ u3), max (max (max u4 u2) u3) u1} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u3, max (max (max u4 u2) u3) u1} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Category.toCategoryStruct.{max u2 u3, max (max (max u4 u2) u3) u1} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3))) F G) (c : CategoryTheory.Limits.Cocone.{u1, u3, u2, u4} J _inst_1 C _inst_3 G), Eq.{succ u3} (Quiver.Hom.{succ u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Limits.colimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u1, u2, u3, u4} C _inst_3 J _inst_1 _inst_4 F)) (CategoryTheory.Limits.Cocone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 G c)) (CategoryTheory.CategoryStruct.comp.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3) (CategoryTheory.Limits.colimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u1, u2, u3, u4} C _inst_3 J _inst_1 _inst_4 F)) (CategoryTheory.Limits.colimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 G (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u1, u2, u3, u4} C _inst_3 J _inst_1 _inst_4 G)) (CategoryTheory.Limits.Cocone.pt.{u1, u3, u2, u4} J _inst_1 C _inst_3 G c) (CategoryTheory.Limits.colimMap.{u1, u2, u3, u4} J _inst_1 C _inst_3 F G (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u1, u2, u3, u4} C _inst_3 J _inst_1 _inst_4 F) (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u1, u2, u3, u4} C _inst_3 J _inst_1 _inst_4 G) Œ±) (CategoryTheory.Limits.colimit.desc.{u1, u2, u3, u4} J _inst_1 C _inst_3 G (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u1, u2, u3, u4} C _inst_3 J _inst_1 _inst_4 G) c)) (CategoryTheory.Limits.colimit.desc.{u1, u2, u3, u4} J _inst_1 C _inst_3 F (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u1, u2, u3, u4} C _inst_3 J _inst_1 _inst_4 F) (Prefunctor.obj.{succ u3, succ u3, max (max u4 u2) u3, max (max u4 u2) u3} (CategoryTheory.Limits.Cocone.{u1, u3, u2, u4} J _inst_1 C _inst_3 G) (CategoryTheory.CategoryStruct.toQuiver.{u3, max (max u4 u2) u3} (CategoryTheory.Limits.Cocone.{u1, u3, u2, u4} J _inst_1 C _inst_3 G) (CategoryTheory.Category.toCategoryStruct.{u3, max (max u4 u2) u3} (CategoryTheory.Limits.Cocone.{u1, u3, u2, u4} J _inst_1 C _inst_3 G) (CategoryTheory.Limits.Cocone.category.{u1, u3, u2, u4} J _inst_1 C _inst_3 G))) (CategoryTheory.Limits.Cocone.{u1, u3, u2, u4} J _inst_1 C _inst_3 F) (CategoryTheory.CategoryStruct.toQuiver.{u3, max (max u4 u2) u3} (CategoryTheory.Limits.Cocone.{u1, u3, u2, u4} J _inst_1 C _inst_3 F) (CategoryTheory.Category.toCategoryStruct.{u3, max (max u4 u2) u3} (CategoryTheory.Limits.Cocone.{u1, u3, u2, u4} J _inst_1 C _inst_3 F) (CategoryTheory.Limits.Cocone.category.{u1, u3, u2, u4} J _inst_1 C _inst_3 F))) (CategoryTheory.Functor.toPrefunctor.{u3, u3, max (max u4 u2) u3, max (max u4 u2) u3} (CategoryTheory.Limits.Cocone.{u1, u3, u2, u4} J _inst_1 C _inst_3 G) (CategoryTheory.Limits.Cocone.category.{u1, u3, u2, u4} J _inst_1 C _inst_3 G) (CategoryTheory.Limits.Cocone.{u1, u3, u2, u4} J _inst_1 C _inst_3 F) (CategoryTheory.Limits.Cocone.category.{u1, u3, u2, u4} J _inst_1 C _inst_3 F) (CategoryTheory.Limits.Cocones.precompose.{u1, u3, u2, u4} J _inst_1 C _inst_3 G F Œ±)) c))
Case conversion may be inaccurate. Consider using '#align category_theory.limits.colimit.map_desc CategoryTheory.Limits.colimit.map_desc‚Çì'. -/
@[simp]
theorem colimit.map_desc (c : Cocone G) :
    colim.map Œ± ‚â´ colimit.desc G c = colimit.desc F ((Cocones.precompose Œ±).obj c) := by
  ext <;> rw [‚Üê assoc, colimit.Œπ_map, assoc, colimit.Œπ_desc, colimit.Œπ_desc] <;> rfl
#align category_theory.limits.colimit.map_desc CategoryTheory.Limits.colimit.map_desc

/- warning: category_theory.limits.colimit.pre_map -> CategoryTheory.Limits.colimit.pre_map is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {K : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u3, u4} K] {C : Type.{u6}} [_inst_3 : CategoryTheory.Category.{u5, u6} C] {F : CategoryTheory.Functor.{u1, u5, u2, u6} J _inst_1 C _inst_3} [_inst_4 : CategoryTheory.Limits.HasColimitsOfShape.{u1, u2, u5, u6} J _inst_1 C _inst_3] {G : CategoryTheory.Functor.{u1, u5, u2, u6} J _inst_1 C _inst_3} (Œ± : Quiver.Hom.{succ (max u2 u5), max u1 u5 u2 u6} (CategoryTheory.Functor.{u1, u5, u2, u6} J _inst_1 C _inst_3) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u5, max u1 u5 u2 u6} (CategoryTheory.Functor.{u1, u5, u2, u6} J _inst_1 C _inst_3) (CategoryTheory.Category.toCategoryStruct.{max u2 u5, max u1 u5 u2 u6} (CategoryTheory.Functor.{u1, u5, u2, u6} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u5, u2, u6} J _inst_1 C _inst_3))) F G) [_inst_5 : CategoryTheory.Limits.HasColimitsOfShape.{u3, u4, u5, u6} K _inst_2 C _inst_3] (E : CategoryTheory.Functor.{u3, u1, u4, u2} K _inst_2 J _inst_1), Eq.{succ u5} (Quiver.Hom.{succ u5, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u5, u6} C (CategoryTheory.Category.toCategoryStruct.{u5, u6} C _inst_3)) (CategoryTheory.Limits.colimit.{u3, u4, u5, u6} K _inst_2 C _inst_3 (CategoryTheory.Functor.comp.{u3, u1, u5, u4, u2, u6} K _inst_2 J _inst_1 C _inst_3 E F) (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u3, u4, u5, u6} C _inst_3 K _inst_2 _inst_5 (CategoryTheory.Functor.comp.{u3, u1, u5, u4, u2, u6} K _inst_2 J _inst_1 C _inst_3 E F))) (CategoryTheory.Functor.obj.{max u2 u5, u5, max u1 u5 u2 u6, u6} (CategoryTheory.Functor.{u1, u5, u2, u6} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u5, u2, u6} J _inst_1 C _inst_3) C _inst_3 (CategoryTheory.Limits.colim.{u1, u2, u5, u6} J _inst_1 C _inst_3 _inst_4) G)) (CategoryTheory.CategoryStruct.comp.{u5, u6} C (CategoryTheory.Category.toCategoryStruct.{u5, u6} C _inst_3) (CategoryTheory.Limits.colimit.{u3, u4, u5, u6} K _inst_2 C _inst_3 (CategoryTheory.Functor.comp.{u3, u1, u5, u4, u2, u6} K _inst_2 J _inst_1 C _inst_3 E F) (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u3, u4, u5, u6} C _inst_3 K _inst_2 _inst_5 (CategoryTheory.Functor.comp.{u3, u1, u5, u4, u2, u6} K _inst_2 J _inst_1 C _inst_3 E F))) (CategoryTheory.Limits.colimit.{u1, u2, u5, u6} J _inst_1 C _inst_3 F (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u1, u2, u5, u6} C _inst_3 J _inst_1 _inst_4 F)) (CategoryTheory.Functor.obj.{max u2 u5, u5, max u1 u5 u2 u6, u6} (CategoryTheory.Functor.{u1, u5, u2, u6} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u5, u2, u6} J _inst_1 C _inst_3) C _inst_3 (CategoryTheory.Limits.colim.{u1, u2, u5, u6} J _inst_1 C _inst_3 _inst_4) G) (CategoryTheory.Limits.colimit.pre.{u1, u2, u3, u4, u5, u6} J _inst_1 K _inst_2 C _inst_3 F (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u1, u2, u5, u6} C _inst_3 J _inst_1 _inst_4 F) E (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u3, u4, u5, u6} C _inst_3 K _inst_2 _inst_5 (CategoryTheory.Functor.comp.{u3, u1, u5, u4, u2, u6} K _inst_2 J _inst_1 C _inst_3 E F))) (CategoryTheory.Functor.map.{max u2 u5, u5, max u1 u5 u2 u6, u6} (CategoryTheory.Functor.{u1, u5, u2, u6} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u5, u2, u6} J _inst_1 C _inst_3) C _inst_3 (CategoryTheory.Limits.colim.{u1, u2, u5, u6} J _inst_1 C _inst_3 _inst_4) F G Œ±)) (CategoryTheory.CategoryStruct.comp.{u5, u6} C (CategoryTheory.Category.toCategoryStruct.{u5, u6} C _inst_3) (CategoryTheory.Limits.colimit.{u3, u4, u5, u6} K _inst_2 C _inst_3 (CategoryTheory.Functor.comp.{u3, u1, u5, u4, u2, u6} K _inst_2 J _inst_1 C _inst_3 E F) (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u3, u4, u5, u6} C _inst_3 K _inst_2 _inst_5 (CategoryTheory.Functor.comp.{u3, u1, u5, u4, u2, u6} K _inst_2 J _inst_1 C _inst_3 E F))) (CategoryTheory.Functor.obj.{max u4 u5, u5, max u3 u5 u4 u6, u6} (CategoryTheory.Functor.{u3, u5, u4, u6} K _inst_2 C _inst_3) (CategoryTheory.Functor.category.{u3, u5, u4, u6} K _inst_2 C _inst_3) C _inst_3 (CategoryTheory.Limits.colim.{u3, u4, u5, u6} K _inst_2 C _inst_3 _inst_5) (CategoryTheory.Functor.comp.{u3, u1, u5, u4, u2, u6} K _inst_2 J _inst_1 C _inst_3 E G)) (CategoryTheory.Functor.obj.{max u2 u5, u5, max u1 u5 u2 u6, u6} (CategoryTheory.Functor.{u1, u5, u2, u6} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u5, u2, u6} J _inst_1 C _inst_3) C _inst_3 (CategoryTheory.Limits.colim.{u1, u2, u5, u6} J _inst_1 C _inst_3 _inst_4) G) (CategoryTheory.Functor.map.{max u4 u5, u5, max u3 u5 u4 u6, u6} (CategoryTheory.Functor.{u3, u5, u4, u6} K _inst_2 C _inst_3) (CategoryTheory.Functor.category.{u3, u5, u4, u6} K _inst_2 C _inst_3) C _inst_3 (CategoryTheory.Limits.colim.{u3, u4, u5, u6} K _inst_2 C _inst_3 _inst_5) (CategoryTheory.Functor.comp.{u3, u1, u5, u4, u2, u6} K _inst_2 J _inst_1 C _inst_3 E F) (CategoryTheory.Functor.comp.{u3, u1, u5, u4, u2, u6} K _inst_2 J _inst_1 C _inst_3 E G) (CategoryTheory.whiskerLeft.{u4, u3, u2, u1, u6, u5} K _inst_2 J _inst_1 C _inst_3 E F G Œ±)) (CategoryTheory.Limits.colimit.pre.{u1, u2, u3, u4, u5, u6} J _inst_1 K _inst_2 C _inst_3 G (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u1, u2, u5, u6} C _inst_3 J _inst_1 _inst_4 G) E (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u3, u4, u5, u6} C _inst_3 K _inst_2 _inst_5 (CategoryTheory.Functor.comp.{u3, u1, u5, u4, u2, u6} K _inst_2 J _inst_1 C _inst_3 E G))))
but is expected to have type
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {K : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u3, u4} K] {C : Type.{u6}} [_inst_3 : CategoryTheory.Category.{u5, u6} C] {F : CategoryTheory.Functor.{u1, u5, u2, u6} J _inst_1 C _inst_3} [_inst_4 : CategoryTheory.Limits.HasColimitsOfShape.{u1, u2, u5, u6} J _inst_1 C _inst_3] {G : CategoryTheory.Functor.{u1, u5, u2, u6} J _inst_1 C _inst_3} (Œ± : Quiver.Hom.{max (succ u2) (succ u5), max (max (max u6 u2) u5) u1} (CategoryTheory.Functor.{u1, u5, u2, u6} J _inst_1 C _inst_3) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u5, max (max (max u6 u2) u5) u1} (CategoryTheory.Functor.{u1, u5, u2, u6} J _inst_1 C _inst_3) (CategoryTheory.Category.toCategoryStruct.{max u2 u5, max (max (max u6 u2) u5) u1} (CategoryTheory.Functor.{u1, u5, u2, u6} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u5, u2, u6} J _inst_1 C _inst_3))) F G) [_inst_5 : CategoryTheory.Limits.HasColimitsOfShape.{u3, u4, u5, u6} K _inst_2 C _inst_3] (E : CategoryTheory.Functor.{u3, u1, u4, u2} K _inst_2 J _inst_1), Eq.{succ u5} (Quiver.Hom.{succ u5, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u5, u6} C (CategoryTheory.Category.toCategoryStruct.{u5, u6} C _inst_3)) (CategoryTheory.Limits.colimit.{u3, u4, u5, u6} K _inst_2 C _inst_3 (CategoryTheory.Functor.comp.{u3, u1, u5, u4, u2, u6} K _inst_2 J _inst_1 C _inst_3 E F) (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u3, u4, u5, u6} C _inst_3 K _inst_2 _inst_5 (CategoryTheory.Functor.comp.{u3, u1, u5, u4, u2, u6} K _inst_2 J _inst_1 C _inst_3 E F))) (Prefunctor.obj.{max (succ u2) (succ u5), succ u5, max (max (max u2 u1) u6) u5, u6} (CategoryTheory.Functor.{u1, u5, u2, u6} J _inst_1 C _inst_3) (CategoryTheory.CategoryStruct.toQuiver.{max u5 u2, max (max (max u6 u5) u2) u1} (CategoryTheory.Functor.{u1, u5, u2, u6} J _inst_1 C _inst_3) (CategoryTheory.Category.toCategoryStruct.{max u5 u2, max (max (max u6 u5) u2) u1} (CategoryTheory.Functor.{u1, u5, u2, u6} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u5, u2, u6} J _inst_1 C _inst_3))) C (CategoryTheory.CategoryStruct.toQuiver.{u5, u6} C (CategoryTheory.Category.toCategoryStruct.{u5, u6} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{max u5 u2, u5, max (max (max u6 u5) u2) u1, u6} (CategoryTheory.Functor.{u1, u5, u2, u6} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u5, u2, u6} J _inst_1 C _inst_3) C _inst_3 (CategoryTheory.Limits.colim.{u1, u2, u5, u6} J _inst_1 C _inst_3 _inst_4)) G)) (CategoryTheory.CategoryStruct.comp.{u5, u6} C (CategoryTheory.Category.toCategoryStruct.{u5, u6} C _inst_3) (CategoryTheory.Limits.colimit.{u3, u4, u5, u6} K _inst_2 C _inst_3 (CategoryTheory.Functor.comp.{u3, u1, u5, u4, u2, u6} K _inst_2 J _inst_1 C _inst_3 E F) (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u3, u4, u5, u6} C _inst_3 K _inst_2 _inst_5 (CategoryTheory.Functor.comp.{u3, u1, u5, u4, u2, u6} K _inst_2 J _inst_1 C _inst_3 E F))) (CategoryTheory.Limits.colimit.{u1, u2, u5, u6} J _inst_1 C _inst_3 F (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u1, u2, u5, u6} C _inst_3 J _inst_1 _inst_4 F)) (Prefunctor.obj.{max (succ u2) (succ u5), succ u5, max (max (max u2 u1) u6) u5, u6} (CategoryTheory.Functor.{u1, u5, u2, u6} J _inst_1 C _inst_3) (CategoryTheory.CategoryStruct.toQuiver.{max u5 u2, max (max (max u6 u5) u2) u1} (CategoryTheory.Functor.{u1, u5, u2, u6} J _inst_1 C _inst_3) (CategoryTheory.Category.toCategoryStruct.{max u5 u2, max (max (max u6 u5) u2) u1} (CategoryTheory.Functor.{u1, u5, u2, u6} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u5, u2, u6} J _inst_1 C _inst_3))) C (CategoryTheory.CategoryStruct.toQuiver.{u5, u6} C (CategoryTheory.Category.toCategoryStruct.{u5, u6} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{max u5 u2, u5, max (max (max u6 u5) u2) u1, u6} (CategoryTheory.Functor.{u1, u5, u2, u6} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u5, u2, u6} J _inst_1 C _inst_3) C _inst_3 (CategoryTheory.Limits.colim.{u1, u2, u5, u6} J _inst_1 C _inst_3 _inst_4)) G) (CategoryTheory.Limits.colimit.pre.{u1, u2, u3, u4, u5, u6} J _inst_1 K _inst_2 C _inst_3 F (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u1, u2, u5, u6} C _inst_3 J _inst_1 _inst_4 F) E (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u3, u4, u5, u6} C _inst_3 K _inst_2 _inst_5 (CategoryTheory.Functor.comp.{u3, u1, u5, u4, u2, u6} K _inst_2 J _inst_1 C _inst_3 E F))) (Prefunctor.map.{max (succ u2) (succ u5), succ u5, max (max (max u2 u1) u6) u5, u6} (CategoryTheory.Functor.{u1, u5, u2, u6} J _inst_1 C _inst_3) (CategoryTheory.CategoryStruct.toQuiver.{max u5 u2, max (max (max u6 u5) u2) u1} (CategoryTheory.Functor.{u1, u5, u2, u6} J _inst_1 C _inst_3) (CategoryTheory.Category.toCategoryStruct.{max u5 u2, max (max (max u6 u5) u2) u1} (CategoryTheory.Functor.{u1, u5, u2, u6} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u5, u2, u6} J _inst_1 C _inst_3))) C (CategoryTheory.CategoryStruct.toQuiver.{u5, u6} C (CategoryTheory.Category.toCategoryStruct.{u5, u6} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{max u5 u2, u5, max (max (max u6 u5) u2) u1, u6} (CategoryTheory.Functor.{u1, u5, u2, u6} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u5, u2, u6} J _inst_1 C _inst_3) C _inst_3 (CategoryTheory.Limits.colim.{u1, u2, u5, u6} J _inst_1 C _inst_3 _inst_4)) F G Œ±)) (CategoryTheory.CategoryStruct.comp.{u5, u6} C (CategoryTheory.Category.toCategoryStruct.{u5, u6} C _inst_3) (Prefunctor.obj.{max (succ u4) (succ u5), succ u5, max (max (max u4 u3) u6) u5, u6} (CategoryTheory.Functor.{u3, u5, u4, u6} K _inst_2 C _inst_3) (CategoryTheory.CategoryStruct.toQuiver.{max u5 u4, max (max (max u6 u5) u4) u3} (CategoryTheory.Functor.{u3, u5, u4, u6} K _inst_2 C _inst_3) (CategoryTheory.Category.toCategoryStruct.{max u5 u4, max (max (max u6 u5) u4) u3} (CategoryTheory.Functor.{u3, u5, u4, u6} K _inst_2 C _inst_3) (CategoryTheory.Functor.category.{u3, u5, u4, u6} K _inst_2 C _inst_3))) C (CategoryTheory.CategoryStruct.toQuiver.{u5, u6} C (CategoryTheory.Category.toCategoryStruct.{u5, u6} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{max u5 u4, u5, max (max (max u6 u5) u4) u3, u6} (CategoryTheory.Functor.{u3, u5, u4, u6} K _inst_2 C _inst_3) (CategoryTheory.Functor.category.{u3, u5, u4, u6} K _inst_2 C _inst_3) C _inst_3 (CategoryTheory.Limits.colim.{u3, u4, u5, u6} K _inst_2 C _inst_3 _inst_5)) (CategoryTheory.Functor.comp.{u3, u1, u5, u4, u2, u6} K _inst_2 J _inst_1 C _inst_3 E F)) (Prefunctor.obj.{max (succ u4) (succ u5), succ u5, max (max (max u4 u3) u6) u5, u6} (CategoryTheory.Functor.{u3, u5, u4, u6} K _inst_2 C _inst_3) (CategoryTheory.CategoryStruct.toQuiver.{max u5 u4, max (max (max u6 u5) u4) u3} (CategoryTheory.Functor.{u3, u5, u4, u6} K _inst_2 C _inst_3) (CategoryTheory.Category.toCategoryStruct.{max u5 u4, max (max (max u6 u5) u4) u3} (CategoryTheory.Functor.{u3, u5, u4, u6} K _inst_2 C _inst_3) (CategoryTheory.Functor.category.{u3, u5, u4, u6} K _inst_2 C _inst_3))) C (CategoryTheory.CategoryStruct.toQuiver.{u5, u6} C (CategoryTheory.Category.toCategoryStruct.{u5, u6} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{max u5 u4, u5, max (max (max u6 u5) u4) u3, u6} (CategoryTheory.Functor.{u3, u5, u4, u6} K _inst_2 C _inst_3) (CategoryTheory.Functor.category.{u3, u5, u4, u6} K _inst_2 C _inst_3) C _inst_3 (CategoryTheory.Limits.colim.{u3, u4, u5, u6} K _inst_2 C _inst_3 _inst_5)) (CategoryTheory.Functor.comp.{u3, u1, u5, u4, u2, u6} K _inst_2 J _inst_1 C _inst_3 E G)) (CategoryTheory.Limits.colimit.{u1, u2, u5, u6} J _inst_1 C _inst_3 G (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u1, u2, u5, u6} C _inst_3 J _inst_1 _inst_4 G)) (Prefunctor.map.{max (succ u4) (succ u5), succ u5, max (max (max u4 u3) u6) u5, u6} (CategoryTheory.Functor.{u3, u5, u4, u6} K _inst_2 C _inst_3) (CategoryTheory.CategoryStruct.toQuiver.{max u5 u4, max (max (max u6 u5) u4) u3} (CategoryTheory.Functor.{u3, u5, u4, u6} K _inst_2 C _inst_3) (CategoryTheory.Category.toCategoryStruct.{max u5 u4, max (max (max u6 u5) u4) u3} (CategoryTheory.Functor.{u3, u5, u4, u6} K _inst_2 C _inst_3) (CategoryTheory.Functor.category.{u3, u5, u4, u6} K _inst_2 C _inst_3))) C (CategoryTheory.CategoryStruct.toQuiver.{u5, u6} C (CategoryTheory.Category.toCategoryStruct.{u5, u6} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{max u5 u4, u5, max (max (max u6 u5) u4) u3, u6} (CategoryTheory.Functor.{u3, u5, u4, u6} K _inst_2 C _inst_3) (CategoryTheory.Functor.category.{u3, u5, u4, u6} K _inst_2 C _inst_3) C _inst_3 (CategoryTheory.Limits.colim.{u3, u4, u5, u6} K _inst_2 C _inst_3 _inst_5)) (CategoryTheory.Functor.comp.{u3, u1, u5, u4, u2, u6} K _inst_2 J _inst_1 C _inst_3 E F) (CategoryTheory.Functor.comp.{u3, u1, u5, u4, u2, u6} K _inst_2 J _inst_1 C _inst_3 E G) (CategoryTheory.whiskerLeft.{u4, u3, u2, u1, u6, u5} K _inst_2 J _inst_1 C _inst_3 E F G Œ±)) (CategoryTheory.Limits.colimit.pre.{u1, u2, u3, u4, u5, u6} J _inst_1 K _inst_2 C _inst_3 G (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u1, u2, u5, u6} C _inst_3 J _inst_1 _inst_4 G) E (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u3, u4, u5, u6} C _inst_3 K _inst_2 _inst_5 (CategoryTheory.Functor.comp.{u3, u1, u5, u4, u2, u6} K _inst_2 J _inst_1 C _inst_3 E G))))
Case conversion may be inaccurate. Consider using '#align category_theory.limits.colimit.pre_map CategoryTheory.Limits.colimit.pre_map‚Çì'. -/
theorem colimit.pre_map [HasColimitsOfShape K C] (E : K ‚•§ J) :
    colimit.pre F E ‚â´ colim.map Œ± = colim.map (whiskerLeft E Œ±) ‚â´ colimit.pre G E := by
  ext <;>
      rw [‚Üê assoc, colimit.Œπ_pre, colimit.Œπ_map, ‚Üê assoc, colimit.Œπ_map, assoc, colimit.Œπ_pre] <;>
    rfl
#align category_theory.limits.colimit.pre_map CategoryTheory.Limits.colimit.pre_map

/- warning: category_theory.limits.colimit.pre_map' -> CategoryTheory.Limits.colimit.pre_map' is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {K : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u3, u4} K] {C : Type.{u6}} [_inst_3 : CategoryTheory.Category.{u5, u6} C] [_inst_4 : CategoryTheory.Limits.HasColimitsOfShape.{u1, u2, u5, u6} J _inst_1 C _inst_3] [_inst_5 : CategoryTheory.Limits.HasColimitsOfShape.{u3, u4, u5, u6} K _inst_2 C _inst_3] (F : CategoryTheory.Functor.{u1, u5, u2, u6} J _inst_1 C _inst_3) {E‚ÇÅ : CategoryTheory.Functor.{u3, u1, u4, u2} K _inst_2 J _inst_1} {E‚ÇÇ : CategoryTheory.Functor.{u3, u1, u4, u2} K _inst_2 J _inst_1} (Œ± : Quiver.Hom.{succ (max u4 u1), max u3 u1 u4 u2} (CategoryTheory.Functor.{u3, u1, u4, u2} K _inst_2 J _inst_1) (CategoryTheory.CategoryStruct.toQuiver.{max u4 u1, max u3 u1 u4 u2} (CategoryTheory.Functor.{u3, u1, u4, u2} K _inst_2 J _inst_1) (CategoryTheory.Category.toCategoryStruct.{max u4 u1, max u3 u1 u4 u2} (CategoryTheory.Functor.{u3, u1, u4, u2} K _inst_2 J _inst_1) (CategoryTheory.Functor.category.{u3, u1, u4, u2} K _inst_2 J _inst_1))) E‚ÇÅ E‚ÇÇ), Eq.{succ u5} (Quiver.Hom.{succ u5, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u5, u6} C (CategoryTheory.Category.toCategoryStruct.{u5, u6} C _inst_3)) (CategoryTheory.Limits.colimit.{u3, u4, u5, u6} K _inst_2 C _inst_3 (CategoryTheory.Functor.comp.{u3, u1, u5, u4, u2, u6} K _inst_2 J _inst_1 C _inst_3 E‚ÇÅ F) (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u3, u4, u5, u6} C _inst_3 K _inst_2 _inst_5 (CategoryTheory.Functor.comp.{u3, u1, u5, u4, u2, u6} K _inst_2 J _inst_1 C _inst_3 E‚ÇÅ F))) (CategoryTheory.Limits.colimit.{u1, u2, u5, u6} J _inst_1 C _inst_3 F (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u1, u2, u5, u6} C _inst_3 J _inst_1 _inst_4 F))) (CategoryTheory.Limits.colimit.pre.{u1, u2, u3, u4, u5, u6} J _inst_1 K _inst_2 C _inst_3 F (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u1, u2, u5, u6} C _inst_3 J _inst_1 _inst_4 F) E‚ÇÅ (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u3, u4, u5, u6} C _inst_3 K _inst_2 _inst_5 (CategoryTheory.Functor.comp.{u3, u1, u5, u4, u2, u6} K _inst_2 J _inst_1 C _inst_3 E‚ÇÅ F))) (CategoryTheory.CategoryStruct.comp.{u5, u6} C (CategoryTheory.Category.toCategoryStruct.{u5, u6} C _inst_3) (CategoryTheory.Limits.colimit.{u3, u4, u5, u6} K _inst_2 C _inst_3 (CategoryTheory.Functor.comp.{u3, u1, u5, u4, u2, u6} K _inst_2 J _inst_1 C _inst_3 E‚ÇÅ F) (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u3, u4, u5, u6} C _inst_3 K _inst_2 _inst_5 (CategoryTheory.Functor.comp.{u3, u1, u5, u4, u2, u6} K _inst_2 J _inst_1 C _inst_3 E‚ÇÅ F))) (CategoryTheory.Functor.obj.{max u4 u5, u5, max u3 u5 u4 u6, u6} (CategoryTheory.Functor.{u3, u5, u4, u6} K _inst_2 C _inst_3) (CategoryTheory.Functor.category.{u3, u5, u4, u6} K _inst_2 C _inst_3) C _inst_3 (CategoryTheory.Limits.colim.{u3, u4, u5, u6} K _inst_2 C _inst_3 _inst_5) (CategoryTheory.Functor.comp.{u3, u1, u5, u4, u2, u6} K _inst_2 J _inst_1 C _inst_3 E‚ÇÇ F)) (CategoryTheory.Limits.colimit.{u1, u2, u5, u6} J _inst_1 C _inst_3 F (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u1, u2, u5, u6} C _inst_3 J _inst_1 _inst_4 F)) (CategoryTheory.Functor.map.{max u4 u5, u5, max u3 u5 u4 u6, u6} (CategoryTheory.Functor.{u3, u5, u4, u6} K _inst_2 C _inst_3) (CategoryTheory.Functor.category.{u3, u5, u4, u6} K _inst_2 C _inst_3) C _inst_3 (CategoryTheory.Limits.colim.{u3, u4, u5, u6} K _inst_2 C _inst_3 _inst_5) (CategoryTheory.Functor.comp.{u3, u1, u5, u4, u2, u6} K _inst_2 J _inst_1 C _inst_3 E‚ÇÅ F) (CategoryTheory.Functor.comp.{u3, u1, u5, u4, u2, u6} K _inst_2 J _inst_1 C _inst_3 E‚ÇÇ F) (CategoryTheory.whiskerRight.{u4, u3, u2, u1, u6, u5} K _inst_2 J _inst_1 C _inst_3 E‚ÇÅ E‚ÇÇ Œ± F)) (CategoryTheory.Limits.colimit.pre.{u1, u2, u3, u4, u5, u6} J _inst_1 K _inst_2 C _inst_3 F (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u1, u2, u5, u6} C _inst_3 J _inst_1 _inst_4 F) E‚ÇÇ (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u3, u4, u5, u6} C _inst_3 K _inst_2 _inst_5 (CategoryTheory.Functor.comp.{u3, u1, u5, u4, u2, u6} K _inst_2 J _inst_1 C _inst_3 E‚ÇÇ F))))
but is expected to have type
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {K : Type.{u4}} [_inst_2 : CategoryTheory.Category.{u3, u4} K] {C : Type.{u6}} [_inst_3 : CategoryTheory.Category.{u5, u6} C] [_inst_4 : CategoryTheory.Limits.HasColimitsOfShape.{u1, u2, u5, u6} J _inst_1 C _inst_3] [_inst_5 : CategoryTheory.Limits.HasColimitsOfShape.{u3, u4, u5, u6} K _inst_2 C _inst_3] (F : CategoryTheory.Functor.{u1, u5, u2, u6} J _inst_1 C _inst_3) {E‚ÇÅ : CategoryTheory.Functor.{u3, u1, u4, u2} K _inst_2 J _inst_1} {E‚ÇÇ : CategoryTheory.Functor.{u3, u1, u4, u2} K _inst_2 J _inst_1} (Œ± : Quiver.Hom.{max (succ u4) (succ u1), max (max (max u2 u4) u1) u3} (CategoryTheory.Functor.{u3, u1, u4, u2} K _inst_2 J _inst_1) (CategoryTheory.CategoryStruct.toQuiver.{max u4 u1, max (max (max u2 u4) u1) u3} (CategoryTheory.Functor.{u3, u1, u4, u2} K _inst_2 J _inst_1) (CategoryTheory.Category.toCategoryStruct.{max u4 u1, max (max (max u2 u4) u1) u3} (CategoryTheory.Functor.{u3, u1, u4, u2} K _inst_2 J _inst_1) (CategoryTheory.Functor.category.{u3, u1, u4, u2} K _inst_2 J _inst_1))) E‚ÇÅ E‚ÇÇ), Eq.{succ u5} (Quiver.Hom.{succ u5, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u5, u6} C (CategoryTheory.Category.toCategoryStruct.{u5, u6} C _inst_3)) (CategoryTheory.Limits.colimit.{u3, u4, u5, u6} K _inst_2 C _inst_3 (CategoryTheory.Functor.comp.{u3, u1, u5, u4, u2, u6} K _inst_2 J _inst_1 C _inst_3 E‚ÇÅ F) (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u3, u4, u5, u6} C _inst_3 K _inst_2 _inst_5 (CategoryTheory.Functor.comp.{u3, u1, u5, u4, u2, u6} K _inst_2 J _inst_1 C _inst_3 E‚ÇÅ F))) (CategoryTheory.Limits.colimit.{u1, u2, u5, u6} J _inst_1 C _inst_3 F (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u1, u2, u5, u6} C _inst_3 J _inst_1 _inst_4 F))) (CategoryTheory.Limits.colimit.pre.{u1, u2, u3, u4, u5, u6} J _inst_1 K _inst_2 C _inst_3 F (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u1, u2, u5, u6} C _inst_3 J _inst_1 _inst_4 F) E‚ÇÅ (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u3, u4, u5, u6} C _inst_3 K _inst_2 _inst_5 (CategoryTheory.Functor.comp.{u3, u1, u5, u4, u2, u6} K _inst_2 J _inst_1 C _inst_3 E‚ÇÅ F))) (CategoryTheory.CategoryStruct.comp.{u5, u6} C (CategoryTheory.Category.toCategoryStruct.{u5, u6} C _inst_3) (Prefunctor.obj.{max (succ u4) (succ u5), succ u5, max (max (max u4 u3) u6) u5, u6} (CategoryTheory.Functor.{u3, u5, u4, u6} K _inst_2 C _inst_3) (CategoryTheory.CategoryStruct.toQuiver.{max u5 u4, max (max (max u6 u5) u4) u3} (CategoryTheory.Functor.{u3, u5, u4, u6} K _inst_2 C _inst_3) (CategoryTheory.Category.toCategoryStruct.{max u5 u4, max (max (max u6 u5) u4) u3} (CategoryTheory.Functor.{u3, u5, u4, u6} K _inst_2 C _inst_3) (CategoryTheory.Functor.category.{u3, u5, u4, u6} K _inst_2 C _inst_3))) C (CategoryTheory.CategoryStruct.toQuiver.{u5, u6} C (CategoryTheory.Category.toCategoryStruct.{u5, u6} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{max u5 u4, u5, max (max (max u6 u5) u4) u3, u6} (CategoryTheory.Functor.{u3, u5, u4, u6} K _inst_2 C _inst_3) (CategoryTheory.Functor.category.{u3, u5, u4, u6} K _inst_2 C _inst_3) C _inst_3 (CategoryTheory.Limits.colim.{u3, u4, u5, u6} K _inst_2 C _inst_3 _inst_5)) (CategoryTheory.Functor.comp.{u3, u1, u5, u4, u2, u6} K _inst_2 J _inst_1 C _inst_3 E‚ÇÅ F)) (Prefunctor.obj.{max (succ u4) (succ u5), succ u5, max (max (max u4 u3) u6) u5, u6} (CategoryTheory.Functor.{u3, u5, u4, u6} K _inst_2 C _inst_3) (CategoryTheory.CategoryStruct.toQuiver.{max u5 u4, max (max (max u6 u5) u4) u3} (CategoryTheory.Functor.{u3, u5, u4, u6} K _inst_2 C _inst_3) (CategoryTheory.Category.toCategoryStruct.{max u5 u4, max (max (max u6 u5) u4) u3} (CategoryTheory.Functor.{u3, u5, u4, u6} K _inst_2 C _inst_3) (CategoryTheory.Functor.category.{u3, u5, u4, u6} K _inst_2 C _inst_3))) C (CategoryTheory.CategoryStruct.toQuiver.{u5, u6} C (CategoryTheory.Category.toCategoryStruct.{u5, u6} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{max u5 u4, u5, max (max (max u6 u5) u4) u3, u6} (CategoryTheory.Functor.{u3, u5, u4, u6} K _inst_2 C _inst_3) (CategoryTheory.Functor.category.{u3, u5, u4, u6} K _inst_2 C _inst_3) C _inst_3 (CategoryTheory.Limits.colim.{u3, u4, u5, u6} K _inst_2 C _inst_3 _inst_5)) (CategoryTheory.Functor.comp.{u3, u1, u5, u4, u2, u6} K _inst_2 J _inst_1 C _inst_3 E‚ÇÇ F)) (CategoryTheory.Limits.colimit.{u1, u2, u5, u6} J _inst_1 C _inst_3 F (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u1, u2, u5, u6} C _inst_3 J _inst_1 _inst_4 F)) (Prefunctor.map.{max (succ u4) (succ u5), succ u5, max (max (max u4 u3) u6) u5, u6} (CategoryTheory.Functor.{u3, u5, u4, u6} K _inst_2 C _inst_3) (CategoryTheory.CategoryStruct.toQuiver.{max u5 u4, max (max (max u6 u5) u4) u3} (CategoryTheory.Functor.{u3, u5, u4, u6} K _inst_2 C _inst_3) (CategoryTheory.Category.toCategoryStruct.{max u5 u4, max (max (max u6 u5) u4) u3} (CategoryTheory.Functor.{u3, u5, u4, u6} K _inst_2 C _inst_3) (CategoryTheory.Functor.category.{u3, u5, u4, u6} K _inst_2 C _inst_3))) C (CategoryTheory.CategoryStruct.toQuiver.{u5, u6} C (CategoryTheory.Category.toCategoryStruct.{u5, u6} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{max u5 u4, u5, max (max (max u6 u5) u4) u3, u6} (CategoryTheory.Functor.{u3, u5, u4, u6} K _inst_2 C _inst_3) (CategoryTheory.Functor.category.{u3, u5, u4, u6} K _inst_2 C _inst_3) C _inst_3 (CategoryTheory.Limits.colim.{u3, u4, u5, u6} K _inst_2 C _inst_3 _inst_5)) (CategoryTheory.Functor.comp.{u3, u1, u5, u4, u2, u6} K _inst_2 J _inst_1 C _inst_3 E‚ÇÅ F) (CategoryTheory.Functor.comp.{u3, u1, u5, u4, u2, u6} K _inst_2 J _inst_1 C _inst_3 E‚ÇÇ F) (CategoryTheory.whiskerRight.{u4, u3, u2, u1, u6, u5} K _inst_2 J _inst_1 C _inst_3 E‚ÇÅ E‚ÇÇ Œ± F)) (CategoryTheory.Limits.colimit.pre.{u1, u2, u3, u4, u5, u6} J _inst_1 K _inst_2 C _inst_3 F (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u1, u2, u5, u6} C _inst_3 J _inst_1 _inst_4 F) E‚ÇÇ (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u3, u4, u5, u6} C _inst_3 K _inst_2 _inst_5 (CategoryTheory.Functor.comp.{u3, u1, u5, u4, u2, u6} K _inst_2 J _inst_1 C _inst_3 E‚ÇÇ F))))
Case conversion may be inaccurate. Consider using '#align category_theory.limits.colimit.pre_map' CategoryTheory.Limits.colimit.pre_map'‚Çì'. -/
theorem colimit.pre_map' [HasColimitsOfShape K C] (F : J ‚•§ C) {E‚ÇÅ E‚ÇÇ : K ‚•§ J} (Œ± : E‚ÇÅ ‚ü∂ E‚ÇÇ) :
    colimit.pre F E‚ÇÅ = colim.map (whiskerRight Œ± F) ‚â´ colimit.pre F E‚ÇÇ := by
  ext1 <;> simp [‚Üê category.assoc]
#align category_theory.limits.colimit.pre_map' CategoryTheory.Limits.colimit.pre_map'

/- warning: category_theory.limits.colimit.pre_id -> CategoryTheory.Limits.colimit.pre_id is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {C : Type.{u4}} [_inst_3 : CategoryTheory.Category.{u3, u4} C] [_inst_4 : CategoryTheory.Limits.HasColimitsOfShape.{u1, u2, u3, u4} J _inst_1 C _inst_3] (F : CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3), Eq.{succ u3} (Quiver.Hom.{succ u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Limits.colimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 (CategoryTheory.Functor.comp.{u1, u1, u3, u2, u2, u4} J _inst_1 J _inst_1 C _inst_3 (CategoryTheory.Functor.id.{u1, u2} J _inst_1) F) (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u1, u2, u3, u4} C _inst_3 J _inst_1 _inst_4 (CategoryTheory.Functor.comp.{u1, u1, u3, u2, u2, u4} J _inst_1 J _inst_1 C _inst_3 (CategoryTheory.Functor.id.{u1, u2} J _inst_1) F))) (CategoryTheory.Limits.colimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u1, u2, u3, u4} C _inst_3 J _inst_1 _inst_4 F))) (CategoryTheory.Limits.colimit.pre.{u1, u2, u1, u2, u3, u4} J _inst_1 J _inst_1 C _inst_3 F (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u1, u2, u3, u4} C _inst_3 J _inst_1 _inst_4 F) (CategoryTheory.Functor.id.{u1, u2} J _inst_1) (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u1, u2, u3, u4} C _inst_3 J _inst_1 _inst_4 (CategoryTheory.Functor.comp.{u1, u1, u3, u2, u2, u4} J _inst_1 J _inst_1 C _inst_3 (CategoryTheory.Functor.id.{u1, u2} J _inst_1) F))) (CategoryTheory.Functor.map.{max u2 u3, u3, max u1 u3 u2 u4, u4} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3) C _inst_3 (CategoryTheory.Limits.colim.{u1, u2, u3, u4} J _inst_1 C _inst_3 _inst_4) (CategoryTheory.Functor.comp.{u1, u1, u3, u2, u2, u4} J _inst_1 J _inst_1 C _inst_3 (CategoryTheory.Functor.id.{u1, u2} J _inst_1) F) F (CategoryTheory.Iso.hom.{max u2 u3, max u1 u3 u2 u4} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.comp.{u1, u1, u3, u2, u2, u4} J _inst_1 J _inst_1 C _inst_3 (CategoryTheory.Functor.id.{u1, u2} J _inst_1) F) F (CategoryTheory.Functor.leftUnitor.{u2, u1, u4, u3} J _inst_1 C _inst_3 F)))
but is expected to have type
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {C : Type.{u4}} [_inst_3 : CategoryTheory.Category.{u3, u4} C] [_inst_4 : CategoryTheory.Limits.HasColimitsOfShape.{u1, u2, u3, u4} J _inst_1 C _inst_3] (F : CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3), Eq.{succ u3} (Quiver.Hom.{succ u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Limits.colimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 (CategoryTheory.Functor.comp.{u1, u1, u3, u2, u2, u4} J _inst_1 J _inst_1 C _inst_3 (CategoryTheory.Functor.id.{u1, u2} J _inst_1) F) (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u1, u2, u3, u4} C _inst_3 J _inst_1 _inst_4 (CategoryTheory.Functor.comp.{u1, u1, u3, u2, u2, u4} J _inst_1 J _inst_1 C _inst_3 (CategoryTheory.Functor.id.{u1, u2} J _inst_1) F))) (CategoryTheory.Limits.colimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u1, u2, u3, u4} C _inst_3 J _inst_1 _inst_4 F))) (CategoryTheory.Limits.colimit.pre.{u1, u2, u1, u2, u3, u4} J _inst_1 J _inst_1 C _inst_3 F (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u1, u2, u3, u4} C _inst_3 J _inst_1 _inst_4 F) (CategoryTheory.Functor.id.{u1, u2} J _inst_1) (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u1, u2, u3, u4} C _inst_3 J _inst_1 _inst_4 (CategoryTheory.Functor.comp.{u1, u1, u3, u2, u2, u4} J _inst_1 J _inst_1 C _inst_3 (CategoryTheory.Functor.id.{u1, u2} J _inst_1) F))) (Prefunctor.map.{max (succ u2) (succ u3), succ u3, max (max (max u2 u1) u4) u3, u4} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max (max (max u4 u3) u2) u1} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max (max (max u4 u3) u2) u1} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3))) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, u3, max (max (max u4 u3) u2) u1, u4} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3) C _inst_3 (CategoryTheory.Limits.colim.{u1, u2, u3, u4} J _inst_1 C _inst_3 _inst_4)) (CategoryTheory.Functor.comp.{u1, u1, u3, u2, u2, u4} J _inst_1 J _inst_1 C _inst_3 (CategoryTheory.Functor.id.{u1, u2} J _inst_1) F) F (CategoryTheory.Iso.hom.{max u2 u3, max (max (max u4 u2) u3) u1} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.comp.{u1, u1, u3, u2, u2, u4} J _inst_1 J _inst_1 C _inst_3 (CategoryTheory.Functor.id.{u1, u2} J _inst_1) F) F (CategoryTheory.Functor.leftUnitor.{u2, u1, u4, u3} J _inst_1 C _inst_3 F)))
Case conversion may be inaccurate. Consider using '#align category_theory.limits.colimit.pre_id CategoryTheory.Limits.colimit.pre_id‚Çì'. -/
theorem colimit.pre_id (F : J ‚•§ C) : colimit.pre F (ùü≠ _) = colim.map (Functor.leftUnitor F).Hom :=
  by tidy
#align category_theory.limits.colimit.pre_id CategoryTheory.Limits.colimit.pre_id

/- warning: category_theory.limits.colimit.map_post -> CategoryTheory.Limits.colimit.map_post is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {C : Type.{u5}} [_inst_3 : CategoryTheory.Category.{u3, u5} C] {F : CategoryTheory.Functor.{u1, u3, u2, u5} J _inst_1 C _inst_3} [_inst_4 : CategoryTheory.Limits.HasColimitsOfShape.{u1, u2, u3, u5} J _inst_1 C _inst_3] {G : CategoryTheory.Functor.{u1, u3, u2, u5} J _inst_1 C _inst_3} (Œ± : Quiver.Hom.{succ (max u2 u3), max u1 u3 u2 u5} (CategoryTheory.Functor.{u1, u3, u2, u5} J _inst_1 C _inst_3) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u3, max u1 u3 u2 u5} (CategoryTheory.Functor.{u1, u3, u2, u5} J _inst_1 C _inst_3) (CategoryTheory.Category.toCategoryStruct.{max u2 u3, max u1 u3 u2 u5} (CategoryTheory.Functor.{u1, u3, u2, u5} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u5} J _inst_1 C _inst_3))) F G) {D : Type.{u6}} [_inst_5 : CategoryTheory.Category.{u4, u6} D] [_inst_6 : CategoryTheory.Limits.HasColimitsOfShape.{u1, u2, u4, u6} J _inst_1 D _inst_5] (H : CategoryTheory.Functor.{u3, u4, u5, u6} C _inst_3 D _inst_5), Eq.{succ u4} (Quiver.Hom.{succ u4, u6} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} D (CategoryTheory.Category.toCategoryStruct.{u4, u6} D _inst_5)) (CategoryTheory.Limits.colimit.{u1, u2, u4, u6} J _inst_1 D _inst_5 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_1 C _inst_3 D _inst_5 F H) (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u1, u2, u4, u6} D _inst_5 J _inst_1 _inst_6 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_1 C _inst_3 D _inst_5 F H))) (CategoryTheory.Functor.obj.{u3, u4, u5, u6} C _inst_3 D _inst_5 H (CategoryTheory.Functor.obj.{max u2 u3, u3, max u1 u3 u2 u5, u5} (CategoryTheory.Functor.{u1, u3, u2, u5} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u5} J _inst_1 C _inst_3) C _inst_3 (CategoryTheory.Limits.colim.{u1, u2, u3, u5} J _inst_1 C _inst_3 _inst_4) G))) (CategoryTheory.CategoryStruct.comp.{u4, u6} D (CategoryTheory.Category.toCategoryStruct.{u4, u6} D _inst_5) (CategoryTheory.Limits.colimit.{u1, u2, u4, u6} J _inst_1 D _inst_5 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_1 C _inst_3 D _inst_5 F H) (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u1, u2, u4, u6} D _inst_5 J _inst_1 _inst_6 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_1 C _inst_3 D _inst_5 F H))) (CategoryTheory.Functor.obj.{u3, u4, u5, u6} C _inst_3 D _inst_5 H (CategoryTheory.Limits.colimit.{u1, u2, u3, u5} J _inst_1 C _inst_3 F (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u1, u2, u3, u5} C _inst_3 J _inst_1 _inst_4 F))) (CategoryTheory.Functor.obj.{u3, u4, u5, u6} C _inst_3 D _inst_5 H (CategoryTheory.Functor.obj.{max u2 u3, u3, max u1 u3 u2 u5, u5} (CategoryTheory.Functor.{u1, u3, u2, u5} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u5} J _inst_1 C _inst_3) C _inst_3 (CategoryTheory.Limits.colim.{u1, u2, u3, u5} J _inst_1 C _inst_3 _inst_4) G)) (CategoryTheory.Limits.colimit.post.{u1, u2, u3, u4, u5, u6} J _inst_1 C _inst_3 F D _inst_5 (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u1, u2, u3, u5} C _inst_3 J _inst_1 _inst_4 F) H (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u1, u2, u4, u6} D _inst_5 J _inst_1 _inst_6 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_1 C _inst_3 D _inst_5 F H))) (CategoryTheory.Functor.map.{u3, u4, u5, u6} C _inst_3 D _inst_5 H (CategoryTheory.Limits.colimit.{u1, u2, u3, u5} J _inst_1 C _inst_3 F (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u1, u2, u3, u5} C _inst_3 J _inst_1 _inst_4 F)) (CategoryTheory.Functor.obj.{max u2 u3, u3, max u1 u3 u2 u5, u5} (CategoryTheory.Functor.{u1, u3, u2, u5} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u5} J _inst_1 C _inst_3) C _inst_3 (CategoryTheory.Limits.colim.{u1, u2, u3, u5} J _inst_1 C _inst_3 _inst_4) G) (CategoryTheory.Functor.map.{max u2 u3, u3, max u1 u3 u2 u5, u5} (CategoryTheory.Functor.{u1, u3, u2, u5} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u5} J _inst_1 C _inst_3) C _inst_3 (CategoryTheory.Limits.colim.{u1, u2, u3, u5} J _inst_1 C _inst_3 _inst_4) F G Œ±))) (CategoryTheory.CategoryStruct.comp.{u4, u6} D (CategoryTheory.Category.toCategoryStruct.{u4, u6} D _inst_5) (CategoryTheory.Limits.colimit.{u1, u2, u4, u6} J _inst_1 D _inst_5 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_1 C _inst_3 D _inst_5 F H) (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u1, u2, u4, u6} D _inst_5 J _inst_1 _inst_6 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_1 C _inst_3 D _inst_5 F H))) (CategoryTheory.Functor.obj.{max u2 u4, u4, max u1 u4 u2 u6, u6} (CategoryTheory.Functor.{u1, u4, u2, u6} J _inst_1 D _inst_5) (CategoryTheory.Functor.category.{u1, u4, u2, u6} J _inst_1 D _inst_5) D _inst_5 (CategoryTheory.Limits.colim.{u1, u2, u4, u6} J _inst_1 D _inst_5 _inst_6) (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_1 C _inst_3 D _inst_5 G H)) (CategoryTheory.Functor.obj.{u3, u4, u5, u6} C _inst_3 D _inst_5 H (CategoryTheory.Functor.obj.{max u2 u3, u3, max u1 u3 u2 u5, u5} (CategoryTheory.Functor.{u1, u3, u2, u5} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u5} J _inst_1 C _inst_3) C _inst_3 (CategoryTheory.Limits.colim.{u1, u2, u3, u5} J _inst_1 C _inst_3 _inst_4) G)) (CategoryTheory.Functor.map.{max u2 u4, u4, max u1 u4 u2 u6, u6} (CategoryTheory.Functor.{u1, u4, u2, u6} J _inst_1 D _inst_5) (CategoryTheory.Functor.category.{u1, u4, u2, u6} J _inst_1 D _inst_5) D _inst_5 (CategoryTheory.Limits.colim.{u1, u2, u4, u6} J _inst_1 D _inst_5 _inst_6) (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_1 C _inst_3 D _inst_5 F H) (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_1 C _inst_3 D _inst_5 G H) (CategoryTheory.whiskerRight.{u2, u1, u5, u3, u6, u4} J _inst_1 C _inst_3 D _inst_5 F G Œ± H)) (CategoryTheory.Limits.colimit.post.{u1, u2, u3, u4, u5, u6} J _inst_1 C _inst_3 G D _inst_5 (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u1, u2, u3, u5} C _inst_3 J _inst_1 _inst_4 G) H (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u1, u2, u4, u6} D _inst_5 J _inst_1 _inst_6 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_1 C _inst_3 D _inst_5 G H))))
but is expected to have type
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {C : Type.{u5}} [_inst_3 : CategoryTheory.Category.{u3, u5} C] {F : CategoryTheory.Functor.{u1, u3, u2, u5} J _inst_1 C _inst_3} [_inst_4 : CategoryTheory.Limits.HasColimitsOfShape.{u1, u2, u3, u5} J _inst_1 C _inst_3] {G : CategoryTheory.Functor.{u1, u3, u2, u5} J _inst_1 C _inst_3} (Œ± : Quiver.Hom.{max (succ u2) (succ u3), max (max (max u5 u2) u3) u1} (CategoryTheory.Functor.{u1, u3, u2, u5} J _inst_1 C _inst_3) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u3, max (max (max u5 u2) u3) u1} (CategoryTheory.Functor.{u1, u3, u2, u5} J _inst_1 C _inst_3) (CategoryTheory.Category.toCategoryStruct.{max u2 u3, max (max (max u5 u2) u3) u1} (CategoryTheory.Functor.{u1, u3, u2, u5} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u5} J _inst_1 C _inst_3))) F G) {D : Type.{u6}} [_inst_5 : CategoryTheory.Category.{u4, u6} D] [_inst_6 : CategoryTheory.Limits.HasColimitsOfShape.{u1, u2, u4, u6} J _inst_1 D _inst_5] (H : CategoryTheory.Functor.{u3, u4, u5, u6} C _inst_3 D _inst_5), Eq.{succ u4} (Quiver.Hom.{succ u4, u6} D (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} D (CategoryTheory.Category.toCategoryStruct.{u4, u6} D _inst_5)) (CategoryTheory.Limits.colimit.{u1, u2, u4, u6} J _inst_1 D _inst_5 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_1 C _inst_3 D _inst_5 F H) (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u1, u2, u4, u6} D _inst_5 J _inst_1 _inst_6 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_1 C _inst_3 D _inst_5 F H))) (Prefunctor.obj.{succ u3, succ u4, u5, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} C (CategoryTheory.Category.toCategoryStruct.{u3, u5} C _inst_3)) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} D (CategoryTheory.Category.toCategoryStruct.{u4, u6} D _inst_5)) (CategoryTheory.Functor.toPrefunctor.{u3, u4, u5, u6} C _inst_3 D _inst_5 H) (Prefunctor.obj.{max (succ u2) (succ u3), succ u3, max (max (max u2 u1) u5) u3, u5} (CategoryTheory.Functor.{u1, u3, u2, u5} J _inst_1 C _inst_3) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max (max (max u5 u3) u2) u1} (CategoryTheory.Functor.{u1, u3, u2, u5} J _inst_1 C _inst_3) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max (max (max u5 u3) u2) u1} (CategoryTheory.Functor.{u1, u3, u2, u5} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u5} J _inst_1 C _inst_3))) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} C (CategoryTheory.Category.toCategoryStruct.{u3, u5} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, u3, max (max (max u5 u3) u2) u1, u5} (CategoryTheory.Functor.{u1, u3, u2, u5} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u5} J _inst_1 C _inst_3) C _inst_3 (CategoryTheory.Limits.colim.{u1, u2, u3, u5} J _inst_1 C _inst_3 _inst_4)) G))) (CategoryTheory.CategoryStruct.comp.{u4, u6} D (CategoryTheory.Category.toCategoryStruct.{u4, u6} D _inst_5) (CategoryTheory.Limits.colimit.{u1, u2, u4, u6} J _inst_1 D _inst_5 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_1 C _inst_3 D _inst_5 F H) (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u1, u2, u4, u6} D _inst_5 J _inst_1 _inst_6 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_1 C _inst_3 D _inst_5 F H))) (Prefunctor.obj.{succ u3, succ u4, u5, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} C (CategoryTheory.Category.toCategoryStruct.{u3, u5} C _inst_3)) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} D (CategoryTheory.Category.toCategoryStruct.{u4, u6} D _inst_5)) (CategoryTheory.Functor.toPrefunctor.{u3, u4, u5, u6} C _inst_3 D _inst_5 H) (CategoryTheory.Limits.colimit.{u1, u2, u3, u5} J _inst_1 C _inst_3 F (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u1, u2, u3, u5} C _inst_3 J _inst_1 _inst_4 F))) (Prefunctor.obj.{succ u3, succ u4, u5, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} C (CategoryTheory.Category.toCategoryStruct.{u3, u5} C _inst_3)) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} D (CategoryTheory.Category.toCategoryStruct.{u4, u6} D _inst_5)) (CategoryTheory.Functor.toPrefunctor.{u3, u4, u5, u6} C _inst_3 D _inst_5 H) (Prefunctor.obj.{max (succ u2) (succ u3), succ u3, max (max (max u2 u1) u5) u3, u5} (CategoryTheory.Functor.{u1, u3, u2, u5} J _inst_1 C _inst_3) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max (max (max u5 u3) u2) u1} (CategoryTheory.Functor.{u1, u3, u2, u5} J _inst_1 C _inst_3) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max (max (max u5 u3) u2) u1} (CategoryTheory.Functor.{u1, u3, u2, u5} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u5} J _inst_1 C _inst_3))) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} C (CategoryTheory.Category.toCategoryStruct.{u3, u5} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, u3, max (max (max u5 u3) u2) u1, u5} (CategoryTheory.Functor.{u1, u3, u2, u5} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u5} J _inst_1 C _inst_3) C _inst_3 (CategoryTheory.Limits.colim.{u1, u2, u3, u5} J _inst_1 C _inst_3 _inst_4)) G)) (CategoryTheory.Limits.colimit.post.{u1, u2, u3, u4, u5, u6} J _inst_1 C _inst_3 F D _inst_5 (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u1, u2, u3, u5} C _inst_3 J _inst_1 _inst_4 F) H (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u1, u2, u4, u6} D _inst_5 J _inst_1 _inst_6 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_1 C _inst_3 D _inst_5 F H))) (Prefunctor.map.{succ u3, succ u4, u5, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} C (CategoryTheory.Category.toCategoryStruct.{u3, u5} C _inst_3)) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} D (CategoryTheory.Category.toCategoryStruct.{u4, u6} D _inst_5)) (CategoryTheory.Functor.toPrefunctor.{u3, u4, u5, u6} C _inst_3 D _inst_5 H) (CategoryTheory.Limits.colimit.{u1, u2, u3, u5} J _inst_1 C _inst_3 F (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u1, u2, u3, u5} C _inst_3 J _inst_1 _inst_4 F)) (Prefunctor.obj.{max (succ u2) (succ u3), succ u3, max (max (max u2 u1) u5) u3, u5} (CategoryTheory.Functor.{u1, u3, u2, u5} J _inst_1 C _inst_3) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max (max (max u5 u3) u2) u1} (CategoryTheory.Functor.{u1, u3, u2, u5} J _inst_1 C _inst_3) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max (max (max u5 u3) u2) u1} (CategoryTheory.Functor.{u1, u3, u2, u5} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u5} J _inst_1 C _inst_3))) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} C (CategoryTheory.Category.toCategoryStruct.{u3, u5} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, u3, max (max (max u5 u3) u2) u1, u5} (CategoryTheory.Functor.{u1, u3, u2, u5} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u5} J _inst_1 C _inst_3) C _inst_3 (CategoryTheory.Limits.colim.{u1, u2, u3, u5} J _inst_1 C _inst_3 _inst_4)) G) (Prefunctor.map.{max (succ u2) (succ u3), succ u3, max (max (max u2 u1) u5) u3, u5} (CategoryTheory.Functor.{u1, u3, u2, u5} J _inst_1 C _inst_3) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u2, max (max (max u5 u3) u2) u1} (CategoryTheory.Functor.{u1, u3, u2, u5} J _inst_1 C _inst_3) (CategoryTheory.Category.toCategoryStruct.{max u3 u2, max (max (max u5 u3) u2) u1} (CategoryTheory.Functor.{u1, u3, u2, u5} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u5} J _inst_1 C _inst_3))) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} C (CategoryTheory.Category.toCategoryStruct.{u3, u5} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{max u3 u2, u3, max (max (max u5 u3) u2) u1, u5} (CategoryTheory.Functor.{u1, u3, u2, u5} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u5} J _inst_1 C _inst_3) C _inst_3 (CategoryTheory.Limits.colim.{u1, u2, u3, u5} J _inst_1 C _inst_3 _inst_4)) F G Œ±))) (CategoryTheory.CategoryStruct.comp.{u4, u6} D (CategoryTheory.Category.toCategoryStruct.{u4, u6} D _inst_5) (Prefunctor.obj.{max (succ u2) (succ u4), succ u4, max (max (max u2 u1) u6) u4, u6} (CategoryTheory.Functor.{u1, u4, u2, u6} J _inst_1 D _inst_5) (CategoryTheory.CategoryStruct.toQuiver.{max u4 u2, max (max (max u6 u4) u2) u1} (CategoryTheory.Functor.{u1, u4, u2, u6} J _inst_1 D _inst_5) (CategoryTheory.Category.toCategoryStruct.{max u4 u2, max (max (max u6 u4) u2) u1} (CategoryTheory.Functor.{u1, u4, u2, u6} J _inst_1 D _inst_5) (CategoryTheory.Functor.category.{u1, u4, u2, u6} J _inst_1 D _inst_5))) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} D (CategoryTheory.Category.toCategoryStruct.{u4, u6} D _inst_5)) (CategoryTheory.Functor.toPrefunctor.{max u4 u2, u4, max (max (max u6 u4) u2) u1, u6} (CategoryTheory.Functor.{u1, u4, u2, u6} J _inst_1 D _inst_5) (CategoryTheory.Functor.category.{u1, u4, u2, u6} J _inst_1 D _inst_5) D _inst_5 (CategoryTheory.Limits.colim.{u1, u2, u4, u6} J _inst_1 D _inst_5 _inst_6)) (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_1 C _inst_3 D _inst_5 F H)) (Prefunctor.obj.{max (succ u2) (succ u4), succ u4, max (max (max u2 u1) u6) u4, u6} (CategoryTheory.Functor.{u1, u4, u2, u6} J _inst_1 D _inst_5) (CategoryTheory.CategoryStruct.toQuiver.{max u4 u2, max (max (max u6 u4) u2) u1} (CategoryTheory.Functor.{u1, u4, u2, u6} J _inst_1 D _inst_5) (CategoryTheory.Category.toCategoryStruct.{max u4 u2, max (max (max u6 u4) u2) u1} (CategoryTheory.Functor.{u1, u4, u2, u6} J _inst_1 D _inst_5) (CategoryTheory.Functor.category.{u1, u4, u2, u6} J _inst_1 D _inst_5))) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} D (CategoryTheory.Category.toCategoryStruct.{u4, u6} D _inst_5)) (CategoryTheory.Functor.toPrefunctor.{max u4 u2, u4, max (max (max u6 u4) u2) u1, u6} (CategoryTheory.Functor.{u1, u4, u2, u6} J _inst_1 D _inst_5) (CategoryTheory.Functor.category.{u1, u4, u2, u6} J _inst_1 D _inst_5) D _inst_5 (CategoryTheory.Limits.colim.{u1, u2, u4, u6} J _inst_1 D _inst_5 _inst_6)) (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_1 C _inst_3 D _inst_5 G H)) (Prefunctor.obj.{succ u3, succ u4, u5, u6} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} C (CategoryTheory.Category.toCategoryStruct.{u3, u5} C _inst_3)) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} D (CategoryTheory.Category.toCategoryStruct.{u4, u6} D _inst_5)) (CategoryTheory.Functor.toPrefunctor.{u3, u4, u5, u6} C _inst_3 D _inst_5 H) (CategoryTheory.Limits.colimit.{u1, u2, u3, u5} J _inst_1 C _inst_3 G (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u1, u2, u3, u5} C _inst_3 J _inst_1 _inst_4 G))) (Prefunctor.map.{max (succ u2) (succ u4), succ u4, max (max (max u2 u1) u6) u4, u6} (CategoryTheory.Functor.{u1, u4, u2, u6} J _inst_1 D _inst_5) (CategoryTheory.CategoryStruct.toQuiver.{max u4 u2, max (max (max u6 u4) u2) u1} (CategoryTheory.Functor.{u1, u4, u2, u6} J _inst_1 D _inst_5) (CategoryTheory.Category.toCategoryStruct.{max u4 u2, max (max (max u6 u4) u2) u1} (CategoryTheory.Functor.{u1, u4, u2, u6} J _inst_1 D _inst_5) (CategoryTheory.Functor.category.{u1, u4, u2, u6} J _inst_1 D _inst_5))) D (CategoryTheory.CategoryStruct.toQuiver.{u4, u6} D (CategoryTheory.Category.toCategoryStruct.{u4, u6} D _inst_5)) (CategoryTheory.Functor.toPrefunctor.{max u4 u2, u4, max (max (max u6 u4) u2) u1, u6} (CategoryTheory.Functor.{u1, u4, u2, u6} J _inst_1 D _inst_5) (CategoryTheory.Functor.category.{u1, u4, u2, u6} J _inst_1 D _inst_5) D _inst_5 (CategoryTheory.Limits.colim.{u1, u2, u4, u6} J _inst_1 D _inst_5 _inst_6)) (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_1 C _inst_3 D _inst_5 F H) (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_1 C _inst_3 D _inst_5 G H) (CategoryTheory.whiskerRight.{u2, u1, u5, u3, u6, u4} J _inst_1 C _inst_3 D _inst_5 F G Œ± H)) (CategoryTheory.Limits.colimit.post.{u1, u2, u3, u4, u5, u6} J _inst_1 C _inst_3 G D _inst_5 (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u1, u2, u3, u5} C _inst_3 J _inst_1 _inst_4 G) H (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u1, u2, u4, u6} D _inst_5 J _inst_1 _inst_6 (CategoryTheory.Functor.comp.{u1, u3, u4, u2, u5, u6} J _inst_1 C _inst_3 D _inst_5 G H))))
Case conversion may be inaccurate. Consider using '#align category_theory.limits.colimit.map_post CategoryTheory.Limits.colimit.map_post‚Çì'. -/
theorem colimit.map_post {D : Type u'} [Category.{v'} D] [HasColimitsOfShape J D]
    (H : C ‚•§ D) :/- H (colimit F) ‚ü∂ H (colimit G) ‚ü∂ colimit (G ‚ãô H) vs
             H (colimit F) ‚ü∂ colimit (F ‚ãô H) ‚ü∂ colimit (G ‚ãô H) -/
          colimit.post
          F H ‚â´
        H.map (colim.map Œ±) =
      colim.map (whiskerRight Œ± H) ‚â´ colimit.post G H :=
  by
  ext
  rw [‚Üê assoc, colimit.Œπ_post, ‚Üê H.map_comp, colimit.Œπ_map, H.map_comp]
  rw [‚Üê assoc, colimit.Œπ_map, assoc, colimit.Œπ_post]
  rfl
#align category_theory.limits.colimit.map_post CategoryTheory.Limits.colimit.map_post

/- warning: category_theory.limits.colim_coyoneda -> CategoryTheory.Limits.colimCoyoneda is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {C : Type.{u4}} [_inst_3 : CategoryTheory.Category.{u3, u4} C] [_inst_4 : CategoryTheory.Limits.HasColimitsOfShape.{u1, u2, u3, u4} J _inst_1 C _inst_3], CategoryTheory.Iso.{max (max u1 u3 u2 u4) u4 u3 u2, max (max u2 u3) (max u4 u3 u2) (max u1 u3 u2 u4) u3 (max u3 u2) u4 (succ (max u3 u2))} (CategoryTheory.Functor.{max u2 u3, max u4 u3 u2, max u1 u3 u2 u4, max u3 (max u3 u2) u4 (succ (max u3 u2))} (Opposite.{succ (max u1 u3 u2 u4)} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3)) (CategoryTheory.Category.opposite.{max u2 u3, max u1 u3 u2 u4} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3)) (CategoryTheory.Functor.{u3, max u3 u2, u4, succ (max u3 u2)} C _inst_3 Type.{max u3 u2} CategoryTheory.types.{max u3 u2}) (CategoryTheory.Functor.category.{u3, max u3 u2, u4, succ (max u3 u2)} C _inst_3 Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.Functor.category.{max u2 u3, max u4 u3 u2, max u1 u3 u2 u4, max u3 (max u3 u2) u4 (succ (max u3 u2))} (Opposite.{succ (max u1 u3 u2 u4)} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3)) (CategoryTheory.Category.opposite.{max u2 u3, max u1 u3 u2 u4} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3)) (CategoryTheory.Functor.{u3, max u3 u2, u4, succ (max u3 u2)} C _inst_3 Type.{max u3 u2} CategoryTheory.types.{max u3 u2}) (CategoryTheory.Functor.category.{u3, max u3 u2, u4, succ (max u3 u2)} C _inst_3 Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.Functor.comp.{max u2 u3, u3, max u4 u3 u2, max u1 u3 u2 u4, u4, max u3 (max u3 u2) u4 (succ (max u3 u2))} (Opposite.{succ (max u1 u3 u2 u4)} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3)) (CategoryTheory.Category.opposite.{max u2 u3, max u1 u3 u2 u4} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3)) (Opposite.{succ u4} C) (CategoryTheory.Category.opposite.{u3, u4} C _inst_3) (CategoryTheory.Functor.{u3, max u3 u2, u4, succ (max u3 u2)} C _inst_3 Type.{max u3 u2} CategoryTheory.types.{max u3 u2}) (CategoryTheory.Functor.category.{u3, max u3 u2, u4, succ (max u3 u2)} C _inst_3 Type.{max u3 u2} CategoryTheory.types.{max u3 u2}) (CategoryTheory.Functor.op.{max u2 u3, u3, max u1 u3 u2 u4, u4} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3) C _inst_3 (CategoryTheory.Limits.colim.{u1, u2, u3, u4} J _inst_1 C _inst_3 _inst_4)) (CategoryTheory.Functor.comp.{u3, max u4 u3, max u4 u3 u2, u4, max u3 u4 (succ u3), max u3 (max u3 u2) u4 (succ (max u3 u2))} (Opposite.{succ u4} C) (CategoryTheory.Category.opposite.{u3, u4} C _inst_3) (CategoryTheory.Functor.{u3, u3, u4, succ u3} C _inst_3 Type.{u3} CategoryTheory.types.{u3}) (CategoryTheory.Functor.category.{u3, u3, u4, succ u3} C _inst_3 Type.{u3} CategoryTheory.types.{u3}) (CategoryTheory.Functor.{u3, max u3 u2, u4, succ (max u3 u2)} C _inst_3 Type.{max u3 u2} CategoryTheory.types.{max u3 u2}) (CategoryTheory.Functor.category.{u3, max u3 u2, u4, succ (max u3 u2)} C _inst_3 Type.{max u3 u2} CategoryTheory.types.{max u3 u2}) (CategoryTheory.coyoneda.{u3, u4} C _inst_3) (CategoryTheory.Functor.obj.{max (succ u3) u3 u2, max (max u3 u4 (succ u3)) u4 u3 u2, max u3 (max u3 u2) (succ u3) (succ (max u3 u2)), max (max u4 u3) (max u4 u3 u2) (max u3 u4 (succ u3)) u3 (max u3 u2) u4 (succ (max u3 u2))} (CategoryTheory.Functor.{u3, max u3 u2, succ u3, succ (max u3 u2)} Type.{u3} CategoryTheory.types.{u3} Type.{max u3 u2} CategoryTheory.types.{max u3 u2}) (CategoryTheory.Functor.category.{u3, max u3 u2, succ u3, succ (max u3 u2)} Type.{u3} CategoryTheory.types.{u3} Type.{max u3 u2} CategoryTheory.types.{max u3 u2}) (CategoryTheory.Functor.{max u4 u3, max u4 u3 u2, max u3 u4 (succ u3), max u3 (max u3 u2) u4 (succ (max u3 u2))} (CategoryTheory.Functor.{u3, u3, u4, succ u3} C _inst_3 Type.{u3} CategoryTheory.types.{u3}) (CategoryTheory.Functor.category.{u3, u3, u4, succ u3} C _inst_3 Type.{u3} CategoryTheory.types.{u3}) (CategoryTheory.Functor.{u3, max u3 u2, u4, succ (max u3 u2)} C _inst_3 Type.{max u3 u2} CategoryTheory.types.{max u3 u2}) (CategoryTheory.Functor.category.{u3, max u3 u2, u4, succ (max u3 u2)} C _inst_3 Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.Functor.category.{max u4 u3, max u4 u3 u2, max u3 u4 (succ u3), max u3 (max u3 u2) u4 (succ (max u3 u2))} (CategoryTheory.Functor.{u3, u3, u4, succ u3} C _inst_3 Type.{u3} CategoryTheory.types.{u3}) (CategoryTheory.Functor.category.{u3, u3, u4, succ u3} C _inst_3 Type.{u3} CategoryTheory.types.{u3}) (CategoryTheory.Functor.{u3, max u3 u2, u4, succ (max u3 u2)} C _inst_3 Type.{max u3 u2} CategoryTheory.types.{max u3 u2}) (CategoryTheory.Functor.category.{u3, max u3 u2, u4, succ (max u3 u2)} C _inst_3 Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.whiskeringRight.{u4, u3, succ u3, u3, succ (max u3 u2), max u3 u2} C _inst_3 Type.{u3} CategoryTheory.types.{u3} Type.{max u3 u2} CategoryTheory.types.{max u3 u2}) CategoryTheory.uliftFunctor.{u2, u3}))) (CategoryTheory.cocones.{u1, u3, u2, u4} J _inst_1 C _inst_3)
but is expected to have type
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {C : Type.{u4}} [_inst_3 : CategoryTheory.Category.{u3, u4} C] [_inst_4 : CategoryTheory.Limits.HasColimitsOfShape.{u1, u2, u3, u4} J _inst_1 C _inst_3], CategoryTheory.Iso.{max (max (max u4 u2) u3) u1, max (max (max (max (max (max (max u2 u3) (succ u2) (succ u3)) u3) u4) (max (max u2 u1) u4) u3) (max u2 u3) u4) u2 u3} (CategoryTheory.Functor.{max u2 u3, max (max u2 u3) u4, max (max (max u2 u1) u4) u3, max (max (max (max u2 u3) (succ u2) (succ u3)) u3) u4} (Opposite.{succ (max (max (max u4 u3) u2) u1)} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3)) (CategoryTheory.Category.opposite.{max u3 u2, max (max (max u4 u3) u2) u1} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3)) (CategoryTheory.Functor.{u3, max u2 u3, u4, max (succ u2) (succ u3)} C _inst_3 Type.{max u3 u2} CategoryTheory.types.{max u3 u2}) (CategoryTheory.Functor.category.{u3, max u2 u3, u4, max (succ u2) (succ u3)} C _inst_3 Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.Functor.category.{max u2 u3, max (max u4 u2) u3, max (max (max u4 u2) u3) u1, max (max u4 (succ u2)) (succ u3)} (Opposite.{succ (max (max (max u4 u3) u2) u1)} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3)) (CategoryTheory.Category.opposite.{max u3 u2, max (max (max u4 u3) u2) u1} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3)) (CategoryTheory.Functor.{u3, max u2 u3, u4, max (succ u2) (succ u3)} C _inst_3 Type.{max u3 u2} CategoryTheory.types.{max u3 u2}) (CategoryTheory.Functor.category.{u3, max u2 u3, u4, max (succ u2) (succ u3)} C _inst_3 Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.Functor.comp.{max u2 u3, u3, max (max u2 u3) u4, max (max (max u2 u1) u4) u3, u4, max (max (max (max u2 u3) (succ u2) (succ u3)) u3) u4} (Opposite.{succ (max (max (max u4 u3) u2) u1)} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3)) (CategoryTheory.Category.opposite.{max u3 u2, max (max (max u4 u3) u2) u1} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3)) (Opposite.{succ u4} C) (CategoryTheory.Category.opposite.{u3, u4} C _inst_3) (CategoryTheory.Functor.{u3, max u2 u3, u4, max (succ u2) (succ u3)} C _inst_3 Type.{max u3 u2} CategoryTheory.types.{max u3 u2}) (CategoryTheory.Functor.category.{u3, max u2 u3, u4, max (succ u2) (succ u3)} C _inst_3 Type.{max u3 u2} CategoryTheory.types.{max u3 u2}) (CategoryTheory.Functor.op.{max u3 u2, u3, max (max (max u4 u3) u2) u1, u4} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3) C _inst_3 (CategoryTheory.Limits.colim.{u1, u2, u3, u4} J _inst_1 C _inst_3 _inst_4)) (CategoryTheory.Functor.comp.{u3, max u4 u3, max (max u2 u3) u4, u4, max u4 (succ u3), max (max (max (max u2 u3) (succ u2) (succ u3)) u3) u4} (Opposite.{succ u4} C) (CategoryTheory.Category.opposite.{u3, u4} C _inst_3) (CategoryTheory.Functor.{u3, u3, u4, succ u3} C _inst_3 Type.{u3} CategoryTheory.types.{u3}) (CategoryTheory.Functor.category.{u3, u3, u4, succ u3} C _inst_3 Type.{u3} CategoryTheory.types.{u3}) (CategoryTheory.Functor.{u3, max u2 u3, u4, max (succ u2) (succ u3)} C _inst_3 Type.{max u3 u2} CategoryTheory.types.{max u3 u2}) (CategoryTheory.Functor.category.{u3, max u2 u3, u4, max (succ u2) (succ u3)} C _inst_3 Type.{max u3 u2} CategoryTheory.types.{max u3 u2}) (CategoryTheory.coyoneda.{u3, u4} C _inst_3) (Prefunctor.obj.{max (succ (max u2 u3)) (succ (succ u3)), max (max (max (max (succ (max u2 u3)) (succ u3)) (succ (succ u3))) (succ u3)) (succ u4), max (max (max (max u2 u3) (succ u2) (succ u3)) u3) (succ u3), max (max (max (max (max (max u2 u3) (succ u2) (succ u3)) u3) (succ u3)) u3) u4} (CategoryTheory.Functor.{u3, max u2 u3, succ u3, max (succ u2) (succ u3)} Type.{u3} CategoryTheory.types.{u3} Type.{max u3 u2} CategoryTheory.types.{max u3 u2}) (CategoryTheory.CategoryStruct.toQuiver.{max (max u2 u3) (succ u3), max (max (max (max u2 u3) (succ u2) (succ u3)) u3) (succ u3)} (CategoryTheory.Functor.{u3, max u2 u3, succ u3, max (succ u2) (succ u3)} Type.{u3} CategoryTheory.types.{u3} Type.{max u3 u2} CategoryTheory.types.{max u3 u2}) (CategoryTheory.Category.toCategoryStruct.{max (max u2 u3) (succ u3), max (max (max (max u2 u3) (succ u2) (succ u3)) u3) (succ u3)} (CategoryTheory.Functor.{u3, max u2 u3, succ u3, max (succ u2) (succ u3)} Type.{u3} CategoryTheory.types.{u3} Type.{max u3 u2} CategoryTheory.types.{max u3 u2}) (CategoryTheory.Functor.category.{u3, max u2 u3, succ u3, max (succ u2) (succ u3)} Type.{u3} CategoryTheory.types.{u3} Type.{max u3 u2} CategoryTheory.types.{max u3 u2}))) (CategoryTheory.Functor.{max u4 u3, max u4 u2 u3, max (max (succ u3) u4) u3, max (max (max (max (succ u2) (succ u3)) u4) u2 u3) u3} (CategoryTheory.Functor.{u3, u3, u4, succ u3} C _inst_3 Type.{u3} CategoryTheory.types.{u3}) (CategoryTheory.Functor.category.{u3, u3, u4, succ u3} C _inst_3 Type.{u3} CategoryTheory.types.{u3}) (CategoryTheory.Functor.{u3, max u2 u3, u4, max (succ u2) (succ u3)} C _inst_3 Type.{max u3 u2} CategoryTheory.types.{max u3 u2}) (CategoryTheory.Functor.category.{u3, max u2 u3, u4, max (succ u2) (succ u3)} C _inst_3 Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.CategoryStruct.toQuiver.{max (max (max (max u2 u3) (succ u3)) u3) u4, max (max (max (max (max (max u2 u3) (succ u2) (succ u3)) u3) (succ u3)) u3) u4} (CategoryTheory.Functor.{max u4 u3, max u4 u2 u3, max (max (succ u3) u4) u3, max (max (max (max (succ u2) (succ u3)) u4) u2 u3) u3} (CategoryTheory.Functor.{u3, u3, u4, succ u3} C _inst_3 Type.{u3} CategoryTheory.types.{u3}) (CategoryTheory.Functor.category.{u3, u3, u4, succ u3} C _inst_3 Type.{u3} CategoryTheory.types.{u3}) (CategoryTheory.Functor.{u3, max u2 u3, u4, max (succ u2) (succ u3)} C _inst_3 Type.{max u3 u2} CategoryTheory.types.{max u3 u2}) (CategoryTheory.Functor.category.{u3, max u2 u3, u4, max (succ u2) (succ u3)} C _inst_3 Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.Category.toCategoryStruct.{max (max (max (max u2 u3) (succ u3)) u3) u4, max (max (max (max (max (max u2 u3) (succ u2) (succ u3)) u3) (succ u3)) u3) u4} (CategoryTheory.Functor.{max u4 u3, max u4 u2 u3, max (max (succ u3) u4) u3, max (max (max (max (succ u2) (succ u3)) u4) u2 u3) u3} (CategoryTheory.Functor.{u3, u3, u4, succ u3} C _inst_3 Type.{u3} CategoryTheory.types.{u3}) (CategoryTheory.Functor.category.{u3, u3, u4, succ u3} C _inst_3 Type.{u3} CategoryTheory.types.{u3}) (CategoryTheory.Functor.{u3, max u2 u3, u4, max (succ u2) (succ u3)} C _inst_3 Type.{max u3 u2} CategoryTheory.types.{max u3 u2}) (CategoryTheory.Functor.category.{u3, max u2 u3, u4, max (succ u2) (succ u3)} C _inst_3 Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.Functor.category.{max u4 u3, max u4 u2 u3, max (max u4 (succ u3)) u3, max (max (max u4 (succ u2) (succ u3)) u3) u2 u3} (CategoryTheory.Functor.{u3, u3, u4, succ u3} C _inst_3 Type.{u3} CategoryTheory.types.{u3}) (CategoryTheory.Functor.category.{u3, u3, u4, succ u3} C _inst_3 Type.{u3} CategoryTheory.types.{u3}) (CategoryTheory.Functor.{u3, max u2 u3, u4, max (succ u2) (succ u3)} C _inst_3 Type.{max u3 u2} CategoryTheory.types.{max u3 u2}) (CategoryTheory.Functor.category.{u3, max u2 u3, u4, max (succ u2) (succ u3)} C _inst_3 Type.{max u3 u2} CategoryTheory.types.{max u3 u2})))) (CategoryTheory.Functor.toPrefunctor.{max (max u2 u3) (succ u3), max (max (max (max u2 u3) (succ u3)) u3) u4, max (max (max (max u2 u3) (succ u2) (succ u3)) u3) (succ u3), max (max (max (max (max (max u2 u3) (succ u2) (succ u3)) u3) (succ u3)) u3) u4} (CategoryTheory.Functor.{u3, max u2 u3, succ u3, max (succ u2) (succ u3)} Type.{u3} CategoryTheory.types.{u3} Type.{max u3 u2} CategoryTheory.types.{max u3 u2}) (CategoryTheory.Functor.category.{u3, max u2 u3, succ u3, max (succ u2) (succ u3)} Type.{u3} CategoryTheory.types.{u3} Type.{max u3 u2} CategoryTheory.types.{max u3 u2}) (CategoryTheory.Functor.{max u4 u3, max u4 u2 u3, max (max (succ u3) u4) u3, max (max (max (max (succ u2) (succ u3)) u4) u2 u3) u3} (CategoryTheory.Functor.{u3, u3, u4, succ u3} C _inst_3 Type.{u3} CategoryTheory.types.{u3}) (CategoryTheory.Functor.category.{u3, u3, u4, succ u3} C _inst_3 Type.{u3} CategoryTheory.types.{u3}) (CategoryTheory.Functor.{u3, max u2 u3, u4, max (succ u2) (succ u3)} C _inst_3 Type.{max u3 u2} CategoryTheory.types.{max u3 u2}) (CategoryTheory.Functor.category.{u3, max u2 u3, u4, max (succ u2) (succ u3)} C _inst_3 Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.Functor.category.{max u4 u3, max u4 u2 u3, max (max u4 (succ u3)) u3, max (max (max u4 (succ u2) (succ u3)) u3) u2 u3} (CategoryTheory.Functor.{u3, u3, u4, succ u3} C _inst_3 Type.{u3} CategoryTheory.types.{u3}) (CategoryTheory.Functor.category.{u3, u3, u4, succ u3} C _inst_3 Type.{u3} CategoryTheory.types.{u3}) (CategoryTheory.Functor.{u3, max u2 u3, u4, max (succ u2) (succ u3)} C _inst_3 Type.{max u3 u2} CategoryTheory.types.{max u3 u2}) (CategoryTheory.Functor.category.{u3, max u2 u3, u4, max (succ u2) (succ u3)} C _inst_3 Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) (CategoryTheory.whiskeringRight.{u4, u3, succ u3, u3, max (succ u2) (succ u3), max u2 u3} C _inst_3 Type.{u3} CategoryTheory.types.{u3} Type.{max u3 u2} CategoryTheory.types.{max u3 u2})) CategoryTheory.uliftFunctor.{u2, u3}))) (CategoryTheory.cocones.{u1, u3, u2, u4} J _inst_1 C _inst_3)
Case conversion may be inaccurate. Consider using '#align category_theory.limits.colim_coyoneda CategoryTheory.Limits.colimCoyoneda‚Çì'. -/
/-- The isomorphism between
morphisms from the cone point of the colimit cocone for `F` to `W`
and cocones over `F` with cone point `W`
is natural in `F`.
-/
def colimCoyoneda :
    colim.op ‚ãô coyoneda ‚ãô (whiskeringRight _ _ _).obj uliftFunctor.{u‚ÇÅ} ‚âÖ
      CategoryTheory.cocones J C :=
  NatIso.ofComponents (fun F => NatIso.ofComponents (colimit.homIso (unop F)) (by tidy)) (by tidy)
#align category_theory.limits.colim_coyoneda CategoryTheory.Limits.colimCoyoneda

#print CategoryTheory.Limits.colimConstAdj /-
/-- The colimit functor and constant functor are adjoint to each other
-/
def colimConstAdj : (colim : (J ‚•§ C) ‚•§ C) ‚ä£ const J
    where
  homEquiv f c :=
    { toFun := fun g =>
        { app := fun _ => colimit.Œπ _ _ ‚â´ g
          naturality' := by tidy }
      invFun := fun g => colimit.desc _ ‚ü®_, g‚ü©
      left_inv := fun _ => colimit.hom_ext fun j => colimit.Œπ_desc _ _
      right_inv := fun _ => NatTrans.ext _ _ <| funext fun j => colimit.Œπ_desc _ _ }
  Unit :=
    { app := fun g =>
        { app := colimit.Œπ _
          naturality' := by tidy }
      naturality' := by tidy }
  counit :=
    { app := fun c => colimit.desc _ ‚ü®_, ùüô _‚ü©
      naturality' := by tidy }
  homEquiv_unit _ _ _ := NatTrans.ext _ _ <| funext fun _ => rfl
  homEquiv_counit _ _ _ := colimit.hom_ext fun _ => by simp
#align category_theory.limits.colim_const_adj CategoryTheory.Limits.colimConstAdj
-/

instance : IsLeftAdjoint (colim : (J ‚•§ C) ‚•§ C) :=
  ‚ü®_, colimConstAdj‚ü©

end ColimFunctor

#print CategoryTheory.Limits.colimMap_epi' /-
instance colimMap_epi' {F G : J ‚•§ C} [HasColimitsOfShape J C] (Œ± : F ‚ü∂ G) [Epi Œ±] :
    Epi (colimMap Œ±) :=
  (colim : (J ‚•§ C) ‚•§ C).map_epi Œ±
#align category_theory.limits.colim_map_epi' CategoryTheory.Limits.colimMap_epi'
-/

/- warning: category_theory.limits.colim_map_epi -> CategoryTheory.Limits.colimMap_epi is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {C : Type.{u4}} [_inst_3 : CategoryTheory.Category.{u3, u4} C] {F : CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3} {G : CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3} [_inst_4 : CategoryTheory.Limits.HasColimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F] [_inst_5 : CategoryTheory.Limits.HasColimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 G] (Œ± : Quiver.Hom.{succ (max u2 u3), max u1 u3 u2 u4} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u3, max u1 u3 u2 u4} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Category.toCategoryStruct.{max u2 u3, max u1 u3 u2 u4} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3))) F G) [_inst_6 : forall (j : J), CategoryTheory.Epi.{u3, u4} C _inst_3 (CategoryTheory.Functor.obj.{u1, u3, u2, u4} J _inst_1 C _inst_3 F j) (CategoryTheory.Functor.obj.{u1, u3, u2, u4} J _inst_1 C _inst_3 G j) (CategoryTheory.NatTrans.app.{u1, u3, u2, u4} J _inst_1 C _inst_3 F G Œ± j)], CategoryTheory.Epi.{u3, u4} C _inst_3 (CategoryTheory.Limits.colimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4) (CategoryTheory.Limits.colimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 G _inst_5) (CategoryTheory.Limits.colimMap.{u1, u2, u3, u4} J _inst_1 C _inst_3 F G _inst_4 _inst_5 Œ±)
but is expected to have type
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {C : Type.{u4}} [_inst_3 : CategoryTheory.Category.{u3, u4} C] {F : CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3} {G : CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3} [_inst_4 : CategoryTheory.Limits.HasColimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F] [_inst_5 : CategoryTheory.Limits.HasColimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 G] (Œ± : Quiver.Hom.{max (succ u2) (succ u3), max (max (max u4 u2) u3) u1} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u3, max (max (max u4 u2) u3) u1} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Category.toCategoryStruct.{max u2 u3, max (max (max u4 u2) u3) u1} (CategoryTheory.Functor.{u1, u3, u2, u4} J _inst_1 C _inst_3) (CategoryTheory.Functor.category.{u1, u3, u2, u4} J _inst_1 C _inst_3))) F G) [_inst_6 : forall (j : J), CategoryTheory.Epi.{u3, u4} C _inst_3 (Prefunctor.obj.{succ u1, succ u3, u2, u4} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, u4} J _inst_1 C _inst_3 F) j) (Prefunctor.obj.{succ u1, succ u3, u2, u4} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u3, u4} C (CategoryTheory.Category.toCategoryStruct.{u3, u4} C _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, u4} J _inst_1 C _inst_3 G) j) (CategoryTheory.NatTrans.app.{u1, u3, u2, u4} J _inst_1 C _inst_3 F G Œ± j)], CategoryTheory.Epi.{u3, u4} C _inst_3 (CategoryTheory.Limits.colimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 F _inst_4) (CategoryTheory.Limits.colimit.{u1, u2, u3, u4} J _inst_1 C _inst_3 G _inst_5) (CategoryTheory.Limits.colimMap.{u1, u2, u3, u4} J _inst_1 C _inst_3 F G _inst_4 _inst_5 Œ±)
Case conversion may be inaccurate. Consider using '#align category_theory.limits.colim_map_epi CategoryTheory.Limits.colimMap_epi‚Çì'. -/
instance colimMap_epi {F G : J ‚•§ C} [HasColimit F] [HasColimit G] (Œ± : F ‚ü∂ G) [‚àÄ j, Epi (Œ±.app j)] :
    Epi (colimMap Œ±) :=
  ‚ü®fun Z u v h =>
    colimit.hom_ext fun j => (cancel_epi (Œ±.app j)).1 <| by simpa using colimit.Œπ _ j ‚â´= h‚ü©
#align category_theory.limits.colim_map_epi CategoryTheory.Limits.colimMap_epi

/- warning: category_theory.limits.has_colimits_of_shape_of_equivalence -> CategoryTheory.Limits.hasColimitsOfShape_of_equivalence is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {C : Type.{u6}} [_inst_3 : CategoryTheory.Category.{u5, u6} C] {J' : Type.{u4}} [_inst_4 : CategoryTheory.Category.{u3, u4} J'], (CategoryTheory.Equivalence.{u1, u3, u2, u4} J _inst_1 J' _inst_4) -> (forall [_inst_5 : CategoryTheory.Limits.HasColimitsOfShape.{u1, u2, u5, u6} J _inst_1 C _inst_3], CategoryTheory.Limits.HasColimitsOfShape.{u3, u4, u5, u6} J' _inst_4 C _inst_3)
but is expected to have type
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] {C : Type.{u6}} [_inst_3 : CategoryTheory.Category.{u5, u6} C] {J' : Type.{u4}} [_inst_4 : CategoryTheory.Category.{u3, u4} J'], (CategoryTheory.Equivalence.{u1, u3, u2, u4} J J' _inst_1 _inst_4) -> (forall [_inst_5 : CategoryTheory.Limits.HasColimitsOfShape.{u1, u2, u5, u6} J _inst_1 C _inst_3], CategoryTheory.Limits.HasColimitsOfShape.{u3, u4, u5, u6} J' _inst_4 C _inst_3)
Case conversion may be inaccurate. Consider using '#align category_theory.limits.has_colimits_of_shape_of_equivalence CategoryTheory.Limits.hasColimitsOfShape_of_equivalence‚Çì'. -/
/-- We can transport colimits of shape `J` along an equivalence `J ‚âå J'`.
-/
theorem hasColimitsOfShape_of_equivalence {J' : Type u‚ÇÇ} [Category.{v‚ÇÇ} J'] (e : J ‚âå J')
    [HasColimitsOfShape J C] : HasColimitsOfShape J' C :=
  by
  constructor
  intro F
  apply has_colimit_of_equivalence_comp e
  infer_instance
#align category_theory.limits.has_colimits_of_shape_of_equivalence CategoryTheory.Limits.hasColimitsOfShape_of_equivalence

variable (C)

#print CategoryTheory.Limits.hasColimitsOfSize_shrink /-
/-- `has_colimits_of_size_shrink.{v u} C` tries to obtain `has_colimits_of_size.{v u} C`
from some other `has_colimits_of_size C`.
-/
theorem hasColimitsOfSize_shrink [HasColimitsOfSize.{max v‚ÇÅ v‚ÇÇ, max u‚ÇÅ u‚ÇÇ} C] :
    HasColimitsOfSize.{v‚ÇÅ, u‚ÇÅ} C :=
  ‚ü®fun J hJ => has_colimits_of_shape_of_equivalence (ULiftHomULiftCategory.equiv.{v‚ÇÇ, u‚ÇÇ} J).symm‚ü©
#align category_theory.limits.has_colimits_of_size_shrink CategoryTheory.Limits.hasColimitsOfSize_shrink
-/

#print CategoryTheory.Limits.hasSmallestColimitsOfHasColimits /-
instance (priority := 100) hasSmallestColimitsOfHasColimits [HasColimits C] :
    HasColimitsOfSize.{0, 0} C :=
  hasColimitsOfSize_shrink.{0, 0} C
#align category_theory.limits.has_smallest_colimits_of_has_colimits CategoryTheory.Limits.hasSmallestColimitsOfHasColimits
-/

end Colimit

section Opposite

#print CategoryTheory.Limits.IsLimit.op /-
/-- If `t : cone F` is a limit cone, then `t.op : cocone F.op` is a colimit cocone.
-/
def IsLimit.op {t : Cone F} (P : IsLimit t) : IsColimit t.op
    where
  desc s := (P.lift s.unop).op
  fac s j := congr_arg Quiver.Hom.op (P.fac s.unop (unop j))
  uniq s m w := by
    rw [‚Üê P.uniq s.unop m.unop]
    ¬∑ rfl
    ¬∑ dsimp
      intro j
      rw [‚Üê w]
      rfl
#align category_theory.limits.is_limit.op CategoryTheory.Limits.IsLimit.op
-/

#print CategoryTheory.Limits.IsColimit.op /-
/-- If `t : cocone F` is a colimit cocone, then `t.op : cone F.op` is a limit cone.
-/
def IsColimit.op {t : Cocone F} (P : IsColimit t) : IsLimit t.op
    where
  lift s := (P.desc s.unop).op
  fac s j := congr_arg Quiver.Hom.op (P.fac s.unop (unop j))
  uniq s m w := by
    rw [‚Üê P.uniq s.unop m.unop]
    ¬∑ rfl
    ¬∑ dsimp
      intro j
      rw [‚Üê w]
      rfl
#align category_theory.limits.is_colimit.op CategoryTheory.Limits.IsColimit.op
-/

#print CategoryTheory.Limits.IsLimit.unop /-
/-- If `t : cone F.op` is a limit cone, then `t.unop : cocone F` is a colimit cocone.
-/
def IsLimit.unop {t : Cone F.op} (P : IsLimit t) : IsColimit t.unop
    where
  desc s := (P.lift s.op).unop
  fac s j := congr_arg Quiver.Hom.unop (P.fac s.op (op j))
  uniq s m w := by
    rw [‚Üê P.uniq s.op m.op]
    ¬∑ rfl
    ¬∑ dsimp
      intro j
      rw [‚Üê w]
      rfl
#align category_theory.limits.is_limit.unop CategoryTheory.Limits.IsLimit.unop
-/

#print CategoryTheory.Limits.IsColimit.unop /-
/-- If `t : cocone F.op` is a colimit cocone, then `t.unop : cone F.` is a limit cone.
-/
def IsColimit.unop {t : Cocone F.op} (P : IsColimit t) : IsLimit t.unop
    where
  lift s := (P.desc s.op).unop
  fac s j := congr_arg Quiver.Hom.unop (P.fac s.op (op j))
  uniq s m w := by
    rw [‚Üê P.uniq s.op m.op]
    ¬∑ rfl
    ¬∑ dsimp
      intro j
      rw [‚Üê w]
      rfl
#align category_theory.limits.is_colimit.unop CategoryTheory.Limits.IsColimit.unop
-/

#print CategoryTheory.Limits.isLimitEquivIsColimitOp /-
/-- `t : cone F` is a limit cone if and only is `t.op : cocone F.op` is a colimit cocone.
-/
def isLimitEquivIsColimitOp {t : Cone F} : IsLimit t ‚âÉ IsColimit t.op :=
  equivOfSubsingletonOfSubsingleton IsLimit.op fun P =>
    P.unop.ofIsoLimit (Cones.ext (Iso.refl _) (by tidy))
#align category_theory.limits.is_limit_equiv_is_colimit_op CategoryTheory.Limits.isLimitEquivIsColimitOp
-/

#print CategoryTheory.Limits.isColimitEquivIsLimitOp /-
/-- `t : cocone F` is a colimit cocone if and only is `t.op : cone F.op` is a limit cone.
-/
def isColimitEquivIsLimitOp {t : Cocone F} : IsColimit t ‚âÉ IsLimit t.op :=
  equivOfSubsingletonOfSubsingleton IsColimit.op fun P =>
    P.unop.ofIsoColimit (Cocones.ext (Iso.refl _) (by tidy))
#align category_theory.limits.is_colimit_equiv_is_limit_op CategoryTheory.Limits.isColimitEquivIsLimitOp
-/

end Opposite

end CategoryTheory.Limits

