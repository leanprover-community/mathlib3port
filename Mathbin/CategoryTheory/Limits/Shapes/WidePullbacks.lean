/-
Copyright (c) 2020 Bhavik Mehta. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Bhavik Mehta, Jakob von Raumer

! This file was ported from Lean 3 source module category_theory.limits.shapes.wide_pullbacks
! leanprover-community/mathlib commit 832f7b9162039c28b9361289c8681f155cae758f
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.CategoryTheory.Limits.HasLimits
import Mathbin.CategoryTheory.Thin

/-!
# Wide pullbacks

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

We define the category `wide_pullback_shape`, (resp. `wide_pushout_shape`) which is the category
obtained from a discrete category of type `J` by adjoining a terminal (resp. initial) element.
Limits of this shape are wide pullbacks (pushouts).
The convenience method `wide_cospan` (`wide_span`) constructs a functor from this category, hitting
the given morphisms.

We use `wide_pullback_shape` to define ordinary pullbacks (pushouts) by using `J := walking_pair`,
which allows easy proofs of some related lemmas.
Furthermore, wide pullbacks are used to show the existence of limits in the slice category.
Namely, if `C` has wide pullbacks then `C/B` has limits for any object `B` in `C`.

Typeclasses `has_wide_pullbacks` and `has_finite_wide_pullbacks` assert the existence of wide
pullbacks and finite wide pullbacks.
-/


universe w w' v u

open CategoryTheory CategoryTheory.Limits Opposite

namespace CategoryTheory.Limits

variable (J : Type w)

#print CategoryTheory.Limits.WidePullbackShape /-
/-- A wide pullback shape for any type `J` can be written simply as `option J`. -/
def WidePullbackShape :=
  Option J deriving Inhabited
#align category_theory.limits.wide_pullback_shape CategoryTheory.Limits.WidePullbackShape
-/

#print CategoryTheory.Limits.WidePushoutShape /-
/-- A wide pushout shape for any type `J` can be written simply as `option J`. -/
def WidePushoutShape :=
  Option J deriving Inhabited
#align category_theory.limits.wide_pushout_shape CategoryTheory.Limits.WidePushoutShape
-/

namespace WidePullbackShape

variable {J}

#print CategoryTheory.Limits.WidePullbackShape.Hom /-
/-- The type of arrows for the shape indexing a wide pullback. -/
inductive Hom : WidePullbackShape J â†’ WidePullbackShape J â†’ Type w
  | id : âˆ€ X, hom X X
  | term : âˆ€ j : J, hom (some j) none
  deriving DecidableEq
#align category_theory.limits.wide_pullback_shape.hom CategoryTheory.Limits.WidePullbackShape.Hom
-/

attribute [nolint unused_arguments] hom.decidable_eq

#print CategoryTheory.Limits.WidePullbackShape.struct /-
instance struct : CategoryStruct (WidePullbackShape J)
    where
  Hom := Hom
  id j := Hom.id j
  comp jâ‚ jâ‚‚ jâ‚ƒ f g := by
    cases f
    exact g
    cases g
    apply hom.term _
#align category_theory.limits.wide_pullback_shape.struct CategoryTheory.Limits.WidePullbackShape.struct
-/

#print CategoryTheory.Limits.WidePullbackShape.Hom.inhabited /-
instance Hom.inhabited : Inhabited (Hom none none) :=
  âŸ¨Hom.id (none : WidePullbackShape J)âŸ©
#align category_theory.limits.wide_pullback_shape.hom.inhabited CategoryTheory.Limits.WidePullbackShape.Hom.inhabited
-/

attribute [local tidy] tactic.case_bash

#print CategoryTheory.Limits.WidePullbackShape.subsingleton_hom /-
instance subsingleton_hom : Quiver.IsThin (WidePullbackShape J) := fun _ _ => âŸ¨by tidyâŸ©
#align category_theory.limits.wide_pullback_shape.subsingleton_hom CategoryTheory.Limits.WidePullbackShape.subsingleton_hom
-/

#print CategoryTheory.Limits.WidePullbackShape.category /-
instance category : SmallCategory (WidePullbackShape J) :=
  thin_category
#align category_theory.limits.wide_pullback_shape.category CategoryTheory.Limits.WidePullbackShape.category
-/

#print CategoryTheory.Limits.WidePullbackShape.hom_id /-
@[simp]
theorem hom_id (X : WidePullbackShape J) : Hom.id X = ğŸ™ X :=
  rfl
#align category_theory.limits.wide_pullback_shape.hom_id CategoryTheory.Limits.WidePullbackShape.hom_id
-/

variable {C : Type u} [Category.{v} C]

#print CategoryTheory.Limits.WidePullbackShape.wideCospan /-
/-- Construct a functor out of the wide pullback shape given a J-indexed collection of arrows to a
fixed object.
-/
@[simps]
def wideCospan (B : C) (objs : J â†’ C) (arrows : âˆ€ j : J, objs j âŸ¶ B) : WidePullbackShape J â¥¤ C
    where
  obj j := Option.casesOn j B objs
  map X Y f := by
    cases' f with _ j
    Â· apply ğŸ™ _
    Â· exact arrows j
  map_comp' _ _ _ f g := by
    cases f
    Â· simpa
    cases g
    simp
#align category_theory.limits.wide_pullback_shape.wide_cospan CategoryTheory.Limits.WidePullbackShape.wideCospan
-/

/- warning: category_theory.limits.wide_pullback_shape.diagram_iso_wide_cospan -> CategoryTheory.Limits.WidePullbackShape.diagramIsoWideCospan is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u1}} {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] (F : CategoryTheory.Functor.{u1, u2, u1, u3} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) C _inst_1), CategoryTheory.Iso.{max u1 u2, max u1 u2 u1 u3} (CategoryTheory.Functor.{u1, u2, u1, u3} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) C _inst_1) (CategoryTheory.Functor.category.{u1, u2, u1, u3} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) C _inst_1) F (CategoryTheory.Limits.WidePullbackShape.wideCospan.{u1, u2, u3} J C _inst_1 (CategoryTheory.Functor.obj.{u1, u2, u1, u3} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) C _inst_1 F (Option.none.{u1} J)) (fun (j : J) => CategoryTheory.Functor.obj.{u1, u2, u1, u3} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) C _inst_1 F (Option.some.{u1} J j)) (fun (j : J) => CategoryTheory.Functor.map.{u1, u2, u1, u3} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) C _inst_1 F (Option.some.{u1} J j) (Option.none.{u1} J) (CategoryTheory.Limits.WidePullbackShape.Hom.term.{u1} J j)))
but is expected to have type
  forall {J : Type.{u1}} {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] (F : CategoryTheory.Functor.{u1, u2, u1, u3} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) C _inst_1), CategoryTheory.Iso.{max u2 u1, max (max u3 u2) u1} (CategoryTheory.Functor.{u1, u2, u1, u3} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) C _inst_1) (CategoryTheory.Functor.category.{u1, u2, u1, u3} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) C _inst_1) F (CategoryTheory.Limits.WidePullbackShape.wideCospan.{u1, u2, u3} J C _inst_1 (Prefunctor.obj.{succ u1, succ u2, u1, u3} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Category.toCategoryStruct.{u1, u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J))) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u1, u3} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) C _inst_1 F) (Option.none.{u1} J)) (fun (j : J) => Prefunctor.obj.{succ u1, succ u2, u1, u3} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Category.toCategoryStruct.{u1, u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J))) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u1, u3} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) C _inst_1 F) (Option.some.{u1} J j)) (fun (j : J) => Prefunctor.map.{succ u1, succ u2, u1, u3} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Category.toCategoryStruct.{u1, u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J))) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u1, u3} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) C _inst_1 F) (Option.some.{u1} J j) (Option.none.{u1} J) (CategoryTheory.Limits.WidePullbackShape.Hom.term.{u1} J j)))
Case conversion may be inaccurate. Consider using '#align category_theory.limits.wide_pullback_shape.diagram_iso_wide_cospan CategoryTheory.Limits.WidePullbackShape.diagramIsoWideCospanâ‚“'. -/
/-- Every diagram is naturally isomorphic (actually, equal) to a `wide_cospan` -/
def diagramIsoWideCospan (F : WidePullbackShape J â¥¤ C) :
    F â‰… wideCospan (F.obj none) (fun j => F.obj (some j)) fun j => F.map (Hom.term j) :=
  (NatIso.ofComponents fun j => eqToIso <| by tidy) <| by tidy
#align category_theory.limits.wide_pullback_shape.diagram_iso_wide_cospan CategoryTheory.Limits.WidePullbackShape.diagramIsoWideCospan

/- warning: category_theory.limits.wide_pullback_shape.mk_cone -> CategoryTheory.Limits.WidePullbackShape.mkCone is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u1}} {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] {F : CategoryTheory.Functor.{u1, u2, u1, u3} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) C _inst_1} {X : C} (f : Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) X (CategoryTheory.Functor.obj.{u1, u2, u1, u3} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) C _inst_1 F (Option.none.{u1} J))) (Ï€ : forall (j : J), Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) X (CategoryTheory.Functor.obj.{u1, u2, u1, u3} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) C _inst_1 F (Option.some.{u1} J j))), (forall (j : J), Eq.{succ u2} (Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) X (CategoryTheory.Functor.obj.{u1, u2, u1, u3} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) C _inst_1 F (Option.none.{u1} J))) (CategoryTheory.CategoryStruct.comp.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1) X (CategoryTheory.Functor.obj.{u1, u2, u1, u3} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) C _inst_1 F (Option.some.{u1} J j)) (CategoryTheory.Functor.obj.{u1, u2, u1, u3} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) C _inst_1 F (Option.none.{u1} J)) (Ï€ j) (CategoryTheory.Functor.map.{u1, u2, u1, u3} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) C _inst_1 F (Option.some.{u1} J j) (Option.none.{u1} J) (CategoryTheory.Limits.WidePullbackShape.Hom.term.{u1} J j))) f) -> (CategoryTheory.Limits.Cone.{u1, u2, u1, u3} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) C _inst_1 F)
but is expected to have type
  forall {J : Type.{u1}} {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] {F : CategoryTheory.Functor.{u1, u2, u1, u3} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) C _inst_1} {X : C} (f : Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) X (Prefunctor.obj.{succ u1, succ u2, u1, u3} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Category.toCategoryStruct.{u1, u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J))) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u1, u3} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) C _inst_1 F) (Option.none.{u1} J))) (Ï€ : forall (j : J), Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) X (Prefunctor.obj.{succ u1, succ u2, u1, u3} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Category.toCategoryStruct.{u1, u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J))) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u1, u3} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) C _inst_1 F) (Option.some.{u1} J j))), (forall (j : J), Eq.{succ u2} (Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) X (Prefunctor.obj.{succ u1, succ u2, u1, u3} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Category.toCategoryStruct.{u1, u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J))) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u1, u3} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) C _inst_1 F) (Option.none.{u1} J))) (CategoryTheory.CategoryStruct.comp.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1) X (Prefunctor.obj.{succ u1, succ u2, u1, u3} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Category.toCategoryStruct.{u1, u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J))) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u1, u3} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) C _inst_1 F) (Option.some.{u1} J j)) (Prefunctor.obj.{succ u1, succ u2, u1, u3} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Category.toCategoryStruct.{u1, u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J))) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u1, u3} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) C _inst_1 F) (Option.none.{u1} J)) (Ï€ j) (Prefunctor.map.{succ u1, succ u2, u1, u3} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Category.toCategoryStruct.{u1, u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J))) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u1, u3} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) C _inst_1 F) (Option.some.{u1} J j) (Option.none.{u1} J) (CategoryTheory.Limits.WidePullbackShape.Hom.term.{u1} J j))) f) -> (CategoryTheory.Limits.Cone.{u1, u2, u1, u3} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) C _inst_1 F)
Case conversion may be inaccurate. Consider using '#align category_theory.limits.wide_pullback_shape.mk_cone CategoryTheory.Limits.WidePullbackShape.mkConeâ‚“'. -/
/-- Construct a cone over a wide cospan. -/
@[simps]
def mkCone {F : WidePullbackShape J â¥¤ C} {X : C} (f : X âŸ¶ F.obj none) (Ï€ : âˆ€ j, X âŸ¶ F.obj (some j))
    (w : âˆ€ j, Ï€ j â‰« F.map (Hom.term j) = f) : Cone F :=
  { pt
    Ï€ :=
      { app := fun j =>
          match j with
          | none => f
          | some j => Ï€ j
        naturality' := fun j j' f => by
          cases j <;> cases j' <;> cases f <;> unfold_aux <;> dsimp <;> simp [w] } }
#align category_theory.limits.wide_pullback_shape.mk_cone CategoryTheory.Limits.WidePullbackShape.mkCone

/- warning: category_theory.limits.wide_pullback_shape.equivalence_of_equiv -> CategoryTheory.Limits.WidePullbackShape.equivalenceOfEquiv is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u1}} (J' : Type.{u2}), (Equiv.{succ u1, succ u2} J J') -> (CategoryTheory.Equivalence.{u1, u2, u1, u2} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) (CategoryTheory.Limits.WidePullbackShape.{u2} J') (CategoryTheory.Limits.WidePullbackShape.category.{u2} J'))
but is expected to have type
  forall {J : Type.{u1}} (J' : Type.{u2}), (Equiv.{succ u1, succ u2} J J') -> (CategoryTheory.Equivalence.{u1, u2, u1, u2} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.{u2} J') (CategoryTheory.Limits.WidePullbackShape.category.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u2} J'))
Case conversion may be inaccurate. Consider using '#align category_theory.limits.wide_pullback_shape.equivalence_of_equiv CategoryTheory.Limits.WidePullbackShape.equivalenceOfEquivâ‚“'. -/
/-- Wide pullback diagrams of equivalent index types are equivlent. -/
def equivalenceOfEquiv (J' : Type w') (h : J â‰ƒ J') : WidePullbackShape J â‰Œ WidePullbackShape J'
    where
  Functor := wideCospan none (fun j => some (h j)) fun j => Hom.term (h j)
  inverse := wideCospan none (fun j => some (h.invFun j)) fun j => Hom.term (h.invFun j)
  unitIso :=
    NatIso.ofComponents (fun j => by cases j <;> simp) fun j k f => by
      simp only [eq_iff_true_of_subsingleton]
  counitIso :=
    NatIso.ofComponents (fun j => by cases j <;> simp) fun j k f => by
      simp only [eq_iff_true_of_subsingleton]
#align category_theory.limits.wide_pullback_shape.equivalence_of_equiv CategoryTheory.Limits.WidePullbackShape.equivalenceOfEquiv

/- warning: category_theory.limits.wide_pullback_shape.ulift_equivalence -> CategoryTheory.Limits.WidePullbackShape.uliftEquivalence is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u1}}, CategoryTheory.Equivalence.{max u2 u1, max u1 u2, max u1 u2, max u1 u2} (CategoryTheory.ULiftHom.{u2, max u1 u2} (ULift.{u2, u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J))) (CategoryTheory.ULiftHom.category.{u1, u2, max u1 u2} (ULift.{u2, u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J)) (CategoryTheory.uliftCategory.{u1, u1, u2} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J))) (CategoryTheory.Limits.WidePullbackShape.{max u1 u2} (ULift.{u2, u1} J)) (CategoryTheory.Limits.WidePullbackShape.category.{max u1 u2} (ULift.{u2, u1} J))
but is expected to have type
  forall {J : Type.{u1}}, CategoryTheory.Equivalence.{max u1 u2, max u1 u2, max u2 u1, max u1 u2} (CategoryTheory.ULiftHom.{u2, max u2 u1} (ULift.{u2, u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J))) (CategoryTheory.Limits.WidePullbackShape.{max u1 u2} (ULift.{u2, u1} J)) (CategoryTheory.ULiftHom.category.{u1, u2, max u1 u2} (ULift.{u2, u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J)) (CategoryTheory.uliftCategory.{u1, u1, u2} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J))) (CategoryTheory.Limits.WidePullbackShape.category.{max u1 u2} (ULift.{u2, u1} J))
Case conversion may be inaccurate. Consider using '#align category_theory.limits.wide_pullback_shape.ulift_equivalence CategoryTheory.Limits.WidePullbackShape.uliftEquivalenceâ‚“'. -/
/-- Lifting universe and morphism levels preserves wide pullback diagrams. -/
def uliftEquivalence :
    ULiftHom.{w'} (ULift.{w'} (WidePullbackShape J)) â‰Œ WidePullbackShape (ULift J) :=
  (ULiftHomULiftCategory.equiv.{w', w', w, w} (WidePullbackShape J)).symm.trans
    (equivalenceOfEquiv _ (Equiv.ulift.{w', w}.symm : J â‰ƒ ULift.{w'} J))
#align category_theory.limits.wide_pullback_shape.ulift_equivalence CategoryTheory.Limits.WidePullbackShape.uliftEquivalence

end WidePullbackShape

namespace WidePushoutShape

variable {J}

#print CategoryTheory.Limits.WidePushoutShape.Hom /-
/-- The type of arrows for the shape indexing a wide psuhout. -/
inductive Hom : WidePushoutShape J â†’ WidePushoutShape J â†’ Type w
  | id : âˆ€ X, hom X X
  | init : âˆ€ j : J, hom none (some j)
  deriving DecidableEq
#align category_theory.limits.wide_pushout_shape.hom CategoryTheory.Limits.WidePushoutShape.Hom
-/

attribute [nolint unused_arguments] hom.decidable_eq

#print CategoryTheory.Limits.WidePushoutShape.struct /-
instance struct : CategoryStruct (WidePushoutShape J)
    where
  Hom := Hom
  id j := Hom.id j
  comp jâ‚ jâ‚‚ jâ‚ƒ f g := by
    cases f
    exact g
    cases g
    apply hom.init _
#align category_theory.limits.wide_pushout_shape.struct CategoryTheory.Limits.WidePushoutShape.struct
-/

#print CategoryTheory.Limits.WidePushoutShape.Hom.inhabited /-
instance Hom.inhabited : Inhabited (Hom none none) :=
  âŸ¨Hom.id (none : WidePushoutShape J)âŸ©
#align category_theory.limits.wide_pushout_shape.hom.inhabited CategoryTheory.Limits.WidePushoutShape.Hom.inhabited
-/

attribute [local tidy] tactic.case_bash

#print CategoryTheory.Limits.WidePushoutShape.subsingleton_hom /-
instance subsingleton_hom : Quiver.IsThin (WidePushoutShape J) := fun _ _ => âŸ¨by tidyâŸ©
#align category_theory.limits.wide_pushout_shape.subsingleton_hom CategoryTheory.Limits.WidePushoutShape.subsingleton_hom
-/

#print CategoryTheory.Limits.WidePushoutShape.category /-
instance category : SmallCategory (WidePushoutShape J) :=
  thin_category
#align category_theory.limits.wide_pushout_shape.category CategoryTheory.Limits.WidePushoutShape.category
-/

#print CategoryTheory.Limits.WidePushoutShape.hom_id /-
@[simp]
theorem hom_id (X : WidePushoutShape J) : Hom.id X = ğŸ™ X :=
  rfl
#align category_theory.limits.wide_pushout_shape.hom_id CategoryTheory.Limits.WidePushoutShape.hom_id
-/

variable {C : Type u} [Category.{v} C]

#print CategoryTheory.Limits.WidePushoutShape.wideSpan /-
/-- Construct a functor out of the wide pushout shape given a J-indexed collection of arrows from a
fixed object.
-/
@[simps]
def wideSpan (B : C) (objs : J â†’ C) (arrows : âˆ€ j : J, B âŸ¶ objs j) : WidePushoutShape J â¥¤ C
    where
  obj j := Option.casesOn j B objs
  map X Y f := by
    cases' f with _ j
    Â· apply ğŸ™ _
    Â· exact arrows j
  map_comp' := by rintro (_ | _) (_ | _) (_ | _) (_ | _) (_ | _) <;> first |simpa|simp
#align category_theory.limits.wide_pushout_shape.wide_span CategoryTheory.Limits.WidePushoutShape.wideSpan
-/

/- warning: category_theory.limits.wide_pushout_shape.diagram_iso_wide_span -> CategoryTheory.Limits.WidePushoutShape.diagramIsoWideSpan is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u1}} {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] (F : CategoryTheory.Functor.{u1, u2, u1, u3} (CategoryTheory.Limits.WidePushoutShape.{u1} J) (CategoryTheory.Limits.WidePushoutShape.category.{u1} J) C _inst_1), CategoryTheory.Iso.{max u1 u2, max u1 u2 u1 u3} (CategoryTheory.Functor.{u1, u2, u1, u3} (CategoryTheory.Limits.WidePushoutShape.{u1} J) (CategoryTheory.Limits.WidePushoutShape.category.{u1} J) C _inst_1) (CategoryTheory.Functor.category.{u1, u2, u1, u3} (CategoryTheory.Limits.WidePushoutShape.{u1} J) (CategoryTheory.Limits.WidePushoutShape.category.{u1} J) C _inst_1) F (CategoryTheory.Limits.WidePushoutShape.wideSpan.{u1, u2, u3} J C _inst_1 (CategoryTheory.Functor.obj.{u1, u2, u1, u3} (CategoryTheory.Limits.WidePushoutShape.{u1} J) (CategoryTheory.Limits.WidePushoutShape.category.{u1} J) C _inst_1 F (Option.none.{u1} J)) (fun (j : J) => CategoryTheory.Functor.obj.{u1, u2, u1, u3} (CategoryTheory.Limits.WidePushoutShape.{u1} J) (CategoryTheory.Limits.WidePushoutShape.category.{u1} J) C _inst_1 F (Option.some.{u1} J j)) (fun (j : J) => CategoryTheory.Functor.map.{u1, u2, u1, u3} (CategoryTheory.Limits.WidePushoutShape.{u1} J) (CategoryTheory.Limits.WidePushoutShape.category.{u1} J) C _inst_1 F (Option.none.{u1} J) (Option.some.{u1} J j) (CategoryTheory.Limits.WidePushoutShape.Hom.init.{u1} J j)))
but is expected to have type
  forall {J : Type.{u1}} {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] (F : CategoryTheory.Functor.{u1, u2, u1, u3} (CategoryTheory.Limits.WidePushoutShape.{u1} J) (CategoryTheory.Limits.WidePushoutShape.category.{u1} J) C _inst_1), CategoryTheory.Iso.{max u2 u1, max (max u3 u2) u1} (CategoryTheory.Functor.{u1, u2, u1, u3} (CategoryTheory.Limits.WidePushoutShape.{u1} J) (CategoryTheory.Limits.WidePushoutShape.category.{u1} J) C _inst_1) (CategoryTheory.Functor.category.{u1, u2, u1, u3} (CategoryTheory.Limits.WidePushoutShape.{u1} J) (CategoryTheory.Limits.WidePushoutShape.category.{u1} J) C _inst_1) F (CategoryTheory.Limits.WidePushoutShape.wideSpan.{u1, u2, u3} J C _inst_1 (Prefunctor.obj.{succ u1, succ u2, u1, u3} (CategoryTheory.Limits.WidePushoutShape.{u1} J) (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} (CategoryTheory.Limits.WidePushoutShape.{u1} J) (CategoryTheory.Category.toCategoryStruct.{u1, u1} (CategoryTheory.Limits.WidePushoutShape.{u1} J) (CategoryTheory.Limits.WidePushoutShape.category.{u1} J))) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u1, u3} (CategoryTheory.Limits.WidePushoutShape.{u1} J) (CategoryTheory.Limits.WidePushoutShape.category.{u1} J) C _inst_1 F) (Option.none.{u1} J)) (fun (j : J) => Prefunctor.obj.{succ u1, succ u2, u1, u3} (CategoryTheory.Limits.WidePushoutShape.{u1} J) (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} (CategoryTheory.Limits.WidePushoutShape.{u1} J) (CategoryTheory.Category.toCategoryStruct.{u1, u1} (CategoryTheory.Limits.WidePushoutShape.{u1} J) (CategoryTheory.Limits.WidePushoutShape.category.{u1} J))) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u1, u3} (CategoryTheory.Limits.WidePushoutShape.{u1} J) (CategoryTheory.Limits.WidePushoutShape.category.{u1} J) C _inst_1 F) (Option.some.{u1} J j)) (fun (j : J) => Prefunctor.map.{succ u1, succ u2, u1, u3} (CategoryTheory.Limits.WidePushoutShape.{u1} J) (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} (CategoryTheory.Limits.WidePushoutShape.{u1} J) (CategoryTheory.Category.toCategoryStruct.{u1, u1} (CategoryTheory.Limits.WidePushoutShape.{u1} J) (CategoryTheory.Limits.WidePushoutShape.category.{u1} J))) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u1, u3} (CategoryTheory.Limits.WidePushoutShape.{u1} J) (CategoryTheory.Limits.WidePushoutShape.category.{u1} J) C _inst_1 F) (Option.none.{u1} J) (Option.some.{u1} J j) (CategoryTheory.Limits.WidePushoutShape.Hom.init.{u1} J j)))
Case conversion may be inaccurate. Consider using '#align category_theory.limits.wide_pushout_shape.diagram_iso_wide_span CategoryTheory.Limits.WidePushoutShape.diagramIsoWideSpanâ‚“'. -/
/-- Every diagram is naturally isomorphic (actually, equal) to a `wide_span` -/
def diagramIsoWideSpan (F : WidePushoutShape J â¥¤ C) :
    F â‰… wideSpan (F.obj none) (fun j => F.obj (some j)) fun j => F.map (Hom.init j) :=
  (NatIso.ofComponents fun j => eqToIso <| by tidy) <| by tidy
#align category_theory.limits.wide_pushout_shape.diagram_iso_wide_span CategoryTheory.Limits.WidePushoutShape.diagramIsoWideSpan

/- warning: category_theory.limits.wide_pushout_shape.mk_cocone -> CategoryTheory.Limits.WidePushoutShape.mkCocone is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u1}} {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] {F : CategoryTheory.Functor.{u1, u2, u1, u3} (CategoryTheory.Limits.WidePushoutShape.{u1} J) (CategoryTheory.Limits.WidePushoutShape.category.{u1} J) C _inst_1} {X : C} (f : Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.Functor.obj.{u1, u2, u1, u3} (CategoryTheory.Limits.WidePushoutShape.{u1} J) (CategoryTheory.Limits.WidePushoutShape.category.{u1} J) C _inst_1 F (Option.none.{u1} J)) X) (Î¹ : forall (j : J), Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.Functor.obj.{u1, u2, u1, u3} (CategoryTheory.Limits.WidePushoutShape.{u1} J) (CategoryTheory.Limits.WidePushoutShape.category.{u1} J) C _inst_1 F (Option.some.{u1} J j)) X), (forall (j : J), Eq.{succ u2} (Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.Functor.obj.{u1, u2, u1, u3} (CategoryTheory.Limits.WidePushoutShape.{u1} J) (CategoryTheory.Limits.WidePushoutShape.category.{u1} J) C _inst_1 F (Option.none.{u1} J)) X) (CategoryTheory.CategoryStruct.comp.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1) (CategoryTheory.Functor.obj.{u1, u2, u1, u3} (CategoryTheory.Limits.WidePushoutShape.{u1} J) (CategoryTheory.Limits.WidePushoutShape.category.{u1} J) C _inst_1 F (Option.none.{u1} J)) (CategoryTheory.Functor.obj.{u1, u2, u1, u3} (CategoryTheory.Limits.WidePushoutShape.{u1} J) (CategoryTheory.Limits.WidePushoutShape.category.{u1} J) C _inst_1 F (Option.some.{u1} J j)) X (CategoryTheory.Functor.map.{u1, u2, u1, u3} (CategoryTheory.Limits.WidePushoutShape.{u1} J) (CategoryTheory.Limits.WidePushoutShape.category.{u1} J) C _inst_1 F (Option.none.{u1} J) (Option.some.{u1} J j) (CategoryTheory.Limits.WidePushoutShape.Hom.init.{u1} J j)) (Î¹ j)) f) -> (CategoryTheory.Limits.Cocone.{u1, u2, u1, u3} (CategoryTheory.Limits.WidePushoutShape.{u1} J) (CategoryTheory.Limits.WidePushoutShape.category.{u1} J) C _inst_1 F)
but is expected to have type
  forall {J : Type.{u1}} {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] {F : CategoryTheory.Functor.{u1, u2, u1, u3} (CategoryTheory.Limits.WidePushoutShape.{u1} J) (CategoryTheory.Limits.WidePushoutShape.category.{u1} J) C _inst_1} {X : C} (f : Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (Prefunctor.obj.{succ u1, succ u2, u1, u3} (CategoryTheory.Limits.WidePushoutShape.{u1} J) (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} (CategoryTheory.Limits.WidePushoutShape.{u1} J) (CategoryTheory.Category.toCategoryStruct.{u1, u1} (CategoryTheory.Limits.WidePushoutShape.{u1} J) (CategoryTheory.Limits.WidePushoutShape.category.{u1} J))) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u1, u3} (CategoryTheory.Limits.WidePushoutShape.{u1} J) (CategoryTheory.Limits.WidePushoutShape.category.{u1} J) C _inst_1 F) (Option.none.{u1} J)) X) (Î¹ : forall (j : J), Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (Prefunctor.obj.{succ u1, succ u2, u1, u3} (CategoryTheory.Limits.WidePushoutShape.{u1} J) (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} (CategoryTheory.Limits.WidePushoutShape.{u1} J) (CategoryTheory.Category.toCategoryStruct.{u1, u1} (CategoryTheory.Limits.WidePushoutShape.{u1} J) (CategoryTheory.Limits.WidePushoutShape.category.{u1} J))) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u1, u3} (CategoryTheory.Limits.WidePushoutShape.{u1} J) (CategoryTheory.Limits.WidePushoutShape.category.{u1} J) C _inst_1 F) (Option.some.{u1} J j)) X), (forall (j : J), Eq.{succ u2} (Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (Prefunctor.obj.{succ u1, succ u2, u1, u3} (CategoryTheory.Limits.WidePushoutShape.{u1} J) (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} (CategoryTheory.Limits.WidePushoutShape.{u1} J) (CategoryTheory.Category.toCategoryStruct.{u1, u1} (CategoryTheory.Limits.WidePushoutShape.{u1} J) (CategoryTheory.Limits.WidePushoutShape.category.{u1} J))) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u1, u3} (CategoryTheory.Limits.WidePushoutShape.{u1} J) (CategoryTheory.Limits.WidePushoutShape.category.{u1} J) C _inst_1 F) (Option.none.{u1} J)) X) (CategoryTheory.CategoryStruct.comp.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1) (Prefunctor.obj.{succ u1, succ u2, u1, u3} (CategoryTheory.Limits.WidePushoutShape.{u1} J) (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} (CategoryTheory.Limits.WidePushoutShape.{u1} J) (CategoryTheory.Category.toCategoryStruct.{u1, u1} (CategoryTheory.Limits.WidePushoutShape.{u1} J) (CategoryTheory.Limits.WidePushoutShape.category.{u1} J))) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u1, u3} (CategoryTheory.Limits.WidePushoutShape.{u1} J) (CategoryTheory.Limits.WidePushoutShape.category.{u1} J) C _inst_1 F) (Option.none.{u1} J)) (Prefunctor.obj.{succ u1, succ u2, u1, u3} (CategoryTheory.Limits.WidePushoutShape.{u1} J) (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} (CategoryTheory.Limits.WidePushoutShape.{u1} J) (CategoryTheory.Category.toCategoryStruct.{u1, u1} (CategoryTheory.Limits.WidePushoutShape.{u1} J) (CategoryTheory.Limits.WidePushoutShape.category.{u1} J))) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u1, u3} (CategoryTheory.Limits.WidePushoutShape.{u1} J) (CategoryTheory.Limits.WidePushoutShape.category.{u1} J) C _inst_1 F) (Option.some.{u1} J j)) X (Prefunctor.map.{succ u1, succ u2, u1, u3} (CategoryTheory.Limits.WidePushoutShape.{u1} J) (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} (CategoryTheory.Limits.WidePushoutShape.{u1} J) (CategoryTheory.Category.toCategoryStruct.{u1, u1} (CategoryTheory.Limits.WidePushoutShape.{u1} J) (CategoryTheory.Limits.WidePushoutShape.category.{u1} J))) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u1, u3} (CategoryTheory.Limits.WidePushoutShape.{u1} J) (CategoryTheory.Limits.WidePushoutShape.category.{u1} J) C _inst_1 F) (Option.none.{u1} J) (Option.some.{u1} J j) (CategoryTheory.Limits.WidePushoutShape.Hom.init.{u1} J j)) (Î¹ j)) f) -> (CategoryTheory.Limits.Cocone.{u1, u2, u1, u3} (CategoryTheory.Limits.WidePushoutShape.{u1} J) (CategoryTheory.Limits.WidePushoutShape.category.{u1} J) C _inst_1 F)
Case conversion may be inaccurate. Consider using '#align category_theory.limits.wide_pushout_shape.mk_cocone CategoryTheory.Limits.WidePushoutShape.mkCoconeâ‚“'. -/
/-- Construct a cocone over a wide span. -/
@[simps]
def mkCocone {F : WidePushoutShape J â¥¤ C} {X : C} (f : F.obj none âŸ¶ X) (Î¹ : âˆ€ j, F.obj (some j) âŸ¶ X)
    (w : âˆ€ j, F.map (Hom.init j) â‰« Î¹ j = f) : Cocone F :=
  { pt
    Î¹ :=
      { app := fun j =>
          match j with
          | none => f
          | some j => Î¹ j
        naturality' := fun j j' f => by
          cases j <;> cases j' <;> cases f <;> unfold_aux <;> dsimp <;> simp [w] } }
#align category_theory.limits.wide_pushout_shape.mk_cocone CategoryTheory.Limits.WidePushoutShape.mkCocone

end WidePushoutShape

variable (C : Type u) [Category.{v} C]

#print CategoryTheory.Limits.HasWidePullbacks /-
/-- `has_wide_pullbacks` represents a choice of wide pullback for every collection of morphisms -/
abbrev HasWidePullbacks : Prop :=
  âˆ€ J : Type w, HasLimitsOfShape (WidePullbackShape J) C
#align category_theory.limits.has_wide_pullbacks CategoryTheory.Limits.HasWidePullbacks
-/

#print CategoryTheory.Limits.HasWidePushouts /-
/-- `has_wide_pushouts` represents a choice of wide pushout for every collection of morphisms -/
abbrev HasWidePushouts : Prop :=
  âˆ€ J : Type w, HasColimitsOfShape (WidePushoutShape J) C
#align category_theory.limits.has_wide_pushouts CategoryTheory.Limits.HasWidePushouts
-/

variable {C J}

#print CategoryTheory.Limits.HasWidePullback /-
/-- `has_wide_pullback B objs arrows` means that `wide_cospan B objs arrows` has a limit. -/
abbrev HasWidePullback (B : C) (objs : J â†’ C) (arrows : âˆ€ j : J, objs j âŸ¶ B) : Prop :=
  HasLimit (WidePullbackShape.wideCospan B objs arrows)
#align category_theory.limits.has_wide_pullback CategoryTheory.Limits.HasWidePullback
-/

#print CategoryTheory.Limits.HasWidePushout /-
/-- `has_wide_pushout B objs arrows` means that `wide_span B objs arrows` has a colimit. -/
abbrev HasWidePushout (B : C) (objs : J â†’ C) (arrows : âˆ€ j : J, B âŸ¶ objs j) : Prop :=
  HasColimit (WidePushoutShape.wideSpan B objs arrows)
#align category_theory.limits.has_wide_pushout CategoryTheory.Limits.HasWidePushout
-/

#print CategoryTheory.Limits.widePullback /-
/-- A choice of wide pullback. -/
noncomputable abbrev widePullback (B : C) (objs : J â†’ C) (arrows : âˆ€ j : J, objs j âŸ¶ B)
    [HasWidePullback B objs arrows] : C :=
  limit (WidePullbackShape.wideCospan B objs arrows)
#align category_theory.limits.wide_pullback CategoryTheory.Limits.widePullback
-/

#print CategoryTheory.Limits.widePushout /-
/-- A choice of wide pushout. -/
noncomputable abbrev widePushout (B : C) (objs : J â†’ C) (arrows : âˆ€ j : J, B âŸ¶ objs j)
    [HasWidePushout B objs arrows] : C :=
  colimit (WidePushoutShape.wideSpan B objs arrows)
#align category_theory.limits.wide_pushout CategoryTheory.Limits.widePushout
-/

variable (C)

namespace WidePullback

variable {C} {B : C} {objs : J â†’ C} (arrows : âˆ€ j : J, objs j âŸ¶ B)

variable [HasWidePullback B objs arrows]

#print CategoryTheory.Limits.WidePullback.Ï€ /-
/-- The `j`-th projection from the pullback. -/
noncomputable abbrev Ï€ (j : J) : widePullback _ _ arrows âŸ¶ objs j :=
  limit.Ï€ (WidePullbackShape.wideCospan _ _ _) (Option.some j)
#align category_theory.limits.wide_pullback.Ï€ CategoryTheory.Limits.WidePullback.Ï€
-/

#print CategoryTheory.Limits.WidePullback.base /-
/-- The unique map to the base from the pullback. -/
noncomputable abbrev base : widePullback _ _ arrows âŸ¶ B :=
  limit.Ï€ (WidePullbackShape.wideCospan _ _ _) Option.none
#align category_theory.limits.wide_pullback.base CategoryTheory.Limits.WidePullback.base
-/

/- warning: category_theory.limits.wide_pullback.Ï€_arrow -> CategoryTheory.Limits.WidePullback.Ï€_arrow is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u1}} {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] {B : C} {objs : J -> C} (arrows : forall (j : J), Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (objs j) B) [_inst_2 : CategoryTheory.Limits.HasWidePullback.{u1, u2, u3} J C _inst_1 B objs arrows] (j : J), Eq.{succ u2} (Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.Limits.widePullback.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) B) (CategoryTheory.CategoryStruct.comp.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1) (CategoryTheory.Limits.widePullback.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) (objs j) B (CategoryTheory.Limits.WidePullback.Ï€.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2 j) (arrows j)) (CategoryTheory.Limits.WidePullback.base.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2)
but is expected to have type
  forall {J : Type.{u2}} {C : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u3, u1} C] {B : C} {objs : J -> C} (arrows : forall (j : J), Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) (objs j) B) [_inst_2 : CategoryTheory.Limits.HasWidePullback.{u2, u3, u1} J C _inst_1 B objs arrows] (j : J), Eq.{succ u3} (Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) (CategoryTheory.Limits.widePullback.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) B) (CategoryTheory.CategoryStruct.comp.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1) (CategoryTheory.Limits.widePullback.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) (objs j) B (CategoryTheory.Limits.WidePullback.Ï€.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2 j) (arrows j)) (CategoryTheory.Limits.WidePullback.base.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2)
Case conversion may be inaccurate. Consider using '#align category_theory.limits.wide_pullback.Ï€_arrow CategoryTheory.Limits.WidePullback.Ï€_arrowâ‚“'. -/
@[simp, reassoc.1]
theorem Ï€_arrow (j : J) : Ï€ arrows j â‰« arrows _ = base arrows := by
  apply limit.w (wide_pullback_shape.wide_cospan _ _ _) (wide_pullback_shape.hom.term j)
#align category_theory.limits.wide_pullback.Ï€_arrow CategoryTheory.Limits.WidePullback.Ï€_arrow

variable {arrows}

#print CategoryTheory.Limits.WidePullback.lift /-
/-- Lift a collection of morphisms to a morphism to the pullback. -/
noncomputable abbrev lift {X : C} (f : X âŸ¶ B) (fs : âˆ€ j : J, X âŸ¶ objs j)
    (w : âˆ€ j, fs j â‰« arrows j = f) : X âŸ¶ widePullback _ _ arrows :=
  limit.lift (WidePullbackShape.wideCospan _ _ _) (WidePullbackShape.mkCone f fs <| w)
#align category_theory.limits.wide_pullback.lift CategoryTheory.Limits.WidePullback.lift
-/

variable (arrows)

variable {X : C} (f : X âŸ¶ B) (fs : âˆ€ j : J, X âŸ¶ objs j) (w : âˆ€ j, fs j â‰« arrows j = f)

/- warning: category_theory.limits.wide_pullback.lift_Ï€ -> CategoryTheory.Limits.WidePullback.lift_Ï€ is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u1}} {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] {B : C} {objs : J -> C} (arrows : forall (j : J), Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (objs j) B) [_inst_2 : CategoryTheory.Limits.HasWidePullback.{u1, u2, u3} J C _inst_1 B objs arrows] {X : C} (f : Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) X B) (fs : forall (j : J), Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) X (objs j)) (w : forall (j : J), Eq.{succ u2} (Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) X B) (CategoryTheory.CategoryStruct.comp.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1) X (objs j) B (fs j) (arrows j)) f) (j : J), Eq.{succ u2} (Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) X (objs j)) (CategoryTheory.CategoryStruct.comp.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1) X (CategoryTheory.Limits.widePullback.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) (fun (j : J) => arrows j) _inst_2) (objs j) (CategoryTheory.Limits.WidePullback.lift.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) (fun (j : J) => arrows j) _inst_2 X f fs w) (CategoryTheory.Limits.WidePullback.Ï€.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2 j)) (fs j)
but is expected to have type
  forall {J : Type.{u2}} {C : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u3, u1} C] {B : C} {objs : J -> C} (arrows : forall (j : J), Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) (objs j) B) [_inst_2 : CategoryTheory.Limits.HasWidePullback.{u2, u3, u1} J C _inst_1 B objs arrows] {X : C} (f : Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) X B) (fs : forall (j : J), Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) X (objs j)) (w : forall (j : J), Eq.{succ u3} (Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) X B) (CategoryTheory.CategoryStruct.comp.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1) X (objs j) B (fs j) (arrows j)) f) (j : J), Eq.{succ u3} (Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) X (objs j)) (CategoryTheory.CategoryStruct.comp.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1) X (CategoryTheory.Limits.widePullback.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) (fun (j : J) => arrows j) _inst_2) (objs j) (CategoryTheory.Limits.WidePullback.lift.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) (fun (j : J) => arrows j) _inst_2 X f fs w) (CategoryTheory.Limits.WidePullback.Ï€.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2 j)) (fs j)
Case conversion may be inaccurate. Consider using '#align category_theory.limits.wide_pullback.lift_Ï€ CategoryTheory.Limits.WidePullback.lift_Ï€â‚“'. -/
@[simp, reassoc.1]
theorem lift_Ï€ (j : J) : lift f fs w â‰« Ï€ arrows j = fs _ :=
  by
  simp
  rfl
#align category_theory.limits.wide_pullback.lift_Ï€ CategoryTheory.Limits.WidePullback.lift_Ï€

/- warning: category_theory.limits.wide_pullback.lift_base -> CategoryTheory.Limits.WidePullback.lift_base is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u1}} {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] {B : C} {objs : J -> C} (arrows : forall (j : J), Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (objs j) B) [_inst_2 : CategoryTheory.Limits.HasWidePullback.{u1, u2, u3} J C _inst_1 B objs arrows] {X : C} (f : Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) X B) (fs : forall (j : J), Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) X (objs j)) (w : forall (j : J), Eq.{succ u2} (Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) X B) (CategoryTheory.CategoryStruct.comp.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1) X (objs j) B (fs j) (arrows j)) f), Eq.{succ u2} (Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) X B) (CategoryTheory.CategoryStruct.comp.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1) X (CategoryTheory.Limits.widePullback.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) (fun (j : J) => arrows j) _inst_2) B (CategoryTheory.Limits.WidePullback.lift.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) (fun (j : J) => arrows j) _inst_2 X f fs w) (CategoryTheory.Limits.WidePullback.base.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2)) f
but is expected to have type
  forall {J : Type.{u2}} {C : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u3, u1} C] {B : C} {objs : J -> C} (arrows : forall (j : J), Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) (objs j) B) [_inst_2 : CategoryTheory.Limits.HasWidePullback.{u2, u3, u1} J C _inst_1 B objs arrows] {X : C} (f : Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) X B) (fs : forall (j : J), Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) X (objs j)) (w : forall (j : J), Eq.{succ u3} (Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) X B) (CategoryTheory.CategoryStruct.comp.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1) X (objs j) B (fs j) (arrows j)) f), Eq.{succ u3} (Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) X B) (CategoryTheory.CategoryStruct.comp.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1) X (CategoryTheory.Limits.widePullback.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) (fun (j : J) => arrows j) _inst_2) B (CategoryTheory.Limits.WidePullback.lift.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) (fun (j : J) => arrows j) _inst_2 X f fs w) (CategoryTheory.Limits.WidePullback.base.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2)) f
Case conversion may be inaccurate. Consider using '#align category_theory.limits.wide_pullback.lift_base CategoryTheory.Limits.WidePullback.lift_baseâ‚“'. -/
@[simp, reassoc.1]
theorem lift_base : lift f fs w â‰« base arrows = f :=
  by
  simp
  rfl
#align category_theory.limits.wide_pullback.lift_base CategoryTheory.Limits.WidePullback.lift_base

/- warning: category_theory.limits.wide_pullback.eq_lift_of_comp_eq -> CategoryTheory.Limits.WidePullback.eq_lift_of_comp_eq is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u1}} {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] {B : C} {objs : J -> C} (arrows : forall (j : J), Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (objs j) B) [_inst_2 : CategoryTheory.Limits.HasWidePullback.{u1, u2, u3} J C _inst_1 B objs arrows] {X : C} (f : Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) X B) (fs : forall (j : J), Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) X (objs j)) (w : forall (j : J), Eq.{succ u2} (Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) X B) (CategoryTheory.CategoryStruct.comp.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1) X (objs j) B (fs j) (arrows j)) f) (g : Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) X (CategoryTheory.Limits.widePullback.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2)), (forall (j : J), Eq.{succ u2} (Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) X (objs j)) (CategoryTheory.CategoryStruct.comp.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1) X (CategoryTheory.Limits.widePullback.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) (objs j) g (CategoryTheory.Limits.WidePullback.Ï€.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2 j)) (fs j)) -> (Eq.{succ u2} (Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) X B) (CategoryTheory.CategoryStruct.comp.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1) X (CategoryTheory.Limits.widePullback.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) B g (CategoryTheory.Limits.WidePullback.base.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2)) f) -> (Eq.{succ u2} (Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) X (CategoryTheory.Limits.widePullback.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2)) g (CategoryTheory.Limits.WidePullback.lift.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2 X f fs w))
but is expected to have type
  forall {J : Type.{u2}} {C : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u3, u1} C] {B : C} {objs : J -> C} (arrows : forall (j : J), Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) (objs j) B) [_inst_2 : CategoryTheory.Limits.HasWidePullback.{u2, u3, u1} J C _inst_1 B objs arrows] {X : C} (f : Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) X B) (fs : forall (j : J), Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) X (objs j)) (w : forall (j : J), Eq.{succ u3} (Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) X B) (CategoryTheory.CategoryStruct.comp.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1) X (objs j) B (fs j) (arrows j)) f) (g : Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) X (CategoryTheory.Limits.widePullback.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2)), (forall (j : J), Eq.{succ u3} (Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) X (objs j)) (CategoryTheory.CategoryStruct.comp.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1) X (CategoryTheory.Limits.widePullback.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) (objs j) g (CategoryTheory.Limits.WidePullback.Ï€.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2 j)) (fs j)) -> (Eq.{succ u3} (Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) X B) (CategoryTheory.CategoryStruct.comp.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1) X (CategoryTheory.Limits.widePullback.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) B g (CategoryTheory.Limits.WidePullback.base.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2)) f) -> (Eq.{succ u3} (Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) X (CategoryTheory.Limits.widePullback.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2)) g (CategoryTheory.Limits.WidePullback.lift.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) (fun (j : J) => arrows j) _inst_2 X f fs w))
Case conversion may be inaccurate. Consider using '#align category_theory.limits.wide_pullback.eq_lift_of_comp_eq CategoryTheory.Limits.WidePullback.eq_lift_of_comp_eqâ‚“'. -/
theorem eq_lift_of_comp_eq (g : X âŸ¶ widePullback _ _ arrows) :
    (âˆ€ j : J, g â‰« Ï€ arrows j = fs j) â†’ g â‰« base arrows = f â†’ g = lift f fs w :=
  by
  intro h1 h2
  apply
    (limit.is_limit (wide_pullback_shape.wide_cospan B objs arrows)).uniq
      (wide_pullback_shape.mk_cone f fs <| w)
  rintro (_ | _)
  Â· apply h2
  Â· apply h1
#align category_theory.limits.wide_pullback.eq_lift_of_comp_eq CategoryTheory.Limits.WidePullback.eq_lift_of_comp_eq

/- warning: category_theory.limits.wide_pullback.hom_eq_lift -> CategoryTheory.Limits.WidePullback.hom_eq_lift is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u1}} {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] {B : C} {objs : J -> C} (arrows : forall (j : J), Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (objs j) B) [_inst_2 : CategoryTheory.Limits.HasWidePullback.{u1, u2, u3} J C _inst_1 B objs arrows] {X : C} (g : Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) X (CategoryTheory.Limits.widePullback.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2)), Eq.{succ u2} (Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) X (CategoryTheory.Limits.widePullback.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2)) g (CategoryTheory.Limits.WidePullback.lift.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2 X (CategoryTheory.CategoryStruct.comp.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1) X (CategoryTheory.Limits.widePullback.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) B g (CategoryTheory.Limits.WidePullback.base.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2)) (fun (j : J) => CategoryTheory.CategoryStruct.comp.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1) X (CategoryTheory.Limits.widePullback.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) (objs j) g (CategoryTheory.Limits.WidePullback.Ï€.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2 j)) (fun (j : J) => id.{0} (forall {X : C} (g : Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) X (CategoryTheory.Limits.widePullback.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2)) (j : J), Eq.{succ u2} (Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) X B) (CategoryTheory.CategoryStruct.comp.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1) X (objs j) B (CategoryTheory.CategoryStruct.comp.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1) X (CategoryTheory.Limits.widePullback.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) (objs j) g (CategoryTheory.Limits.WidePullback.Ï€.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2 j)) (arrows j)) (CategoryTheory.CategoryStruct.comp.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1) X (CategoryTheory.Limits.widePullback.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) B g (CategoryTheory.Limits.WidePullback.base.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2))) (fun {X : C} (g : Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) X (CategoryTheory.Limits.widePullback.{u1, u2, u3} J C _inst_1 B objs arrows _inst_2)) (j : J) => Eq.mpr.{0} (Eq.{succ u2} (Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) X B) (CategoryTheory.CategoryStruct.comp.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1) X (objs j) B (CategoryTheory.CategoryStruct.comp.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1) X (CategoryTheory.Limits.widePullback.{u1, u2, u3} J C _inst_1 B objs arrows _inst_2) (objs j) g (CategoryTheory.Limits.WidePullback.Ï€.{u1, u2, u3} J C _inst_1 B objs arrows _inst_2 j)) (arrows j)) (CategoryTheory.CategoryStruct.comp.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1) X (CategoryTheory.Limits.widePullback.{u1, u2, u3} J C _inst_1 B objs arrows _inst_2) B g (CategoryTheory.Limits.WidePullback.base.{u1, u2, u3} J C _inst_1 B objs arrows _inst_2))) True (id_tag Tactic.IdTag.simp (Eq.{1} Prop (Eq.{succ u2} (Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) X B) (CategoryTheory.CategoryStruct.comp.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1) X (objs j) B (CategoryTheory.CategoryStruct.comp.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1) X (CategoryTheory.Limits.widePullback.{u1, u2, u3} J C _inst_1 B objs arrows _inst_2) (objs j) g (CategoryTheory.Limits.WidePullback.Ï€.{u1, u2, u3} J C _inst_1 B objs arrows _inst_2 j)) (arrows j)) (CategoryTheory.CategoryStruct.comp.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1) X (CategoryTheory.Limits.widePullback.{u1, u2, u3} J C _inst_1 B objs arrows _inst_2) B g (CategoryTheory.Limits.WidePullback.base.{u1, u2, u3} J C _inst_1 B objs arrows _inst_2))) True) (Eq.trans.{1} Prop (Eq.{succ u2} (Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) X B) (CategoryTheory.CategoryStruct.comp.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1) X (objs j) B (CategoryTheory.CategoryStruct.comp.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1) X (CategoryTheory.Limits.widePullback.{u1, u2, u3} J C _inst_1 B objs arrows _inst_2) (objs j) g (CategoryTheory.Limits.WidePullback.Ï€.{u1, u2, u3} J C _inst_1 B objs arrows _inst_2 j)) (arrows j)) (CategoryTheory.CategoryStruct.comp.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1) X (CategoryTheory.Limits.widePullback.{u1, u2, u3} J C _inst_1 B objs arrows _inst_2) B g (CategoryTheory.Limits.WidePullback.base.{u1, u2, u3} J C _inst_1 B objs arrows _inst_2))) (Eq.{succ u2} (Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) X B) (CategoryTheory.CategoryStruct.comp.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1) X (CategoryTheory.Limits.widePullback.{u1, u2, u3} J C _inst_1 B objs arrows _inst_2) B g (CategoryTheory.Limits.WidePullback.base.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2)) (CategoryTheory.CategoryStruct.comp.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1) X (CategoryTheory.Limits.widePullback.{u1, u2, u3} J C _inst_1 B objs arrows _inst_2) B g (CategoryTheory.Limits.WidePullback.base.{u1, u2, u3} J C _inst_1 B objs arrows _inst_2))) True ((fun (a : Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) X B) (a_1 : Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) X B) (e_1 : Eq.{succ u2} (Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) X B) a a_1) (á¾° : Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) X B) (á¾°_1 : Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) X B) (e_2 : Eq.{succ u2} (Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) X B) á¾° á¾°_1) => congr.{succ u2, 1} (Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) X B) Prop (Eq.{succ u2} (Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) X B) a) (Eq.{succ u2} (Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) X B) a_1) á¾° á¾°_1 (congr_arg.{succ u2, succ u2} (Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) X B) ((Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) X B) -> Prop) a a_1 (Eq.{succ u2} (Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) X B)) e_1) e_2) (CategoryTheory.CategoryStruct.comp.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1) X (objs j) B (CategoryTheory.CategoryStruct.comp.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1) X (CategoryTheory.Limits.widePullback.{u1, u2, u3} J C _inst_1 B objs arrows _inst_2) (objs j) g (CategoryTheory.Limits.WidePullback.Ï€.{u1, u2, u3} J C _inst_1 B objs arrows _inst_2 j)) (arrows j)) (CategoryTheory.CategoryStruct.comp.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1) X (CategoryTheory.Limits.widePullback.{u1, u2, u3} J C _inst_1 B objs arrows _inst_2) B g (CategoryTheory.Limits.WidePullback.base.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2)) (Eq.trans.{succ u2} (Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) X B) (CategoryTheory.CategoryStruct.comp.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1) X (objs j) B (CategoryTheory.CategoryStruct.comp.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1) X (CategoryTheory.Limits.widePullback.{u1, u2, u3} J C _inst_1 B objs arrows _inst_2) (objs j) g (CategoryTheory.Limits.WidePullback.Ï€.{u1, u2, u3} J C _inst_1 B objs arrows _inst_2 j)) (arrows j)) (CategoryTheory.CategoryStruct.comp.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1) X (CategoryTheory.Limits.widePullback.{u1, u2, u3} J C _inst_1 B objs arrows _inst_2) B g (CategoryTheory.CategoryStruct.comp.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1) (CategoryTheory.Limits.widePullback.{u1, u2, u3} J C _inst_1 B objs arrows _inst_2) (objs j) B (CategoryTheory.Limits.WidePullback.Ï€.{u1, u2, u3} J C _inst_1 B objs arrows _inst_2 j) (arrows j))) (CategoryTheory.CategoryStruct.comp.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1) X (CategoryTheory.Limits.widePullback.{u1, u2, u3} J C _inst_1 B objs arrows _inst_2) B g (CategoryTheory.Limits.WidePullback.base.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2)) (CategoryTheory.Category.assoc.{u2, u3} C _inst_1 X (CategoryTheory.Limits.widePullback.{u1, u2, u3} J C _inst_1 B objs arrows _inst_2) (objs j) B g (CategoryTheory.Limits.WidePullback.Ï€.{u1, u2, u3} J C _inst_1 B objs arrows _inst_2 j) (arrows j)) ((fun (á¾° : Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) X (CategoryTheory.Limits.widePullback.{u1, u2, u3} J C _inst_1 B objs arrows _inst_2)) (á¾°_1 : Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) X (CategoryTheory.Limits.widePullback.{u1, u2, u3} J C _inst_1 B objs arrows _inst_2)) (e_1 : Eq.{succ u2} (Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) X (CategoryTheory.Limits.widePullback.{u1, u2, u3} J C _inst_1 B objs arrows _inst_2)) á¾° á¾°_1) (á¾°_2 : Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.Limits.widePullback.{u1, u2, u3} J C _inst_1 B objs arrows _inst_2) B) (á¾°_3 : Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.Limits.widePullback.{u1, u2, u3} J C _inst_1 B objs arrows _inst_2) B) (e_2 : Eq.{succ u2} (Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.Limits.widePullback.{u1, u2, u3} J C _inst_1 B objs arrows _inst_2) B) á¾°_2 á¾°_3) => congr.{succ u2, succ u2} (Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.Limits.widePullback.{u1, u2, u3} J C _inst_1 B objs arrows _inst_2) B) (Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) X B) (CategoryTheory.CategoryStruct.comp.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1) X (CategoryTheory.Limits.widePullback.{u1, u2, u3} J C _inst_1 B objs arrows _inst_2) B á¾°) (CategoryTheory.CategoryStruct.comp.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1) X (CategoryTheory.Limits.widePullback.{u1, u2, u3} J C _inst_1 B objs arrows _inst_2) B á¾°_1) á¾°_2 á¾°_3 (congr_arg.{succ u2, succ u2} (Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) X (CategoryTheory.Limits.widePullback.{u1, u2, u3} J C _inst_1 B objs arrows _inst_2)) ((Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.Limits.widePullback.{u1, u2, u3} J C _inst_1 B objs arrows _inst_2) B) -> (Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) X B)) á¾° á¾°_1 (CategoryTheory.CategoryStruct.comp.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1) X (CategoryTheory.Limits.widePullback.{u1, u2, u3} J C _inst_1 B objs arrows _inst_2) B) e_1) e_2) g g (rfl.{succ u2} (Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) X (CategoryTheory.Limits.widePullback.{u1, u2, u3} J C _inst_1 B objs arrows _inst_2)) g) (CategoryTheory.CategoryStruct.comp.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1) (CategoryTheory.Limits.widePullback.{u1, u2, u3} J C _inst_1 B objs arrows _inst_2) (objs j) B (CategoryTheory.Limits.WidePullback.Ï€.{u1, u2, u3} J C _inst_1 B objs arrows _inst_2 j) (arrows j)) (CategoryTheory.Limits.WidePullback.base.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) (CategoryTheory.Limits.WidePullback.Ï€_arrow.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2 j))) (CategoryTheory.CategoryStruct.comp.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1) X (CategoryTheory.Limits.widePullback.{u1, u2, u3} J C _inst_1 B objs arrows _inst_2) B g (CategoryTheory.Limits.WidePullback.base.{u1, u2, u3} J C _inst_1 B objs arrows _inst_2)) (CategoryTheory.CategoryStruct.comp.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1) X (CategoryTheory.Limits.widePullback.{u1, u2, u3} J C _inst_1 B objs arrows _inst_2) B g (CategoryTheory.Limits.WidePullback.base.{u1, u2, u3} J C _inst_1 B objs arrows _inst_2)) (rfl.{succ u2} (Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) X B) (CategoryTheory.CategoryStruct.comp.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1) X (CategoryTheory.Limits.widePullback.{u1, u2, u3} J C _inst_1 B objs arrows _inst_2) B g (CategoryTheory.Limits.WidePullback.base.{u1, u2, u3} J C _inst_1 B objs arrows _inst_2)))) (propext (Eq.{succ u2} (Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) X B) (CategoryTheory.CategoryStruct.comp.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1) X (CategoryTheory.Limits.widePullback.{u1, u2, u3} J C _inst_1 B objs arrows _inst_2) B g (CategoryTheory.Limits.WidePullback.base.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2)) (CategoryTheory.CategoryStruct.comp.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1) X (CategoryTheory.Limits.widePullback.{u1, u2, u3} J C _inst_1 B objs arrows _inst_2) B g (CategoryTheory.Limits.WidePullback.base.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2))) True (eq_self_iff_true.{succ u2} (Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) X B) (CategoryTheory.CategoryStruct.comp.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1) X (CategoryTheory.Limits.widePullback.{u1, u2, u3} J C _inst_1 B objs arrows _inst_2) B g (CategoryTheory.Limits.WidePullback.base.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2)))))) trivial) X g j))
but is expected to have type
  forall {J : Type.{u2}} {C : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u3, u1} C] {B : C} {objs : J -> C} (arrows : forall (j : J), Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) (objs j) B) [_inst_2 : CategoryTheory.Limits.HasWidePullback.{u2, u3, u1} J C _inst_1 B objs arrows] {X : C} (g : Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) X (CategoryTheory.Limits.widePullback.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2)), Eq.{succ u3} (Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) X (CategoryTheory.Limits.widePullback.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2)) g (CategoryTheory.Limits.WidePullback.lift.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2 X (CategoryTheory.CategoryStruct.comp.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1) X (CategoryTheory.Limits.widePullback.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) B g (CategoryTheory.Limits.WidePullback.base.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2)) (fun (j : J) => CategoryTheory.CategoryStruct.comp.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1) X (CategoryTheory.Limits.widePullback.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) (objs j) g (CategoryTheory.Limits.WidePullback.Ï€.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2 j)) (fun (j : J) => of_eq_true (Eq.{succ u3} (Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) X B) (CategoryTheory.CategoryStruct.comp.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1) X (objs j) B (CategoryTheory.CategoryStruct.comp.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1) X (CategoryTheory.Limits.widePullback.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) (objs j) g (CategoryTheory.Limits.WidePullback.Ï€.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2 j)) (arrows j)) (CategoryTheory.CategoryStruct.comp.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1) X (CategoryTheory.Limits.widePullback.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) B g (CategoryTheory.Limits.WidePullback.base.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2))) (Eq.trans.{1} Prop (Eq.{succ u3} (Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) X B) (CategoryTheory.CategoryStruct.comp.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1) X (objs j) B (CategoryTheory.CategoryStruct.comp.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1) X (CategoryTheory.Limits.widePullback.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) (objs j) g (CategoryTheory.Limits.WidePullback.Ï€.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2 j)) (arrows j)) (CategoryTheory.CategoryStruct.comp.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1) X (CategoryTheory.Limits.widePullback.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) B g (CategoryTheory.Limits.WidePullback.base.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2))) (Eq.{succ u3} (Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) X B) (CategoryTheory.CategoryStruct.comp.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1) X (CategoryTheory.Limits.widePullback.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) B g (CategoryTheory.Limits.WidePullback.base.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2)) (CategoryTheory.CategoryStruct.comp.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1) X (CategoryTheory.Limits.widePullback.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) B g (CategoryTheory.Limits.WidePullback.base.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2))) True (congrFun.{succ u3, 1} (Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) X B) (fun (a._@.Init.Prelude._hyg.170 : Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) X B) => Prop) (Eq.{succ u3} (Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) X B) (CategoryTheory.CategoryStruct.comp.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1) X (objs j) B (CategoryTheory.CategoryStruct.comp.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1) X (CategoryTheory.Limits.widePullback.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) (objs j) g (CategoryTheory.Limits.WidePullback.Ï€.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2 j)) (arrows j))) (Eq.{succ u3} (Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) X B) (CategoryTheory.CategoryStruct.comp.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1) X (CategoryTheory.Limits.widePullback.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) B g (CategoryTheory.Limits.WidePullback.base.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2))) (congrArg.{succ u3, succ u3} (Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) X B) ((Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) X B) -> Prop) (CategoryTheory.CategoryStruct.comp.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1) X (objs j) B (CategoryTheory.CategoryStruct.comp.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1) X (CategoryTheory.Limits.widePullback.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) (objs j) g (CategoryTheory.Limits.WidePullback.Ï€.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2 j)) (arrows j)) (CategoryTheory.CategoryStruct.comp.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1) X (CategoryTheory.Limits.widePullback.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) B g (CategoryTheory.Limits.WidePullback.base.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2)) (Eq.{succ u3} (Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) X B)) (Eq.trans.{succ u3} (Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) X B) (CategoryTheory.CategoryStruct.comp.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1) X (objs j) B (CategoryTheory.CategoryStruct.comp.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1) X (CategoryTheory.Limits.widePullback.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) (objs j) g (CategoryTheory.Limits.WidePullback.Ï€.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2 j)) (arrows j)) (CategoryTheory.CategoryStruct.comp.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1) X (CategoryTheory.Limits.widePullback.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) B g (CategoryTheory.CategoryStruct.comp.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1) (CategoryTheory.Limits.widePullback.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) (objs j) B (CategoryTheory.Limits.WidePullback.Ï€.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2 j) (arrows j))) (CategoryTheory.CategoryStruct.comp.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1) X (CategoryTheory.Limits.widePullback.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) B g (CategoryTheory.Limits.WidePullback.base.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2)) (CategoryTheory.Category.assoc.{u3, u1} C _inst_1 X (CategoryTheory.Limits.widePullback.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) (objs j) B g (CategoryTheory.Limits.WidePullback.Ï€.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2 j) (arrows j)) (congrArg.{succ u3, succ u3} (Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) (CategoryTheory.Limits.widePullback.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) B) (Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) X B) (CategoryTheory.CategoryStruct.comp.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1) (CategoryTheory.Limits.widePullback.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) (objs j) B (CategoryTheory.Limits.WidePullback.Ï€.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2 j) (arrows j)) (CategoryTheory.Limits.WidePullback.base.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) (CategoryTheory.CategoryStruct.comp.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1) X (CategoryTheory.Limits.widePullback.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) B g) (CategoryTheory.Limits.WidePullback.Ï€_arrow.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2 j)))) (CategoryTheory.CategoryStruct.comp.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1) X (CategoryTheory.Limits.widePullback.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) B g (CategoryTheory.Limits.WidePullback.base.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2))) (eq_self.{succ u3} (Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) X B) (CategoryTheory.CategoryStruct.comp.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1) X (CategoryTheory.Limits.widePullback.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) B g (CategoryTheory.Limits.WidePullback.base.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2))))))
Case conversion may be inaccurate. Consider using '#align category_theory.limits.wide_pullback.hom_eq_lift CategoryTheory.Limits.WidePullback.hom_eq_liftâ‚“'. -/
theorem hom_eq_lift (g : X âŸ¶ widePullback _ _ arrows) :
    g = lift (g â‰« base arrows) (fun j => g â‰« Ï€ arrows j) (by tidy) :=
  by
  apply eq_lift_of_comp_eq
  tidy
#align category_theory.limits.wide_pullback.hom_eq_lift CategoryTheory.Limits.WidePullback.hom_eq_lift

/- warning: category_theory.limits.wide_pullback.hom_ext -> CategoryTheory.Limits.WidePullback.hom_ext is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u1}} {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] {B : C} {objs : J -> C} (arrows : forall (j : J), Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (objs j) B) [_inst_2 : CategoryTheory.Limits.HasWidePullback.{u1, u2, u3} J C _inst_1 B objs arrows] {X : C} (g1 : Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) X (CategoryTheory.Limits.widePullback.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2)) (g2 : Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) X (CategoryTheory.Limits.widePullback.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2)), (forall (j : J), Eq.{succ u2} (Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) X (objs j)) (CategoryTheory.CategoryStruct.comp.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1) X (CategoryTheory.Limits.widePullback.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) (objs j) g1 (CategoryTheory.Limits.WidePullback.Ï€.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2 j)) (CategoryTheory.CategoryStruct.comp.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1) X (CategoryTheory.Limits.widePullback.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) (objs j) g2 (CategoryTheory.Limits.WidePullback.Ï€.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2 j))) -> (Eq.{succ u2} (Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) X B) (CategoryTheory.CategoryStruct.comp.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1) X (CategoryTheory.Limits.widePullback.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) B g1 (CategoryTheory.Limits.WidePullback.base.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2)) (CategoryTheory.CategoryStruct.comp.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1) X (CategoryTheory.Limits.widePullback.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) B g2 (CategoryTheory.Limits.WidePullback.base.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2))) -> (Eq.{succ u2} (Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) X (CategoryTheory.Limits.widePullback.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2)) g1 g2)
but is expected to have type
  forall {J : Type.{u2}} {C : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u3, u1} C] {B : C} {objs : J -> C} (arrows : forall (j : J), Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) (objs j) B) [_inst_2 : CategoryTheory.Limits.HasWidePullback.{u2, u3, u1} J C _inst_1 B objs arrows] {X : C} (g1 : Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) X (CategoryTheory.Limits.widePullback.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2)) (g2 : Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) X (CategoryTheory.Limits.widePullback.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2)), (forall (j : J), Eq.{succ u3} (Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) X (objs j)) (CategoryTheory.CategoryStruct.comp.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1) X (CategoryTheory.Limits.widePullback.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) (objs j) g1 (CategoryTheory.Limits.WidePullback.Ï€.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2 j)) (CategoryTheory.CategoryStruct.comp.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1) X (CategoryTheory.Limits.widePullback.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) (objs j) g2 (CategoryTheory.Limits.WidePullback.Ï€.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2 j))) -> (Eq.{succ u3} (Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) X B) (CategoryTheory.CategoryStruct.comp.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1) X (CategoryTheory.Limits.widePullback.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) B g1 (CategoryTheory.Limits.WidePullback.base.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2)) (CategoryTheory.CategoryStruct.comp.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1) X (CategoryTheory.Limits.widePullback.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) B g2 (CategoryTheory.Limits.WidePullback.base.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2))) -> (Eq.{succ u3} (Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) X (CategoryTheory.Limits.widePullback.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2)) g1 g2)
Case conversion may be inaccurate. Consider using '#align category_theory.limits.wide_pullback.hom_ext CategoryTheory.Limits.WidePullback.hom_extâ‚“'. -/
@[ext]
theorem hom_ext (g1 g2 : X âŸ¶ widePullback _ _ arrows) :
    (âˆ€ j : J, g1 â‰« Ï€ arrows j = g2 â‰« Ï€ arrows j) â†’ g1 â‰« base arrows = g2 â‰« base arrows â†’ g1 = g2 :=
  by
  intro h1 h2
  apply limit.hom_ext
  rintro (_ | _)
  Â· apply h2
  Â· apply h1
#align category_theory.limits.wide_pullback.hom_ext CategoryTheory.Limits.WidePullback.hom_ext

end WidePullback

namespace WidePushout

variable {C} {B : C} {objs : J â†’ C} (arrows : âˆ€ j : J, B âŸ¶ objs j)

variable [HasWidePushout B objs arrows]

#print CategoryTheory.Limits.WidePushout.Î¹ /-
/-- The `j`-th inclusion to the pushout. -/
noncomputable abbrev Î¹ (j : J) : objs j âŸ¶ widePushout _ _ arrows :=
  colimit.Î¹ (WidePushoutShape.wideSpan _ _ _) (Option.some j)
#align category_theory.limits.wide_pushout.Î¹ CategoryTheory.Limits.WidePushout.Î¹
-/

#print CategoryTheory.Limits.WidePushout.head /-
/-- The unique map from the head to the pushout. -/
noncomputable abbrev head : B âŸ¶ widePushout B objs arrows :=
  colimit.Î¹ (WidePushoutShape.wideSpan _ _ _) Option.none
#align category_theory.limits.wide_pushout.head CategoryTheory.Limits.WidePushout.head
-/

/- warning: category_theory.limits.wide_pushout.arrow_Î¹ -> CategoryTheory.Limits.WidePushout.arrow_Î¹ is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u1}} {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] {B : C} {objs : J -> C} (arrows : forall (j : J), Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) B (objs j)) [_inst_2 : CategoryTheory.Limits.HasWidePushout.{u1, u2, u3} J C _inst_1 B objs arrows] (j : J), Eq.{succ u2} (Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) B (CategoryTheory.Limits.widePushout.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2)) (CategoryTheory.CategoryStruct.comp.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1) B (objs j) (CategoryTheory.Limits.widePushout.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) (arrows j) (CategoryTheory.Limits.WidePushout.Î¹.{u1, u2, u3} J C _inst_1 B objs arrows _inst_2 j)) (CategoryTheory.Limits.WidePushout.head.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2)
but is expected to have type
  forall {J : Type.{u2}} {C : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u3, u1} C] {B : C} {objs : J -> C} (arrows : forall (j : J), Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) B (objs j)) [_inst_2 : CategoryTheory.Limits.HasWidePushout.{u2, u3, u1} J C _inst_1 B objs arrows] (j : J), Eq.{succ u3} (Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) B (CategoryTheory.Limits.widePushout.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2)) (CategoryTheory.CategoryStruct.comp.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1) B (objs j) (CategoryTheory.Limits.widePushout.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) (arrows j) (CategoryTheory.Limits.WidePushout.Î¹.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2 j)) (CategoryTheory.Limits.WidePushout.head.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2)
Case conversion may be inaccurate. Consider using '#align category_theory.limits.wide_pushout.arrow_Î¹ CategoryTheory.Limits.WidePushout.arrow_Î¹â‚“'. -/
@[simp, reassoc.1]
theorem arrow_Î¹ (j : J) : arrows j â‰« Î¹ arrows j = head arrows := by
  apply colimit.w (wide_pushout_shape.wide_span _ _ _) (wide_pushout_shape.hom.init j)
#align category_theory.limits.wide_pushout.arrow_Î¹ CategoryTheory.Limits.WidePushout.arrow_Î¹

variable {arrows}

#print CategoryTheory.Limits.WidePushout.desc /-
/-- Descend a collection of morphisms to a morphism from the pushout. -/
noncomputable abbrev desc {X : C} (f : B âŸ¶ X) (fs : âˆ€ j : J, objs j âŸ¶ X)
    (w : âˆ€ j, arrows j â‰« fs j = f) : widePushout _ _ arrows âŸ¶ X :=
  colimit.desc (WidePushoutShape.wideSpan B objs arrows) (WidePushoutShape.mkCocone f fs <| w)
#align category_theory.limits.wide_pushout.desc CategoryTheory.Limits.WidePushout.desc
-/

variable (arrows)

variable {X : C} (f : B âŸ¶ X) (fs : âˆ€ j : J, objs j âŸ¶ X) (w : âˆ€ j, arrows j â‰« fs j = f)

/- warning: category_theory.limits.wide_pushout.Î¹_desc -> CategoryTheory.Limits.WidePushout.Î¹_desc is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u1}} {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] {B : C} {objs : J -> C} (arrows : forall (j : J), Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) B (objs j)) [_inst_2 : CategoryTheory.Limits.HasWidePushout.{u1, u2, u3} J C _inst_1 B objs arrows] {X : C} (f : Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) B X) (fs : forall (j : J), Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (objs j) X) (w : forall (j : J), Eq.{succ u2} (Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) B X) (CategoryTheory.CategoryStruct.comp.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1) B (objs j) X (arrows j) (fs j)) f) (j : J), Eq.{succ u2} (Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (objs j) X) (CategoryTheory.CategoryStruct.comp.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1) (objs j) (CategoryTheory.Limits.widePushout.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) X (CategoryTheory.Limits.WidePushout.Î¹.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2 j) (CategoryTheory.Limits.WidePushout.desc.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2 X f fs w)) (fs j)
but is expected to have type
  forall {J : Type.{u2}} {C : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u3, u1} C] {B : C} {objs : J -> C} (arrows : forall (j : J), Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) B (objs j)) [_inst_2 : CategoryTheory.Limits.HasWidePushout.{u2, u3, u1} J C _inst_1 B objs arrows] {X : C} (f : Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) B X) (fs : forall (j : J), Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) (objs j) X) (w : forall (j : J), Eq.{succ u3} (Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) B X) (CategoryTheory.CategoryStruct.comp.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1) B (objs j) X (arrows j) (fs j)) f) (j : J), Eq.{succ u3} (Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) (objs j) X) (CategoryTheory.CategoryStruct.comp.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1) (objs j) (CategoryTheory.Limits.widePushout.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) X (CategoryTheory.Limits.WidePushout.Î¹.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2 j) (CategoryTheory.Limits.WidePushout.desc.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2 X f fs w)) (fs j)
Case conversion may be inaccurate. Consider using '#align category_theory.limits.wide_pushout.Î¹_desc CategoryTheory.Limits.WidePushout.Î¹_descâ‚“'. -/
@[simp, reassoc.1]
theorem Î¹_desc (j : J) : Î¹ arrows j â‰« desc f fs w = fs _ :=
  by
  simp
  rfl
#align category_theory.limits.wide_pushout.Î¹_desc CategoryTheory.Limits.WidePushout.Î¹_desc

/- warning: category_theory.limits.wide_pushout.head_desc -> CategoryTheory.Limits.WidePushout.head_desc is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u1}} {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] {B : C} {objs : J -> C} (arrows : forall (j : J), Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) B (objs j)) [_inst_2 : CategoryTheory.Limits.HasWidePushout.{u1, u2, u3} J C _inst_1 B objs arrows] {X : C} (f : Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) B X) (fs : forall (j : J), Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (objs j) X) (w : forall (j : J), Eq.{succ u2} (Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) B X) (CategoryTheory.CategoryStruct.comp.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1) B (objs j) X (arrows j) (fs j)) f), Eq.{succ u2} (Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) B X) (CategoryTheory.CategoryStruct.comp.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1) B (CategoryTheory.Limits.widePushout.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) X (CategoryTheory.Limits.WidePushout.head.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) (CategoryTheory.Limits.WidePushout.desc.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2 X f fs w)) f
but is expected to have type
  forall {J : Type.{u2}} {C : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u3, u1} C] {B : C} {objs : J -> C} (arrows : forall (j : J), Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) B (objs j)) [_inst_2 : CategoryTheory.Limits.HasWidePushout.{u2, u3, u1} J C _inst_1 B objs arrows] {X : C} (f : Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) B X) (fs : forall (j : J), Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) (objs j) X) (w : forall (j : J), Eq.{succ u3} (Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) B X) (CategoryTheory.CategoryStruct.comp.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1) B (objs j) X (arrows j) (fs j)) f), Eq.{succ u3} (Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) B X) (CategoryTheory.CategoryStruct.comp.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1) B (CategoryTheory.Limits.widePushout.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) X (CategoryTheory.Limits.WidePushout.head.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) (CategoryTheory.Limits.WidePushout.desc.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2 X f fs w)) f
Case conversion may be inaccurate. Consider using '#align category_theory.limits.wide_pushout.head_desc CategoryTheory.Limits.WidePushout.head_descâ‚“'. -/
@[simp, reassoc.1]
theorem head_desc : head arrows â‰« desc f fs w = f :=
  by
  simp
  rfl
#align category_theory.limits.wide_pushout.head_desc CategoryTheory.Limits.WidePushout.head_desc

/- warning: category_theory.limits.wide_pushout.eq_desc_of_comp_eq -> CategoryTheory.Limits.WidePushout.eq_desc_of_comp_eq is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u1}} {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] {B : C} {objs : J -> C} (arrows : forall (j : J), Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) B (objs j)) [_inst_2 : CategoryTheory.Limits.HasWidePushout.{u1, u2, u3} J C _inst_1 B objs arrows] {X : C} (f : Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) B X) (fs : forall (j : J), Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (objs j) X) (w : forall (j : J), Eq.{succ u2} (Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) B X) (CategoryTheory.CategoryStruct.comp.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1) B (objs j) X (arrows j) (fs j)) f) (g : Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.Limits.widePushout.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) X), (forall (j : J), Eq.{succ u2} (Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (objs j) X) (CategoryTheory.CategoryStruct.comp.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1) (objs j) (CategoryTheory.Limits.widePushout.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) X (CategoryTheory.Limits.WidePushout.Î¹.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2 j) g) (fs j)) -> (Eq.{succ u2} (Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) B X) (CategoryTheory.CategoryStruct.comp.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1) B (CategoryTheory.Limits.widePushout.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) X (CategoryTheory.Limits.WidePushout.head.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) g) f) -> (Eq.{succ u2} (Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.Limits.widePushout.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) X) g (CategoryTheory.Limits.WidePushout.desc.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2 X f fs w))
but is expected to have type
  forall {J : Type.{u2}} {C : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u3, u1} C] {B : C} {objs : J -> C} (arrows : forall (j : J), Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) B (objs j)) [_inst_2 : CategoryTheory.Limits.HasWidePushout.{u2, u3, u1} J C _inst_1 B objs arrows] {X : C} (f : Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) B X) (fs : forall (j : J), Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) (objs j) X) (w : forall (j : J), Eq.{succ u3} (Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) B X) (CategoryTheory.CategoryStruct.comp.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1) B (objs j) X (arrows j) (fs j)) f) (g : Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) (CategoryTheory.Limits.widePushout.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) X), (forall (j : J), Eq.{succ u3} (Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) (objs j) X) (CategoryTheory.CategoryStruct.comp.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1) (objs j) (CategoryTheory.Limits.widePushout.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) X (CategoryTheory.Limits.WidePushout.Î¹.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2 j) g) (fs j)) -> (Eq.{succ u3} (Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) B X) (CategoryTheory.CategoryStruct.comp.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1) B (CategoryTheory.Limits.widePushout.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) X (CategoryTheory.Limits.WidePushout.head.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) g) f) -> (Eq.{succ u3} (Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) (CategoryTheory.Limits.widePushout.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) X) g (CategoryTheory.Limits.WidePushout.desc.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) (fun (j : J) => arrows j) _inst_2 X f fs w))
Case conversion may be inaccurate. Consider using '#align category_theory.limits.wide_pushout.eq_desc_of_comp_eq CategoryTheory.Limits.WidePushout.eq_desc_of_comp_eqâ‚“'. -/
theorem eq_desc_of_comp_eq (g : widePushout _ _ arrows âŸ¶ X) :
    (âˆ€ j : J, Î¹ arrows j â‰« g = fs j) â†’ head arrows â‰« g = f â†’ g = desc f fs w :=
  by
  intro h1 h2
  apply
    (colimit.is_colimit (wide_pushout_shape.wide_span B objs arrows)).uniq
      (wide_pushout_shape.mk_cocone f fs <| w)
  rintro (_ | _)
  Â· apply h2
  Â· apply h1
#align category_theory.limits.wide_pushout.eq_desc_of_comp_eq CategoryTheory.Limits.WidePushout.eq_desc_of_comp_eq

/- warning: category_theory.limits.wide_pushout.hom_eq_desc -> CategoryTheory.Limits.WidePushout.hom_eq_desc is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u1}} {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] {B : C} {objs : J -> C} (arrows : forall (j : J), Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) B (objs j)) [_inst_2 : CategoryTheory.Limits.HasWidePushout.{u1, u2, u3} J C _inst_1 B objs arrows] {X : C} (g : Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.Limits.widePushout.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) X), Eq.{succ u2} (Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.Limits.widePushout.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) X) g (CategoryTheory.Limits.WidePushout.desc.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2 X (CategoryTheory.CategoryStruct.comp.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1) B (CategoryTheory.Limits.widePushout.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) X (CategoryTheory.Limits.WidePushout.head.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) g) (fun (j : J) => CategoryTheory.CategoryStruct.comp.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1) (objs j) (CategoryTheory.Limits.widePushout.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) X (CategoryTheory.Limits.WidePushout.Î¹.{u1, u2, u3} J C _inst_1 B objs arrows _inst_2 j) g) (fun (j : J) => Eq.mpr.{0} (Eq.{succ u2} (Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) B X) (CategoryTheory.CategoryStruct.comp.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1) B (objs j) X (arrows j) (CategoryTheory.CategoryStruct.comp.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1) (objs j) (CategoryTheory.Limits.widePushout.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) X (CategoryTheory.Limits.WidePushout.Î¹.{u1, u2, u3} J C _inst_1 B objs arrows _inst_2 j) g)) (CategoryTheory.CategoryStruct.comp.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1) B (CategoryTheory.Limits.widePushout.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) X (CategoryTheory.Limits.WidePushout.head.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) g)) (Eq.{succ u2} (Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) B X) (CategoryTheory.CategoryStruct.comp.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1) B (CategoryTheory.Limits.widePushout.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) X (CategoryTheory.CategoryStruct.comp.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1) B (objs j) (CategoryTheory.Limits.widePushout.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) (arrows j) (CategoryTheory.Limits.WidePushout.Î¹.{u1, u2, u3} J C _inst_1 B objs arrows _inst_2 j)) g) (CategoryTheory.CategoryStruct.comp.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1) B (CategoryTheory.Limits.widePushout.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) X (CategoryTheory.Limits.WidePushout.head.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) g)) (id_tag Tactic.IdTag.rw (Eq.{1} Prop (Eq.{succ u2} (Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) B X) (CategoryTheory.CategoryStruct.comp.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1) B (objs j) X (arrows j) (CategoryTheory.CategoryStruct.comp.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1) (objs j) (CategoryTheory.Limits.widePushout.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) X (CategoryTheory.Limits.WidePushout.Î¹.{u1, u2, u3} J C _inst_1 B objs arrows _inst_2 j) g)) (CategoryTheory.CategoryStruct.comp.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1) B (CategoryTheory.Limits.widePushout.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) X (CategoryTheory.Limits.WidePushout.head.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) g)) (Eq.{succ u2} (Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) B X) (CategoryTheory.CategoryStruct.comp.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1) B (CategoryTheory.Limits.widePushout.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) X (CategoryTheory.CategoryStruct.comp.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1) B (objs j) (CategoryTheory.Limits.widePushout.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) (arrows j) (CategoryTheory.Limits.WidePushout.Î¹.{u1, u2, u3} J C _inst_1 B objs arrows _inst_2 j)) g) (CategoryTheory.CategoryStruct.comp.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1) B (CategoryTheory.Limits.widePushout.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) X (CategoryTheory.Limits.WidePushout.head.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) g))) (Eq.ndrec.{0, succ u2} (Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) B X) (CategoryTheory.CategoryStruct.comp.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1) B (objs j) X (arrows j) (CategoryTheory.CategoryStruct.comp.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1) (objs j) (CategoryTheory.Limits.widePushout.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) X (CategoryTheory.Limits.WidePushout.Î¹.{u1, u2, u3} J C _inst_1 B objs arrows _inst_2 j) g)) (fun (_a : Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) B X) => Eq.{1} Prop (Eq.{succ u2} (Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) B X) (CategoryTheory.CategoryStruct.comp.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1) B (objs j) X (arrows j) (CategoryTheory.CategoryStruct.comp.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1) (objs j) (CategoryTheory.Limits.widePushout.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) X (CategoryTheory.Limits.WidePushout.Î¹.{u1, u2, u3} J C _inst_1 B objs arrows _inst_2 j) g)) (CategoryTheory.CategoryStruct.comp.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1) B (CategoryTheory.Limits.widePushout.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) X (CategoryTheory.Limits.WidePushout.head.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) g)) (Eq.{succ u2} (Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) B X) _a (CategoryTheory.CategoryStruct.comp.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1) B (CategoryTheory.Limits.widePushout.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) X (CategoryTheory.Limits.WidePushout.head.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) g))) (rfl.{1} Prop (Eq.{succ u2} (Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) B X) (CategoryTheory.CategoryStruct.comp.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1) B (objs j) X (arrows j) (CategoryTheory.CategoryStruct.comp.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1) (objs j) (CategoryTheory.Limits.widePushout.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) X (CategoryTheory.Limits.WidePushout.Î¹.{u1, u2, u3} J C _inst_1 B objs arrows _inst_2 j) g)) (CategoryTheory.CategoryStruct.comp.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1) B (CategoryTheory.Limits.widePushout.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) X (CategoryTheory.Limits.WidePushout.head.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) g))) (CategoryTheory.CategoryStruct.comp.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1) B (CategoryTheory.Limits.widePushout.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) X (CategoryTheory.CategoryStruct.comp.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1) B (objs j) (CategoryTheory.Limits.widePushout.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) (arrows j) (CategoryTheory.Limits.WidePushout.Î¹.{u1, u2, u3} J C _inst_1 B objs arrows _inst_2 j)) g) (Eq.symm.{succ u2} (Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) B X) (CategoryTheory.CategoryStruct.comp.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1) B (CategoryTheory.Limits.widePushout.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) X (CategoryTheory.CategoryStruct.comp.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1) B (objs j) (CategoryTheory.Limits.widePushout.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) (arrows j) (CategoryTheory.Limits.WidePushout.Î¹.{u1, u2, u3} J C _inst_1 B objs arrows _inst_2 j)) g) (CategoryTheory.CategoryStruct.comp.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1) B (objs j) X (arrows j) (CategoryTheory.CategoryStruct.comp.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1) (objs j) (CategoryTheory.Limits.widePushout.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) X (CategoryTheory.Limits.WidePushout.Î¹.{u1, u2, u3} J C _inst_1 B objs arrows _inst_2 j) g)) (CategoryTheory.Category.assoc.{u2, u3} C _inst_1 B (objs j) (CategoryTheory.Limits.widePushout.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) X (arrows j) (CategoryTheory.Limits.WidePushout.Î¹.{u1, u2, u3} J C _inst_1 B objs arrows _inst_2 j) g)))) (Eq.mpr.{0} (Eq.{succ u2} (Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) B X) (CategoryTheory.CategoryStruct.comp.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1) B (CategoryTheory.Limits.widePushout.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) X (CategoryTheory.CategoryStruct.comp.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1) B (objs j) (CategoryTheory.Limits.widePushout.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) (arrows j) (CategoryTheory.Limits.WidePushout.Î¹.{u1, u2, u3} J C _inst_1 B objs arrows _inst_2 j)) g) (CategoryTheory.CategoryStruct.comp.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1) B (CategoryTheory.Limits.widePushout.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) X (CategoryTheory.Limits.WidePushout.head.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) g)) True (id_tag Tactic.IdTag.simp (Eq.{1} Prop (Eq.{succ u2} (Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) B X) (CategoryTheory.CategoryStruct.comp.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1) B (CategoryTheory.Limits.widePushout.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) X (CategoryTheory.CategoryStruct.comp.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1) B (objs j) (CategoryTheory.Limits.widePushout.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) (arrows j) (CategoryTheory.Limits.WidePushout.Î¹.{u1, u2, u3} J C _inst_1 B objs arrows _inst_2 j)) g) (CategoryTheory.CategoryStruct.comp.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1) B (CategoryTheory.Limits.widePushout.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) X (CategoryTheory.Limits.WidePushout.head.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) g)) True) (Eq.trans.{1} Prop (Eq.{succ u2} (Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) B X) (CategoryTheory.CategoryStruct.comp.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1) B (CategoryTheory.Limits.widePushout.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) X (CategoryTheory.CategoryStruct.comp.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1) B (objs j) (CategoryTheory.Limits.widePushout.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) (arrows j) (CategoryTheory.Limits.WidePushout.Î¹.{u1, u2, u3} J C _inst_1 B objs arrows _inst_2 j)) g) (CategoryTheory.CategoryStruct.comp.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1) B (CategoryTheory.Limits.widePushout.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) X (CategoryTheory.Limits.WidePushout.head.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) g)) (Eq.{succ u2} (Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) B X) (CategoryTheory.CategoryStruct.comp.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1) B (CategoryTheory.Limits.widePushout.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) X (CategoryTheory.Limits.WidePushout.head.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) g) (CategoryTheory.CategoryStruct.comp.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1) B (CategoryTheory.Limits.widePushout.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) X (CategoryTheory.Limits.WidePushout.head.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) g)) True ((fun (a : Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) B X) (a_1 : Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) B X) (e_1 : Eq.{succ u2} (Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) B X) a a_1) (á¾° : Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) B X) (á¾°_1 : Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) B X) (e_2 : Eq.{succ u2} (Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) B X) á¾° á¾°_1) => congr.{succ u2, 1} (Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) B X) Prop (Eq.{succ u2} (Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) B X) a) (Eq.{succ u2} (Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) B X) a_1) á¾° á¾°_1 (congr_arg.{succ u2, succ u2} (Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) B X) ((Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) B X) -> Prop) a a_1 (Eq.{succ u2} (Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) B X)) e_1) e_2) (CategoryTheory.CategoryStruct.comp.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1) B (CategoryTheory.Limits.widePushout.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) X (CategoryTheory.CategoryStruct.comp.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1) B (objs j) (CategoryTheory.Limits.widePushout.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) (arrows j) (CategoryTheory.Limits.WidePushout.Î¹.{u1, u2, u3} J C _inst_1 B objs arrows _inst_2 j)) g) (CategoryTheory.CategoryStruct.comp.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1) B (CategoryTheory.Limits.widePushout.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) X (CategoryTheory.Limits.WidePushout.head.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) g) ((fun (á¾° : Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) B (CategoryTheory.Limits.widePushout.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2)) (á¾°_1 : Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) B (CategoryTheory.Limits.widePushout.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2)) (e_1 : Eq.{succ u2} (Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) B (CategoryTheory.Limits.widePushout.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2)) á¾° á¾°_1) (á¾°_2 : Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.Limits.widePushout.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) X) (á¾°_3 : Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.Limits.widePushout.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) X) (e_2 : Eq.{succ u2} (Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.Limits.widePushout.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) X) á¾°_2 á¾°_3) => congr.{succ u2, succ u2} (Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.Limits.widePushout.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) X) (Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) B X) (CategoryTheory.CategoryStruct.comp.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1) B (CategoryTheory.Limits.widePushout.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) X á¾°) (CategoryTheory.CategoryStruct.comp.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1) B (CategoryTheory.Limits.widePushout.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) X á¾°_1) á¾°_2 á¾°_3 (congr_arg.{succ u2, succ u2} (Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) B (CategoryTheory.Limits.widePushout.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2)) ((Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.Limits.widePushout.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) X) -> (Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) B X)) á¾° á¾°_1 (CategoryTheory.CategoryStruct.comp.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1) B (CategoryTheory.Limits.widePushout.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) X) e_1) e_2) (CategoryTheory.CategoryStruct.comp.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1) B (objs j) (CategoryTheory.Limits.widePushout.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) (arrows j) (CategoryTheory.Limits.WidePushout.Î¹.{u1, u2, u3} J C _inst_1 B objs arrows _inst_2 j)) (CategoryTheory.Limits.WidePushout.head.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) (CategoryTheory.Limits.WidePushout.arrow_Î¹.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2 j) g g (rfl.{succ u2} (Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.Limits.widePushout.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) X) g)) (CategoryTheory.CategoryStruct.comp.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1) B (CategoryTheory.Limits.widePushout.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) X (CategoryTheory.Limits.WidePushout.head.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) g) (CategoryTheory.CategoryStruct.comp.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1) B (CategoryTheory.Limits.widePushout.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) X (CategoryTheory.Limits.WidePushout.head.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) g) (rfl.{succ u2} (Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) B X) (CategoryTheory.CategoryStruct.comp.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1) B (CategoryTheory.Limits.widePushout.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) X (CategoryTheory.Limits.WidePushout.head.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) g))) (propext (Eq.{succ u2} (Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) B X) (CategoryTheory.CategoryStruct.comp.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1) B (CategoryTheory.Limits.widePushout.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) X (CategoryTheory.Limits.WidePushout.head.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) g) (CategoryTheory.CategoryStruct.comp.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1) B (CategoryTheory.Limits.widePushout.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) X (CategoryTheory.Limits.WidePushout.head.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) g)) True (eq_self_iff_true.{succ u2} (Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) B X) (CategoryTheory.CategoryStruct.comp.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1) B (CategoryTheory.Limits.widePushout.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) X (CategoryTheory.Limits.WidePushout.head.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) g))))) trivial)))
but is expected to have type
  forall {J : Type.{u2}} {C : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u3, u1} C] {B : C} {objs : J -> C} (arrows : forall (j : J), Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) B (objs j)) [_inst_2 : CategoryTheory.Limits.HasWidePushout.{u2, u3, u1} J C _inst_1 B objs arrows] {X : C} (g : Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) (CategoryTheory.Limits.widePushout.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) X), Eq.{succ u3} (Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) (CategoryTheory.Limits.widePushout.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) X) g (CategoryTheory.Limits.WidePushout.desc.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2 X (CategoryTheory.CategoryStruct.comp.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1) B (CategoryTheory.Limits.widePushout.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) X (CategoryTheory.Limits.WidePushout.head.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) g) (fun (j : J) => CategoryTheory.CategoryStruct.comp.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1) (objs j) (CategoryTheory.Limits.widePushout.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) X (CategoryTheory.Limits.WidePushout.Î¹.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2 j) g) (fun (j : J) => Eq.mpr.{0} (Eq.{succ u3} (Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) B X) (CategoryTheory.CategoryStruct.comp.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1) B (objs j) X (arrows j) ((fun (j : J) => CategoryTheory.CategoryStruct.comp.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1) (objs j) (CategoryTheory.Limits.widePushout.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) X (CategoryTheory.Limits.WidePushout.Î¹.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2 j) g) j)) (CategoryTheory.CategoryStruct.comp.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1) B (CategoryTheory.Limits.widePushout.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) X (CategoryTheory.Limits.WidePushout.head.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) g)) (Eq.{succ u3} (Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) B X) (CategoryTheory.CategoryStruct.comp.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1) B (CategoryTheory.Limits.widePushout.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) X (CategoryTheory.CategoryStruct.comp.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1) B (objs j) (CategoryTheory.Limits.widePushout.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) (arrows j) (CategoryTheory.Limits.WidePushout.Î¹.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2 j)) g) (CategoryTheory.CategoryStruct.comp.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1) B (CategoryTheory.Limits.widePushout.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) X (CategoryTheory.Limits.WidePushout.head.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) g)) (id.{0} (Eq.{1} Prop (Eq.{succ u3} (Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) B X) (CategoryTheory.CategoryStruct.comp.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1) B (objs j) X (arrows j) ((fun (j : J) => CategoryTheory.CategoryStruct.comp.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1) (objs j) (CategoryTheory.Limits.widePushout.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) X (CategoryTheory.Limits.WidePushout.Î¹.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2 j) g) j)) (CategoryTheory.CategoryStruct.comp.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1) B (CategoryTheory.Limits.widePushout.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) X (CategoryTheory.Limits.WidePushout.head.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) g)) (Eq.{succ u3} (Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) B X) (CategoryTheory.CategoryStruct.comp.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1) B (CategoryTheory.Limits.widePushout.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) X (CategoryTheory.CategoryStruct.comp.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1) B (objs j) (CategoryTheory.Limits.widePushout.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) (arrows j) (CategoryTheory.Limits.WidePushout.Î¹.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2 j)) g) (CategoryTheory.CategoryStruct.comp.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1) B (CategoryTheory.Limits.widePushout.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) X (CategoryTheory.Limits.WidePushout.head.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) g))) (Eq.ndrec.{0, succ u3} (Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) B X) (CategoryTheory.CategoryStruct.comp.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1) B (objs j) X (arrows j) (CategoryTheory.CategoryStruct.comp.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1) (objs j) (CategoryTheory.Limits.widePushout.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) X (CategoryTheory.Limits.WidePushout.Î¹.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2 j) g)) (fun (_a : Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) B X) => Eq.{1} Prop (Eq.{succ u3} (Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) B X) (CategoryTheory.CategoryStruct.comp.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1) B (objs j) X (arrows j) ((fun (j : J) => CategoryTheory.CategoryStruct.comp.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1) (objs j) (CategoryTheory.Limits.widePushout.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) X (CategoryTheory.Limits.WidePushout.Î¹.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2 j) g) j)) (CategoryTheory.CategoryStruct.comp.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1) B (CategoryTheory.Limits.widePushout.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) X (CategoryTheory.Limits.WidePushout.head.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) g)) (Eq.{succ u3} (Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) B X) _a (CategoryTheory.CategoryStruct.comp.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1) B (CategoryTheory.Limits.widePushout.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) X (CategoryTheory.Limits.WidePushout.head.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) g))) (Eq.refl.{1} Prop (Eq.{succ u3} (Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) B X) (CategoryTheory.CategoryStruct.comp.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1) B (objs j) X (arrows j) ((fun (j : J) => CategoryTheory.CategoryStruct.comp.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1) (objs j) (CategoryTheory.Limits.widePushout.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) X (CategoryTheory.Limits.WidePushout.Î¹.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2 j) g) j)) (CategoryTheory.CategoryStruct.comp.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1) B (CategoryTheory.Limits.widePushout.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) X (CategoryTheory.Limits.WidePushout.head.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) g))) (CategoryTheory.CategoryStruct.comp.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1) B (CategoryTheory.Limits.widePushout.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) X (CategoryTheory.CategoryStruct.comp.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1) B (objs j) (CategoryTheory.Limits.widePushout.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) (arrows j) (CategoryTheory.Limits.WidePushout.Î¹.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2 j)) g) (Eq.symm.{succ u3} (Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) B X) (CategoryTheory.CategoryStruct.comp.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1) B (CategoryTheory.Limits.widePushout.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) X (CategoryTheory.CategoryStruct.comp.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1) B (objs j) (CategoryTheory.Limits.widePushout.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) (arrows j) (CategoryTheory.Limits.WidePushout.Î¹.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2 j)) g) (CategoryTheory.CategoryStruct.comp.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1) B (objs j) X (arrows j) (CategoryTheory.CategoryStruct.comp.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1) (objs j) (CategoryTheory.Limits.widePushout.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) X (CategoryTheory.Limits.WidePushout.Î¹.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2 j) g)) (CategoryTheory.Category.assoc.{u3, u1} C _inst_1 B (objs j) (CategoryTheory.Limits.widePushout.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) X (arrows j) (CategoryTheory.Limits.WidePushout.Î¹.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2 j) g)))) (of_eq_true (Eq.{succ u3} (Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) B X) (CategoryTheory.CategoryStruct.comp.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1) B (CategoryTheory.Limits.widePushout.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) X (CategoryTheory.CategoryStruct.comp.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1) B (objs j) (CategoryTheory.Limits.widePushout.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) (arrows j) (CategoryTheory.Limits.WidePushout.Î¹.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2 j)) g) (CategoryTheory.CategoryStruct.comp.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1) B (CategoryTheory.Limits.widePushout.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) X (CategoryTheory.Limits.WidePushout.head.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) g)) (Eq.trans.{1} Prop (Eq.{succ u3} (Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) B X) (CategoryTheory.CategoryStruct.comp.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1) B (CategoryTheory.Limits.widePushout.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) X (CategoryTheory.CategoryStruct.comp.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1) B (objs j) (CategoryTheory.Limits.widePushout.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) (arrows j) (CategoryTheory.Limits.WidePushout.Î¹.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2 j)) g) (CategoryTheory.CategoryStruct.comp.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1) B (CategoryTheory.Limits.widePushout.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) X (CategoryTheory.Limits.WidePushout.head.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) g)) (Eq.{succ u3} (Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) B X) (CategoryTheory.CategoryStruct.comp.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1) B (CategoryTheory.Limits.widePushout.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) X (CategoryTheory.Limits.WidePushout.head.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) g) (CategoryTheory.CategoryStruct.comp.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1) B (CategoryTheory.Limits.widePushout.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) X (CategoryTheory.Limits.WidePushout.head.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) g)) True (congrFun.{succ u3, 1} (Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) B X) (fun (a._@.Init.Prelude._hyg.170 : Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) B X) => Prop) (Eq.{succ u3} (Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) B X) (CategoryTheory.CategoryStruct.comp.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1) B (CategoryTheory.Limits.widePushout.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) X (CategoryTheory.CategoryStruct.comp.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1) B (objs j) (CategoryTheory.Limits.widePushout.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) (arrows j) (CategoryTheory.Limits.WidePushout.Î¹.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2 j)) g)) (Eq.{succ u3} (Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) B X) (CategoryTheory.CategoryStruct.comp.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1) B (CategoryTheory.Limits.widePushout.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) X (CategoryTheory.Limits.WidePushout.head.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) g)) (congrArg.{succ u3, succ u3} (Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) B X) ((Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) B X) -> Prop) (CategoryTheory.CategoryStruct.comp.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1) B (CategoryTheory.Limits.widePushout.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) X (CategoryTheory.CategoryStruct.comp.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1) B (objs j) (CategoryTheory.Limits.widePushout.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) (arrows j) (CategoryTheory.Limits.WidePushout.Î¹.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2 j)) g) (CategoryTheory.CategoryStruct.comp.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1) B (CategoryTheory.Limits.widePushout.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) X (CategoryTheory.Limits.WidePushout.head.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) g) (Eq.{succ u3} (Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) B X)) (congrFun.{succ u3, succ u3} (Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) (CategoryTheory.Limits.widePushout.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) X) (fun (a._@.Mathlib.CategoryTheory.Category.Basic._hyg.118 : Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) (CategoryTheory.Limits.widePushout.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) X) => Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) B X) (CategoryTheory.CategoryStruct.comp.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1) B (CategoryTheory.Limits.widePushout.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) X (CategoryTheory.CategoryStruct.comp.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1) B (objs j) (CategoryTheory.Limits.widePushout.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) (arrows j) (CategoryTheory.Limits.WidePushout.Î¹.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2 j))) (CategoryTheory.CategoryStruct.comp.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1) B (CategoryTheory.Limits.widePushout.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) X (CategoryTheory.Limits.WidePushout.head.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2)) (congrArg.{succ u3, succ u3} (Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) B (CategoryTheory.Limits.widePushout.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2)) ((Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) (CategoryTheory.Limits.widePushout.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) X) -> (Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) B X)) (CategoryTheory.CategoryStruct.comp.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1) B (objs j) (CategoryTheory.Limits.widePushout.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) (arrows j) (CategoryTheory.Limits.WidePushout.Î¹.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2 j)) (CategoryTheory.Limits.WidePushout.head.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) (CategoryTheory.CategoryStruct.comp.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1) B (CategoryTheory.Limits.widePushout.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) X) (CategoryTheory.Limits.WidePushout.arrow_Î¹.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2 j)) g)) (CategoryTheory.CategoryStruct.comp.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1) B (CategoryTheory.Limits.widePushout.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) X (CategoryTheory.Limits.WidePushout.head.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) g)) (eq_self.{succ u3} (Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) B X) (CategoryTheory.CategoryStruct.comp.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1) B (CategoryTheory.Limits.widePushout.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) X (CategoryTheory.Limits.WidePushout.head.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) g))))))
Case conversion may be inaccurate. Consider using '#align category_theory.limits.wide_pushout.hom_eq_desc CategoryTheory.Limits.WidePushout.hom_eq_descâ‚“'. -/
theorem hom_eq_desc (g : widePushout _ _ arrows âŸ¶ X) :
    g =
      desc (head arrows â‰« g) (fun j => Î¹ arrows j â‰« g) fun j =>
        by
        rw [â† category.assoc]
        simp :=
  by
  apply eq_desc_of_comp_eq
  tidy
#align category_theory.limits.wide_pushout.hom_eq_desc CategoryTheory.Limits.WidePushout.hom_eq_desc

/- warning: category_theory.limits.wide_pushout.hom_ext -> CategoryTheory.Limits.WidePushout.hom_ext is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u1}} {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] {B : C} {objs : J -> C} (arrows : forall (j : J), Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) B (objs j)) [_inst_2 : CategoryTheory.Limits.HasWidePushout.{u1, u2, u3} J C _inst_1 B objs arrows] {X : C} (g1 : Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.Limits.widePushout.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) X) (g2 : Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.Limits.widePushout.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) X), (forall (j : J), Eq.{succ u2} (Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (objs j) X) (CategoryTheory.CategoryStruct.comp.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1) (objs j) (CategoryTheory.Limits.widePushout.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) X (CategoryTheory.Limits.WidePushout.Î¹.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2 j) g1) (CategoryTheory.CategoryStruct.comp.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1) (objs j) (CategoryTheory.Limits.widePushout.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) X (CategoryTheory.Limits.WidePushout.Î¹.{u1, u2, u3} J C _inst_1 B objs arrows _inst_2 j) g2)) -> (Eq.{succ u2} (Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) B X) (CategoryTheory.CategoryStruct.comp.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1) B (CategoryTheory.Limits.widePushout.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) X (CategoryTheory.Limits.WidePushout.head.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) g1) (CategoryTheory.CategoryStruct.comp.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1) B (CategoryTheory.Limits.widePushout.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) X (CategoryTheory.Limits.WidePushout.head.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) g2)) -> (Eq.{succ u2} (Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) (CategoryTheory.Limits.widePushout.{u1, u2, u3} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) X) g1 g2)
but is expected to have type
  forall {J : Type.{u2}} {C : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u3, u1} C] {B : C} {objs : J -> C} (arrows : forall (j : J), Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) B (objs j)) [_inst_2 : CategoryTheory.Limits.HasWidePushout.{u2, u3, u1} J C _inst_1 B objs arrows] {X : C} (g1 : Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) (CategoryTheory.Limits.widePushout.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) X) (g2 : Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) (CategoryTheory.Limits.widePushout.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) X), (forall (j : J), Eq.{succ u3} (Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) (objs j) X) (CategoryTheory.CategoryStruct.comp.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1) (objs j) (CategoryTheory.Limits.widePushout.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) X (CategoryTheory.Limits.WidePushout.Î¹.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2 j) g1) (CategoryTheory.CategoryStruct.comp.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1) (objs j) (CategoryTheory.Limits.widePushout.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) X (CategoryTheory.Limits.WidePushout.Î¹.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2 j) g2)) -> (Eq.{succ u3} (Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) B X) (CategoryTheory.CategoryStruct.comp.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1) B (CategoryTheory.Limits.widePushout.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) X (CategoryTheory.Limits.WidePushout.head.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) g1) (CategoryTheory.CategoryStruct.comp.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1) B (CategoryTheory.Limits.widePushout.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) X (CategoryTheory.Limits.WidePushout.head.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) g2)) -> (Eq.{succ u3} (Quiver.Hom.{succ u3, u1} C (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} C (CategoryTheory.Category.toCategoryStruct.{u3, u1} C _inst_1)) (CategoryTheory.Limits.widePushout.{u2, u3, u1} J C _inst_1 B (fun (j : J) => objs j) arrows _inst_2) X) g1 g2)
Case conversion may be inaccurate. Consider using '#align category_theory.limits.wide_pushout.hom_ext CategoryTheory.Limits.WidePushout.hom_extâ‚“'. -/
@[ext]
theorem hom_ext (g1 g2 : widePushout _ _ arrows âŸ¶ X) :
    (âˆ€ j : J, Î¹ arrows j â‰« g1 = Î¹ arrows j â‰« g2) â†’ head arrows â‰« g1 = head arrows â‰« g2 â†’ g1 = g2 :=
  by
  intro h1 h2
  apply colimit.hom_ext
  rintro (_ | _)
  Â· apply h2
  Â· apply h1
#align category_theory.limits.wide_pushout.hom_ext CategoryTheory.Limits.WidePushout.hom_ext

end WidePushout

variable (J)

#print CategoryTheory.Limits.widePullbackShapeOpMap /-
/-- The action on morphisms of the obvious functor
  `wide_pullback_shape_op : wide_pullback_shape J â¥¤ (wide_pushout_shape J)áµ’áµ–`-/
def widePullbackShapeOpMap :
    âˆ€ X Y : WidePullbackShape J,
      (X âŸ¶ Y) â†’ ((op X : (WidePushoutShape J)áµ’áµ–) âŸ¶ (op Y : (WidePushoutShape J)áµ’áµ–))
  | _, _, wide_pullback_shape.hom.id X => Quiver.Hom.op (WidePushoutShape.Hom.id _)
  | _, _, wide_pullback_shape.hom.term j => Quiver.Hom.op (WidePushoutShape.Hom.init _)
#align category_theory.limits.wide_pullback_shape_op_map CategoryTheory.Limits.widePullbackShapeOpMap
-/

#print CategoryTheory.Limits.widePullbackShapeOp /-
/-- The obvious functor `wide_pullback_shape J â¥¤ (wide_pushout_shape J)áµ’áµ–` -/
@[simps]
def widePullbackShapeOp : WidePullbackShape J â¥¤ (WidePushoutShape J)áµ’áµ–
    where
  obj X := op X
  map := widePullbackShapeOpMap J
#align category_theory.limits.wide_pullback_shape_op CategoryTheory.Limits.widePullbackShapeOp
-/

#print CategoryTheory.Limits.widePushoutShapeOpMap /-
/-- The action on morphisms of the obvious functor
`wide_pushout_shape_op : `wide_pushout_shape J â¥¤ (wide_pullback_shape J)áµ’áµ–` -/
def widePushoutShapeOpMap :
    âˆ€ X Y : WidePushoutShape J,
      (X âŸ¶ Y) â†’ ((op X : (WidePullbackShape J)áµ’áµ–) âŸ¶ (op Y : (WidePullbackShape J)áµ’áµ–))
  | _, _, wide_pushout_shape.hom.id X => Quiver.Hom.op (WidePullbackShape.Hom.id _)
  | _, _, wide_pushout_shape.hom.init j => Quiver.Hom.op (WidePullbackShape.Hom.term _)
#align category_theory.limits.wide_pushout_shape_op_map CategoryTheory.Limits.widePushoutShapeOpMap
-/

#print CategoryTheory.Limits.widePushoutShapeOp /-
/-- The obvious functor `wide_pushout_shape J â¥¤ (wide_pullback_shape J)áµ’áµ–` -/
@[simps]
def widePushoutShapeOp : WidePushoutShape J â¥¤ (WidePullbackShape J)áµ’áµ–
    where
  obj X := op X
  map := widePushoutShapeOpMap J
#align category_theory.limits.wide_pushout_shape_op CategoryTheory.Limits.widePushoutShapeOp
-/

#print CategoryTheory.Limits.widePullbackShapeUnop /-
/-- The obvious functor `(wide_pullback_shape J)áµ’áµ– â¥¤ wide_pushout_shape J`-/
@[simps]
def widePullbackShapeUnop : (WidePullbackShape J)áµ’áµ– â¥¤ WidePushoutShape J :=
  (widePullbackShapeOp J).leftOp
#align category_theory.limits.wide_pullback_shape_unop CategoryTheory.Limits.widePullbackShapeUnop
-/

#print CategoryTheory.Limits.widePushoutShapeUnop /-
/-- The obvious functor `(wide_pushout_shape J)áµ’áµ– â¥¤ wide_pullback_shape J` -/
@[simps]
def widePushoutShapeUnop : (WidePushoutShape J)áµ’áµ– â¥¤ WidePullbackShape J :=
  (widePushoutShapeOp J).leftOp
#align category_theory.limits.wide_pushout_shape_unop CategoryTheory.Limits.widePushoutShapeUnop
-/

#print CategoryTheory.Limits.widePushoutShapeOpUnop /-
/-- The inverse of the unit isomorphism of the equivalence
`wide_pushout_shape_op_equiv : (wide_pushout_shape J)áµ’áµ– â‰Œ wide_pullback_shape J` -/
def widePushoutShapeOpUnop : widePushoutShapeUnop J â‹™ widePullbackShapeOp J â‰… ğŸ­ _ :=
  NatIso.ofComponents (fun X => Iso.refl _) fun X Y f => by decide
#align category_theory.limits.wide_pushout_shape_op_unop CategoryTheory.Limits.widePushoutShapeOpUnop
-/

#print CategoryTheory.Limits.widePushoutShapeUnopOp /-
/-- The counit isomorphism of the equivalence
`wide_pullback_shape_op_equiv : (wide_pullback_shape J)áµ’áµ– â‰Œ wide_pushout_shape J` -/
def widePushoutShapeUnopOp : widePushoutShapeOp J â‹™ widePullbackShapeUnop J â‰… ğŸ­ _ :=
  NatIso.ofComponents (fun X => Iso.refl _) fun X Y f => by decide
#align category_theory.limits.wide_pushout_shape_unop_op CategoryTheory.Limits.widePushoutShapeUnopOp
-/

#print CategoryTheory.Limits.widePullbackShapeOpUnop /-
/-- The inverse of the unit isomorphism of the equivalence
`wide_pullback_shape_op_equiv : (wide_pullback_shape J)áµ’áµ– â‰Œ wide_pushout_shape J` -/
def widePullbackShapeOpUnop : widePullbackShapeUnop J â‹™ widePushoutShapeOp J â‰… ğŸ­ _ :=
  NatIso.ofComponents (fun X => Iso.refl _) fun X Y f => by decide
#align category_theory.limits.wide_pullback_shape_op_unop CategoryTheory.Limits.widePullbackShapeOpUnop
-/

#print CategoryTheory.Limits.widePullbackShapeUnopOp /-
/-- The counit isomorphism of the equivalence
`wide_pushout_shape_op_equiv : (wide_pushout_shape J)áµ’áµ– â‰Œ wide_pullback_shape J` -/
def widePullbackShapeUnopOp : widePullbackShapeOp J â‹™ widePushoutShapeUnop J â‰… ğŸ­ _ :=
  NatIso.ofComponents (fun X => Iso.refl _) fun X Y f => by decide
#align category_theory.limits.wide_pullback_shape_unop_op CategoryTheory.Limits.widePullbackShapeUnopOp
-/

/- warning: category_theory.limits.wide_pushout_shape_op_equiv -> CategoryTheory.Limits.widePushoutShapeOpEquiv is a dubious translation:
lean 3 declaration is
  forall (J : Type.{u1}), CategoryTheory.Equivalence.{u1, u1, u1, u1} (Opposite.{succ u1} (CategoryTheory.Limits.WidePushoutShape.{u1} J)) (CategoryTheory.Category.opposite.{u1, u1} (CategoryTheory.Limits.WidePushoutShape.{u1} J) (CategoryTheory.Limits.WidePushoutShape.category.{u1} J)) (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J)
but is expected to have type
  forall (J : Type.{u1}), CategoryTheory.Equivalence.{u1, u1, u1, u1} (Opposite.{succ u1} (CategoryTheory.Limits.WidePushoutShape.{u1} J)) (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Category.opposite.{u1, u1} (CategoryTheory.Limits.WidePushoutShape.{u1} J) (CategoryTheory.Limits.WidePushoutShape.category.{u1} J)) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J)
Case conversion may be inaccurate. Consider using '#align category_theory.limits.wide_pushout_shape_op_equiv CategoryTheory.Limits.widePushoutShapeOpEquivâ‚“'. -/
/-- The duality equivalence `(wide_pushout_shape J)áµ’áµ– â‰Œ wide_pullback_shape J` -/
@[simps]
def widePushoutShapeOpEquiv : (WidePushoutShape J)áµ’áµ– â‰Œ WidePullbackShape J
    where
  Functor := widePushoutShapeUnop J
  inverse := widePullbackShapeOp J
  unitIso := (widePushoutShapeOpUnop J).symm
  counitIso := widePullbackShapeUnopOp J
#align category_theory.limits.wide_pushout_shape_op_equiv CategoryTheory.Limits.widePushoutShapeOpEquiv

/- warning: category_theory.limits.wide_pullback_shape_op_equiv -> CategoryTheory.Limits.widePullbackShapeOpEquiv is a dubious translation:
lean 3 declaration is
  forall (J : Type.{u1}), CategoryTheory.Equivalence.{u1, u1, u1, u1} (Opposite.{succ u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J)) (CategoryTheory.Category.opposite.{u1, u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J)) (CategoryTheory.Limits.WidePushoutShape.{u1} J) (CategoryTheory.Limits.WidePushoutShape.category.{u1} J)
but is expected to have type
  forall (J : Type.{u1}), CategoryTheory.Equivalence.{u1, u1, u1, u1} (Opposite.{succ u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J)) (CategoryTheory.Limits.WidePushoutShape.{u1} J) (CategoryTheory.Category.opposite.{u1, u1} (CategoryTheory.Limits.WidePullbackShape.{u1} J) (CategoryTheory.Limits.WidePullbackShape.category.{u1} J)) (CategoryTheory.Limits.WidePushoutShape.category.{u1} J)
Case conversion may be inaccurate. Consider using '#align category_theory.limits.wide_pullback_shape_op_equiv CategoryTheory.Limits.widePullbackShapeOpEquivâ‚“'. -/
/-- The duality equivalence `(wide_pullback_shape J)áµ’áµ– â‰Œ wide_pushout_shape J` -/
@[simps]
def widePullbackShapeOpEquiv : (WidePullbackShape J)áµ’áµ– â‰Œ WidePushoutShape J
    where
  Functor := widePullbackShapeUnop J
  inverse := widePushoutShapeOp J
  unitIso := (widePullbackShapeOpUnop J).symm
  counitIso := widePushoutShapeUnopOp J
#align category_theory.limits.wide_pullback_shape_op_equiv CategoryTheory.Limits.widePullbackShapeOpEquiv

#print CategoryTheory.Limits.hasWidePullbacks_shrink /-
/-- If a category has wide pullbacks on a higher universe level it also has wide pullbacks
on a lower universe level. -/
theorem hasWidePullbacks_shrink [HasWidePullbacks.{max w w'} C] : HasWidePullbacks.{w} C := fun J =>
  hasLimitsOfShape_of_equivalence (WidePullbackShape.equivalenceOfEquiv _ Equiv.ulift.{w'})
#align category_theory.limits.has_wide_pullbacks_shrink CategoryTheory.Limits.hasWidePullbacks_shrink
-/

end CategoryTheory.Limits

