/-
Copyright (c) 2020 Scott Morrison. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Scott Morrison

! This file was ported from Lean 3 source module category_theory.limits.filtered_colimit_commutes_finite_limit
! leanprover-community/mathlib commit f2b757fc5c341d88741b9c4630b1e8ba973c5726
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.CategoryTheory.Limits.ColimitLimit
import Mathbin.CategoryTheory.Limits.Preserves.FunctorCategory
import Mathbin.CategoryTheory.Limits.Preserves.Finite
import Mathbin.CategoryTheory.Limits.Shapes.FiniteLimits
import Mathbin.CategoryTheory.Limits.Preserves.Filtered
import Mathbin.CategoryTheory.ConcreteCategory.Basic

/-!
# Filtered colimits commute with finite limits.

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

We show that for a functor `F : J Ã— K â¥¤ Type v`, when `J` is finite and `K` is filtered,
the universal morphism `colimit_limit_to_limit_colimit F` comparing the
colimit (over `K`) of the limits (over `J`) with the limit of the colimits is an isomorphism.

(In fact, to prove that it is injective only requires that `J` has finitely many objects.)

## References
* Borceux, Handbook of categorical algebra 1, Theorem 2.13.4
* [Stacks: Filtered colimits](https://stacks.math.columbia.edu/tag/002W)
-/


universe v u

open CategoryTheory

open CategoryTheory.Category

open CategoryTheory.Limits.Types

open CategoryTheory.Limits.Types.FilteredColimit

namespace CategoryTheory.Limits

variable {J K : Type v} [SmallCategory J] [SmallCategory K]

variable (F : J Ã— K â¥¤ Type v)

open CategoryTheory.prod

variable [IsFiltered K]

section

/-!
Injectivity doesn't need that we have finitely many morphisms in `J`,
only that there are finitely many objects.
-/


variable [Finite J]

/- warning: category_theory.limits.colimit_limit_to_limit_colimit_injective -> CategoryTheory.Limits.colimitLimitToLimitColimit_injective is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u1}} {K : Type.{u1}} [_inst_1 : CategoryTheory.SmallCategory.{u1} J] [_inst_2 : CategoryTheory.SmallCategory.{u1} K] (F : CategoryTheory.Functor.{u1, u1, u1, succ u1} (Prod.{u1, u1} J K) (CategoryTheory.uniformProd.{u1, u1} J _inst_1 K _inst_2) Type.{u1} CategoryTheory.types.{u1}) [_inst_3 : CategoryTheory.IsFiltered.{u1, u1} K _inst_2] [_inst_4 : Finite.{succ u1} J], Function.Injective.{succ u1, succ u1} (CategoryTheory.Limits.colimit.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.Functor.comp.{u1, u1, u1, u1, succ u1, succ u1} K _inst_2 (CategoryTheory.Functor.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1}) Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.Functor.obj.{u1, u1, succ u1, succ u1} (CategoryTheory.Functor.{u1, u1, u1, succ u1} (Prod.{u1, u1} K J) (CategoryTheory.prod.{u1, u1, u1, u1} K _inst_2 J _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} (Prod.{u1, u1} K J) (CategoryTheory.prod.{u1, u1, u1, u1} K _inst_2 J _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.{u1, u1, u1, succ u1} K _inst_2 (CategoryTheory.Functor.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} K _inst_2 (CategoryTheory.Functor.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.curry.{u1, u1, u1, u1, u1, succ u1} K _inst_2 J _inst_1 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.comp.{u1, u1, u1, u1, u1, succ u1} (Prod.{u1, u1} K J) (CategoryTheory.prod.{u1, u1, u1, u1} K _inst_2 J _inst_1) (Prod.{u1, u1} J K) (CategoryTheory.prod.{u1, u1, u1, u1} J _inst_1 K _inst_2) Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.Prod.swap.{u1, u1, u1, u1} K _inst_2 J _inst_1) F)) (CategoryTheory.Limits.lim.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} Type.{u1} CategoryTheory.types.{u1} J _inst_1 CategoryTheory.Limits.Types.Sort.CategoryTheory.Limits.hasLimits.{u1}))) (CategoryTheory.Limits.colimitLimitToLimitColimit._proof_1.{succ u1, u1} J K _inst_1 _inst_2 Type.{u1} CategoryTheory.types.{u1} F (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} Type.{u1} CategoryTheory.types.{u1} J _inst_1 CategoryTheory.Limits.Types.Sort.CategoryTheory.Limits.hasLimits.{u1}) (CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize.{u1, u1, u1, succ u1} Type.{u1} CategoryTheory.types.{u1} K _inst_2 CategoryTheory.Limits.Types.Sort.CategoryTheory.Limits.hasColimits.{u1}))) (CategoryTheory.Limits.limit.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.Functor.comp.{u1, u1, u1, u1, succ u1, succ u1} J _inst_1 (CategoryTheory.Functor.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1}) Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.Functor.obj.{u1, u1, succ u1, succ u1} (CategoryTheory.Functor.{u1, u1, u1, succ u1} (Prod.{u1, u1} J K) (CategoryTheory.prod.{u1, u1, u1, u1} J _inst_1 K _inst_2) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} (Prod.{u1, u1} J K) (CategoryTheory.prod.{u1, u1, u1, u1} J _inst_1 K _inst_2) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.{u1, u1, u1, succ u1} J _inst_1 (CategoryTheory.Functor.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} J _inst_1 (CategoryTheory.Functor.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.curry.{u1, u1, u1, u1, u1, succ u1} J _inst_1 K _inst_2 Type.{u1} CategoryTheory.types.{u1}) F) (CategoryTheory.Limits.colim.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize.{u1, u1, u1, succ u1} Type.{u1} CategoryTheory.types.{u1} K _inst_2 CategoryTheory.Limits.Types.Sort.CategoryTheory.Limits.hasColimits.{u1}))) (CategoryTheory.Limits.colimitLimitToLimitColimit._proof_2.{succ u1, u1} J K _inst_1 _inst_2 Type.{u1} CategoryTheory.types.{u1} F (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} Type.{u1} CategoryTheory.types.{u1} J _inst_1 CategoryTheory.Limits.Types.Sort.CategoryTheory.Limits.hasLimits.{u1}) (CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize.{u1, u1, u1, succ u1} Type.{u1} CategoryTheory.types.{u1} K _inst_2 CategoryTheory.Limits.Types.Sort.CategoryTheory.Limits.hasColimits.{u1}))) (CategoryTheory.Limits.colimitLimitToLimitColimit.{u1, succ u1} J K _inst_1 _inst_2 Type.{u1} CategoryTheory.types.{u1} F (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} Type.{u1} CategoryTheory.types.{u1} J _inst_1 CategoryTheory.Limits.Types.Sort.CategoryTheory.Limits.hasLimits.{u1}) (CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize.{u1, u1, u1, succ u1} Type.{u1} CategoryTheory.types.{u1} K _inst_2 CategoryTheory.Limits.Types.Sort.CategoryTheory.Limits.hasColimits.{u1}))
but is expected to have type
  forall {J : Type.{u1}} {K : Type.{u1}} [_inst_1 : CategoryTheory.SmallCategory.{u1} J] [_inst_2 : CategoryTheory.SmallCategory.{u1} K] (F : CategoryTheory.Functor.{u1, u1, u1, succ u1} (Prod.{u1, u1} J K) (CategoryTheory.uniformProd.{u1, u1} J _inst_1 K _inst_2) Type.{u1} CategoryTheory.types.{u1}) [_inst_3 : CategoryTheory.IsFiltered.{u1, u1} K _inst_2] [_inst_4 : Finite.{succ u1} J], Function.Injective.{succ u1, succ u1} (CategoryTheory.Limits.colimit.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.Functor.comp.{u1, u1, u1, u1, succ u1, succ u1} K _inst_2 (CategoryTheory.Functor.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1}) Type.{u1} CategoryTheory.types.{u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} (CategoryTheory.Functor.{u1, u1, u1, succ u1} (Prod.{u1, u1} K J) (CategoryTheory.prod.{u1, u1, u1, u1} K _inst_2 J _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} (CategoryTheory.Functor.{u1, u1, u1, succ u1} (Prod.{u1, u1} K J) (CategoryTheory.prod.{u1, u1, u1, u1} K _inst_2 J _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} (CategoryTheory.Functor.{u1, u1, u1, succ u1} (Prod.{u1, u1} K J) (CategoryTheory.prod.{u1, u1, u1, u1} K _inst_2 J _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} (Prod.{u1, u1} K J) (CategoryTheory.prod.{u1, u1, u1, u1} K _inst_2 J _inst_1) Type.{u1} CategoryTheory.types.{u1}))) (CategoryTheory.Functor.{u1, u1, u1, succ u1} K _inst_2 (CategoryTheory.Functor.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} (CategoryTheory.Functor.{u1, u1, u1, succ u1} K _inst_2 (CategoryTheory.Functor.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} (CategoryTheory.Functor.{u1, u1, u1, succ u1} K _inst_2 (CategoryTheory.Functor.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} K _inst_2 (CategoryTheory.Functor.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1})))) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} (CategoryTheory.Functor.{u1, u1, u1, succ u1} (Prod.{u1, u1} K J) (CategoryTheory.prod.{u1, u1, u1, u1} K _inst_2 J _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} (Prod.{u1, u1} K J) (CategoryTheory.prod.{u1, u1, u1, u1} K _inst_2 J _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.{u1, u1, u1, succ u1} K _inst_2 (CategoryTheory.Functor.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} K _inst_2 (CategoryTheory.Functor.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.curry.{u1, u1, u1, u1, u1, succ u1} K _inst_2 J _inst_1 Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.comp.{u1, u1, u1, u1, u1, succ u1} (Prod.{u1, u1} K J) (CategoryTheory.prod.{u1, u1, u1, u1} K _inst_2 J _inst_1) (Prod.{u1, u1} J K) (CategoryTheory.prod.{u1, u1, u1, u1} J _inst_1 K _inst_2) Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.Prod.swap.{u1, u1, u1, u1} K _inst_2 J _inst_1) F)) (CategoryTheory.Limits.lim.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} Type.{u1} CategoryTheory.types.{u1} J _inst_1 CategoryTheory.Limits.Types.instHasLimitsTypeTypes.{u1}))) (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u1, u1, u1, succ u1} Type.{u1} CategoryTheory.types.{u1} K _inst_2 (CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize.{u1, u1, u1, succ u1} Type.{u1} CategoryTheory.types.{u1} K _inst_2 CategoryTheory.Limits.Types.instHasColimitsTypeTypes.{u1}) (CategoryTheory.Functor.comp.{u1, u1, u1, u1, succ u1, succ u1} K _inst_2 (CategoryTheory.Functor.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1}) Type.{u1} CategoryTheory.types.{u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} (CategoryTheory.Functor.{u1, u1, u1, succ u1} (Prod.{u1, u1} K J) (CategoryTheory.prod.{u1, u1, u1, u1} K _inst_2 J _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} (CategoryTheory.Functor.{u1, u1, u1, succ u1} (Prod.{u1, u1} K J) (CategoryTheory.prod.{u1, u1, u1, u1} K _inst_2 J _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} (CategoryTheory.Functor.{u1, u1, u1, succ u1} (Prod.{u1, u1} K J) (CategoryTheory.prod.{u1, u1, u1, u1} K _inst_2 J _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} (Prod.{u1, u1} K J) (CategoryTheory.prod.{u1, u1, u1, u1} K _inst_2 J _inst_1) Type.{u1} CategoryTheory.types.{u1}))) (CategoryTheory.Functor.{u1, u1, u1, succ u1} K _inst_2 (CategoryTheory.Functor.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} (CategoryTheory.Functor.{u1, u1, u1, succ u1} K _inst_2 (CategoryTheory.Functor.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} (CategoryTheory.Functor.{u1, u1, u1, succ u1} K _inst_2 (CategoryTheory.Functor.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} K _inst_2 (CategoryTheory.Functor.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1})))) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} (CategoryTheory.Functor.{u1, u1, u1, succ u1} (Prod.{u1, u1} K J) (CategoryTheory.prod.{u1, u1, u1, u1} K _inst_2 J _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} (Prod.{u1, u1} K J) (CategoryTheory.prod.{u1, u1, u1, u1} K _inst_2 J _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.{u1, u1, u1, succ u1} K _inst_2 (CategoryTheory.Functor.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} K _inst_2 (CategoryTheory.Functor.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.curry.{u1, u1, u1, u1, u1, succ u1} K _inst_2 J _inst_1 Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.comp.{u1, u1, u1, u1, u1, succ u1} (Prod.{u1, u1} K J) (CategoryTheory.prod.{u1, u1, u1, u1} K _inst_2 J _inst_1) (Prod.{u1, u1} J K) (CategoryTheory.prod.{u1, u1, u1, u1} J _inst_1 K _inst_2) Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.Prod.swap.{u1, u1, u1, u1} K _inst_2 J _inst_1) F)) (CategoryTheory.Limits.lim.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} Type.{u1} CategoryTheory.types.{u1} J _inst_1 CategoryTheory.Limits.Types.instHasLimitsTypeTypes.{u1}))))) (CategoryTheory.Limits.limit.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.Functor.comp.{u1, u1, u1, u1, succ u1, succ u1} J _inst_1 (CategoryTheory.Functor.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1}) Type.{u1} CategoryTheory.types.{u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} (CategoryTheory.Functor.{u1, u1, u1, succ u1} (Prod.{u1, u1} J K) (CategoryTheory.prod.{u1, u1, u1, u1} J _inst_1 K _inst_2) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} (CategoryTheory.Functor.{u1, u1, u1, succ u1} (Prod.{u1, u1} J K) (CategoryTheory.prod.{u1, u1, u1, u1} J _inst_1 K _inst_2) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} (CategoryTheory.Functor.{u1, u1, u1, succ u1} (Prod.{u1, u1} J K) (CategoryTheory.prod.{u1, u1, u1, u1} J _inst_1 K _inst_2) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} (Prod.{u1, u1} J K) (CategoryTheory.prod.{u1, u1, u1, u1} J _inst_1 K _inst_2) Type.{u1} CategoryTheory.types.{u1}))) (CategoryTheory.Functor.{u1, u1, u1, succ u1} J _inst_1 (CategoryTheory.Functor.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} (CategoryTheory.Functor.{u1, u1, u1, succ u1} J _inst_1 (CategoryTheory.Functor.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} (CategoryTheory.Functor.{u1, u1, u1, succ u1} J _inst_1 (CategoryTheory.Functor.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} J _inst_1 (CategoryTheory.Functor.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1})))) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} (CategoryTheory.Functor.{u1, u1, u1, succ u1} (Prod.{u1, u1} J K) (CategoryTheory.prod.{u1, u1, u1, u1} J _inst_1 K _inst_2) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} (Prod.{u1, u1} J K) (CategoryTheory.prod.{u1, u1, u1, u1} J _inst_1 K _inst_2) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.{u1, u1, u1, succ u1} J _inst_1 (CategoryTheory.Functor.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} J _inst_1 (CategoryTheory.Functor.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.curry.{u1, u1, u1, u1, u1, succ u1} J _inst_1 K _inst_2 Type.{u1} CategoryTheory.types.{u1})) F) (CategoryTheory.Limits.colim.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize.{u1, u1, u1, succ u1} Type.{u1} CategoryTheory.types.{u1} K _inst_2 CategoryTheory.Limits.Types.instHasColimitsTypeTypes.{u1}))) (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u1, u1, succ u1} Type.{u1} CategoryTheory.types.{u1} J _inst_1 (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} Type.{u1} CategoryTheory.types.{u1} J _inst_1 CategoryTheory.Limits.Types.instHasLimitsTypeTypes.{u1}) (CategoryTheory.Functor.comp.{u1, u1, u1, u1, succ u1, succ u1} J _inst_1 (CategoryTheory.Functor.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1}) Type.{u1} CategoryTheory.types.{u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} (CategoryTheory.Functor.{u1, u1, u1, succ u1} (Prod.{u1, u1} J K) (CategoryTheory.prod.{u1, u1, u1, u1} J _inst_1 K _inst_2) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} (CategoryTheory.Functor.{u1, u1, u1, succ u1} (Prod.{u1, u1} J K) (CategoryTheory.prod.{u1, u1, u1, u1} J _inst_1 K _inst_2) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} (CategoryTheory.Functor.{u1, u1, u1, succ u1} (Prod.{u1, u1} J K) (CategoryTheory.prod.{u1, u1, u1, u1} J _inst_1 K _inst_2) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} (Prod.{u1, u1} J K) (CategoryTheory.prod.{u1, u1, u1, u1} J _inst_1 K _inst_2) Type.{u1} CategoryTheory.types.{u1}))) (CategoryTheory.Functor.{u1, u1, u1, succ u1} J _inst_1 (CategoryTheory.Functor.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} (CategoryTheory.Functor.{u1, u1, u1, succ u1} J _inst_1 (CategoryTheory.Functor.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} (CategoryTheory.Functor.{u1, u1, u1, succ u1} J _inst_1 (CategoryTheory.Functor.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} J _inst_1 (CategoryTheory.Functor.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1})))) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} (CategoryTheory.Functor.{u1, u1, u1, succ u1} (Prod.{u1, u1} J K) (CategoryTheory.prod.{u1, u1, u1, u1} J _inst_1 K _inst_2) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} (Prod.{u1, u1} J K) (CategoryTheory.prod.{u1, u1, u1, u1} J _inst_1 K _inst_2) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.{u1, u1, u1, succ u1} J _inst_1 (CategoryTheory.Functor.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} J _inst_1 (CategoryTheory.Functor.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.curry.{u1, u1, u1, u1, u1, succ u1} J _inst_1 K _inst_2 Type.{u1} CategoryTheory.types.{u1})) F) (CategoryTheory.Limits.colim.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize.{u1, u1, u1, succ u1} Type.{u1} CategoryTheory.types.{u1} K _inst_2 CategoryTheory.Limits.Types.instHasColimitsTypeTypes.{u1}))))) (CategoryTheory.Limits.colimitLimitToLimitColimit.{u1, succ u1} J K _inst_1 _inst_2 Type.{u1} CategoryTheory.types.{u1} F (CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits.{u1, u1, u1, succ u1} Type.{u1} CategoryTheory.types.{u1} J _inst_1 CategoryTheory.Limits.Types.instHasLimitsTypeTypes.{u1}) (CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize.{u1, u1, u1, succ u1} Type.{u1} CategoryTheory.types.{u1} K _inst_2 CategoryTheory.Limits.Types.instHasColimitsTypeTypes.{u1}))
Case conversion may be inaccurate. Consider using '#align category_theory.limits.colimit_limit_to_limit_colimit_injective CategoryTheory.Limits.colimitLimitToLimitColimit_injectiveâ‚“'. -/
/-- This follows this proof from
* Borceux, Handbook of categorical algebra 1, Theorem 2.13.4
-/
theorem colimitLimitToLimitColimit_injective : Function.Injective (colimitLimitToLimitColimit F) :=
  by
  classical
    cases nonempty_fintype J
    -- Suppose we have two terms `x y` in the colimit (over `K`) of the limits (over `J`),
    -- and that these have the same image under `colimit_limit_to_limit_colimit F`.
    intro x y h
    -- These elements of the colimit have representatives somewhere:
    obtain âŸ¨kx, x, rflâŸ© := jointly_surjective'.{v, v} x
    obtain âŸ¨ky, y, rflâŸ© := jointly_surjective'.{v, v} y
    dsimp at x y
    -- Since the images of `x` and `y` are equal in a limit, they are equal componentwise
    -- (indexed by `j : J`),
    replace h := fun j => congr_arg (limit.Ï€ (curry.obj F â‹™ colim) j) h
    -- and they are equations in a filtered colimit,
    -- so for each `j` we have some place `k j` to the right of both `kx` and `ky`
    simp [colimit_eq_iff.{v, v}] at h
    let k j := (h j).some
    let f : âˆ€ j, kx âŸ¶ k j := fun j => (h j).choose_spec.some
    let g : âˆ€ j, ky âŸ¶ k j := fun j => (h j).choose_spec.choose_spec.some
    -- where the images of the components of the representatives become equal:
    have w :
      âˆ€ j,
        F.map ((ðŸ™ j, f j) : (j, kx) âŸ¶ (j, k j)) (limit.Ï€ ((curry.obj (swap K J â‹™ F)).obj kx) j x) =
          F.map ((ðŸ™ j, g j) : (j, ky) âŸ¶ (j, k j))
            (limit.Ï€ ((curry.obj (swap K J â‹™ F)).obj ky) j y) :=
      fun j => (h j).choose_spec.choose_spec.choose_spec
    -- We now use that `K` is filtered, picking some point to the right of all these
    -- morphisms `f j` and `g j`.
    let O : Finset K := finset.univ.image k âˆª {kx, ky}
    have kxO : kx âˆˆ O := finset.mem_union.mpr (Or.inr (by simp))
    have kyO : ky âˆˆ O := finset.mem_union.mpr (Or.inr (by simp))
    have kjO : âˆ€ j, k j âˆˆ O := fun j => finset.mem_union.mpr (Or.inl (by simp))
    let H : Finset (Î£'(X Y : K)(mX : X âˆˆ O)(mY : Y âˆˆ O), X âŸ¶ Y) :=
      (Finset.univ.image fun j : J =>
          âŸ¨kx, k j, kxO, finset.mem_union.mpr (Or.inl (by simp)), f jâŸ©) âˆª
        Finset.univ.image fun j : J => âŸ¨ky, k j, kyO, finset.mem_union.mpr (Or.inl (by simp)), g jâŸ©
    obtain âŸ¨S, T, WâŸ© := is_filtered.sup_exists O H
    have fH : âˆ€ j, (âŸ¨kx, k j, kxO, kjO j, f jâŸ© : Î£'(X Y : K)(mX : X âˆˆ O)(mY : Y âˆˆ O), X âŸ¶ Y) âˆˆ H :=
      fun j =>
      finset.mem_union.mpr
        (Or.inl
          (by
            simp only [true_and_iff, Finset.mem_univ, eq_self_iff_true, exists_prop_of_true,
              Finset.mem_image, heq_iff_eq]
            refine' âŸ¨j, rfl, _âŸ©
            simp only [heq_iff_eq]
            exact âŸ¨rfl, rfl, rflâŸ©))
    have gH : âˆ€ j, (âŸ¨ky, k j, kyO, kjO j, g jâŸ© : Î£'(X Y : K)(mX : X âˆˆ O)(mY : Y âˆˆ O), X âŸ¶ Y) âˆˆ H :=
      fun j =>
      finset.mem_union.mpr
        (Or.inr
          (by
            simp only [true_and_iff, Finset.mem_univ, eq_self_iff_true, exists_prop_of_true,
              Finset.mem_image, heq_iff_eq]
            refine' âŸ¨j, rfl, _âŸ©
            simp only [heq_iff_eq]
            exact âŸ¨rfl, rfl, rflâŸ©))
    -- Our goal is now an equation between equivalence classes of representatives of a colimit,
    -- and so it suffices to show those representative become equal somewhere, in particular at `S`.
    apply colimit_sound'.{v, v} (T kxO) (T kyO)
    -- We can check if two elements of a limit (in `Type`) are equal by comparing them componentwise.
    ext
    -- Now it's just a calculation using `W` and `w`.
    simp only [functor.comp_map, limit.map_Ï€_apply, curry_obj_map_app, swap_map]
    rw [â† W _ _ (fH j)]
    rw [â† W _ _ (gH j)]
    simp [w]
#align category_theory.limits.colimit_limit_to_limit_colimit_injective CategoryTheory.Limits.colimitLimitToLimitColimit_injective

end

variable [FinCategory J]

/- warning: category_theory.limits.colimit_limit_to_limit_colimit_surjective -> CategoryTheory.Limits.colimitLimitToLimitColimit_surjective is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u1}} {K : Type.{u1}} [_inst_1 : CategoryTheory.SmallCategory.{u1} J] [_inst_2 : CategoryTheory.SmallCategory.{u1} K] (F : CategoryTheory.Functor.{u1, u1, u1, succ u1} (Prod.{u1, u1} J K) (CategoryTheory.uniformProd.{u1, u1} J _inst_1 K _inst_2) Type.{u1} CategoryTheory.types.{u1}) [_inst_3 : CategoryTheory.IsFiltered.{u1, u1} K _inst_2] [_inst_4 : CategoryTheory.FinCategory.{u1} J _inst_1], Function.Surjective.{succ u1, succ u1} (CategoryTheory.Limits.colimit.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.Functor.comp.{u1, u1, u1, u1, succ u1, succ u1} K _inst_2 (CategoryTheory.Functor.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1}) Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.Functor.obj.{u1, u1, succ u1, succ u1} (CategoryTheory.Functor.{u1, u1, u1, succ u1} (Prod.{u1, u1} K J) (CategoryTheory.prod.{u1, u1, u1, u1} K _inst_2 J _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} (Prod.{u1, u1} K J) (CategoryTheory.prod.{u1, u1, u1, u1} K _inst_2 J _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.{u1, u1, u1, succ u1} K _inst_2 (CategoryTheory.Functor.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} K _inst_2 (CategoryTheory.Functor.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.curry.{u1, u1, u1, u1, u1, succ u1} K _inst_2 J _inst_1 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.comp.{u1, u1, u1, u1, u1, succ u1} (Prod.{u1, u1} K J) (CategoryTheory.prod.{u1, u1, u1, u1} K _inst_2 J _inst_1) (Prod.{u1, u1} J K) (CategoryTheory.prod.{u1, u1, u1, u1} J _inst_1 K _inst_2) Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.Prod.swap.{u1, u1, u1, u1} K _inst_2 J _inst_1) F)) (CategoryTheory.Limits.lim.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.Limits.hasLimitsOfShape_of_hasFiniteLimits.{u1, u1, succ u1} Type.{u1} CategoryTheory.types.{u1} J _inst_1 _inst_4 (CategoryTheory.Limits.hasFiniteLimits_of_hasLimits.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1} CategoryTheory.Limits.Types.Sort.CategoryTheory.Limits.hasLimits.{u1})))) (CategoryTheory.Limits.colimitLimitToLimitColimit._proof_1.{succ u1, u1} J K _inst_1 _inst_2 Type.{u1} CategoryTheory.types.{u1} F (CategoryTheory.Limits.hasLimitsOfShape_of_hasFiniteLimits.{u1, u1, succ u1} Type.{u1} CategoryTheory.types.{u1} J _inst_1 _inst_4 (CategoryTheory.Limits.hasFiniteLimits_of_hasLimits.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1} CategoryTheory.Limits.Types.Sort.CategoryTheory.Limits.hasLimits.{u1})) (CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize.{u1, u1, u1, succ u1} Type.{u1} CategoryTheory.types.{u1} K _inst_2 CategoryTheory.Limits.Types.Sort.CategoryTheory.Limits.hasColimits.{u1}))) (CategoryTheory.Limits.limit.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.Functor.comp.{u1, u1, u1, u1, succ u1, succ u1} J _inst_1 (CategoryTheory.Functor.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1}) Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.Functor.obj.{u1, u1, succ u1, succ u1} (CategoryTheory.Functor.{u1, u1, u1, succ u1} (Prod.{u1, u1} J K) (CategoryTheory.prod.{u1, u1, u1, u1} J _inst_1 K _inst_2) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} (Prod.{u1, u1} J K) (CategoryTheory.prod.{u1, u1, u1, u1} J _inst_1 K _inst_2) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.{u1, u1, u1, succ u1} J _inst_1 (CategoryTheory.Functor.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} J _inst_1 (CategoryTheory.Functor.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.curry.{u1, u1, u1, u1, u1, succ u1} J _inst_1 K _inst_2 Type.{u1} CategoryTheory.types.{u1}) F) (CategoryTheory.Limits.colim.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize.{u1, u1, u1, succ u1} Type.{u1} CategoryTheory.types.{u1} K _inst_2 CategoryTheory.Limits.Types.Sort.CategoryTheory.Limits.hasColimits.{u1}))) (CategoryTheory.Limits.colimitLimitToLimitColimit._proof_2.{succ u1, u1} J K _inst_1 _inst_2 Type.{u1} CategoryTheory.types.{u1} F (CategoryTheory.Limits.hasLimitsOfShape_of_hasFiniteLimits.{u1, u1, succ u1} Type.{u1} CategoryTheory.types.{u1} J _inst_1 _inst_4 (CategoryTheory.Limits.hasFiniteLimits_of_hasLimits.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1} CategoryTheory.Limits.Types.Sort.CategoryTheory.Limits.hasLimits.{u1})) (CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize.{u1, u1, u1, succ u1} Type.{u1} CategoryTheory.types.{u1} K _inst_2 CategoryTheory.Limits.Types.Sort.CategoryTheory.Limits.hasColimits.{u1}))) (CategoryTheory.Limits.colimitLimitToLimitColimit.{u1, succ u1} J K _inst_1 _inst_2 Type.{u1} CategoryTheory.types.{u1} F (CategoryTheory.Limits.hasLimitsOfShape_of_hasFiniteLimits.{u1, u1, succ u1} Type.{u1} CategoryTheory.types.{u1} J _inst_1 _inst_4 (CategoryTheory.Limits.hasFiniteLimits_of_hasLimits.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1} CategoryTheory.Limits.Types.Sort.CategoryTheory.Limits.hasLimits.{u1})) (CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize.{u1, u1, u1, succ u1} Type.{u1} CategoryTheory.types.{u1} K _inst_2 CategoryTheory.Limits.Types.Sort.CategoryTheory.Limits.hasColimits.{u1}))
but is expected to have type
  forall {J : Type.{u1}} {K : Type.{u1}} [_inst_1 : CategoryTheory.SmallCategory.{u1} J] [_inst_2 : CategoryTheory.SmallCategory.{u1} K] (F : CategoryTheory.Functor.{u1, u1, u1, succ u1} (Prod.{u1, u1} J K) (CategoryTheory.uniformProd.{u1, u1} J _inst_1 K _inst_2) Type.{u1} CategoryTheory.types.{u1}) [_inst_3 : CategoryTheory.IsFiltered.{u1, u1} K _inst_2] [_inst_4 : CategoryTheory.FinCategory.{u1} J _inst_1], Function.Surjective.{succ u1, succ u1} (CategoryTheory.Limits.colimit.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.Functor.comp.{u1, u1, u1, u1, succ u1, succ u1} K _inst_2 (CategoryTheory.Functor.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1}) Type.{u1} CategoryTheory.types.{u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} (CategoryTheory.Functor.{u1, u1, u1, succ u1} (Prod.{u1, u1} K J) (CategoryTheory.prod.{u1, u1, u1, u1} K _inst_2 J _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} (CategoryTheory.Functor.{u1, u1, u1, succ u1} (Prod.{u1, u1} K J) (CategoryTheory.prod.{u1, u1, u1, u1} K _inst_2 J _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} (CategoryTheory.Functor.{u1, u1, u1, succ u1} (Prod.{u1, u1} K J) (CategoryTheory.prod.{u1, u1, u1, u1} K _inst_2 J _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} (Prod.{u1, u1} K J) (CategoryTheory.prod.{u1, u1, u1, u1} K _inst_2 J _inst_1) Type.{u1} CategoryTheory.types.{u1}))) (CategoryTheory.Functor.{u1, u1, u1, succ u1} K _inst_2 (CategoryTheory.Functor.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} (CategoryTheory.Functor.{u1, u1, u1, succ u1} K _inst_2 (CategoryTheory.Functor.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} (CategoryTheory.Functor.{u1, u1, u1, succ u1} K _inst_2 (CategoryTheory.Functor.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} K _inst_2 (CategoryTheory.Functor.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1})))) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} (CategoryTheory.Functor.{u1, u1, u1, succ u1} (Prod.{u1, u1} K J) (CategoryTheory.prod.{u1, u1, u1, u1} K _inst_2 J _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} (Prod.{u1, u1} K J) (CategoryTheory.prod.{u1, u1, u1, u1} K _inst_2 J _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.{u1, u1, u1, succ u1} K _inst_2 (CategoryTheory.Functor.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} K _inst_2 (CategoryTheory.Functor.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.curry.{u1, u1, u1, u1, u1, succ u1} K _inst_2 J _inst_1 Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.comp.{u1, u1, u1, u1, u1, succ u1} (Prod.{u1, u1} K J) (CategoryTheory.prod.{u1, u1, u1, u1} K _inst_2 J _inst_1) (Prod.{u1, u1} J K) (CategoryTheory.prod.{u1, u1, u1, u1} J _inst_1 K _inst_2) Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.Prod.swap.{u1, u1, u1, u1} K _inst_2 J _inst_1) F)) (CategoryTheory.Limits.lim.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.Limits.hasLimitsOfShape_of_hasFiniteLimits.{u1, u1, succ u1} Type.{u1} CategoryTheory.types.{u1} J _inst_1 _inst_4 (CategoryTheory.Limits.hasFiniteLimits_of_hasLimits.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1} CategoryTheory.Limits.Types.instHasLimitsTypeTypes.{u1})))) (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u1, u1, u1, succ u1} Type.{u1} CategoryTheory.types.{u1} K _inst_2 (CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize.{u1, u1, u1, succ u1} Type.{u1} CategoryTheory.types.{u1} K _inst_2 CategoryTheory.Limits.Types.instHasColimitsTypeTypes.{u1}) (CategoryTheory.Functor.comp.{u1, u1, u1, u1, succ u1, succ u1} K _inst_2 (CategoryTheory.Functor.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1}) Type.{u1} CategoryTheory.types.{u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} (CategoryTheory.Functor.{u1, u1, u1, succ u1} (Prod.{u1, u1} K J) (CategoryTheory.prod.{u1, u1, u1, u1} K _inst_2 J _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} (CategoryTheory.Functor.{u1, u1, u1, succ u1} (Prod.{u1, u1} K J) (CategoryTheory.prod.{u1, u1, u1, u1} K _inst_2 J _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} (CategoryTheory.Functor.{u1, u1, u1, succ u1} (Prod.{u1, u1} K J) (CategoryTheory.prod.{u1, u1, u1, u1} K _inst_2 J _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} (Prod.{u1, u1} K J) (CategoryTheory.prod.{u1, u1, u1, u1} K _inst_2 J _inst_1) Type.{u1} CategoryTheory.types.{u1}))) (CategoryTheory.Functor.{u1, u1, u1, succ u1} K _inst_2 (CategoryTheory.Functor.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} (CategoryTheory.Functor.{u1, u1, u1, succ u1} K _inst_2 (CategoryTheory.Functor.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} (CategoryTheory.Functor.{u1, u1, u1, succ u1} K _inst_2 (CategoryTheory.Functor.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} K _inst_2 (CategoryTheory.Functor.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1})))) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} (CategoryTheory.Functor.{u1, u1, u1, succ u1} (Prod.{u1, u1} K J) (CategoryTheory.prod.{u1, u1, u1, u1} K _inst_2 J _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} (Prod.{u1, u1} K J) (CategoryTheory.prod.{u1, u1, u1, u1} K _inst_2 J _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.{u1, u1, u1, succ u1} K _inst_2 (CategoryTheory.Functor.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} K _inst_2 (CategoryTheory.Functor.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.curry.{u1, u1, u1, u1, u1, succ u1} K _inst_2 J _inst_1 Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.comp.{u1, u1, u1, u1, u1, succ u1} (Prod.{u1, u1} K J) (CategoryTheory.prod.{u1, u1, u1, u1} K _inst_2 J _inst_1) (Prod.{u1, u1} J K) (CategoryTheory.prod.{u1, u1, u1, u1} J _inst_1 K _inst_2) Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.Prod.swap.{u1, u1, u1, u1} K _inst_2 J _inst_1) F)) (CategoryTheory.Limits.lim.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.Limits.hasLimitsOfShape_of_hasFiniteLimits.{u1, u1, succ u1} Type.{u1} CategoryTheory.types.{u1} J _inst_1 _inst_4 (CategoryTheory.Limits.hasFiniteLimits_of_hasLimits.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1} CategoryTheory.Limits.Types.instHasLimitsTypeTypes.{u1})))))) (CategoryTheory.Limits.limit.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.Functor.comp.{u1, u1, u1, u1, succ u1, succ u1} J _inst_1 (CategoryTheory.Functor.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1}) Type.{u1} CategoryTheory.types.{u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} (CategoryTheory.Functor.{u1, u1, u1, succ u1} (Prod.{u1, u1} J K) (CategoryTheory.prod.{u1, u1, u1, u1} J _inst_1 K _inst_2) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} (CategoryTheory.Functor.{u1, u1, u1, succ u1} (Prod.{u1, u1} J K) (CategoryTheory.prod.{u1, u1, u1, u1} J _inst_1 K _inst_2) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} (CategoryTheory.Functor.{u1, u1, u1, succ u1} (Prod.{u1, u1} J K) (CategoryTheory.prod.{u1, u1, u1, u1} J _inst_1 K _inst_2) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} (Prod.{u1, u1} J K) (CategoryTheory.prod.{u1, u1, u1, u1} J _inst_1 K _inst_2) Type.{u1} CategoryTheory.types.{u1}))) (CategoryTheory.Functor.{u1, u1, u1, succ u1} J _inst_1 (CategoryTheory.Functor.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} (CategoryTheory.Functor.{u1, u1, u1, succ u1} J _inst_1 (CategoryTheory.Functor.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} (CategoryTheory.Functor.{u1, u1, u1, succ u1} J _inst_1 (CategoryTheory.Functor.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} J _inst_1 (CategoryTheory.Functor.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1})))) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} (CategoryTheory.Functor.{u1, u1, u1, succ u1} (Prod.{u1, u1} J K) (CategoryTheory.prod.{u1, u1, u1, u1} J _inst_1 K _inst_2) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} (Prod.{u1, u1} J K) (CategoryTheory.prod.{u1, u1, u1, u1} J _inst_1 K _inst_2) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.{u1, u1, u1, succ u1} J _inst_1 (CategoryTheory.Functor.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} J _inst_1 (CategoryTheory.Functor.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.curry.{u1, u1, u1, u1, u1, succ u1} J _inst_1 K _inst_2 Type.{u1} CategoryTheory.types.{u1})) F) (CategoryTheory.Limits.colim.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize.{u1, u1, u1, succ u1} Type.{u1} CategoryTheory.types.{u1} K _inst_2 CategoryTheory.Limits.Types.instHasColimitsTypeTypes.{u1}))) (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u1, u1, succ u1} Type.{u1} CategoryTheory.types.{u1} J _inst_1 (CategoryTheory.Limits.hasLimitsOfShape_of_hasFiniteLimits.{u1, u1, succ u1} Type.{u1} CategoryTheory.types.{u1} J _inst_1 _inst_4 (CategoryTheory.Limits.hasFiniteLimits_of_hasLimits.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1} CategoryTheory.Limits.Types.instHasLimitsTypeTypes.{u1})) (CategoryTheory.Functor.comp.{u1, u1, u1, u1, succ u1, succ u1} J _inst_1 (CategoryTheory.Functor.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1}) Type.{u1} CategoryTheory.types.{u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} (CategoryTheory.Functor.{u1, u1, u1, succ u1} (Prod.{u1, u1} J K) (CategoryTheory.prod.{u1, u1, u1, u1} J _inst_1 K _inst_2) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} (CategoryTheory.Functor.{u1, u1, u1, succ u1} (Prod.{u1, u1} J K) (CategoryTheory.prod.{u1, u1, u1, u1} J _inst_1 K _inst_2) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} (CategoryTheory.Functor.{u1, u1, u1, succ u1} (Prod.{u1, u1} J K) (CategoryTheory.prod.{u1, u1, u1, u1} J _inst_1 K _inst_2) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} (Prod.{u1, u1} J K) (CategoryTheory.prod.{u1, u1, u1, u1} J _inst_1 K _inst_2) Type.{u1} CategoryTheory.types.{u1}))) (CategoryTheory.Functor.{u1, u1, u1, succ u1} J _inst_1 (CategoryTheory.Functor.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} (CategoryTheory.Functor.{u1, u1, u1, succ u1} J _inst_1 (CategoryTheory.Functor.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} (CategoryTheory.Functor.{u1, u1, u1, succ u1} J _inst_1 (CategoryTheory.Functor.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} J _inst_1 (CategoryTheory.Functor.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1})))) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} (CategoryTheory.Functor.{u1, u1, u1, succ u1} (Prod.{u1, u1} J K) (CategoryTheory.prod.{u1, u1, u1, u1} J _inst_1 K _inst_2) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} (Prod.{u1, u1} J K) (CategoryTheory.prod.{u1, u1, u1, u1} J _inst_1 K _inst_2) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.{u1, u1, u1, succ u1} J _inst_1 (CategoryTheory.Functor.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} J _inst_1 (CategoryTheory.Functor.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.curry.{u1, u1, u1, u1, u1, succ u1} J _inst_1 K _inst_2 Type.{u1} CategoryTheory.types.{u1})) F) (CategoryTheory.Limits.colim.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize.{u1, u1, u1, succ u1} Type.{u1} CategoryTheory.types.{u1} K _inst_2 CategoryTheory.Limits.Types.instHasColimitsTypeTypes.{u1}))))) (CategoryTheory.Limits.colimitLimitToLimitColimit.{u1, succ u1} J K _inst_1 _inst_2 Type.{u1} CategoryTheory.types.{u1} F (CategoryTheory.Limits.hasLimitsOfShape_of_hasFiniteLimits.{u1, u1, succ u1} Type.{u1} CategoryTheory.types.{u1} J _inst_1 _inst_4 (CategoryTheory.Limits.hasFiniteLimits_of_hasLimits.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1} CategoryTheory.Limits.Types.instHasLimitsTypeTypes.{u1})) (CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize.{u1, u1, u1, succ u1} Type.{u1} CategoryTheory.types.{u1} K _inst_2 CategoryTheory.Limits.Types.instHasColimitsTypeTypes.{u1}))
Case conversion may be inaccurate. Consider using '#align category_theory.limits.colimit_limit_to_limit_colimit_surjective CategoryTheory.Limits.colimitLimitToLimitColimit_surjectiveâ‚“'. -/
/-- This follows this proof from
* Borceux, Handbook of categorical algebra 1, Theorem 2.13.4
although with different names.
-/
theorem colimitLimitToLimitColimit_surjective :
    Function.Surjective (colimitLimitToLimitColimit F) := by
  classical
    -- We begin with some element `x` in the limit (over J) over the colimits (over K),
    intro x
    -- This consists of some coherent family of elements in the various colimits,
    -- and so our first task is to pick representatives of these elements.
    have z := fun j => jointly_surjective'.{v, v} (limit.Ï€ (curry.obj F â‹™ limits.colim) j x)
    -- `k : J âŸ¶ K` records where the representative of the element in the `j`-th element of `x` lives
    let k : J â†’ K := fun j => (z j).some
    -- `y j : F.obj (j, k j)` is the representative
    let y : âˆ€ j, F.obj (j, k j) := fun j => (z j).choose_spec.some
    -- and we record that these representatives, when mapped back into the relevant colimits,
    -- are actually the components of `x`.
    have e :
      âˆ€ j, colimit.Î¹ ((curry.obj F).obj j) (k j) (y j) = limit.Ï€ (curry.obj F â‹™ limits.colim) j x :=
      fun j => (z j).choose_spec.choose_spec
    clear_value k y
    -- A little tidying up of things we no longer need.
    clear z
    -- As a first step, we use that `K` is filtered to pick some point `k' : K` above all the `k j`
    let k' : K := is_filtered.sup (finset.univ.image k) âˆ…
    -- and name the morphisms as `g j : k j âŸ¶ k'`.
    have g : âˆ€ j, k j âŸ¶ k' := fun j => is_filtered.to_sup (finset.univ.image k) âˆ… (by simp)
    clear_value k'
    -- Recalling that the components of `x`, which are indexed by `j : J`, are "coherent",
    -- in other words preserved by morphisms in the `J` direction,
    -- we see that for any morphism `f : j âŸ¶ j'` in `J`,
    -- the images of `y j` and `y j'`, when mapped to `F.obj (j', k')` respectively by
    -- `(f, g j)` and `(ðŸ™ j', g j')`, both represent the same element in the colimit.
    have w :
      âˆ€ {j j' : J} (f : j âŸ¶ j'),
        colimit.Î¹ ((curry.obj F).obj j') k' (F.map ((ðŸ™ j', g j') : (j', k j') âŸ¶ (j', k')) (y j')) =
          colimit.Î¹ ((curry.obj F).obj j') k' (F.map ((f, g j) : (j, k j) âŸ¶ (j', k')) (y j)) :=
      by
      intro j j' f
      have t :
        (f, g j) = (((f, ðŸ™ (k j)) : (j, k j) âŸ¶ (j', k j)) â‰« (ðŸ™ j', g j) : (j, k j) âŸ¶ (j', k')) := by
        simp only [id_comp, comp_id, prod_comp]
      erw [colimit.w_apply', t, functor_to_types.map_comp_apply, colimit.w_apply', e, â†
        limit.w_apply' f, â† e]
      simp
    -- Because `K` is filtered, we can restate this as saying that
    -- for each such `f`, there is some place to the right of `k'`
    -- where these images of `y j` and `y j'` become equal.
    simp_rw [colimit_eq_iff.{v, v}] at w
    -- We take a moment to restate `w` more conveniently.
    let kf : âˆ€ {j j'} (f : j âŸ¶ j'), K := fun _ _ f => (w f).some
    let gf : âˆ€ {j j'} (f : j âŸ¶ j'), k' âŸ¶ kf f := fun _ _ f => (w f).choose_spec.some
    let hf : âˆ€ {j j'} (f : j âŸ¶ j'), k' âŸ¶ kf f := fun _ _ f => (w f).choose_spec.choose_spec.some
    have wf :
      âˆ€ {j j'} (f : j âŸ¶ j'),
        F.map ((ðŸ™ j', g j' â‰« gf f) : (j', k j') âŸ¶ (j', kf f)) (y j') =
          F.map ((f, g j â‰« hf f) : (j, k j) âŸ¶ (j', kf f)) (y j) :=
      fun j j' f =>
      by
      have q :
        ((curry.obj F).obj j').map (gf f) (F.map _ (y j')) =
          ((curry.obj F).obj j').map (hf f) (F.map _ (y j)) :=
        (w f).choose_spec.choose_spec.choose_spec
      dsimp at q
      simp_rw [â† functor_to_types.map_comp_apply] at q
      convert q <;> simp only [comp_id]
    clear_value kf gf hf
    -- and clean up some things that are no longer needed.
    clear w
    -- We're now ready to use the fact that `K` is filtered a second time,
    -- picking some place to the right of all of
    -- the morphisms `gf f : k' âŸ¶ kh f` and `hf f : k' âŸ¶ kf f`.
    -- At this point we're relying on there being only finitely morphisms in `J`.
    let O :=
      (finset.univ.bUnion fun j => finset.univ.bUnion fun j' => finset.univ.image (@kf j j')) âˆª {k'}
    have kfO : âˆ€ {j j'} (f : j âŸ¶ j'), kf f âˆˆ O := fun j j' f =>
      finset.mem_union.mpr
        (Or.inl
          (by
            rw [Finset.mem_biUnion]
            refine' âŸ¨j, Finset.mem_univ j, _âŸ©
            rw [Finset.mem_biUnion]
            refine' âŸ¨j', Finset.mem_univ j', _âŸ©
            rw [Finset.mem_image]
            refine' âŸ¨f, Finset.mem_univ _, _âŸ©
            rfl))
    have k'O : k' âˆˆ O := finset.mem_union.mpr (Or.inr (finset.mem_singleton.mpr rfl))
    let H : Finset (Î£'(X Y : K)(mX : X âˆˆ O)(mY : Y âˆˆ O), X âŸ¶ Y) :=
      finset.univ.bUnion fun j : J =>
        finset.univ.bUnion fun j' : J =>
          finset.univ.bUnion fun f : j âŸ¶ j' =>
            {âŸ¨k', kf f, k'O, kfO f, gf fâŸ©, âŸ¨k', kf f, k'O, kfO f, hf fâŸ©}
    obtain âŸ¨k'', i', s'âŸ© := is_filtered.sup_exists O H
    -- We then restate this slightly more conveniently, as a family of morphism `i f : kf f âŸ¶ k''`,
    -- satisfying `gf f â‰« i f = hf f' â‰« i f'`.
    let i : âˆ€ {j j'} (f : j âŸ¶ j'), kf f âŸ¶ k'' := fun j j' f => i' (kfO f)
    have s : âˆ€ {jâ‚ jâ‚‚ jâ‚ƒ jâ‚„} (f : jâ‚ âŸ¶ jâ‚‚) (f' : jâ‚ƒ âŸ¶ jâ‚„), gf f â‰« i f = hf f' â‰« i f' :=
      by
      intros
      rw [s', s']
      swap
      exact k'O
      swap
      Â· rw [Finset.mem_biUnion]
        refine' âŸ¨jâ‚, Finset.mem_univ _, _âŸ©
        rw [Finset.mem_biUnion]
        refine' âŸ¨jâ‚‚, Finset.mem_univ _, _âŸ©
        rw [Finset.mem_biUnion]
        refine' âŸ¨f, Finset.mem_univ _, _âŸ©
        simp only [true_or_iff, eq_self_iff_true, and_self_iff, Finset.mem_insert, heq_iff_eq]
      Â· rw [Finset.mem_biUnion]
        refine' âŸ¨jâ‚ƒ, Finset.mem_univ _, _âŸ©
        rw [Finset.mem_biUnion]
        refine' âŸ¨jâ‚„, Finset.mem_univ _, _âŸ©
        rw [Finset.mem_biUnion]
        refine' âŸ¨f', Finset.mem_univ _, _âŸ©
        simp only [eq_self_iff_true, or_true_iff, and_self_iff, Finset.mem_insert,
          Finset.mem_singleton, heq_iff_eq]
    clear_value i
    clear s' i' H kfO k'O O
    -- We're finally ready to construct the pre-image, and verify it really maps to `x`.
    fconstructor
    Â· -- We construct the pre-image (which, recall is meant to be a point
      -- in the colimit (over `K`) of the limits (over `J`)) via a representative at `k''`.
      apply colimit.Î¹ (curry.obj (swap K J â‹™ F) â‹™ limits.lim) k'' _
      dsimp
      -- This representative is meant to be an element of a limit,
      -- so we need to construct a family of elements in `F.obj (j, k'')` for varying `j`,
      -- then show that are coherent with respect to morphisms in the `j` direction.
      apply Limit.mk.{v, v}
      swap
      Â·-- We construct the elements as the images of the `y j`.
        exact fun j => F.map (âŸ¨ðŸ™ j, g j â‰« gf (ðŸ™ j) â‰« i (ðŸ™ j)âŸ© : (j, k j) âŸ¶ (j, k'')) (y j)
      Â· -- After which it's just a calculation, using `s` and `wf`, to see they are coherent.
        dsimp
        intro j j' f
        simp only [â† functor_to_types.map_comp_apply, prod_comp, id_comp, comp_id]
        calc
          F.map ((f, g j â‰« gf (ðŸ™ j) â‰« i (ðŸ™ j)) : (j, k j) âŸ¶ (j', k'')) (y j) =
              F.map ((f, g j â‰« hf f â‰« i f) : (j, k j) âŸ¶ (j', k'')) (y j) :=
            by rw [s (ðŸ™ j) f]
          _ =
              F.map ((ðŸ™ j', i f) : (j', kf f) âŸ¶ (j', k''))
                (F.map ((f, g j â‰« hf f) : (j, k j) âŸ¶ (j', kf f)) (y j)) :=
            by rw [â† functor_to_types.map_comp_apply, prod_comp, comp_id, assoc]
          _ =
              F.map ((ðŸ™ j', i f) : (j', kf f) âŸ¶ (j', k''))
                (F.map ((ðŸ™ j', g j' â‰« gf f) : (j', k j') âŸ¶ (j', kf f)) (y j')) :=
            by rw [â† wf f]
          _ = F.map ((ðŸ™ j', g j' â‰« gf f â‰« i f) : (j', k j') âŸ¶ (j', k'')) (y j') := by
            rw [â† functor_to_types.map_comp_apply, prod_comp, id_comp, assoc]
          _ = F.map ((ðŸ™ j', g j' â‰« gf (ðŸ™ j') â‰« i (ðŸ™ j')) : (j', k j') âŸ¶ (j', k'')) (y j') := by
            rw [s f (ðŸ™ j'), â† s (ðŸ™ j') (ðŸ™ j')]
          
    -- Finally we check that this maps to `x`.
    Â· -- We can do this componentwise:
      apply limit_ext'
      intro j
      -- and as each component is an equation in a colimit, we can verify it by
      -- pointing out the morphism which carries one representative to the other:
      simp only [â† e, colimit_eq_iff.{v, v}, curry_obj_obj_map, limit.Ï€_mk', bifunctor.map_id_comp,
        id.def, types_comp_apply, limits.Î¹_colimit_limit_to_limit_colimit_Ï€_apply]
      refine' âŸ¨k'', ðŸ™ k'', g j â‰« gf (ðŸ™ j) â‰« i (ðŸ™ j), _âŸ©
      simp only [bifunctor.map_id_comp, types_comp_apply, bifunctor.map_id, types_id_apply]
#align category_theory.limits.colimit_limit_to_limit_colimit_surjective CategoryTheory.Limits.colimitLimitToLimitColimit_surjective

/- warning: category_theory.limits.colimit_limit_to_limit_colimit_is_iso -> CategoryTheory.Limits.colimitLimitToLimitColimit_isIso is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u1}} {K : Type.{u1}} [_inst_1 : CategoryTheory.SmallCategory.{u1} J] [_inst_2 : CategoryTheory.SmallCategory.{u1} K] (F : CategoryTheory.Functor.{u1, u1, u1, succ u1} (Prod.{u1, u1} J K) (CategoryTheory.uniformProd.{u1, u1} J _inst_1 K _inst_2) Type.{u1} CategoryTheory.types.{u1}) [_inst_3 : CategoryTheory.IsFiltered.{u1, u1} K _inst_2] [_inst_4 : CategoryTheory.FinCategory.{u1} J _inst_1], CategoryTheory.IsIso.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.Limits.colimit.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.Functor.comp.{u1, u1, u1, u1, succ u1, succ u1} K _inst_2 (CategoryTheory.Functor.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1}) Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.Functor.obj.{u1, u1, succ u1, succ u1} (CategoryTheory.Functor.{u1, u1, u1, succ u1} (Prod.{u1, u1} K J) (CategoryTheory.prod.{u1, u1, u1, u1} K _inst_2 J _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} (Prod.{u1, u1} K J) (CategoryTheory.prod.{u1, u1, u1, u1} K _inst_2 J _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.{u1, u1, u1, succ u1} K _inst_2 (CategoryTheory.Functor.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} K _inst_2 (CategoryTheory.Functor.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.curry.{u1, u1, u1, u1, u1, succ u1} K _inst_2 J _inst_1 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.comp.{u1, u1, u1, u1, u1, succ u1} (Prod.{u1, u1} K J) (CategoryTheory.prod.{u1, u1, u1, u1} K _inst_2 J _inst_1) (Prod.{u1, u1} J K) (CategoryTheory.prod.{u1, u1, u1, u1} J _inst_1 K _inst_2) Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.Prod.swap.{u1, u1, u1, u1} K _inst_2 J _inst_1) F)) (CategoryTheory.Limits.lim.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.Limits.hasLimitsOfShape_of_hasFiniteLimits.{u1, u1, succ u1} Type.{u1} CategoryTheory.types.{u1} J _inst_1 _inst_4 (CategoryTheory.Limits.hasFiniteLimits_of_hasLimits.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1} CategoryTheory.Limits.Types.Sort.CategoryTheory.Limits.hasLimits.{u1})))) (CategoryTheory.Limits.colimitLimitToLimitColimit._proof_1.{succ u1, u1} J K _inst_1 _inst_2 Type.{u1} CategoryTheory.types.{u1} F (CategoryTheory.Limits.hasLimitsOfShape_of_hasFiniteLimits.{u1, u1, succ u1} Type.{u1} CategoryTheory.types.{u1} J _inst_1 _inst_4 (CategoryTheory.Limits.hasFiniteLimits_of_hasLimits.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1} CategoryTheory.Limits.Types.Sort.CategoryTheory.Limits.hasLimits.{u1})) (CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize.{u1, u1, u1, succ u1} Type.{u1} CategoryTheory.types.{u1} K _inst_2 CategoryTheory.Limits.Types.Sort.CategoryTheory.Limits.hasColimits.{u1}))) (CategoryTheory.Limits.limit.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.Functor.comp.{u1, u1, u1, u1, succ u1, succ u1} J _inst_1 (CategoryTheory.Functor.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1}) Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.Functor.obj.{u1, u1, succ u1, succ u1} (CategoryTheory.Functor.{u1, u1, u1, succ u1} (Prod.{u1, u1} J K) (CategoryTheory.prod.{u1, u1, u1, u1} J _inst_1 K _inst_2) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} (Prod.{u1, u1} J K) (CategoryTheory.prod.{u1, u1, u1, u1} J _inst_1 K _inst_2) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.{u1, u1, u1, succ u1} J _inst_1 (CategoryTheory.Functor.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} J _inst_1 (CategoryTheory.Functor.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.curry.{u1, u1, u1, u1, u1, succ u1} J _inst_1 K _inst_2 Type.{u1} CategoryTheory.types.{u1}) F) (CategoryTheory.Limits.colim.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize.{u1, u1, u1, succ u1} Type.{u1} CategoryTheory.types.{u1} K _inst_2 CategoryTheory.Limits.Types.Sort.CategoryTheory.Limits.hasColimits.{u1}))) (CategoryTheory.Limits.colimitLimitToLimitColimit._proof_2.{succ u1, u1} J K _inst_1 _inst_2 Type.{u1} CategoryTheory.types.{u1} F (CategoryTheory.Limits.hasLimitsOfShape_of_hasFiniteLimits.{u1, u1, succ u1} Type.{u1} CategoryTheory.types.{u1} J _inst_1 _inst_4 (CategoryTheory.Limits.hasFiniteLimits_of_hasLimits.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1} CategoryTheory.Limits.Types.Sort.CategoryTheory.Limits.hasLimits.{u1})) (CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize.{u1, u1, u1, succ u1} Type.{u1} CategoryTheory.types.{u1} K _inst_2 CategoryTheory.Limits.Types.Sort.CategoryTheory.Limits.hasColimits.{u1}))) (CategoryTheory.Limits.colimitLimitToLimitColimit.{u1, succ u1} J K _inst_1 _inst_2 Type.{u1} CategoryTheory.types.{u1} F (CategoryTheory.Limits.hasLimitsOfShape_of_hasFiniteLimits.{u1, u1, succ u1} Type.{u1} CategoryTheory.types.{u1} J _inst_1 _inst_4 (CategoryTheory.Limits.hasFiniteLimits_of_hasLimits.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1} CategoryTheory.Limits.Types.Sort.CategoryTheory.Limits.hasLimits.{u1})) (CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize.{u1, u1, u1, succ u1} Type.{u1} CategoryTheory.types.{u1} K _inst_2 CategoryTheory.Limits.Types.Sort.CategoryTheory.Limits.hasColimits.{u1}))
but is expected to have type
  forall {J : Type.{u1}} {K : Type.{u1}} [_inst_1 : CategoryTheory.SmallCategory.{u1} J] [_inst_2 : CategoryTheory.SmallCategory.{u1} K] (F : CategoryTheory.Functor.{u1, u1, u1, succ u1} (Prod.{u1, u1} J K) (CategoryTheory.uniformProd.{u1, u1} J _inst_1 K _inst_2) Type.{u1} CategoryTheory.types.{u1}) [_inst_3 : CategoryTheory.IsFiltered.{u1, u1} K _inst_2] [_inst_4 : CategoryTheory.FinCategory.{u1} J _inst_1], CategoryTheory.IsIso.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.Limits.colimit.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.Functor.comp.{u1, u1, u1, u1, succ u1, succ u1} K _inst_2 (CategoryTheory.Functor.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1}) Type.{u1} CategoryTheory.types.{u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} (CategoryTheory.Functor.{u1, u1, u1, succ u1} (Prod.{u1, u1} K J) (CategoryTheory.prod.{u1, u1, u1, u1} K _inst_2 J _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} (CategoryTheory.Functor.{u1, u1, u1, succ u1} (Prod.{u1, u1} K J) (CategoryTheory.prod.{u1, u1, u1, u1} K _inst_2 J _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} (CategoryTheory.Functor.{u1, u1, u1, succ u1} (Prod.{u1, u1} K J) (CategoryTheory.prod.{u1, u1, u1, u1} K _inst_2 J _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} (Prod.{u1, u1} K J) (CategoryTheory.prod.{u1, u1, u1, u1} K _inst_2 J _inst_1) Type.{u1} CategoryTheory.types.{u1}))) (CategoryTheory.Functor.{u1, u1, u1, succ u1} K _inst_2 (CategoryTheory.Functor.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} (CategoryTheory.Functor.{u1, u1, u1, succ u1} K _inst_2 (CategoryTheory.Functor.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} (CategoryTheory.Functor.{u1, u1, u1, succ u1} K _inst_2 (CategoryTheory.Functor.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} K _inst_2 (CategoryTheory.Functor.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1})))) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} (CategoryTheory.Functor.{u1, u1, u1, succ u1} (Prod.{u1, u1} K J) (CategoryTheory.prod.{u1, u1, u1, u1} K _inst_2 J _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} (Prod.{u1, u1} K J) (CategoryTheory.prod.{u1, u1, u1, u1} K _inst_2 J _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.{u1, u1, u1, succ u1} K _inst_2 (CategoryTheory.Functor.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} K _inst_2 (CategoryTheory.Functor.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.curry.{u1, u1, u1, u1, u1, succ u1} K _inst_2 J _inst_1 Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.comp.{u1, u1, u1, u1, u1, succ u1} (Prod.{u1, u1} K J) (CategoryTheory.prod.{u1, u1, u1, u1} K _inst_2 J _inst_1) (Prod.{u1, u1} J K) (CategoryTheory.prod.{u1, u1, u1, u1} J _inst_1 K _inst_2) Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.Prod.swap.{u1, u1, u1, u1} K _inst_2 J _inst_1) F)) (CategoryTheory.Limits.lim.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.Limits.hasLimitsOfShape_of_hasFiniteLimits.{u1, u1, succ u1} Type.{u1} CategoryTheory.types.{u1} J _inst_1 _inst_4 (CategoryTheory.Limits.hasFiniteLimits_of_hasLimits.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1} CategoryTheory.Limits.Types.instHasLimitsTypeTypes.{u1})))) (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u1, u1, u1, succ u1} Type.{u1} CategoryTheory.types.{u1} K _inst_2 (CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize.{u1, u1, u1, succ u1} Type.{u1} CategoryTheory.types.{u1} K _inst_2 CategoryTheory.Limits.Types.instHasColimitsTypeTypes.{u1}) (CategoryTheory.Functor.comp.{u1, u1, u1, u1, succ u1, succ u1} K _inst_2 (CategoryTheory.Functor.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1}) Type.{u1} CategoryTheory.types.{u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} (CategoryTheory.Functor.{u1, u1, u1, succ u1} (Prod.{u1, u1} K J) (CategoryTheory.prod.{u1, u1, u1, u1} K _inst_2 J _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} (CategoryTheory.Functor.{u1, u1, u1, succ u1} (Prod.{u1, u1} K J) (CategoryTheory.prod.{u1, u1, u1, u1} K _inst_2 J _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} (CategoryTheory.Functor.{u1, u1, u1, succ u1} (Prod.{u1, u1} K J) (CategoryTheory.prod.{u1, u1, u1, u1} K _inst_2 J _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} (Prod.{u1, u1} K J) (CategoryTheory.prod.{u1, u1, u1, u1} K _inst_2 J _inst_1) Type.{u1} CategoryTheory.types.{u1}))) (CategoryTheory.Functor.{u1, u1, u1, succ u1} K _inst_2 (CategoryTheory.Functor.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} (CategoryTheory.Functor.{u1, u1, u1, succ u1} K _inst_2 (CategoryTheory.Functor.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} (CategoryTheory.Functor.{u1, u1, u1, succ u1} K _inst_2 (CategoryTheory.Functor.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} K _inst_2 (CategoryTheory.Functor.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1})))) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} (CategoryTheory.Functor.{u1, u1, u1, succ u1} (Prod.{u1, u1} K J) (CategoryTheory.prod.{u1, u1, u1, u1} K _inst_2 J _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} (Prod.{u1, u1} K J) (CategoryTheory.prod.{u1, u1, u1, u1} K _inst_2 J _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.{u1, u1, u1, succ u1} K _inst_2 (CategoryTheory.Functor.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} K _inst_2 (CategoryTheory.Functor.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.curry.{u1, u1, u1, u1, u1, succ u1} K _inst_2 J _inst_1 Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.comp.{u1, u1, u1, u1, u1, succ u1} (Prod.{u1, u1} K J) (CategoryTheory.prod.{u1, u1, u1, u1} K _inst_2 J _inst_1) (Prod.{u1, u1} J K) (CategoryTheory.prod.{u1, u1, u1, u1} J _inst_1 K _inst_2) Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.Prod.swap.{u1, u1, u1, u1} K _inst_2 J _inst_1) F)) (CategoryTheory.Limits.lim.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.Limits.hasLimitsOfShape_of_hasFiniteLimits.{u1, u1, succ u1} Type.{u1} CategoryTheory.types.{u1} J _inst_1 _inst_4 (CategoryTheory.Limits.hasFiniteLimits_of_hasLimits.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1} CategoryTheory.Limits.Types.instHasLimitsTypeTypes.{u1})))))) (CategoryTheory.Limits.limit.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.Functor.comp.{u1, u1, u1, u1, succ u1, succ u1} J _inst_1 (CategoryTheory.Functor.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1}) Type.{u1} CategoryTheory.types.{u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} (CategoryTheory.Functor.{u1, u1, u1, succ u1} (Prod.{u1, u1} J K) (CategoryTheory.prod.{u1, u1, u1, u1} J _inst_1 K _inst_2) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} (CategoryTheory.Functor.{u1, u1, u1, succ u1} (Prod.{u1, u1} J K) (CategoryTheory.prod.{u1, u1, u1, u1} J _inst_1 K _inst_2) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} (CategoryTheory.Functor.{u1, u1, u1, succ u1} (Prod.{u1, u1} J K) (CategoryTheory.prod.{u1, u1, u1, u1} J _inst_1 K _inst_2) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} (Prod.{u1, u1} J K) (CategoryTheory.prod.{u1, u1, u1, u1} J _inst_1 K _inst_2) Type.{u1} CategoryTheory.types.{u1}))) (CategoryTheory.Functor.{u1, u1, u1, succ u1} J _inst_1 (CategoryTheory.Functor.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} (CategoryTheory.Functor.{u1, u1, u1, succ u1} J _inst_1 (CategoryTheory.Functor.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} (CategoryTheory.Functor.{u1, u1, u1, succ u1} J _inst_1 (CategoryTheory.Functor.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} J _inst_1 (CategoryTheory.Functor.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1})))) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} (CategoryTheory.Functor.{u1, u1, u1, succ u1} (Prod.{u1, u1} J K) (CategoryTheory.prod.{u1, u1, u1, u1} J _inst_1 K _inst_2) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} (Prod.{u1, u1} J K) (CategoryTheory.prod.{u1, u1, u1, u1} J _inst_1 K _inst_2) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.{u1, u1, u1, succ u1} J _inst_1 (CategoryTheory.Functor.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} J _inst_1 (CategoryTheory.Functor.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.curry.{u1, u1, u1, u1, u1, succ u1} J _inst_1 K _inst_2 Type.{u1} CategoryTheory.types.{u1})) F) (CategoryTheory.Limits.colim.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize.{u1, u1, u1, succ u1} Type.{u1} CategoryTheory.types.{u1} K _inst_2 CategoryTheory.Limits.Types.instHasColimitsTypeTypes.{u1}))) (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u1, u1, succ u1} Type.{u1} CategoryTheory.types.{u1} J _inst_1 (CategoryTheory.Limits.hasLimitsOfShape_of_hasFiniteLimits.{u1, u1, succ u1} Type.{u1} CategoryTheory.types.{u1} J _inst_1 _inst_4 (CategoryTheory.Limits.hasFiniteLimits_of_hasLimits.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1} CategoryTheory.Limits.Types.instHasLimitsTypeTypes.{u1})) (CategoryTheory.Functor.comp.{u1, u1, u1, u1, succ u1, succ u1} J _inst_1 (CategoryTheory.Functor.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1}) Type.{u1} CategoryTheory.types.{u1} (Prefunctor.obj.{succ u1, succ u1, succ u1, succ u1} (CategoryTheory.Functor.{u1, u1, u1, succ u1} (Prod.{u1, u1} J K) (CategoryTheory.prod.{u1, u1, u1, u1} J _inst_1 K _inst_2) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} (CategoryTheory.Functor.{u1, u1, u1, succ u1} (Prod.{u1, u1} J K) (CategoryTheory.prod.{u1, u1, u1, u1} J _inst_1 K _inst_2) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} (CategoryTheory.Functor.{u1, u1, u1, succ u1} (Prod.{u1, u1} J K) (CategoryTheory.prod.{u1, u1, u1, u1} J _inst_1 K _inst_2) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} (Prod.{u1, u1} J K) (CategoryTheory.prod.{u1, u1, u1, u1} J _inst_1 K _inst_2) Type.{u1} CategoryTheory.types.{u1}))) (CategoryTheory.Functor.{u1, u1, u1, succ u1} J _inst_1 (CategoryTheory.Functor.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} (CategoryTheory.Functor.{u1, u1, u1, succ u1} J _inst_1 (CategoryTheory.Functor.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} (CategoryTheory.Functor.{u1, u1, u1, succ u1} J _inst_1 (CategoryTheory.Functor.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} J _inst_1 (CategoryTheory.Functor.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1})))) (CategoryTheory.Functor.toPrefunctor.{u1, u1, succ u1, succ u1} (CategoryTheory.Functor.{u1, u1, u1, succ u1} (Prod.{u1, u1} J K) (CategoryTheory.prod.{u1, u1, u1, u1} J _inst_1 K _inst_2) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} (Prod.{u1, u1} J K) (CategoryTheory.prod.{u1, u1, u1, u1} J _inst_1 K _inst_2) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.{u1, u1, u1, succ u1} J _inst_1 (CategoryTheory.Functor.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} J _inst_1 (CategoryTheory.Functor.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.curry.{u1, u1, u1, u1, u1, succ u1} J _inst_1 K _inst_2 Type.{u1} CategoryTheory.types.{u1})) F) (CategoryTheory.Limits.colim.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize.{u1, u1, u1, succ u1} Type.{u1} CategoryTheory.types.{u1} K _inst_2 CategoryTheory.Limits.Types.instHasColimitsTypeTypes.{u1}))))) (CategoryTheory.Limits.colimitLimitToLimitColimit.{u1, succ u1} J K _inst_1 _inst_2 Type.{u1} CategoryTheory.types.{u1} F (CategoryTheory.Limits.hasLimitsOfShape_of_hasFiniteLimits.{u1, u1, succ u1} Type.{u1} CategoryTheory.types.{u1} J _inst_1 _inst_4 (CategoryTheory.Limits.hasFiniteLimits_of_hasLimits.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1} CategoryTheory.Limits.Types.instHasLimitsTypeTypes.{u1})) (CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize.{u1, u1, u1, succ u1} Type.{u1} CategoryTheory.types.{u1} K _inst_2 CategoryTheory.Limits.Types.instHasColimitsTypeTypes.{u1}))
Case conversion may be inaccurate. Consider using '#align category_theory.limits.colimit_limit_to_limit_colimit_is_iso CategoryTheory.Limits.colimitLimitToLimitColimit_isIsoâ‚“'. -/
instance colimitLimitToLimitColimit_isIso : IsIso (colimitLimitToLimitColimit F) :=
  (isIso_iff_bijective _).mpr
    âŸ¨colimitLimitToLimitColimit_injective F, colimitLimitToLimitColimit_surjective FâŸ©
#align category_theory.limits.colimit_limit_to_limit_colimit_is_iso CategoryTheory.Limits.colimitLimitToLimitColimit_isIso

/- warning: category_theory.limits.colimit_limit_to_limit_colimit_cone_iso -> CategoryTheory.Limits.colimitLimitToLimitColimitCone_iso is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u1}} {K : Type.{u1}} [_inst_1 : CategoryTheory.SmallCategory.{u1} J] [_inst_2 : CategoryTheory.SmallCategory.{u1} K] [_inst_3 : CategoryTheory.IsFiltered.{u1, u1} K _inst_2] [_inst_4 : CategoryTheory.FinCategory.{u1} J _inst_1] (F : CategoryTheory.Functor.{u1, u1, u1, succ u1} J _inst_1 (CategoryTheory.Functor.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1})), CategoryTheory.IsIso.{u1, succ u1} (CategoryTheory.Limits.Cone.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.Functor.comp.{u1, u1, u1, u1, succ u1, succ u1} J _inst_1 (CategoryTheory.Functor.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1}) Type.{u1} CategoryTheory.types.{u1} F (CategoryTheory.Limits.colim.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize.{u1, u1, u1, succ u1} Type.{u1} CategoryTheory.types.{u1} K _inst_2 CategoryTheory.Limits.Types.Sort.CategoryTheory.Limits.hasColimits.{u1})))) (CategoryTheory.Limits.Cone.category.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.Functor.comp.{u1, u1, u1, u1, succ u1, succ u1} J _inst_1 (CategoryTheory.Functor.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1}) Type.{u1} CategoryTheory.types.{u1} F (CategoryTheory.Limits.colim.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize.{u1, u1, u1, succ u1} Type.{u1} CategoryTheory.types.{u1} K _inst_2 CategoryTheory.Limits.Types.Sort.CategoryTheory.Limits.hasColimits.{u1})))) (CategoryTheory.Functor.mapCone.{u1, u1, u1, u1, succ u1, succ u1} J _inst_1 (CategoryTheory.Functor.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1}) Type.{u1} CategoryTheory.types.{u1} F (CategoryTheory.Limits.colim.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize.{u1, u1, u1, succ u1} Type.{u1} CategoryTheory.types.{u1} K _inst_2 CategoryTheory.Limits.Types.Sort.CategoryTheory.Limits.hasColimits.{u1})) (CategoryTheory.Limits.limit.cone.{u1, u1, u1, succ u1} J _inst_1 (CategoryTheory.Functor.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1}) F (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u1, u1, succ u1} (CategoryTheory.Functor.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1}) J _inst_1 (CategoryTheory.Limits.functorCategoryHasLimitsOfShape.{u1, u1, u1, u1, u1, succ u1} Type.{u1} CategoryTheory.types.{u1} J _inst_1 K _inst_2 (CategoryTheory.Limits.hasLimitsOfShape_of_hasFiniteLimits.{u1, u1, succ u1} Type.{u1} CategoryTheory.types.{u1} J _inst_1 _inst_4 (CategoryTheory.Limits.hasFiniteLimits_of_hasLimits.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1} CategoryTheory.Limits.Types.Sort.CategoryTheory.Limits.hasLimits.{u1}))) F))) (CategoryTheory.Limits.limit.cone.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.Functor.comp.{u1, u1, u1, u1, succ u1, succ u1} J _inst_1 (CategoryTheory.Functor.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1}) Type.{u1} CategoryTheory.types.{u1} F (CategoryTheory.Limits.colim.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize.{u1, u1, u1, succ u1} Type.{u1} CategoryTheory.types.{u1} K _inst_2 CategoryTheory.Limits.Types.Sort.CategoryTheory.Limits.hasColimits.{u1}))) (CategoryTheory.Limits.colimitLimitToLimitColimitCone._proof_1.{succ u1, u1} J K _inst_1 _inst_2 Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.Limits.hasLimitsOfShape_of_hasFiniteLimits.{u1, u1, succ u1} Type.{u1} CategoryTheory.types.{u1} J _inst_1 _inst_4 (CategoryTheory.Limits.hasFiniteLimits_of_hasLimits.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1} CategoryTheory.Limits.Types.Sort.CategoryTheory.Limits.hasLimits.{u1})) (CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize.{u1, u1, u1, succ u1} Type.{u1} CategoryTheory.types.{u1} K _inst_2 CategoryTheory.Limits.Types.Sort.CategoryTheory.Limits.hasColimits.{u1}) F)) (CategoryTheory.Limits.colimitLimitToLimitColimitCone.{u1, succ u1} J K _inst_1 _inst_2 Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.Limits.hasLimitsOfShape_of_hasFiniteLimits.{u1, u1, succ u1} Type.{u1} CategoryTheory.types.{u1} J _inst_1 _inst_4 (CategoryTheory.Limits.hasFiniteLimits_of_hasLimits.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1} CategoryTheory.Limits.Types.Sort.CategoryTheory.Limits.hasLimits.{u1})) (CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize.{u1, u1, u1, succ u1} Type.{u1} CategoryTheory.types.{u1} K _inst_2 CategoryTheory.Limits.Types.Sort.CategoryTheory.Limits.hasColimits.{u1}) F (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u1, u1, succ u1} (CategoryTheory.Functor.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1}) J _inst_1 (CategoryTheory.Limits.functorCategoryHasLimitsOfShape.{u1, u1, u1, u1, u1, succ u1} Type.{u1} CategoryTheory.types.{u1} J _inst_1 K _inst_2 (CategoryTheory.Limits.hasLimitsOfShape_of_hasFiniteLimits.{u1, u1, succ u1} Type.{u1} CategoryTheory.types.{u1} J _inst_1 _inst_4 (CategoryTheory.Limits.hasFiniteLimits_of_hasLimits.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1} CategoryTheory.Limits.Types.Sort.CategoryTheory.Limits.hasLimits.{u1}))) F))
but is expected to have type
  forall {J : Type.{u1}} {K : Type.{u1}} [_inst_1 : CategoryTheory.SmallCategory.{u1} J] [_inst_2 : CategoryTheory.SmallCategory.{u1} K] [_inst_3 : CategoryTheory.IsFiltered.{u1, u1} K _inst_2] [_inst_4 : CategoryTheory.FinCategory.{u1} J _inst_1] (F : CategoryTheory.Functor.{u1, u1, u1, succ u1} J _inst_1 (CategoryTheory.Functor.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1})), CategoryTheory.IsIso.{u1, succ u1} (CategoryTheory.Limits.Cone.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.Functor.comp.{u1, u1, u1, u1, succ u1, succ u1} J _inst_1 (CategoryTheory.Functor.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1}) Type.{u1} CategoryTheory.types.{u1} F (CategoryTheory.Limits.colim.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize.{u1, u1, u1, succ u1} Type.{u1} CategoryTheory.types.{u1} K _inst_2 CategoryTheory.Limits.Types.instHasColimitsTypeTypes.{u1})))) (CategoryTheory.Limits.Cone.category.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.Functor.comp.{u1, u1, u1, u1, succ u1, succ u1} J _inst_1 (CategoryTheory.Functor.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1}) Type.{u1} CategoryTheory.types.{u1} F (CategoryTheory.Limits.colim.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize.{u1, u1, u1, succ u1} Type.{u1} CategoryTheory.types.{u1} K _inst_2 CategoryTheory.Limits.Types.instHasColimitsTypeTypes.{u1})))) (CategoryTheory.Functor.mapCone.{u1, u1, u1, u1, succ u1, succ u1} J _inst_1 (CategoryTheory.Functor.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1}) Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.Limits.colim.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize.{u1, u1, u1, succ u1} Type.{u1} CategoryTheory.types.{u1} K _inst_2 CategoryTheory.Limits.Types.instHasColimitsTypeTypes.{u1})) F (CategoryTheory.Limits.limit.cone.{u1, u1, u1, succ u1} J _inst_1 (CategoryTheory.Functor.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1}) F (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u1, u1, succ u1} (CategoryTheory.Functor.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1}) J _inst_1 (CategoryTheory.Limits.functorCategoryHasLimitsOfShape.{u1, u1, u1, u1, u1, succ u1} Type.{u1} CategoryTheory.types.{u1} J _inst_1 K _inst_2 (CategoryTheory.Limits.hasLimitsOfShape_of_hasFiniteLimits.{u1, u1, succ u1} Type.{u1} CategoryTheory.types.{u1} J _inst_1 _inst_4 (CategoryTheory.Limits.hasFiniteLimits_of_hasLimits.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1} CategoryTheory.Limits.Types.instHasLimitsTypeTypes.{u1}))) F))) (CategoryTheory.Limits.limit.cone.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.Functor.comp.{u1, u1, u1, u1, succ u1, succ u1} J _inst_1 (CategoryTheory.Functor.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1}) Type.{u1} CategoryTheory.types.{u1} F (CategoryTheory.Limits.colim.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize.{u1, u1, u1, succ u1} Type.{u1} CategoryTheory.types.{u1} K _inst_2 CategoryTheory.Limits.Types.instHasColimitsTypeTypes.{u1}))) (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u1, u1, succ u1} Type.{u1} CategoryTheory.types.{u1} J _inst_1 (CategoryTheory.Limits.hasLimitsOfShape_of_hasFiniteLimits.{u1, u1, succ u1} Type.{u1} CategoryTheory.types.{u1} J _inst_1 _inst_4 (CategoryTheory.Limits.hasFiniteLimits_of_hasLimits.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1} CategoryTheory.Limits.Types.instHasLimitsTypeTypes.{u1})) (CategoryTheory.Functor.comp.{u1, u1, u1, u1, succ u1, succ u1} J _inst_1 (CategoryTheory.Functor.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1}) Type.{u1} CategoryTheory.types.{u1} F (CategoryTheory.Limits.colim.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize.{u1, u1, u1, succ u1} Type.{u1} CategoryTheory.types.{u1} K _inst_2 CategoryTheory.Limits.Types.instHasColimitsTypeTypes.{u1}))))) (CategoryTheory.Limits.colimitLimitToLimitColimitCone.{u1, succ u1} J K _inst_1 _inst_2 Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.Limits.hasLimitsOfShape_of_hasFiniteLimits.{u1, u1, succ u1} Type.{u1} CategoryTheory.types.{u1} J _inst_1 _inst_4 (CategoryTheory.Limits.hasFiniteLimits_of_hasLimits.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1} CategoryTheory.Limits.Types.instHasLimitsTypeTypes.{u1})) (CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize.{u1, u1, u1, succ u1} Type.{u1} CategoryTheory.types.{u1} K _inst_2 CategoryTheory.Limits.Types.instHasColimitsTypeTypes.{u1}) F (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u1, u1, succ u1} (CategoryTheory.Functor.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u1, succ u1} K _inst_2 Type.{u1} CategoryTheory.types.{u1}) J _inst_1 (CategoryTheory.Limits.functorCategoryHasLimitsOfShape.{u1, u1, u1, u1, u1, succ u1} Type.{u1} CategoryTheory.types.{u1} J _inst_1 K _inst_2 (CategoryTheory.Limits.hasLimitsOfShape_of_hasFiniteLimits.{u1, u1, succ u1} Type.{u1} CategoryTheory.types.{u1} J _inst_1 _inst_4 (CategoryTheory.Limits.hasFiniteLimits_of_hasLimits.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1} CategoryTheory.Limits.Types.instHasLimitsTypeTypes.{u1}))) F))
Case conversion may be inaccurate. Consider using '#align category_theory.limits.colimit_limit_to_limit_colimit_cone_iso CategoryTheory.Limits.colimitLimitToLimitColimitCone_isoâ‚“'. -/
instance colimitLimitToLimitColimitCone_iso (F : J â¥¤ K â¥¤ Type v) :
    IsIso (colimitLimitToLimitColimitCone F) :=
  by
  have : is_iso (colimit_limit_to_limit_colimit_cone F).Hom :=
    by
    dsimp only [colimit_limit_to_limit_colimit_cone]
    infer_instance
  apply cones.cone_iso_of_hom_iso
#align category_theory.limits.colimit_limit_to_limit_colimit_cone_iso CategoryTheory.Limits.colimitLimitToLimitColimitCone_iso

#print CategoryTheory.Limits.filteredColimPreservesFiniteLimitsOfTypes /-
noncomputable instance filteredColimPreservesFiniteLimitsOfTypes :
    PreservesFiniteLimits (colim : (K â¥¤ Type v) â¥¤ _) :=
  by
  apply preservesFiniteLimitsOfPreservesFiniteLimitsOfSize.{v}
  intro J _ _; skip; constructor
  intro F; constructor
  intro c hc
  apply is_limit.of_iso_limit (limit.is_limit _)
  symm; trans colim.map_cone (limit.cone F)
  exact functor.map_iso _ (hc.unique_up_to_iso (limit.is_limit F))
  exact as_iso (colimitLimitToLimitColimitCone.{v, v + 1} F)
#align category_theory.limits.filtered_colim_preserves_finite_limits_of_types CategoryTheory.Limits.filteredColimPreservesFiniteLimitsOfTypes
-/

variable {C : Type u} [Category.{v} C] [ConcreteCategory.{v} C]

section

variable [HasLimitsOfShape J C] [HasColimitsOfShape K C]

variable [ReflectsLimitsOfShape J (forget C)] [PreservesColimitsOfShape K (forget C)]

variable [PreservesLimitsOfShape J (forget C)]

#print CategoryTheory.Limits.filteredColimPreservesFiniteLimits /-
noncomputable instance filteredColimPreservesFiniteLimits :
    PreservesLimitsOfShape J (colim : (K â¥¤ C) â¥¤ _) :=
  haveI : preserves_limits_of_shape J ((colim : (K â¥¤ C) â¥¤ _) â‹™ forget C) :=
    preserves_limits_of_shape_of_nat_iso (preserves_colimit_nat_iso _).symm
  preserves_limits_of_shape_of_reflects_of_preserves _ (forget C)
#align category_theory.limits.filtered_colim_preserves_finite_limits CategoryTheory.Limits.filteredColimPreservesFiniteLimits
-/

end

attribute [local instance] reflects_limits_of_shape_of_reflects_isomorphisms

noncomputable instance [PreservesFiniteLimits (forget C)] [PreservesFilteredColimits (forget C)]
    [HasFiniteLimits C] [HasColimitsOfShape K C] [ReflectsIsomorphisms (forget C)] :
    PreservesFiniteLimits (colim : (K â¥¤ C) â¥¤ _) :=
  by
  apply preservesFiniteLimitsOfPreservesFiniteLimitsOfSize.{v}
  intro J _ _; skip; infer_instance

section

variable [HasLimitsOfShape J C] [HasColimitsOfShape K C]

variable [ReflectsLimitsOfShape J (forget C)] [PreservesColimitsOfShape K (forget C)]

variable [PreservesLimitsOfShape J (forget C)]

#print CategoryTheory.Limits.colimitLimitIso /-
/-- A curried version of the fact that filtered colimits commute with finite limits. -/
noncomputable def colimitLimitIso (F : J â¥¤ K â¥¤ C) : colimit (limit F) â‰… limit (colimit F.flip) :=
  (isLimitOfPreserves colim (limit.isLimit _)).conePointUniqueUpToIso (limit.isLimit _) â‰ªâ‰«
    HasLimit.isoOfNatIso (colimitFlipIsoCompColim _).symm
#align category_theory.limits.colimit_limit_iso CategoryTheory.Limits.colimitLimitIso
-/

/- warning: category_theory.limits.Î¹_colimit_limit_iso_limit_Ï€ -> CategoryTheory.Limits.Î¹_colimitLimitIso_limit_Ï€ is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u1}} {K : Type.{u1}} [_inst_1 : CategoryTheory.SmallCategory.{u1} J] [_inst_2 : CategoryTheory.SmallCategory.{u1} K] [_inst_3 : CategoryTheory.IsFiltered.{u1, u1} K _inst_2] [_inst_4 : CategoryTheory.FinCategory.{u1} J _inst_1] {C : Type.{u2}} [_inst_5 : CategoryTheory.Category.{u1, u2} C] [_inst_6 : CategoryTheory.ConcreteCategory.{u1, u1, u2} C _inst_5] [_inst_7 : CategoryTheory.Limits.HasLimitsOfShape.{u1, u1, u1, u2} J _inst_1 C _inst_5] [_inst_8 : CategoryTheory.Limits.HasColimitsOfShape.{u1, u1, u1, u2} K _inst_2 C _inst_5] [_inst_9 : CategoryTheory.Limits.ReflectsLimitsOfShape.{u1, u1, u1, u1, u2, succ u1} C _inst_5 Type.{u1} CategoryTheory.types.{u1} J _inst_1 (CategoryTheory.forget.{u2, u1, u1} C _inst_5 _inst_6)] [_inst_10 : CategoryTheory.Limits.PreservesColimitsOfShape.{u1, u1, u1, u1, u2, succ u1} C _inst_5 Type.{u1} CategoryTheory.types.{u1} K _inst_2 (CategoryTheory.forget.{u2, u1, u1} C _inst_5 _inst_6)] [_inst_11 : CategoryTheory.Limits.PreservesLimitsOfShape.{u1, u1, u1, u1, u2, succ u1} C _inst_5 Type.{u1} CategoryTheory.types.{u1} J _inst_1 (CategoryTheory.forget.{u2, u1, u1} C _inst_5 _inst_6)] (F : CategoryTheory.Functor.{u1, u1, u1, max u1 u2} J _inst_1 (CategoryTheory.Functor.{u1, u1, u1, u2} K _inst_2 C _inst_5) (CategoryTheory.Functor.category.{u1, u1, u1, u2} K _inst_2 C _inst_5)) (a : K) (b : J), Eq.{succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_5)) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} K _inst_2 C _inst_5 (CategoryTheory.Limits.limit.{u1, u1, u1, max u1 u2} J _inst_1 (CategoryTheory.Functor.{u1, u1, u1, u2} K _inst_2 C _inst_5) (CategoryTheory.Functor.category.{u1, u1, u1, u2} K _inst_2 C _inst_5) F (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u1, u1, max u1 u2} (CategoryTheory.Functor.{u1, u1, u1, u2} K _inst_2 C _inst_5) (CategoryTheory.Functor.category.{u1, u1, u1, u2} K _inst_2 C _inst_5) J _inst_1 (CategoryTheory.Limits.functorCategoryHasLimitsOfShape.{u1, u1, u1, u1, u1, u2} C _inst_5 J _inst_1 K _inst_2 _inst_7) F)) a) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_1 C _inst_5 (CategoryTheory.Limits.colimit.{u1, u1, u1, max u1 u2} K _inst_2 (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_1 C _inst_5) (CategoryTheory.Functor.category.{u1, u1, u1, u2} J _inst_1 C _inst_5) (CategoryTheory.Functor.flip.{u1, u1, u1, u1, u1, u2} J _inst_1 K _inst_2 C _inst_5 F) (CategoryTheory.Limits.colimitLimitIso._proof_3.{u2, u1} J K _inst_1 _inst_2 C _inst_5 _inst_8 F)) b)) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_5) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} K _inst_2 C _inst_5 (CategoryTheory.Limits.limit.{u1, u1, u1, max u1 u2} J _inst_1 (CategoryTheory.Functor.{u1, u1, u1, u2} K _inst_2 C _inst_5) (CategoryTheory.Functor.category.{u1, u1, u1, u2} K _inst_2 C _inst_5) F (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u1, u1, max u1 u2} (CategoryTheory.Functor.{u1, u1, u1, u2} K _inst_2 C _inst_5) (CategoryTheory.Functor.category.{u1, u1, u1, u2} K _inst_2 C _inst_5) J _inst_1 (CategoryTheory.Limits.functorCategoryHasLimitsOfShape.{u1, u1, u1, u1, u1, u2} C _inst_5 J _inst_1 K _inst_2 _inst_7) F)) a) (CategoryTheory.Limits.colimit.{u1, u1, u1, u2} K _inst_2 C _inst_5 (CategoryTheory.Limits.limit.{u1, u1, u1, max u1 u2} J _inst_1 (CategoryTheory.Functor.{u1, u1, u1, u2} K _inst_2 C _inst_5) (CategoryTheory.Functor.category.{u1, u1, u1, u2} K _inst_2 C _inst_5) F (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u1, u1, max u1 u2} (CategoryTheory.Functor.{u1, u1, u1, u2} K _inst_2 C _inst_5) (CategoryTheory.Functor.category.{u1, u1, u1, u2} K _inst_2 C _inst_5) J _inst_1 (CategoryTheory.Limits.functorCategoryHasLimitsOfShape.{u1, u1, u1, u1, u1, u2} C _inst_5 J _inst_1 K _inst_2 _inst_7) F)) (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u1, u1, u1, u2} C _inst_5 K _inst_2 _inst_8 (CategoryTheory.Limits.limit.{u1, u1, u1, max u1 u2} J _inst_1 (CategoryTheory.Functor.{u1, u1, u1, u2} K _inst_2 C _inst_5) (CategoryTheory.Functor.category.{u1, u1, u1, u2} K _inst_2 C _inst_5) F (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u1, u1, max u1 u2} (CategoryTheory.Functor.{u1, u1, u1, u2} K _inst_2 C _inst_5) (CategoryTheory.Functor.category.{u1, u1, u1, u2} K _inst_2 C _inst_5) J _inst_1 (CategoryTheory.Limits.functorCategoryHasLimitsOfShape.{u1, u1, u1, u1, u1, u2} C _inst_5 J _inst_1 K _inst_2 _inst_7) F)))) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_1 C _inst_5 (CategoryTheory.Limits.colimit.{u1, u1, u1, max u1 u2} K _inst_2 (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_1 C _inst_5) (CategoryTheory.Functor.category.{u1, u1, u1, u2} J _inst_1 C _inst_5) (CategoryTheory.Functor.flip.{u1, u1, u1, u1, u1, u2} J _inst_1 K _inst_2 C _inst_5 F) (CategoryTheory.Limits.colimitLimitIso._proof_3.{u2, u1} J K _inst_1 _inst_2 C _inst_5 _inst_8 F)) b) (CategoryTheory.Limits.colimit.Î¹.{u1, u1, u1, u2} K _inst_2 C _inst_5 (CategoryTheory.Limits.limit.{u1, u1, u1, max u1 u2} J _inst_1 (CategoryTheory.Functor.{u1, u1, u1, u2} K _inst_2 C _inst_5) (CategoryTheory.Functor.category.{u1, u1, u1, u2} K _inst_2 C _inst_5) F (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u1, u1, max u1 u2} (CategoryTheory.Functor.{u1, u1, u1, u2} K _inst_2 C _inst_5) (CategoryTheory.Functor.category.{u1, u1, u1, u2} K _inst_2 C _inst_5) J _inst_1 (CategoryTheory.Limits.functorCategoryHasLimitsOfShape.{u1, u1, u1, u1, u1, u2} C _inst_5 J _inst_1 K _inst_2 _inst_7) F)) (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u1, u1, u1, u2} C _inst_5 K _inst_2 _inst_8 (CategoryTheory.Limits.limit.{u1, u1, u1, max u1 u2} J _inst_1 (CategoryTheory.Functor.{u1, u1, u1, u2} K _inst_2 C _inst_5) (CategoryTheory.Functor.category.{u1, u1, u1, u2} K _inst_2 C _inst_5) F (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u1, u1, max u1 u2} (CategoryTheory.Functor.{u1, u1, u1, u2} K _inst_2 C _inst_5) (CategoryTheory.Functor.category.{u1, u1, u1, u2} K _inst_2 C _inst_5) J _inst_1 (CategoryTheory.Limits.functorCategoryHasLimitsOfShape.{u1, u1, u1, u1, u1, u2} C _inst_5 J _inst_1 K _inst_2 _inst_7) F))) a) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_5) (CategoryTheory.Limits.colimit.{u1, u1, u1, u2} K _inst_2 C _inst_5 (CategoryTheory.Limits.limit.{u1, u1, u1, max u1 u2} J _inst_1 (CategoryTheory.Functor.{u1, u1, u1, u2} K _inst_2 C _inst_5) (CategoryTheory.Functor.category.{u1, u1, u1, u2} K _inst_2 C _inst_5) F (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u1, u1, max u1 u2} (CategoryTheory.Functor.{u1, u1, u1, u2} K _inst_2 C _inst_5) (CategoryTheory.Functor.category.{u1, u1, u1, u2} K _inst_2 C _inst_5) J _inst_1 (CategoryTheory.Limits.functorCategoryHasLimitsOfShape.{u1, u1, u1, u1, u1, u2} C _inst_5 J _inst_1 K _inst_2 _inst_7) F)) (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u1, u1, u1, u2} C _inst_5 K _inst_2 _inst_8 (CategoryTheory.Limits.limit.{u1, u1, u1, max u1 u2} J _inst_1 (CategoryTheory.Functor.{u1, u1, u1, u2} K _inst_2 C _inst_5) (CategoryTheory.Functor.category.{u1, u1, u1, u2} K _inst_2 C _inst_5) F (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u1, u1, max u1 u2} (CategoryTheory.Functor.{u1, u1, u1, u2} K _inst_2 C _inst_5) (CategoryTheory.Functor.category.{u1, u1, u1, u2} K _inst_2 C _inst_5) J _inst_1 (CategoryTheory.Limits.functorCategoryHasLimitsOfShape.{u1, u1, u1, u1, u1, u2} C _inst_5 J _inst_1 K _inst_2 _inst_7) F)))) (CategoryTheory.Limits.limit.{u1, u1, u1, u2} J _inst_1 C _inst_5 (CategoryTheory.Limits.colimit.{u1, u1, u1, max u1 u2} K _inst_2 (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_1 C _inst_5) (CategoryTheory.Functor.category.{u1, u1, u1, u2} J _inst_1 C _inst_5) (CategoryTheory.Functor.flip.{u1, u1, u1, u1, u1, u2} J _inst_1 K _inst_2 C _inst_5 F) (CategoryTheory.Limits.colimitLimitIso._proof_3.{u2, u1} J K _inst_1 _inst_2 C _inst_5 _inst_8 F)) (CategoryTheory.Limits.colimitLimitIso._proof_4.{u2, u1} J K _inst_1 _inst_2 C _inst_5 _inst_7 _inst_8 F)) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_1 C _inst_5 (CategoryTheory.Limits.colimit.{u1, u1, u1, max u1 u2} K _inst_2 (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_1 C _inst_5) (CategoryTheory.Functor.category.{u1, u1, u1, u2} J _inst_1 C _inst_5) (CategoryTheory.Functor.flip.{u1, u1, u1, u1, u1, u2} J _inst_1 K _inst_2 C _inst_5 F) (CategoryTheory.Limits.colimitLimitIso._proof_3.{u2, u1} J K _inst_1 _inst_2 C _inst_5 _inst_8 F)) b) (CategoryTheory.Iso.hom.{u1, u2} C _inst_5 (CategoryTheory.Limits.colimit.{u1, u1, u1, u2} K _inst_2 C _inst_5 (CategoryTheory.Limits.limit.{u1, u1, u1, max u1 u2} J _inst_1 (CategoryTheory.Functor.{u1, u1, u1, u2} K _inst_2 C _inst_5) (CategoryTheory.Functor.category.{u1, u1, u1, u2} K _inst_2 C _inst_5) F (CategoryTheory.Limits.colimitLimitIso._proof_1.{u2, u1} J K _inst_1 _inst_2 C _inst_5 _inst_7 F)) (CategoryTheory.Limits.colimitLimitIso._proof_2.{u2, u1} J K _inst_1 _inst_2 C _inst_5 _inst_7 _inst_8 F)) (CategoryTheory.Limits.limit.{u1, u1, u1, u2} J _inst_1 C _inst_5 (CategoryTheory.Limits.colimit.{u1, u1, u1, max u1 u2} K _inst_2 (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_1 C _inst_5) (CategoryTheory.Functor.category.{u1, u1, u1, u2} J _inst_1 C _inst_5) (CategoryTheory.Functor.flip.{u1, u1, u1, u1, u1, u2} J _inst_1 K _inst_2 C _inst_5 F) (CategoryTheory.Limits.colimitLimitIso._proof_3.{u2, u1} J K _inst_1 _inst_2 C _inst_5 _inst_8 F)) (CategoryTheory.Limits.colimitLimitIso._proof_4.{u2, u1} J K _inst_1 _inst_2 C _inst_5 _inst_7 _inst_8 F)) (CategoryTheory.Limits.colimitLimitIso.{u1, u2} J K _inst_1 _inst_2 _inst_3 _inst_4 C _inst_5 _inst_6 _inst_7 _inst_8 _inst_9 _inst_10 _inst_11 F)) (CategoryTheory.Limits.limit.Ï€.{u1, u1, u1, u2} J _inst_1 C _inst_5 (CategoryTheory.Limits.colimit.{u1, u1, u1, max u1 u2} K _inst_2 (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_1 C _inst_5) (CategoryTheory.Functor.category.{u1, u1, u1, u2} J _inst_1 C _inst_5) (CategoryTheory.Functor.flip.{u1, u1, u1, u1, u1, u2} J _inst_1 K _inst_2 C _inst_5 F) (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u1, u1, u1, max u1 u2} (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_1 C _inst_5) (CategoryTheory.Functor.category.{u1, u1, u1, u2} J _inst_1 C _inst_5) K _inst_2 (CategoryTheory.Limits.functorCategoryHasColimitsOfShape.{u1, u1, u1, u1, u1, u2} C _inst_5 K _inst_2 J _inst_1 _inst_8) (CategoryTheory.Functor.flip.{u1, u1, u1, u1, u1, u2} J _inst_1 K _inst_2 C _inst_5 F))) (CategoryTheory.Limits.colimitLimitIso._proof_4.{u2, u1} J K _inst_1 _inst_2 C _inst_5 _inst_7 _inst_8 F) b))) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_5) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} K _inst_2 C _inst_5 (CategoryTheory.Limits.limit.{u1, u1, u1, max u1 u2} J _inst_1 (CategoryTheory.Functor.{u1, u1, u1, u2} K _inst_2 C _inst_5) (CategoryTheory.Functor.category.{u1, u1, u1, u2} K _inst_2 C _inst_5) F (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u1, u1, max u1 u2} (CategoryTheory.Functor.{u1, u1, u1, u2} K _inst_2 C _inst_5) (CategoryTheory.Functor.category.{u1, u1, u1, u2} K _inst_2 C _inst_5) J _inst_1 (CategoryTheory.Limits.functorCategoryHasLimitsOfShape.{u1, u1, u1, u1, u1, u2} C _inst_5 J _inst_1 K _inst_2 _inst_7) F)) a) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} K _inst_2 C _inst_5 (CategoryTheory.Functor.obj.{u1, u1, u1, max u1 u2} J _inst_1 (CategoryTheory.Functor.{u1, u1, u1, u2} K _inst_2 C _inst_5) (CategoryTheory.Functor.category.{u1, u1, u1, u2} K _inst_2 C _inst_5) F b) a) (CategoryTheory.Functor.obj.{u1, u1, u1, u2} J _inst_1 C _inst_5 (CategoryTheory.Limits.colimit.{u1, u1, u1, max u1 u2} K _inst_2 (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_1 C _inst_5) (CategoryTheory.Functor.category.{u1, u1, u1, u2} J _inst_1 C _inst_5) (CategoryTheory.Functor.flip.{u1, u1, u1, u1, u1, u2} J _inst_1 K _inst_2 C _inst_5 F) (CategoryTheory.Limits.colimitLimitIso._proof_3.{u2, u1} J K _inst_1 _inst_2 C _inst_5 _inst_8 F)) b) (CategoryTheory.NatTrans.app.{u1, u1, u1, u2} K _inst_2 C _inst_5 (CategoryTheory.Limits.limit.{u1, u1, u1, max u1 u2} J _inst_1 (CategoryTheory.Functor.{u1, u1, u1, u2} K _inst_2 C _inst_5) (CategoryTheory.Functor.category.{u1, u1, u1, u2} K _inst_2 C _inst_5) F (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u1, u1, max u1 u2} (CategoryTheory.Functor.{u1, u1, u1, u2} K _inst_2 C _inst_5) (CategoryTheory.Functor.category.{u1, u1, u1, u2} K _inst_2 C _inst_5) J _inst_1 (CategoryTheory.Limits.functorCategoryHasLimitsOfShape.{u1, u1, u1, u1, u1, u2} C _inst_5 J _inst_1 K _inst_2 _inst_7) F)) (CategoryTheory.Functor.obj.{u1, u1, u1, max u1 u2} J _inst_1 (CategoryTheory.Functor.{u1, u1, u1, u2} K _inst_2 C _inst_5) (CategoryTheory.Functor.category.{u1, u1, u1, u2} K _inst_2 C _inst_5) F b) (CategoryTheory.Limits.limit.Ï€.{u1, u1, u1, max u1 u2} J _inst_1 (CategoryTheory.Functor.{u1, u1, u1, u2} K _inst_2 C _inst_5) (CategoryTheory.Functor.category.{u1, u1, u1, u2} K _inst_2 C _inst_5) F (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u1, u1, max u1 u2} (CategoryTheory.Functor.{u1, u1, u1, u2} K _inst_2 C _inst_5) (CategoryTheory.Functor.category.{u1, u1, u1, u2} K _inst_2 C _inst_5) J _inst_1 (CategoryTheory.Limits.functorCategoryHasLimitsOfShape.{u1, u1, u1, u1, u1, u2} C _inst_5 J _inst_1 K _inst_2 _inst_7) F) b) a) (CategoryTheory.NatTrans.app.{u1, u1, u1, u2} J _inst_1 C _inst_5 (CategoryTheory.Functor.obj.{u1, u1, u1, max u1 u2} K _inst_2 (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_1 C _inst_5) (CategoryTheory.Functor.category.{u1, u1, u1, u2} J _inst_1 C _inst_5) (CategoryTheory.Functor.flip.{u1, u1, u1, u1, u1, u2} J _inst_1 K _inst_2 C _inst_5 F) a) (CategoryTheory.Limits.colimit.{u1, u1, u1, max u1 u2} K _inst_2 (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_1 C _inst_5) (CategoryTheory.Functor.category.{u1, u1, u1, u2} J _inst_1 C _inst_5) (CategoryTheory.Functor.flip.{u1, u1, u1, u1, u1, u2} J _inst_1 K _inst_2 C _inst_5 F) (CategoryTheory.Limits.colimitLimitIso._proof_3.{u2, u1} J K _inst_1 _inst_2 C _inst_5 _inst_8 F)) (CategoryTheory.Limits.colimit.Î¹.{u1, u1, u1, max u1 u2} K _inst_2 (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_1 C _inst_5) (CategoryTheory.Functor.category.{u1, u1, u1, u2} J _inst_1 C _inst_5) (CategoryTheory.Functor.flip.{u1, u1, u1, u1, u1, u2} J _inst_1 K _inst_2 C _inst_5 F) (CategoryTheory.Limits.colimitLimitIso._proof_3.{u2, u1} J K _inst_1 _inst_2 C _inst_5 _inst_8 F) a) b))
but is expected to have type
  forall {J : Type.{u1}} {K : Type.{u1}} [_inst_1 : CategoryTheory.SmallCategory.{u1} J] [_inst_2 : CategoryTheory.SmallCategory.{u1} K] [_inst_3 : CategoryTheory.IsFiltered.{u1, u1} K _inst_2] [_inst_4 : CategoryTheory.FinCategory.{u1} J _inst_1] {C : Type.{u2}} [_inst_5 : CategoryTheory.Category.{u1, u2} C] [_inst_6 : CategoryTheory.ConcreteCategory.{u1, u1, u2} C _inst_5] [_inst_7 : CategoryTheory.Limits.HasLimitsOfShape.{u1, u1, u1, u2} J _inst_1 C _inst_5] [_inst_8 : CategoryTheory.Limits.HasColimitsOfShape.{u1, u1, u1, u2} K _inst_2 C _inst_5] [_inst_9 : CategoryTheory.Limits.ReflectsLimitsOfShape.{u1, u1, u1, u1, u2, succ u1} C _inst_5 Type.{u1} CategoryTheory.types.{u1} J _inst_1 (CategoryTheory.forget.{u2, u1, u1} C _inst_5 _inst_6)] [_inst_10 : CategoryTheory.Limits.PreservesColimitsOfShape.{u1, u1, u1, u1, u2, succ u1} C _inst_5 Type.{u1} CategoryTheory.types.{u1} K _inst_2 (CategoryTheory.forget.{u2, u1, u1} C _inst_5 _inst_6)] [_inst_11 : CategoryTheory.Limits.PreservesLimitsOfShape.{u1, u1, u1, u1, u2, succ u1} C _inst_5 Type.{u1} CategoryTheory.types.{u1} J _inst_1 (CategoryTheory.forget.{u2, u1, u1} C _inst_5 _inst_6)] (F : CategoryTheory.Functor.{u1, u1, u1, max u2 u1} J _inst_1 (CategoryTheory.Functor.{u1, u1, u1, u2} K _inst_2 C _inst_5) (CategoryTheory.Functor.category.{u1, u1, u1, u2} K _inst_2 C _inst_5)) (a : K) (b : J), Eq.{succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_5)) (Prefunctor.obj.{succ u1, succ u1, u1, u2} K (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} K (CategoryTheory.Category.toCategoryStruct.{u1, u1} K _inst_2)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_5)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} K _inst_2 C _inst_5 (CategoryTheory.Limits.limit.{u1, u1, u1, max u2 u1} J _inst_1 (CategoryTheory.Functor.{u1, u1, u1, u2} K _inst_2 C _inst_5) (CategoryTheory.Functor.category.{u1, u1, u1, u2} K _inst_2 C _inst_5) F (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u1, u1, max u2 u1} (CategoryTheory.Functor.{u1, u1, u1, u2} K _inst_2 C _inst_5) (CategoryTheory.Functor.category.{u1, u1, u1, u2} K _inst_2 C _inst_5) J _inst_1 (CategoryTheory.Limits.functorCategoryHasLimitsOfShape.{u1, u1, u1, u1, u1, u2} C _inst_5 J _inst_1 K _inst_2 _inst_7) F))) a) (Prefunctor.obj.{succ u1, succ u1, u1, u2} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_5)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} J _inst_1 C _inst_5 (CategoryTheory.Limits.colimit.{u1, u1, u1, max u2 u1} K _inst_2 (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_1 C _inst_5) (CategoryTheory.Functor.category.{u1, u1, u1, u2} J _inst_1 C _inst_5) (CategoryTheory.Functor.flip.{u1, u1, u1, u1, u1, u2} J _inst_1 K _inst_2 C _inst_5 F) (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u1, u1, u1, max u2 u1} (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_1 C _inst_5) (CategoryTheory.Functor.category.{u1, u1, u1, u2} J _inst_1 C _inst_5) K _inst_2 (CategoryTheory.Limits.functorCategoryHasColimitsOfShape.{u1, u1, u1, u1, u1, u2} C _inst_5 K _inst_2 J _inst_1 _inst_8) (CategoryTheory.Functor.flip.{u1, u1, u1, u1, u1, u2} J _inst_1 K _inst_2 C _inst_5 F)))) b)) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_5) (Prefunctor.obj.{succ u1, succ u1, u1, u2} K (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} K (CategoryTheory.Category.toCategoryStruct.{u1, u1} K _inst_2)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_5)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} K _inst_2 C _inst_5 (CategoryTheory.Limits.limit.{u1, u1, u1, max u2 u1} J _inst_1 (CategoryTheory.Functor.{u1, u1, u1, u2} K _inst_2 C _inst_5) (CategoryTheory.Functor.category.{u1, u1, u1, u2} K _inst_2 C _inst_5) F (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u1, u1, max u2 u1} (CategoryTheory.Functor.{u1, u1, u1, u2} K _inst_2 C _inst_5) (CategoryTheory.Functor.category.{u1, u1, u1, u2} K _inst_2 C _inst_5) J _inst_1 (CategoryTheory.Limits.functorCategoryHasLimitsOfShape.{u1, u1, u1, u1, u1, u2} C _inst_5 J _inst_1 K _inst_2 _inst_7) F))) a) (CategoryTheory.Limits.colimit.{u1, u1, u1, u2} K _inst_2 C _inst_5 (CategoryTheory.Limits.limit.{u1, u1, u1, max u2 u1} J _inst_1 (CategoryTheory.Functor.{u1, u1, u1, u2} K _inst_2 C _inst_5) (CategoryTheory.Functor.category.{u1, u1, u1, u2} K _inst_2 C _inst_5) F (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u1, u1, max u2 u1} (CategoryTheory.Functor.{u1, u1, u1, u2} K _inst_2 C _inst_5) (CategoryTheory.Functor.category.{u1, u1, u1, u2} K _inst_2 C _inst_5) J _inst_1 (CategoryTheory.Limits.functorCategoryHasLimitsOfShape.{u1, u1, u1, u1, u1, u2} C _inst_5 J _inst_1 K _inst_2 _inst_7) F)) (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u1, u1, u1, u2} C _inst_5 K _inst_2 _inst_8 (CategoryTheory.Limits.limit.{u1, u1, u1, max u2 u1} J _inst_1 (CategoryTheory.Functor.{u1, u1, u1, u2} K _inst_2 C _inst_5) (CategoryTheory.Functor.category.{u1, u1, u1, u2} K _inst_2 C _inst_5) F (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u1, u1, max u2 u1} (CategoryTheory.Functor.{u1, u1, u1, u2} K _inst_2 C _inst_5) (CategoryTheory.Functor.category.{u1, u1, u1, u2} K _inst_2 C _inst_5) J _inst_1 (CategoryTheory.Limits.functorCategoryHasLimitsOfShape.{u1, u1, u1, u1, u1, u2} C _inst_5 J _inst_1 K _inst_2 _inst_7) F)))) (Prefunctor.obj.{succ u1, succ u1, u1, u2} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_5)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} J _inst_1 C _inst_5 (CategoryTheory.Limits.colimit.{u1, u1, u1, max u2 u1} K _inst_2 (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_1 C _inst_5) (CategoryTheory.Functor.category.{u1, u1, u1, u2} J _inst_1 C _inst_5) (CategoryTheory.Functor.flip.{u1, u1, u1, u1, u1, u2} J _inst_1 K _inst_2 C _inst_5 F) (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u1, u1, u1, max u2 u1} (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_1 C _inst_5) (CategoryTheory.Functor.category.{u1, u1, u1, u2} J _inst_1 C _inst_5) K _inst_2 (CategoryTheory.Limits.functorCategoryHasColimitsOfShape.{u1, u1, u1, u1, u1, u2} C _inst_5 K _inst_2 J _inst_1 _inst_8) (CategoryTheory.Functor.flip.{u1, u1, u1, u1, u1, u2} J _inst_1 K _inst_2 C _inst_5 F)))) b) (CategoryTheory.Limits.colimit.Î¹.{u1, u1, u1, u2} K _inst_2 C _inst_5 (CategoryTheory.Limits.limit.{u1, u1, u1, max u2 u1} J _inst_1 (CategoryTheory.Functor.{u1, u1, u1, u2} K _inst_2 C _inst_5) (CategoryTheory.Functor.category.{u1, u1, u1, u2} K _inst_2 C _inst_5) F (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u1, u1, max u2 u1} (CategoryTheory.Functor.{u1, u1, u1, u2} K _inst_2 C _inst_5) (CategoryTheory.Functor.category.{u1, u1, u1, u2} K _inst_2 C _inst_5) J _inst_1 (CategoryTheory.Limits.functorCategoryHasLimitsOfShape.{u1, u1, u1, u1, u1, u2} C _inst_5 J _inst_1 K _inst_2 _inst_7) F)) (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u1, u1, u1, u2} C _inst_5 K _inst_2 _inst_8 (CategoryTheory.Limits.limit.{u1, u1, u1, max u2 u1} J _inst_1 (CategoryTheory.Functor.{u1, u1, u1, u2} K _inst_2 C _inst_5) (CategoryTheory.Functor.category.{u1, u1, u1, u2} K _inst_2 C _inst_5) F (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u1, u1, max u2 u1} (CategoryTheory.Functor.{u1, u1, u1, u2} K _inst_2 C _inst_5) (CategoryTheory.Functor.category.{u1, u1, u1, u2} K _inst_2 C _inst_5) J _inst_1 (CategoryTheory.Limits.functorCategoryHasLimitsOfShape.{u1, u1, u1, u1, u1, u2} C _inst_5 J _inst_1 K _inst_2 _inst_7) F))) a) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_5) (CategoryTheory.Limits.colimit.{u1, u1, u1, u2} K _inst_2 C _inst_5 (CategoryTheory.Limits.limit.{u1, u1, u1, max u2 u1} J _inst_1 (CategoryTheory.Functor.{u1, u1, u1, u2} K _inst_2 C _inst_5) (CategoryTheory.Functor.category.{u1, u1, u1, u2} K _inst_2 C _inst_5) F (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u1, u1, max u2 u1} (CategoryTheory.Functor.{u1, u1, u1, u2} K _inst_2 C _inst_5) (CategoryTheory.Functor.category.{u1, u1, u1, u2} K _inst_2 C _inst_5) J _inst_1 (CategoryTheory.Limits.functorCategoryHasLimitsOfShape.{u1, u1, u1, u1, u1, u2} C _inst_5 J _inst_1 K _inst_2 _inst_7) F)) (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u1, u1, u1, u2} C _inst_5 K _inst_2 _inst_8 (CategoryTheory.Limits.limit.{u1, u1, u1, max u2 u1} J _inst_1 (CategoryTheory.Functor.{u1, u1, u1, u2} K _inst_2 C _inst_5) (CategoryTheory.Functor.category.{u1, u1, u1, u2} K _inst_2 C _inst_5) F (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u1, u1, max u2 u1} (CategoryTheory.Functor.{u1, u1, u1, u2} K _inst_2 C _inst_5) (CategoryTheory.Functor.category.{u1, u1, u1, u2} K _inst_2 C _inst_5) J _inst_1 (CategoryTheory.Limits.functorCategoryHasLimitsOfShape.{u1, u1, u1, u1, u1, u2} C _inst_5 J _inst_1 K _inst_2 _inst_7) F)))) (CategoryTheory.Limits.limit.{u1, u1, u1, u2} J _inst_1 C _inst_5 (CategoryTheory.Limits.colimit.{u1, u1, u1, max u2 u1} K _inst_2 (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_1 C _inst_5) (CategoryTheory.Functor.category.{u1, u1, u1, u2} J _inst_1 C _inst_5) (CategoryTheory.Functor.flip.{u1, u1, u1, u1, u1, u2} J _inst_1 K _inst_2 C _inst_5 F) (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u1, u1, u1, max u2 u1} (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_1 C _inst_5) (CategoryTheory.Functor.category.{u1, u1, u1, u2} J _inst_1 C _inst_5) K _inst_2 (CategoryTheory.Limits.functorCategoryHasColimitsOfShape.{u1, u1, u1, u1, u1, u2} C _inst_5 K _inst_2 J _inst_1 _inst_8) (CategoryTheory.Functor.flip.{u1, u1, u1, u1, u1, u2} J _inst_1 K _inst_2 C _inst_5 F))) (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u1, u1, u2} C _inst_5 J _inst_1 _inst_7 (CategoryTheory.Limits.colimit.{u1, u1, u1, max u2 u1} K _inst_2 (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_1 C _inst_5) (CategoryTheory.Functor.category.{u1, u1, u1, u2} J _inst_1 C _inst_5) (CategoryTheory.Functor.flip.{u1, u1, u1, u1, u1, u2} J _inst_1 K _inst_2 C _inst_5 F) (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u1, u1, u1, max u2 u1} (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_1 C _inst_5) (CategoryTheory.Functor.category.{u1, u1, u1, u2} J _inst_1 C _inst_5) K _inst_2 (CategoryTheory.Limits.functorCategoryHasColimitsOfShape.{u1, u1, u1, u1, u1, u2} C _inst_5 K _inst_2 J _inst_1 _inst_8) (CategoryTheory.Functor.flip.{u1, u1, u1, u1, u1, u2} J _inst_1 K _inst_2 C _inst_5 F))))) (Prefunctor.obj.{succ u1, succ u1, u1, u2} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_5)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} J _inst_1 C _inst_5 (CategoryTheory.Limits.colimit.{u1, u1, u1, max u2 u1} K _inst_2 (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_1 C _inst_5) (CategoryTheory.Functor.category.{u1, u1, u1, u2} J _inst_1 C _inst_5) (CategoryTheory.Functor.flip.{u1, u1, u1, u1, u1, u2} J _inst_1 K _inst_2 C _inst_5 F) (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u1, u1, u1, max u2 u1} (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_1 C _inst_5) (CategoryTheory.Functor.category.{u1, u1, u1, u2} J _inst_1 C _inst_5) K _inst_2 (CategoryTheory.Limits.functorCategoryHasColimitsOfShape.{u1, u1, u1, u1, u1, u2} C _inst_5 K _inst_2 J _inst_1 _inst_8) (CategoryTheory.Functor.flip.{u1, u1, u1, u1, u1, u2} J _inst_1 K _inst_2 C _inst_5 F)))) b) (CategoryTheory.Iso.hom.{u1, u2} C _inst_5 (CategoryTheory.Limits.colimit.{u1, u1, u1, u2} K _inst_2 C _inst_5 (CategoryTheory.Limits.limit.{u1, u1, u1, max u2 u1} J _inst_1 (CategoryTheory.Functor.{u1, u1, u1, u2} K _inst_2 C _inst_5) (CategoryTheory.Functor.category.{u1, u1, u1, u2} K _inst_2 C _inst_5) F (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u1, u1, max u2 u1} (CategoryTheory.Functor.{u1, u1, u1, u2} K _inst_2 C _inst_5) (CategoryTheory.Functor.category.{u1, u1, u1, u2} K _inst_2 C _inst_5) J _inst_1 (CategoryTheory.Limits.functorCategoryHasLimitsOfShape.{u1, u1, u1, u1, u1, u2} C _inst_5 J _inst_1 K _inst_2 _inst_7) F)) (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u1, u1, u1, u2} C _inst_5 K _inst_2 _inst_8 (CategoryTheory.Limits.limit.{u1, u1, u1, max u2 u1} J _inst_1 (CategoryTheory.Functor.{u1, u1, u1, u2} K _inst_2 C _inst_5) (CategoryTheory.Functor.category.{u1, u1, u1, u2} K _inst_2 C _inst_5) F (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u1, u1, max u2 u1} (CategoryTheory.Functor.{u1, u1, u1, u2} K _inst_2 C _inst_5) (CategoryTheory.Functor.category.{u1, u1, u1, u2} K _inst_2 C _inst_5) J _inst_1 (CategoryTheory.Limits.functorCategoryHasLimitsOfShape.{u1, u1, u1, u1, u1, u2} C _inst_5 J _inst_1 K _inst_2 _inst_7) F)))) (CategoryTheory.Limits.limit.{u1, u1, u1, u2} J _inst_1 C _inst_5 (CategoryTheory.Limits.colimit.{u1, u1, u1, max u2 u1} K _inst_2 (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_1 C _inst_5) (CategoryTheory.Functor.category.{u1, u1, u1, u2} J _inst_1 C _inst_5) (CategoryTheory.Functor.flip.{u1, u1, u1, u1, u1, u2} J _inst_1 K _inst_2 C _inst_5 F) (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u1, u1, u1, max u2 u1} (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_1 C _inst_5) (CategoryTheory.Functor.category.{u1, u1, u1, u2} J _inst_1 C _inst_5) K _inst_2 (CategoryTheory.Limits.functorCategoryHasColimitsOfShape.{u1, u1, u1, u1, u1, u2} C _inst_5 K _inst_2 J _inst_1 _inst_8) (CategoryTheory.Functor.flip.{u1, u1, u1, u1, u1, u2} J _inst_1 K _inst_2 C _inst_5 F))) (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u1, u1, u2} C _inst_5 J _inst_1 _inst_7 (CategoryTheory.Limits.colimit.{u1, u1, u1, max u2 u1} K _inst_2 (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_1 C _inst_5) (CategoryTheory.Functor.category.{u1, u1, u1, u2} J _inst_1 C _inst_5) (CategoryTheory.Functor.flip.{u1, u1, u1, u1, u1, u2} J _inst_1 K _inst_2 C _inst_5 F) (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u1, u1, u1, max u2 u1} (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_1 C _inst_5) (CategoryTheory.Functor.category.{u1, u1, u1, u2} J _inst_1 C _inst_5) K _inst_2 (CategoryTheory.Limits.functorCategoryHasColimitsOfShape.{u1, u1, u1, u1, u1, u2} C _inst_5 K _inst_2 J _inst_1 _inst_8) (CategoryTheory.Functor.flip.{u1, u1, u1, u1, u1, u2} J _inst_1 K _inst_2 C _inst_5 F))))) (CategoryTheory.Limits.colimitLimitIso.{u1, u2} J K _inst_1 _inst_2 _inst_3 _inst_4 C _inst_5 _inst_6 _inst_7 _inst_8 _inst_9 _inst_10 _inst_11 F)) (CategoryTheory.Limits.limit.Ï€.{u1, u1, u1, u2} J _inst_1 C _inst_5 (CategoryTheory.Limits.colimit.{u1, u1, u1, max u2 u1} K _inst_2 (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_1 C _inst_5) (CategoryTheory.Functor.category.{u1, u1, u1, u2} J _inst_1 C _inst_5) (CategoryTheory.Functor.flip.{u1, u1, u1, u1, u1, u2} J _inst_1 K _inst_2 C _inst_5 F) (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u1, u1, u1, max u2 u1} (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_1 C _inst_5) (CategoryTheory.Functor.category.{u1, u1, u1, u2} J _inst_1 C _inst_5) K _inst_2 (CategoryTheory.Limits.functorCategoryHasColimitsOfShape.{u1, u1, u1, u1, u1, u2} C _inst_5 K _inst_2 J _inst_1 _inst_8) (CategoryTheory.Functor.flip.{u1, u1, u1, u1, u1, u2} J _inst_1 K _inst_2 C _inst_5 F))) (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u1, u1, u2} C _inst_5 J _inst_1 _inst_7 (CategoryTheory.Limits.colimit.{u1, u1, u1, max u2 u1} K _inst_2 (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_1 C _inst_5) (CategoryTheory.Functor.category.{u1, u1, u1, u2} J _inst_1 C _inst_5) (CategoryTheory.Functor.flip.{u1, u1, u1, u1, u1, u2} J _inst_1 K _inst_2 C _inst_5 F) (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u1, u1, u1, max u2 u1} (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_1 C _inst_5) (CategoryTheory.Functor.category.{u1, u1, u1, u2} J _inst_1 C _inst_5) K _inst_2 (CategoryTheory.Limits.functorCategoryHasColimitsOfShape.{u1, u1, u1, u1, u1, u2} C _inst_5 K _inst_2 J _inst_1 _inst_8) (CategoryTheory.Functor.flip.{u1, u1, u1, u1, u1, u2} J _inst_1 K _inst_2 C _inst_5 F)))) b))) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_5) (Prefunctor.obj.{succ u1, succ u1, u1, u2} K (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} K (CategoryTheory.Category.toCategoryStruct.{u1, u1} K _inst_2)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_5)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} K _inst_2 C _inst_5 (CategoryTheory.Limits.limit.{u1, u1, u1, max u2 u1} J _inst_1 (CategoryTheory.Functor.{u1, u1, u1, u2} K _inst_2 C _inst_5) (CategoryTheory.Functor.category.{u1, u1, u1, u2} K _inst_2 C _inst_5) F (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u1, u1, max u2 u1} (CategoryTheory.Functor.{u1, u1, u1, u2} K _inst_2 C _inst_5) (CategoryTheory.Functor.category.{u1, u1, u1, u2} K _inst_2 C _inst_5) J _inst_1 (CategoryTheory.Limits.functorCategoryHasLimitsOfShape.{u1, u1, u1, u1, u1, u2} C _inst_5 J _inst_1 K _inst_2 _inst_7) F))) a) (Prefunctor.obj.{succ u1, succ u1, u1, u2} K (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} K (CategoryTheory.Category.toCategoryStruct.{u1, u1} K _inst_2)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_5)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} K _inst_2 C _inst_5 (Prefunctor.obj.{succ u1, succ u1, u1, max u2 u1} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) (CategoryTheory.Functor.{u1, u1, u1, u2} K _inst_2 C _inst_5) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u2 u1} (CategoryTheory.Functor.{u1, u1, u1, u2} K _inst_2 C _inst_5) (CategoryTheory.Category.toCategoryStruct.{u1, max u2 u1} (CategoryTheory.Functor.{u1, u1, u1, u2} K _inst_2 C _inst_5) (CategoryTheory.Functor.category.{u1, u1, u1, u2} K _inst_2 C _inst_5))) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, max u2 u1} J _inst_1 (CategoryTheory.Functor.{u1, u1, u1, u2} K _inst_2 C _inst_5) (CategoryTheory.Functor.category.{u1, u1, u1, u2} K _inst_2 C _inst_5) F) b)) a) (Prefunctor.obj.{succ u1, succ u1, u1, u2} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_5)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, u2} J _inst_1 C _inst_5 (CategoryTheory.Limits.colimit.{u1, u1, u1, max u2 u1} K _inst_2 (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_1 C _inst_5) (CategoryTheory.Functor.category.{u1, u1, u1, u2} J _inst_1 C _inst_5) (CategoryTheory.Functor.flip.{u1, u1, u1, u1, u1, u2} J _inst_1 K _inst_2 C _inst_5 F) (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u1, u1, u1, max u2 u1} (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_1 C _inst_5) (CategoryTheory.Functor.category.{u1, u1, u1, u2} J _inst_1 C _inst_5) K _inst_2 (CategoryTheory.Limits.functorCategoryHasColimitsOfShape.{u1, u1, u1, u1, u1, u2} C _inst_5 K _inst_2 J _inst_1 _inst_8) (CategoryTheory.Functor.flip.{u1, u1, u1, u1, u1, u2} J _inst_1 K _inst_2 C _inst_5 F)))) b) (CategoryTheory.NatTrans.app.{u1, u1, u1, u2} K _inst_2 C _inst_5 (CategoryTheory.Limits.limit.{u1, u1, u1, max u2 u1} J _inst_1 (CategoryTheory.Functor.{u1, u1, u1, u2} K _inst_2 C _inst_5) (CategoryTheory.Functor.category.{u1, u1, u1, u2} K _inst_2 C _inst_5) F (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u1, u1, max u2 u1} (CategoryTheory.Functor.{u1, u1, u1, u2} K _inst_2 C _inst_5) (CategoryTheory.Functor.category.{u1, u1, u1, u2} K _inst_2 C _inst_5) J _inst_1 (CategoryTheory.Limits.functorCategoryHasLimitsOfShape.{u1, u1, u1, u1, u1, u2} C _inst_5 J _inst_1 K _inst_2 _inst_7) F)) (Prefunctor.obj.{succ u1, succ u1, u1, max u2 u1} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) (CategoryTheory.Functor.{u1, u1, u1, u2} K _inst_2 C _inst_5) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u2 u1} (CategoryTheory.Functor.{u1, u1, u1, u2} K _inst_2 C _inst_5) (CategoryTheory.Category.toCategoryStruct.{u1, max u2 u1} (CategoryTheory.Functor.{u1, u1, u1, u2} K _inst_2 C _inst_5) (CategoryTheory.Functor.category.{u1, u1, u1, u2} K _inst_2 C _inst_5))) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, max u2 u1} J _inst_1 (CategoryTheory.Functor.{u1, u1, u1, u2} K _inst_2 C _inst_5) (CategoryTheory.Functor.category.{u1, u1, u1, u2} K _inst_2 C _inst_5) F) b) (CategoryTheory.Limits.limit.Ï€.{u1, u1, u1, max u2 u1} J _inst_1 (CategoryTheory.Functor.{u1, u1, u1, u2} K _inst_2 C _inst_5) (CategoryTheory.Functor.category.{u1, u1, u1, u2} K _inst_2 C _inst_5) F (CategoryTheory.Limits.hasLimitOfHasLimitsOfShape.{u1, u1, u1, max u2 u1} (CategoryTheory.Functor.{u1, u1, u1, u2} K _inst_2 C _inst_5) (CategoryTheory.Functor.category.{u1, u1, u1, u2} K _inst_2 C _inst_5) J _inst_1 (CategoryTheory.Limits.functorCategoryHasLimitsOfShape.{u1, u1, u1, u1, u1, u2} C _inst_5 J _inst_1 K _inst_2 _inst_7) F) b) a) (CategoryTheory.NatTrans.app.{u1, u1, u1, u2} J _inst_1 C _inst_5 (Prefunctor.obj.{succ u1, succ u1, u1, max u2 u1} K (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} K (CategoryTheory.Category.toCategoryStruct.{u1, u1} K _inst_2)) (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_1 C _inst_5) (CategoryTheory.CategoryStruct.toQuiver.{u1, max u2 u1} (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_1 C _inst_5) (CategoryTheory.Category.toCategoryStruct.{u1, max u2 u1} (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_1 C _inst_5) (CategoryTheory.Functor.category.{u1, u1, u1, u2} J _inst_1 C _inst_5))) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, max u2 u1} K _inst_2 (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_1 C _inst_5) (CategoryTheory.Functor.category.{u1, u1, u1, u2} J _inst_1 C _inst_5) (CategoryTheory.Functor.flip.{u1, u1, u1, u1, u1, u2} J _inst_1 K _inst_2 C _inst_5 F)) a) (CategoryTheory.Limits.colimit.{u1, u1, u1, max u2 u1} K _inst_2 (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_1 C _inst_5) (CategoryTheory.Functor.category.{u1, u1, u1, u2} J _inst_1 C _inst_5) (CategoryTheory.Functor.flip.{u1, u1, u1, u1, u1, u2} J _inst_1 K _inst_2 C _inst_5 F) (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u1, u1, u1, max u2 u1} (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_1 C _inst_5) (CategoryTheory.Functor.category.{u1, u1, u1, u2} J _inst_1 C _inst_5) K _inst_2 (CategoryTheory.Limits.functorCategoryHasColimitsOfShape.{u1, u1, u1, u1, u1, u2} C _inst_5 K _inst_2 J _inst_1 _inst_8) (CategoryTheory.Functor.flip.{u1, u1, u1, u1, u1, u2} J _inst_1 K _inst_2 C _inst_5 F))) (CategoryTheory.Limits.colimit.Î¹.{u1, u1, u1, max u2 u1} K _inst_2 (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_1 C _inst_5) (CategoryTheory.Functor.category.{u1, u1, u1, u2} J _inst_1 C _inst_5) (CategoryTheory.Functor.flip.{u1, u1, u1, u1, u1, u2} J _inst_1 K _inst_2 C _inst_5 F) (CategoryTheory.Limits.hasColimitOfHasColimitsOfShape.{u1, u1, u1, max u2 u1} (CategoryTheory.Functor.{u1, u1, u1, u2} J _inst_1 C _inst_5) (CategoryTheory.Functor.category.{u1, u1, u1, u2} J _inst_1 C _inst_5) K _inst_2 (CategoryTheory.Limits.functorCategoryHasColimitsOfShape.{u1, u1, u1, u1, u1, u2} C _inst_5 K _inst_2 J _inst_1 _inst_8) (CategoryTheory.Functor.flip.{u1, u1, u1, u1, u1, u2} J _inst_1 K _inst_2 C _inst_5 F)) a) b))
Case conversion may be inaccurate. Consider using '#align category_theory.limits.Î¹_colimit_limit_iso_limit_Ï€ CategoryTheory.Limits.Î¹_colimitLimitIso_limit_Ï€â‚“'. -/
@[simp, reassoc.1]
theorem Î¹_colimitLimitIso_limit_Ï€ (F : J â¥¤ K â¥¤ C) (a) (b) :
    colimit.Î¹ (limit F) a â‰« (colimitLimitIso F).Hom â‰« limit.Ï€ (colimit F.flip) b =
      (limit.Ï€ F b).app a â‰« (colimit.Î¹ F.flip a).app b :=
  by
  dsimp [colimit_limit_iso]
  simp only [functor.map_cone_Ï€_app, iso.symm_hom,
    limits.limit.cone_point_unique_up_to_iso_hom_comp_assoc, limits.limit.cone_Ï€,
    limits.colimit.Î¹_map_assoc, limits.colimit_flip_iso_comp_colim_inv_app, assoc,
    limits.has_limit.iso_of_nat_iso_hom_Ï€]
  congr 1
  simp only [â† category.assoc, iso.comp_inv_eq,
    limits.colimit_obj_iso_colimit_comp_evaluation_Î¹_app_hom,
    limits.has_colimit.iso_of_nat_iso_Î¹_hom, nat_iso.of_components_hom_app]
  dsimp
  simp
#align category_theory.limits.Î¹_colimit_limit_iso_limit_Ï€ CategoryTheory.Limits.Î¹_colimitLimitIso_limit_Ï€

end

end CategoryTheory.Limits

