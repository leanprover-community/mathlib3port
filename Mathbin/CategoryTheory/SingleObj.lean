/-
Copyright (c) 2019 Yury Kudryashov. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Yury Kudryashov

! This file was ported from Lean 3 source module category_theory.single_obj
! leanprover-community/mathlib commit c085f3044fe585c575e322bfab45b3633c48d820
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.CategoryTheory.Endomorphism
import Mathbin.CategoryTheory.Category.Cat
import Mathbin.Algebra.Category.Mon.Basic
import Mathbin.Combinatorics.Quiver.SingleObj

/-!
# Single-object category

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

Single object category with a given monoid of endomorphisms.
It is defined to facilitate transfering some definitions and lemmas (e.g., conjugacy etc.)
from category theory to monoids and groups.

## Main definitions

Given a type `Î±` with a monoid structure, `single_obj Î±` is `unit` type with `category` structure
such that `End (single_obj Î±).star` is the monoid `Î±`.  This can be extended to a functor `Mon â¥¤
Cat`.

If `Î±` is a group, then `single_obj Î±` is a groupoid.

An element `x : Î±` can be reinterpreted as an element of `End (single_obj.star Î±)` using
`single_obj.to_End`.

## Implementation notes

- `category_struct.comp` on `End (single_obj.star Î±)` is `flip (*)`, not `(*)`. This way
  multiplication on `End` agrees with the multiplication on `Î±`.

- By default, Lean puts instances into `category_theory` namespace instead of
  `category_theory.single_obj`, so we give all names explicitly.
-/


universe u v w

namespace CategoryTheory

#print CategoryTheory.SingleObj /-
/-- Abbreviation that allows writing `category_theory.single_obj` rather than `quiver.single_obj`.
-/
abbrev SingleObj :=
  Quiver.SingleObj
#align category_theory.single_obj CategoryTheory.SingleObj
-/

namespace SingleObj

variable (Î± : Type u)

#print CategoryTheory.SingleObj.categoryStruct /-
/-- One and `flip (*)` become `id` and `comp` for morphisms of the single object category. -/
instance categoryStruct [One Î±] [Mul Î±] : CategoryStruct (SingleObj Î±)
    where
  Hom _ _ := Î±
  comp _ _ _ x y := y * x
  id _ := 1
#align category_theory.single_obj.category_struct CategoryTheory.SingleObj.categoryStruct
-/

#print CategoryTheory.SingleObj.category /-
/-- Monoid laws become category laws for the single object category. -/
instance category [Monoid Î±] : Category (SingleObj Î±)
    where
  comp_id' _ _ := one_mul
  id_comp' _ _ := mul_one
  assoc' _ _ _ _ x y z := (mul_assoc z y x).symm
#align category_theory.single_obj.category CategoryTheory.SingleObj.category
-/

/- warning: category_theory.single_obj.id_as_one -> CategoryTheory.SingleObj.id_as_one is a dubious translation:
lean 3 declaration is
  forall (Î± : Type.{u1}) [_inst_1 : Monoid.{u1} Î±] (x : CategoryTheory.SingleObj.{u1} Î±), Eq.{succ u1} (Quiver.Hom.{succ u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.categoryStruct.{u1} Î± (MulOneClass.toHasOne.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1)) (MulOneClass.toHasMul.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1)))) x x) (CategoryTheory.CategoryStruct.id.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.categoryStruct.{u1} Î± (MulOneClass.toHasOne.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1)) (MulOneClass.toHasMul.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1))) x) (OfNat.ofNat.{u1} (Quiver.Hom.{succ u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.categoryStruct.{u1} Î± (MulOneClass.toHasOne.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1)) (MulOneClass.toHasMul.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1)))) x x) 1 (OfNat.mk.{u1} (Quiver.Hom.{succ u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.categoryStruct.{u1} Î± (MulOneClass.toHasOne.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1)) (MulOneClass.toHasMul.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1)))) x x) 1 (One.one.{u1} (Quiver.Hom.{succ u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.categoryStruct.{u1} Î± (MulOneClass.toHasOne.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1)) (MulOneClass.toHasMul.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1)))) x x) (MulOneClass.toHasOne.{u1} (Quiver.Hom.{succ u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.categoryStruct.{u1} Î± (MulOneClass.toHasOne.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1)) (MulOneClass.toHasMul.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1)))) x x) (Monoid.toMulOneClass.{u1} (Quiver.Hom.{succ u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.categoryStruct.{u1} Î± (MulOneClass.toHasOne.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1)) (MulOneClass.toHasMul.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1)))) x x) _inst_1)))))
but is expected to have type
  forall (Î± : Type.{u1}) [_inst_1 : Monoid.{u1} Î±] (x : CategoryTheory.SingleObj.{u1} Î±), Eq.{succ u1} (Quiver.Hom.{succ u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.categoryStruct.{u1} Î± (Monoid.toOne.{u1} Î± _inst_1) (MulOneClass.toMul.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1)))) x x) (CategoryTheory.CategoryStruct.id.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.categoryStruct.{u1} Î± (Monoid.toOne.{u1} Î± _inst_1) (MulOneClass.toMul.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1))) x) (OfNat.ofNat.{u1} (Quiver.Hom.{succ u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.categoryStruct.{u1} Î± (Monoid.toOne.{u1} Î± _inst_1) (MulOneClass.toMul.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1)))) x x) 1 (One.toOfNat1.{u1} (Quiver.Hom.{succ u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.categoryStruct.{u1} Î± (Monoid.toOne.{u1} Î± _inst_1) (MulOneClass.toMul.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1)))) x x) (Monoid.toOne.{u1} (Quiver.Hom.{succ u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.categoryStruct.{u1} Î± (Monoid.toOne.{u1} Î± _inst_1) (MulOneClass.toMul.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1)))) x x) _inst_1)))
Case conversion may be inaccurate. Consider using '#align category_theory.single_obj.id_as_one CategoryTheory.SingleObj.id_as_oneâ‚“'. -/
theorem id_as_one [Monoid Î±] (x : SingleObj Î±) : ðŸ™ x = 1 :=
  rfl
#align category_theory.single_obj.id_as_one CategoryTheory.SingleObj.id_as_one

/- warning: category_theory.single_obj.comp_as_mul -> CategoryTheory.SingleObj.comp_as_mul is a dubious translation:
lean 3 declaration is
  forall (Î± : Type.{u1}) [_inst_1 : Monoid.{u1} Î±] {x : CategoryTheory.SingleObj.{u1} Î±} {y : CategoryTheory.SingleObj.{u1} Î±} {z : CategoryTheory.SingleObj.{u1} Î±} (f : Quiver.Hom.{succ u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (Quiver.SingleObj.quiver.{u1} Î±) x y) (g : Quiver.Hom.{succ u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (Quiver.SingleObj.quiver.{u1} Î±) y z), Eq.{succ u1} (Quiver.Hom.{succ u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.categoryStruct.{u1} Î± (MulOneClass.toHasOne.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1)) (MulOneClass.toHasMul.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1)))) x z) (CategoryTheory.CategoryStruct.comp.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.categoryStruct.{u1} Î± (MulOneClass.toHasOne.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1)) (MulOneClass.toHasMul.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1))) x y z f g) (HMul.hMul.{u1, u1, u1} (Quiver.Hom.{succ u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.categoryStruct.{u1} Î± (MulOneClass.toHasOne.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1)) (MulOneClass.toHasMul.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1)))) x z) (Quiver.Hom.{succ u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.categoryStruct.{u1} Î± (MulOneClass.toHasOne.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1)) (MulOneClass.toHasMul.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1)))) x z) (Quiver.Hom.{succ u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.categoryStruct.{u1} Î± (MulOneClass.toHasOne.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1)) (MulOneClass.toHasMul.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1)))) x z) (instHMul.{u1} (Quiver.Hom.{succ u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.categoryStruct.{u1} Î± (MulOneClass.toHasOne.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1)) (MulOneClass.toHasMul.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1)))) x z) (MulOneClass.toHasMul.{u1} (Quiver.Hom.{succ u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.categoryStruct.{u1} Î± (MulOneClass.toHasOne.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1)) (MulOneClass.toHasMul.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1)))) x z) (Monoid.toMulOneClass.{u1} (Quiver.Hom.{succ u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.categoryStruct.{u1} Î± (MulOneClass.toHasOne.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1)) (MulOneClass.toHasMul.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1)))) x z) _inst_1))) g f)
but is expected to have type
  forall (Î± : Type.{u1}) [_inst_1 : Monoid.{u1} Î±] {x : CategoryTheory.SingleObj.{u1} Î±} {y : CategoryTheory.SingleObj.{u1} Î±} {z : CategoryTheory.SingleObj.{u1} Î±} (f : Quiver.Hom.{succ u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (Quiver.SingleObj.instQuiverSingleObj.{u1} Î±) x y) (g : Quiver.Hom.{succ u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (Quiver.SingleObj.instQuiverSingleObj.{u1} Î±) y z), Eq.{succ u1} (Quiver.Hom.{succ u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.categoryStruct.{u1} Î± (Monoid.toOne.{u1} Î± _inst_1) (MulOneClass.toMul.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1)))) x z) (CategoryTheory.CategoryStruct.comp.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.categoryStruct.{u1} Î± (Monoid.toOne.{u1} Î± _inst_1) (MulOneClass.toMul.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1))) x y z f g) (HMul.hMul.{u1, u1, u1} (Quiver.Hom.{succ u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (Quiver.SingleObj.instQuiverSingleObj.{u1} Î±) y z) (Quiver.Hom.{succ u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (Quiver.SingleObj.instQuiverSingleObj.{u1} Î±) x y) (Quiver.Hom.{succ u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (Quiver.SingleObj.instQuiverSingleObj.{u1} Î±) y z) (instHMul.{u1} (Quiver.Hom.{succ u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (Quiver.SingleObj.instQuiverSingleObj.{u1} Î±) y z) (MulOneClass.toMul.{u1} (Quiver.Hom.{succ u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (Quiver.SingleObj.instQuiverSingleObj.{u1} Î±) y z) (Monoid.toMulOneClass.{u1} (Quiver.Hom.{succ u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (Quiver.SingleObj.instQuiverSingleObj.{u1} Î±) y z) _inst_1))) g f)
Case conversion may be inaccurate. Consider using '#align category_theory.single_obj.comp_as_mul CategoryTheory.SingleObj.comp_as_mulâ‚“'. -/
theorem comp_as_mul [Monoid Î±] {x y z : SingleObj Î±} (f : x âŸ¶ y) (g : y âŸ¶ z) : f â‰« g = g * f :=
  rfl
#align category_theory.single_obj.comp_as_mul CategoryTheory.SingleObj.comp_as_mul

#print CategoryTheory.SingleObj.groupoid /-
/-- Groupoid structure on `single_obj Î±`.

See <https://stacks.math.columbia.edu/tag/0019>.
-/
instance groupoid [Group Î±] : Groupoid (SingleObj Î±)
    where
  inv _ _ x := xâ»Â¹
  inv_comp' _ _ := mul_right_inv
  comp_inv' _ _ := mul_left_inv
#align category_theory.single_obj.groupoid CategoryTheory.SingleObj.groupoid
-/

/- warning: category_theory.single_obj.inv_as_inv -> CategoryTheory.SingleObj.inv_as_inv is a dubious translation:
lean 3 declaration is
  forall (Î± : Type.{u1}) [_inst_1 : Group.{u1} Î±] {x : CategoryTheory.SingleObj.{u1} Î±} {y : CategoryTheory.SingleObj.{u1} Î±} (f : Quiver.Hom.{succ u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (Quiver.SingleObj.quiver.{u1} Î±) x y), Eq.{succ u1} (Quiver.Hom.{succ u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.category.{u1} Î± (DivInvMonoid.toMonoid.{u1} Î± (Group.toDivInvMonoid.{u1} Î± _inst_1))))) y x) (CategoryTheory.inv.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.category.{u1} Î± (DivInvMonoid.toMonoid.{u1} Î± (Group.toDivInvMonoid.{u1} Î± _inst_1))) x y f (CategoryTheory.IsIso.of_groupoid.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.groupoid.{u1} Î± _inst_1) x y f)) (Inv.inv.{u1} (Quiver.Hom.{succ u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.category.{u1} Î± (DivInvMonoid.toMonoid.{u1} Î± (Group.toDivInvMonoid.{u1} Î± _inst_1))))) y x) (DivInvMonoid.toHasInv.{u1} (Quiver.Hom.{succ u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.category.{u1} Î± (DivInvMonoid.toMonoid.{u1} Î± (Group.toDivInvMonoid.{u1} Î± _inst_1))))) y x) (Group.toDivInvMonoid.{u1} (Quiver.Hom.{succ u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.category.{u1} Î± (DivInvMonoid.toMonoid.{u1} Î± (Group.toDivInvMonoid.{u1} Î± _inst_1))))) y x) _inst_1)) f)
but is expected to have type
  forall (Î± : Type.{u1}) [_inst_1 : Group.{u1} Î±] {x : CategoryTheory.SingleObj.{u1} Î±} {y : CategoryTheory.SingleObj.{u1} Î±} (f : Quiver.Hom.{succ u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (Quiver.SingleObj.instQuiverSingleObj.{u1} Î±) x y), Eq.{succ u1} (Quiver.Hom.{succ u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.category.{u1} Î± (DivInvMonoid.toMonoid.{u1} Î± (Group.toDivInvMonoid.{u1} Î± _inst_1))))) y x) (CategoryTheory.inv.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.category.{u1} Î± (DivInvMonoid.toMonoid.{u1} Î± (Group.toDivInvMonoid.{u1} Î± _inst_1))) x y f (CategoryTheory.IsIso.of_groupoid.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.groupoid.{u1} Î± _inst_1) x y f)) (Inv.inv.{u1} (Quiver.Hom.{succ u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (Quiver.SingleObj.instQuiverSingleObj.{u1} Î±) x y) (InvOneClass.toInv.{u1} (Quiver.Hom.{succ u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (Quiver.SingleObj.instQuiverSingleObj.{u1} Î±) x y) (DivInvOneMonoid.toInvOneClass.{u1} (Quiver.Hom.{succ u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (Quiver.SingleObj.instQuiverSingleObj.{u1} Î±) x y) (DivisionMonoid.toDivInvOneMonoid.{u1} (Quiver.Hom.{succ u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (Quiver.SingleObj.instQuiverSingleObj.{u1} Î±) x y) (Group.toDivisionMonoid.{u1} (Quiver.Hom.{succ u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (Quiver.SingleObj.instQuiverSingleObj.{u1} Î±) x y) _inst_1)))) f)
Case conversion may be inaccurate. Consider using '#align category_theory.single_obj.inv_as_inv CategoryTheory.SingleObj.inv_as_invâ‚“'. -/
theorem inv_as_inv [Group Î±] {x y : SingleObj Î±} (f : x âŸ¶ y) : inv f = fâ»Â¹ :=
  by
  ext
  rw [comp_as_mul, inv_mul_self, id_as_one]
#align category_theory.single_obj.inv_as_inv CategoryTheory.SingleObj.inv_as_inv

#print CategoryTheory.SingleObj.star /-
/-- Abbreviation that allows writing `category_theory.single_obj.star` rather than
`quiver.single_obj.star`.
-/
abbrev star : SingleObj Î± :=
  Quiver.SingleObj.star Î±
#align category_theory.single_obj.star CategoryTheory.SingleObj.star
-/

/- warning: category_theory.single_obj.to_End -> CategoryTheory.SingleObj.toEnd is a dubious translation:
lean 3 declaration is
  forall (Î± : Type.{u1}) [_inst_1 : Monoid.{u1} Î±], MulEquiv.{u1, u1} Î± (CategoryTheory.End.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.categoryStruct.{u1} Î± (MulOneClass.toHasOne.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1)) (MulOneClass.toHasMul.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1))) (CategoryTheory.SingleObj.star.{u1} Î±)) (MulOneClass.toHasMul.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1)) (CategoryTheory.End.mul.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.categoryStruct.{u1} Î± (MulOneClass.toHasOne.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1)) (MulOneClass.toHasMul.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1))) (CategoryTheory.SingleObj.star.{u1} Î±))
but is expected to have type
  forall (Î± : Type.{u1}) [_inst_1 : Monoid.{u1} Î±], MulEquiv.{u1, u1} Î± (CategoryTheory.End.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.categoryStruct.{u1} Î± (Monoid.toOne.{u1} Î± _inst_1) (MulOneClass.toMul.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1))) (CategoryTheory.SingleObj.star.{u1} Î±)) (MulOneClass.toMul.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1)) (CategoryTheory.End.mul.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.categoryStruct.{u1} Î± (Monoid.toOne.{u1} Î± _inst_1) (MulOneClass.toMul.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1))) (CategoryTheory.SingleObj.star.{u1} Î±))
Case conversion may be inaccurate. Consider using '#align category_theory.single_obj.to_End CategoryTheory.SingleObj.toEndâ‚“'. -/
/-- The endomorphisms monoid of the only object in `single_obj Î±` is equivalent to the original
     monoid Î±. -/
def toEnd [Monoid Î±] : Î± â‰ƒ* End (SingleObj.star Î±) :=
  { Equiv.refl Î± with map_mul' := fun x y => rfl }
#align category_theory.single_obj.to_End CategoryTheory.SingleObj.toEnd

/- warning: category_theory.single_obj.to_End_def -> CategoryTheory.SingleObj.toEnd_def is a dubious translation:
lean 3 declaration is
  forall (Î± : Type.{u1}) [_inst_1 : Monoid.{u1} Î±] (x : Î±), Eq.{succ u1} (CategoryTheory.End.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.categoryStruct.{u1} Î± (MulOneClass.toHasOne.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1)) (MulOneClass.toHasMul.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1))) (CategoryTheory.SingleObj.star.{u1} Î±)) (coeFn.{succ u1, succ u1} (MulEquiv.{u1, u1} Î± (CategoryTheory.End.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.categoryStruct.{u1} Î± (MulOneClass.toHasOne.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1)) (MulOneClass.toHasMul.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1))) (CategoryTheory.SingleObj.star.{u1} Î±)) (MulOneClass.toHasMul.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1)) (CategoryTheory.End.mul.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.categoryStruct.{u1} Î± (MulOneClass.toHasOne.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1)) (MulOneClass.toHasMul.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1))) (CategoryTheory.SingleObj.star.{u1} Î±))) (fun (_x : MulEquiv.{u1, u1} Î± (CategoryTheory.End.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.categoryStruct.{u1} Î± (MulOneClass.toHasOne.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1)) (MulOneClass.toHasMul.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1))) (CategoryTheory.SingleObj.star.{u1} Î±)) (MulOneClass.toHasMul.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1)) (CategoryTheory.End.mul.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.categoryStruct.{u1} Î± (MulOneClass.toHasOne.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1)) (MulOneClass.toHasMul.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1))) (CategoryTheory.SingleObj.star.{u1} Î±))) => Î± -> (CategoryTheory.End.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.categoryStruct.{u1} Î± (MulOneClass.toHasOne.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1)) (MulOneClass.toHasMul.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1))) (CategoryTheory.SingleObj.star.{u1} Î±))) (MulEquiv.hasCoeToFun.{u1, u1} Î± (CategoryTheory.End.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.categoryStruct.{u1} Î± (MulOneClass.toHasOne.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1)) (MulOneClass.toHasMul.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1))) (CategoryTheory.SingleObj.star.{u1} Î±)) (MulOneClass.toHasMul.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1)) (CategoryTheory.End.mul.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.categoryStruct.{u1} Î± (MulOneClass.toHasOne.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1)) (MulOneClass.toHasMul.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1))) (CategoryTheory.SingleObj.star.{u1} Î±))) (CategoryTheory.SingleObj.toEnd.{u1} Î± _inst_1) x) x
but is expected to have type
  forall (Î± : Type.{u1}) [_inst_1 : Monoid.{u1} Î±] (x : Î±), Eq.{succ u1} ((fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Î±) => CategoryTheory.End.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.categoryStruct.{u1} Î± (Monoid.toOne.{u1} Î± _inst_1) (MulOneClass.toMul.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1))) (CategoryTheory.SingleObj.star.{u1} Î±)) x) (FunLike.coe.{succ u1, succ u1, succ u1} (MulEquiv.{u1, u1} Î± (CategoryTheory.End.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.categoryStruct.{u1} Î± (Monoid.toOne.{u1} Î± _inst_1) (MulOneClass.toMul.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1))) (CategoryTheory.SingleObj.star.{u1} Î±)) (MulOneClass.toMul.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1)) (CategoryTheory.End.mul.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.categoryStruct.{u1} Î± (Monoid.toOne.{u1} Î± _inst_1) (MulOneClass.toMul.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1))) (CategoryTheory.SingleObj.star.{u1} Î±))) Î± (fun (_x : Î±) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Î±) => CategoryTheory.End.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.categoryStruct.{u1} Î± (Monoid.toOne.{u1} Î± _inst_1) (MulOneClass.toMul.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1))) (CategoryTheory.SingleObj.star.{u1} Î±)) _x) (EmbeddingLike.toFunLike.{succ u1, succ u1, succ u1} (MulEquiv.{u1, u1} Î± (CategoryTheory.End.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.categoryStruct.{u1} Î± (Monoid.toOne.{u1} Î± _inst_1) (MulOneClass.toMul.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1))) (CategoryTheory.SingleObj.star.{u1} Î±)) (MulOneClass.toMul.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1)) (CategoryTheory.End.mul.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.categoryStruct.{u1} Î± (Monoid.toOne.{u1} Î± _inst_1) (MulOneClass.toMul.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1))) (CategoryTheory.SingleObj.star.{u1} Î±))) Î± (CategoryTheory.End.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.categoryStruct.{u1} Î± (Monoid.toOne.{u1} Î± _inst_1) (MulOneClass.toMul.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1))) (CategoryTheory.SingleObj.star.{u1} Î±)) (EquivLike.toEmbeddingLike.{succ u1, succ u1, succ u1} (MulEquiv.{u1, u1} Î± (CategoryTheory.End.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.categoryStruct.{u1} Î± (Monoid.toOne.{u1} Î± _inst_1) (MulOneClass.toMul.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1))) (CategoryTheory.SingleObj.star.{u1} Î±)) (MulOneClass.toMul.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1)) (CategoryTheory.End.mul.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.categoryStruct.{u1} Î± (Monoid.toOne.{u1} Î± _inst_1) (MulOneClass.toMul.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1))) (CategoryTheory.SingleObj.star.{u1} Î±))) Î± (CategoryTheory.End.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.categoryStruct.{u1} Î± (Monoid.toOne.{u1} Î± _inst_1) (MulOneClass.toMul.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1))) (CategoryTheory.SingleObj.star.{u1} Î±)) (MulEquivClass.toEquivLike.{u1, u1, u1} (MulEquiv.{u1, u1} Î± (CategoryTheory.End.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.categoryStruct.{u1} Î± (Monoid.toOne.{u1} Î± _inst_1) (MulOneClass.toMul.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1))) (CategoryTheory.SingleObj.star.{u1} Î±)) (MulOneClass.toMul.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1)) (CategoryTheory.End.mul.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.categoryStruct.{u1} Î± (Monoid.toOne.{u1} Î± _inst_1) (MulOneClass.toMul.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1))) (CategoryTheory.SingleObj.star.{u1} Î±))) Î± (CategoryTheory.End.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.categoryStruct.{u1} Î± (Monoid.toOne.{u1} Î± _inst_1) (MulOneClass.toMul.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1))) (CategoryTheory.SingleObj.star.{u1} Î±)) (MulOneClass.toMul.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1)) (CategoryTheory.End.mul.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.categoryStruct.{u1} Î± (Monoid.toOne.{u1} Î± _inst_1) (MulOneClass.toMul.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1))) (CategoryTheory.SingleObj.star.{u1} Î±)) (MulEquiv.instMulEquivClassMulEquiv.{u1, u1} Î± (CategoryTheory.End.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.categoryStruct.{u1} Î± (Monoid.toOne.{u1} Î± _inst_1) (MulOneClass.toMul.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1))) (CategoryTheory.SingleObj.star.{u1} Î±)) (MulOneClass.toMul.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1)) (CategoryTheory.End.mul.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.categoryStruct.{u1} Î± (Monoid.toOne.{u1} Î± _inst_1) (MulOneClass.toMul.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1))) (CategoryTheory.SingleObj.star.{u1} Î±)))))) (CategoryTheory.SingleObj.toEnd.{u1} Î± _inst_1) x) x
Case conversion may be inaccurate. Consider using '#align category_theory.single_obj.to_End_def CategoryTheory.SingleObj.toEnd_defâ‚“'. -/
theorem toEnd_def [Monoid Î±] (x : Î±) : toEnd Î± x = x :=
  rfl
#align category_theory.single_obj.to_End_def CategoryTheory.SingleObj.toEnd_def

#print CategoryTheory.SingleObj.mapHom /-
/-- There is a 1-1 correspondence between monoid homomorphisms `Î± â†’ Î²` and functors between the
    corresponding single-object categories. It means that `single_obj` is a fully faithful
    functor.

See <https://stacks.math.columbia.edu/tag/001F> --
although we do not characterize when the functor is full or faithful.
-/
def mapHom (Î± : Type u) (Î² : Type v) [Monoid Î±] [Monoid Î²] : (Î± â†’* Î²) â‰ƒ SingleObj Î± â¥¤ SingleObj Î²
    where
  toFun f :=
    { obj := id
      map := fun _ _ => â‡‘f
      map_id' := fun _ => f.map_one
      map_comp' := fun _ _ _ x y => f.map_mul y x }
  invFun f :=
    { toFun := @Functor.map _ _ _ _ f (SingleObj.star Î±) (SingleObj.star Î±)
      map_one' := f.map_id _
      map_mul' := fun x y => f.map_comp y x }
  left_inv := fun âŸ¨f, hâ‚, hâ‚‚âŸ© => rfl
  right_inv f := by cases f <;> obviously
#align category_theory.single_obj.map_hom CategoryTheory.SingleObj.mapHom
-/

#print CategoryTheory.SingleObj.mapHom_id /-
theorem mapHom_id (Î± : Type u) [Monoid Î±] : mapHom Î± Î± (MonoidHom.id Î±) = ðŸ­ _ :=
  rfl
#align category_theory.single_obj.map_hom_id CategoryTheory.SingleObj.mapHom_id
-/

#print CategoryTheory.SingleObj.mapHom_comp /-
theorem mapHom_comp {Î± : Type u} {Î² : Type v} [Monoid Î±] [Monoid Î²] (f : Î± â†’* Î²) {Î³ : Type w}
    [Monoid Î³] (g : Î² â†’* Î³) : mapHom Î± Î³ (g.comp f) = mapHom Î± Î² f â‹™ mapHom Î² Î³ g :=
  rfl
#align category_theory.single_obj.map_hom_comp CategoryTheory.SingleObj.mapHom_comp
-/

#print CategoryTheory.SingleObj.differenceFunctor /-
/-- Given a function `f : C â†’ G` from a category to a group, we get a functor
    `C â¥¤ G` sending any morphism `x âŸ¶ y` to `f y * (f x)â»Â¹`. -/
@[simps]
def differenceFunctor {C G} [Category C] [Group G] (f : C â†’ G) : C â¥¤ SingleObj G
    where
  obj _ := ()
  map x y _ := f y * (f x)â»Â¹
  map_id' := by
    intro
    rw [single_obj.id_as_one, mul_right_inv]
  map_comp' := by
    intros
    rw [single_obj.comp_as_mul, â† mul_assoc, mul_left_inj, mul_assoc, inv_mul_self, mul_one]
#align category_theory.single_obj.difference_functor CategoryTheory.SingleObj.differenceFunctor
-/

end SingleObj

end CategoryTheory

open CategoryTheory

namespace MonoidHom

#print MonoidHom.toFunctor /-
/-- Reinterpret a monoid homomorphism `f : Î± â†’ Î²` as a functor `(single_obj Î±) â¥¤ (single_obj Î²)`.
See also `category_theory.single_obj.map_hom` for an equivalence between these types. -/
@[reducible]
def toFunctor {Î± : Type u} {Î² : Type v} [Monoid Î±] [Monoid Î²] (f : Î± â†’* Î²) :
    SingleObj Î± â¥¤ SingleObj Î² :=
  SingleObj.mapHom Î± Î² f
#align monoid_hom.to_functor MonoidHom.toFunctor
-/

#print MonoidHom.id_toFunctor /-
@[simp]
theorem id_toFunctor (Î± : Type u) [Monoid Î±] : (id Î±).toFunctor = ðŸ­ _ :=
  rfl
#align monoid_hom.id_to_functor MonoidHom.id_toFunctor
-/

#print MonoidHom.comp_toFunctor /-
@[simp]
theorem comp_toFunctor {Î± : Type u} {Î² : Type v} [Monoid Î±] [Monoid Î²] (f : Î± â†’* Î²) {Î³ : Type w}
    [Monoid Î³] (g : Î² â†’* Î³) : (g.comp f).toFunctor = f.toFunctor â‹™ g.toFunctor :=
  rfl
#align monoid_hom.comp_to_functor MonoidHom.comp_toFunctor
-/

end MonoidHom

namespace Units

variable (Î± : Type u) [Monoid Î±]

/- warning: units.to_Aut -> Units.toAut is a dubious translation:
lean 3 declaration is
  forall (Î± : Type.{u1}) [_inst_1 : Monoid.{u1} Î±], MulEquiv.{u1, u1} (Units.{u1} Î± _inst_1) (CategoryTheory.Aut.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.category.{u1} Î± _inst_1) (CategoryTheory.SingleObj.star.{u1} Î±)) (MulOneClass.toHasMul.{u1} (Units.{u1} Î± _inst_1) (Units.mulOneClass.{u1} Î± _inst_1)) (MulOneClass.toHasMul.{u1} (CategoryTheory.Aut.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.category.{u1} Î± _inst_1) (CategoryTheory.SingleObj.star.{u1} Î±)) (Monoid.toMulOneClass.{u1} (CategoryTheory.Aut.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.category.{u1} Î± _inst_1) (CategoryTheory.SingleObj.star.{u1} Î±)) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Aut.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.category.{u1} Î± _inst_1) (CategoryTheory.SingleObj.star.{u1} Î±)) (Group.toDivInvMonoid.{u1} (CategoryTheory.Aut.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.category.{u1} Î± _inst_1) (CategoryTheory.SingleObj.star.{u1} Î±)) (CategoryTheory.Aut.group.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.category.{u1} Î± _inst_1) (CategoryTheory.SingleObj.star.{u1} Î±))))))
but is expected to have type
  forall (Î± : Type.{u1}) [_inst_1 : Monoid.{u1} Î±], MulEquiv.{u1, u1} (Units.{u1} Î± _inst_1) (CategoryTheory.Aut.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.category.{u1} Î± _inst_1) (CategoryTheory.SingleObj.star.{u1} Î±)) (MulOneClass.toMul.{u1} (Units.{u1} Î± _inst_1) (Units.instMulOneClassUnits.{u1} Î± _inst_1)) (MulOneClass.toMul.{u1} (CategoryTheory.Aut.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.category.{u1} Î± _inst_1) (CategoryTheory.SingleObj.star.{u1} Î±)) (Monoid.toMulOneClass.{u1} (CategoryTheory.Aut.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.category.{u1} Î± _inst_1) (CategoryTheory.SingleObj.star.{u1} Î±)) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Aut.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.category.{u1} Î± _inst_1) (CategoryTheory.SingleObj.star.{u1} Î±)) (Group.toDivInvMonoid.{u1} (CategoryTheory.Aut.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.category.{u1} Î± _inst_1) (CategoryTheory.SingleObj.star.{u1} Î±)) (CategoryTheory.Aut.instGroupAut.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.category.{u1} Î± _inst_1) (CategoryTheory.SingleObj.star.{u1} Î±))))))
Case conversion may be inaccurate. Consider using '#align units.to_Aut Units.toAutâ‚“'. -/
/-- The units in a monoid are (multiplicatively) equivalent to
the automorphisms of `star` when we think of the monoid as a single-object category. -/
def toAut : Î±Ë£ â‰ƒ* Aut (SingleObj.star Î±) :=
  (Units.mapEquiv (SingleObj.toEnd Î±)).trans <| Aut.unitsEndEquivAut _
#align units.to_Aut Units.toAut

/- warning: units.to_Aut_hom -> Units.toAut_hom is a dubious translation:
lean 3 declaration is
  forall (Î± : Type.{u1}) [_inst_1 : Monoid.{u1} Î±] (x : Units.{u1} Î± _inst_1), Eq.{succ u1} (Quiver.Hom.{succ u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.category.{u1} Î± _inst_1))) (CategoryTheory.SingleObj.star.{u1} Î±) (CategoryTheory.SingleObj.star.{u1} Î±)) (CategoryTheory.Iso.hom.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.category.{u1} Î± _inst_1) (CategoryTheory.SingleObj.star.{u1} Î±) (CategoryTheory.SingleObj.star.{u1} Î±) (coeFn.{succ u1, succ u1} (MulEquiv.{u1, u1} (Units.{u1} Î± _inst_1) (CategoryTheory.Aut.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.category.{u1} Î± _inst_1) (CategoryTheory.SingleObj.star.{u1} Î±)) (MulOneClass.toHasMul.{u1} (Units.{u1} Î± _inst_1) (Units.mulOneClass.{u1} Î± _inst_1)) (MulOneClass.toHasMul.{u1} (CategoryTheory.Aut.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.category.{u1} Î± _inst_1) (CategoryTheory.SingleObj.star.{u1} Î±)) (Monoid.toMulOneClass.{u1} (CategoryTheory.Aut.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.category.{u1} Î± _inst_1) (CategoryTheory.SingleObj.star.{u1} Î±)) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Aut.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.category.{u1} Î± _inst_1) (CategoryTheory.SingleObj.star.{u1} Î±)) (Group.toDivInvMonoid.{u1} (CategoryTheory.Aut.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.category.{u1} Î± _inst_1) (CategoryTheory.SingleObj.star.{u1} Î±)) (CategoryTheory.Aut.group.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.category.{u1} Î± _inst_1) (CategoryTheory.SingleObj.star.{u1} Î±))))))) (fun (_x : MulEquiv.{u1, u1} (Units.{u1} Î± _inst_1) (CategoryTheory.Aut.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.category.{u1} Î± _inst_1) (CategoryTheory.SingleObj.star.{u1} Î±)) (MulOneClass.toHasMul.{u1} (Units.{u1} Î± _inst_1) (Units.mulOneClass.{u1} Î± _inst_1)) (MulOneClass.toHasMul.{u1} (CategoryTheory.Aut.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.category.{u1} Î± _inst_1) (CategoryTheory.SingleObj.star.{u1} Î±)) (Monoid.toMulOneClass.{u1} (CategoryTheory.Aut.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.category.{u1} Î± _inst_1) (CategoryTheory.SingleObj.star.{u1} Î±)) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Aut.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.category.{u1} Î± _inst_1) (CategoryTheory.SingleObj.star.{u1} Î±)) (Group.toDivInvMonoid.{u1} (CategoryTheory.Aut.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.category.{u1} Î± _inst_1) (CategoryTheory.SingleObj.star.{u1} Î±)) (CategoryTheory.Aut.group.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.category.{u1} Î± _inst_1) (CategoryTheory.SingleObj.star.{u1} Î±))))))) => (Units.{u1} Î± _inst_1) -> (CategoryTheory.Aut.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.category.{u1} Î± _inst_1) (CategoryTheory.SingleObj.star.{u1} Î±))) (MulEquiv.hasCoeToFun.{u1, u1} (Units.{u1} Î± _inst_1) (CategoryTheory.Aut.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.category.{u1} Î± _inst_1) (CategoryTheory.SingleObj.star.{u1} Î±)) (MulOneClass.toHasMul.{u1} (Units.{u1} Î± _inst_1) (Units.mulOneClass.{u1} Î± _inst_1)) (MulOneClass.toHasMul.{u1} (CategoryTheory.Aut.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.category.{u1} Î± _inst_1) (CategoryTheory.SingleObj.star.{u1} Î±)) (Monoid.toMulOneClass.{u1} (CategoryTheory.Aut.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.category.{u1} Î± _inst_1) (CategoryTheory.SingleObj.star.{u1} Î±)) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Aut.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.category.{u1} Î± _inst_1) (CategoryTheory.SingleObj.star.{u1} Î±)) (Group.toDivInvMonoid.{u1} (CategoryTheory.Aut.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.category.{u1} Î± _inst_1) (CategoryTheory.SingleObj.star.{u1} Î±)) (CategoryTheory.Aut.group.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.category.{u1} Î± _inst_1) (CategoryTheory.SingleObj.star.{u1} Î±))))))) (Units.toAut.{u1} Î± _inst_1) x)) (coeFn.{succ u1, succ u1} (MulEquiv.{u1, u1} Î± (CategoryTheory.End.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.categoryStruct.{u1} Î± (MulOneClass.toHasOne.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1)) (MulOneClass.toHasMul.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1))) (CategoryTheory.SingleObj.star.{u1} Î±)) (MulOneClass.toHasMul.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1)) (CategoryTheory.End.mul.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.categoryStruct.{u1} Î± (MulOneClass.toHasOne.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1)) (MulOneClass.toHasMul.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1))) (CategoryTheory.SingleObj.star.{u1} Î±))) (fun (_x : MulEquiv.{u1, u1} Î± (CategoryTheory.End.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.categoryStruct.{u1} Î± (MulOneClass.toHasOne.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1)) (MulOneClass.toHasMul.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1))) (CategoryTheory.SingleObj.star.{u1} Î±)) (MulOneClass.toHasMul.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1)) (CategoryTheory.End.mul.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.categoryStruct.{u1} Î± (MulOneClass.toHasOne.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1)) (MulOneClass.toHasMul.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1))) (CategoryTheory.SingleObj.star.{u1} Î±))) => Î± -> (CategoryTheory.End.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.categoryStruct.{u1} Î± (MulOneClass.toHasOne.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1)) (MulOneClass.toHasMul.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1))) (CategoryTheory.SingleObj.star.{u1} Î±))) (MulEquiv.hasCoeToFun.{u1, u1} Î± (CategoryTheory.End.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.categoryStruct.{u1} Î± (MulOneClass.toHasOne.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1)) (MulOneClass.toHasMul.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1))) (CategoryTheory.SingleObj.star.{u1} Î±)) (MulOneClass.toHasMul.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1)) (CategoryTheory.End.mul.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.categoryStruct.{u1} Î± (MulOneClass.toHasOne.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1)) (MulOneClass.toHasMul.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1))) (CategoryTheory.SingleObj.star.{u1} Î±))) (CategoryTheory.SingleObj.toEnd.{u1} Î± _inst_1) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Units.{u1} Î± _inst_1) Î± (HasLiftT.mk.{succ u1, succ u1} (Units.{u1} Î± _inst_1) Î± (CoeTCâ‚“.coe.{succ u1, succ u1} (Units.{u1} Î± _inst_1) Î± (coeBase.{succ u1, succ u1} (Units.{u1} Î± _inst_1) Î± (Units.hasCoe.{u1} Î± _inst_1)))) x))
but is expected to have type
  forall (Î± : Type.{u1}) [_inst_1 : Monoid.{u1} Î±] (x : Units.{u1} Î± _inst_1), Eq.{succ u1} (Quiver.Hom.{succ u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.category.{u1} Î± _inst_1))) (CategoryTheory.SingleObj.star.{u1} Î±) (CategoryTheory.SingleObj.star.{u1} Î±)) (CategoryTheory.Iso.hom.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.category.{u1} Î± _inst_1) (CategoryTheory.SingleObj.star.{u1} Î±) (CategoryTheory.SingleObj.star.{u1} Î±) (FunLike.coe.{succ u1, succ u1, succ u1} (MulEquiv.{u1, u1} (Units.{u1} Î± _inst_1) (CategoryTheory.Aut.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.category.{u1} Î± _inst_1) (CategoryTheory.SingleObj.star.{u1} Î±)) (MulOneClass.toMul.{u1} (Units.{u1} Î± _inst_1) (Units.instMulOneClassUnits.{u1} Î± _inst_1)) (MulOneClass.toMul.{u1} (CategoryTheory.Aut.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.category.{u1} Î± _inst_1) (CategoryTheory.SingleObj.star.{u1} Î±)) (Monoid.toMulOneClass.{u1} (CategoryTheory.Aut.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.category.{u1} Î± _inst_1) (CategoryTheory.SingleObj.star.{u1} Î±)) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Aut.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.category.{u1} Î± _inst_1) (CategoryTheory.SingleObj.star.{u1} Î±)) (Group.toDivInvMonoid.{u1} (CategoryTheory.Aut.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.category.{u1} Î± _inst_1) (CategoryTheory.SingleObj.star.{u1} Î±)) (CategoryTheory.Aut.instGroupAut.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.category.{u1} Î± _inst_1) (CategoryTheory.SingleObj.star.{u1} Î±))))))) (Units.{u1} Î± _inst_1) (fun (_x : Units.{u1} Î± _inst_1) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Units.{u1} Î± _inst_1) => CategoryTheory.Aut.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.category.{u1} Î± _inst_1) (CategoryTheory.SingleObj.star.{u1} Î±)) _x) (EmbeddingLike.toFunLike.{succ u1, succ u1, succ u1} (MulEquiv.{u1, u1} (Units.{u1} Î± _inst_1) (CategoryTheory.Aut.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.category.{u1} Î± _inst_1) (CategoryTheory.SingleObj.star.{u1} Î±)) (MulOneClass.toMul.{u1} (Units.{u1} Î± _inst_1) (Units.instMulOneClassUnits.{u1} Î± _inst_1)) (MulOneClass.toMul.{u1} (CategoryTheory.Aut.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.category.{u1} Î± _inst_1) (CategoryTheory.SingleObj.star.{u1} Î±)) (Monoid.toMulOneClass.{u1} (CategoryTheory.Aut.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.category.{u1} Î± _inst_1) (CategoryTheory.SingleObj.star.{u1} Î±)) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Aut.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.category.{u1} Î± _inst_1) (CategoryTheory.SingleObj.star.{u1} Î±)) (Group.toDivInvMonoid.{u1} (CategoryTheory.Aut.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.category.{u1} Î± _inst_1) (CategoryTheory.SingleObj.star.{u1} Î±)) (CategoryTheory.Aut.instGroupAut.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.category.{u1} Î± _inst_1) (CategoryTheory.SingleObj.star.{u1} Î±))))))) (Units.{u1} Î± _inst_1) (CategoryTheory.Aut.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.category.{u1} Î± _inst_1) (CategoryTheory.SingleObj.star.{u1} Î±)) (EquivLike.toEmbeddingLike.{succ u1, succ u1, succ u1} (MulEquiv.{u1, u1} (Units.{u1} Î± _inst_1) (CategoryTheory.Aut.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.category.{u1} Î± _inst_1) (CategoryTheory.SingleObj.star.{u1} Î±)) (MulOneClass.toMul.{u1} (Units.{u1} Î± _inst_1) (Units.instMulOneClassUnits.{u1} Î± _inst_1)) (MulOneClass.toMul.{u1} (CategoryTheory.Aut.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.category.{u1} Î± _inst_1) (CategoryTheory.SingleObj.star.{u1} Î±)) (Monoid.toMulOneClass.{u1} (CategoryTheory.Aut.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.category.{u1} Î± _inst_1) (CategoryTheory.SingleObj.star.{u1} Î±)) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Aut.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.category.{u1} Î± _inst_1) (CategoryTheory.SingleObj.star.{u1} Î±)) (Group.toDivInvMonoid.{u1} (CategoryTheory.Aut.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.category.{u1} Î± _inst_1) (CategoryTheory.SingleObj.star.{u1} Î±)) (CategoryTheory.Aut.instGroupAut.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.category.{u1} Î± _inst_1) (CategoryTheory.SingleObj.star.{u1} Î±))))))) (Units.{u1} Î± _inst_1) (CategoryTheory.Aut.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.category.{u1} Î± _inst_1) (CategoryTheory.SingleObj.star.{u1} Î±)) (MulEquivClass.toEquivLike.{u1, u1, u1} (MulEquiv.{u1, u1} (Units.{u1} Î± _inst_1) (CategoryTheory.Aut.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.category.{u1} Î± _inst_1) (CategoryTheory.SingleObj.star.{u1} Î±)) (MulOneClass.toMul.{u1} (Units.{u1} Î± _inst_1) (Units.instMulOneClassUnits.{u1} Î± _inst_1)) (MulOneClass.toMul.{u1} (CategoryTheory.Aut.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.category.{u1} Î± _inst_1) (CategoryTheory.SingleObj.star.{u1} Î±)) (Monoid.toMulOneClass.{u1} (CategoryTheory.Aut.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.category.{u1} Î± _inst_1) (CategoryTheory.SingleObj.star.{u1} Î±)) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Aut.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.category.{u1} Î± _inst_1) (CategoryTheory.SingleObj.star.{u1} Î±)) (Group.toDivInvMonoid.{u1} (CategoryTheory.Aut.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.category.{u1} Î± _inst_1) (CategoryTheory.SingleObj.star.{u1} Î±)) (CategoryTheory.Aut.instGroupAut.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.category.{u1} Î± _inst_1) (CategoryTheory.SingleObj.star.{u1} Î±))))))) (Units.{u1} Î± _inst_1) (CategoryTheory.Aut.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.category.{u1} Î± _inst_1) (CategoryTheory.SingleObj.star.{u1} Î±)) (MulOneClass.toMul.{u1} (Units.{u1} Î± _inst_1) (Units.instMulOneClassUnits.{u1} Î± _inst_1)) (MulOneClass.toMul.{u1} (CategoryTheory.Aut.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.category.{u1} Î± _inst_1) (CategoryTheory.SingleObj.star.{u1} Î±)) (Monoid.toMulOneClass.{u1} (CategoryTheory.Aut.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.category.{u1} Î± _inst_1) (CategoryTheory.SingleObj.star.{u1} Î±)) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Aut.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.category.{u1} Î± _inst_1) (CategoryTheory.SingleObj.star.{u1} Î±)) (Group.toDivInvMonoid.{u1} (CategoryTheory.Aut.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.category.{u1} Î± _inst_1) (CategoryTheory.SingleObj.star.{u1} Î±)) (CategoryTheory.Aut.instGroupAut.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.category.{u1} Î± _inst_1) (CategoryTheory.SingleObj.star.{u1} Î±)))))) (MulEquiv.instMulEquivClassMulEquiv.{u1, u1} (Units.{u1} Î± _inst_1) (CategoryTheory.Aut.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.category.{u1} Î± _inst_1) (CategoryTheory.SingleObj.star.{u1} Î±)) (MulOneClass.toMul.{u1} (Units.{u1} Î± _inst_1) (Units.instMulOneClassUnits.{u1} Î± _inst_1)) (MulOneClass.toMul.{u1} (CategoryTheory.Aut.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.category.{u1} Î± _inst_1) (CategoryTheory.SingleObj.star.{u1} Î±)) (Monoid.toMulOneClass.{u1} (CategoryTheory.Aut.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.category.{u1} Î± _inst_1) (CategoryTheory.SingleObj.star.{u1} Î±)) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Aut.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.category.{u1} Î± _inst_1) (CategoryTheory.SingleObj.star.{u1} Î±)) (Group.toDivInvMonoid.{u1} (CategoryTheory.Aut.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.category.{u1} Î± _inst_1) (CategoryTheory.SingleObj.star.{u1} Î±)) (CategoryTheory.Aut.instGroupAut.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.category.{u1} Î± _inst_1) (CategoryTheory.SingleObj.star.{u1} Î±)))))))))) (Units.toAut.{u1} Î± _inst_1) x)) (FunLike.coe.{succ u1, succ u1, succ u1} (MulEquiv.{u1, u1} Î± (CategoryTheory.End.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.categoryStruct.{u1} Î± (Monoid.toOne.{u1} Î± _inst_1) (MulOneClass.toMul.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1))) (CategoryTheory.SingleObj.star.{u1} Î±)) (MulOneClass.toMul.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1)) (CategoryTheory.End.mul.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.categoryStruct.{u1} Î± (Monoid.toOne.{u1} Î± _inst_1) (MulOneClass.toMul.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1))) (CategoryTheory.SingleObj.star.{u1} Î±))) Î± (fun (_x : Î±) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Î±) => CategoryTheory.End.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.categoryStruct.{u1} Î± (Monoid.toOne.{u1} Î± _inst_1) (MulOneClass.toMul.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1))) (CategoryTheory.SingleObj.star.{u1} Î±)) _x) (EmbeddingLike.toFunLike.{succ u1, succ u1, succ u1} (MulEquiv.{u1, u1} Î± (CategoryTheory.End.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.categoryStruct.{u1} Î± (Monoid.toOne.{u1} Î± _inst_1) (MulOneClass.toMul.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1))) (CategoryTheory.SingleObj.star.{u1} Î±)) (MulOneClass.toMul.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1)) (CategoryTheory.End.mul.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.categoryStruct.{u1} Î± (Monoid.toOne.{u1} Î± _inst_1) (MulOneClass.toMul.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1))) (CategoryTheory.SingleObj.star.{u1} Î±))) Î± (CategoryTheory.End.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.categoryStruct.{u1} Î± (Monoid.toOne.{u1} Î± _inst_1) (MulOneClass.toMul.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1))) (CategoryTheory.SingleObj.star.{u1} Î±)) (EquivLike.toEmbeddingLike.{succ u1, succ u1, succ u1} (MulEquiv.{u1, u1} Î± (CategoryTheory.End.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.categoryStruct.{u1} Î± (Monoid.toOne.{u1} Î± _inst_1) (MulOneClass.toMul.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1))) (CategoryTheory.SingleObj.star.{u1} Î±)) (MulOneClass.toMul.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1)) (CategoryTheory.End.mul.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.categoryStruct.{u1} Î± (Monoid.toOne.{u1} Î± _inst_1) (MulOneClass.toMul.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1))) (CategoryTheory.SingleObj.star.{u1} Î±))) Î± (CategoryTheory.End.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.categoryStruct.{u1} Î± (Monoid.toOne.{u1} Î± _inst_1) (MulOneClass.toMul.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1))) (CategoryTheory.SingleObj.star.{u1} Î±)) (MulEquivClass.toEquivLike.{u1, u1, u1} (MulEquiv.{u1, u1} Î± (CategoryTheory.End.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.categoryStruct.{u1} Î± (Monoid.toOne.{u1} Î± _inst_1) (MulOneClass.toMul.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1))) (CategoryTheory.SingleObj.star.{u1} Î±)) (MulOneClass.toMul.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1)) (CategoryTheory.End.mul.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.categoryStruct.{u1} Î± (Monoid.toOne.{u1} Î± _inst_1) (MulOneClass.toMul.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1))) (CategoryTheory.SingleObj.star.{u1} Î±))) Î± (CategoryTheory.End.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.categoryStruct.{u1} Î± (Monoid.toOne.{u1} Î± _inst_1) (MulOneClass.toMul.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1))) (CategoryTheory.SingleObj.star.{u1} Î±)) (MulOneClass.toMul.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1)) (CategoryTheory.End.mul.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.categoryStruct.{u1} Î± (Monoid.toOne.{u1} Î± _inst_1) (MulOneClass.toMul.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1))) (CategoryTheory.SingleObj.star.{u1} Î±)) (MulEquiv.instMulEquivClassMulEquiv.{u1, u1} Î± (CategoryTheory.End.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.categoryStruct.{u1} Î± (Monoid.toOne.{u1} Î± _inst_1) (MulOneClass.toMul.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1))) (CategoryTheory.SingleObj.star.{u1} Î±)) (MulOneClass.toMul.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1)) (CategoryTheory.End.mul.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.categoryStruct.{u1} Î± (Monoid.toOne.{u1} Î± _inst_1) (MulOneClass.toMul.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1))) (CategoryTheory.SingleObj.star.{u1} Î±)))))) (CategoryTheory.SingleObj.toEnd.{u1} Î± _inst_1) (Units.val.{u1} Î± _inst_1 x))
Case conversion may be inaccurate. Consider using '#align units.to_Aut_hom Units.toAut_homâ‚“'. -/
@[simp]
theorem toAut_hom (x : Î±Ë£) : (toAut Î± x).Hom = SingleObj.toEnd Î± x :=
  rfl
#align units.to_Aut_hom Units.toAut_hom

/- warning: units.to_Aut_inv -> Units.toAut_inv is a dubious translation:
lean 3 declaration is
  forall (Î± : Type.{u1}) [_inst_1 : Monoid.{u1} Î±] (x : Units.{u1} Î± _inst_1), Eq.{succ u1} (Quiver.Hom.{succ u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.category.{u1} Î± _inst_1))) (CategoryTheory.SingleObj.star.{u1} Î±) (CategoryTheory.SingleObj.star.{u1} Î±)) (CategoryTheory.Iso.inv.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.category.{u1} Î± _inst_1) (CategoryTheory.SingleObj.star.{u1} Î±) (CategoryTheory.SingleObj.star.{u1} Î±) (coeFn.{succ u1, succ u1} (MulEquiv.{u1, u1} (Units.{u1} Î± _inst_1) (CategoryTheory.Aut.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.category.{u1} Î± _inst_1) (CategoryTheory.SingleObj.star.{u1} Î±)) (MulOneClass.toHasMul.{u1} (Units.{u1} Î± _inst_1) (Units.mulOneClass.{u1} Î± _inst_1)) (MulOneClass.toHasMul.{u1} (CategoryTheory.Aut.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.category.{u1} Î± _inst_1) (CategoryTheory.SingleObj.star.{u1} Î±)) (Monoid.toMulOneClass.{u1} (CategoryTheory.Aut.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.category.{u1} Î± _inst_1) (CategoryTheory.SingleObj.star.{u1} Î±)) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Aut.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.category.{u1} Î± _inst_1) (CategoryTheory.SingleObj.star.{u1} Î±)) (Group.toDivInvMonoid.{u1} (CategoryTheory.Aut.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.category.{u1} Î± _inst_1) (CategoryTheory.SingleObj.star.{u1} Î±)) (CategoryTheory.Aut.group.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.category.{u1} Î± _inst_1) (CategoryTheory.SingleObj.star.{u1} Î±))))))) (fun (_x : MulEquiv.{u1, u1} (Units.{u1} Î± _inst_1) (CategoryTheory.Aut.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.category.{u1} Î± _inst_1) (CategoryTheory.SingleObj.star.{u1} Î±)) (MulOneClass.toHasMul.{u1} (Units.{u1} Î± _inst_1) (Units.mulOneClass.{u1} Î± _inst_1)) (MulOneClass.toHasMul.{u1} (CategoryTheory.Aut.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.category.{u1} Î± _inst_1) (CategoryTheory.SingleObj.star.{u1} Î±)) (Monoid.toMulOneClass.{u1} (CategoryTheory.Aut.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.category.{u1} Î± _inst_1) (CategoryTheory.SingleObj.star.{u1} Î±)) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Aut.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.category.{u1} Î± _inst_1) (CategoryTheory.SingleObj.star.{u1} Î±)) (Group.toDivInvMonoid.{u1} (CategoryTheory.Aut.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.category.{u1} Î± _inst_1) (CategoryTheory.SingleObj.star.{u1} Î±)) (CategoryTheory.Aut.group.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.category.{u1} Î± _inst_1) (CategoryTheory.SingleObj.star.{u1} Î±))))))) => (Units.{u1} Î± _inst_1) -> (CategoryTheory.Aut.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.category.{u1} Î± _inst_1) (CategoryTheory.SingleObj.star.{u1} Î±))) (MulEquiv.hasCoeToFun.{u1, u1} (Units.{u1} Î± _inst_1) (CategoryTheory.Aut.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.category.{u1} Î± _inst_1) (CategoryTheory.SingleObj.star.{u1} Î±)) (MulOneClass.toHasMul.{u1} (Units.{u1} Î± _inst_1) (Units.mulOneClass.{u1} Î± _inst_1)) (MulOneClass.toHasMul.{u1} (CategoryTheory.Aut.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.category.{u1} Î± _inst_1) (CategoryTheory.SingleObj.star.{u1} Î±)) (Monoid.toMulOneClass.{u1} (CategoryTheory.Aut.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.category.{u1} Î± _inst_1) (CategoryTheory.SingleObj.star.{u1} Î±)) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Aut.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.category.{u1} Î± _inst_1) (CategoryTheory.SingleObj.star.{u1} Î±)) (Group.toDivInvMonoid.{u1} (CategoryTheory.Aut.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.category.{u1} Î± _inst_1) (CategoryTheory.SingleObj.star.{u1} Î±)) (CategoryTheory.Aut.group.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.category.{u1} Î± _inst_1) (CategoryTheory.SingleObj.star.{u1} Î±))))))) (Units.toAut.{u1} Î± _inst_1) x)) (coeFn.{succ u1, succ u1} (MulEquiv.{u1, u1} Î± (CategoryTheory.End.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.categoryStruct.{u1} Î± (MulOneClass.toHasOne.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1)) (MulOneClass.toHasMul.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1))) (CategoryTheory.SingleObj.star.{u1} Î±)) (MulOneClass.toHasMul.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1)) (CategoryTheory.End.mul.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.categoryStruct.{u1} Î± (MulOneClass.toHasOne.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1)) (MulOneClass.toHasMul.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1))) (CategoryTheory.SingleObj.star.{u1} Î±))) (fun (_x : MulEquiv.{u1, u1} Î± (CategoryTheory.End.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.categoryStruct.{u1} Î± (MulOneClass.toHasOne.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1)) (MulOneClass.toHasMul.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1))) (CategoryTheory.SingleObj.star.{u1} Î±)) (MulOneClass.toHasMul.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1)) (CategoryTheory.End.mul.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.categoryStruct.{u1} Î± (MulOneClass.toHasOne.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1)) (MulOneClass.toHasMul.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1))) (CategoryTheory.SingleObj.star.{u1} Î±))) => Î± -> (CategoryTheory.End.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.categoryStruct.{u1} Î± (MulOneClass.toHasOne.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1)) (MulOneClass.toHasMul.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1))) (CategoryTheory.SingleObj.star.{u1} Î±))) (MulEquiv.hasCoeToFun.{u1, u1} Î± (CategoryTheory.End.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.categoryStruct.{u1} Î± (MulOneClass.toHasOne.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1)) (MulOneClass.toHasMul.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1))) (CategoryTheory.SingleObj.star.{u1} Î±)) (MulOneClass.toHasMul.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1)) (CategoryTheory.End.mul.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.categoryStruct.{u1} Î± (MulOneClass.toHasOne.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1)) (MulOneClass.toHasMul.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1))) (CategoryTheory.SingleObj.star.{u1} Î±))) (CategoryTheory.SingleObj.toEnd.{u1} Î± _inst_1) ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Units.{u1} Î± _inst_1) Î± (HasLiftT.mk.{succ u1, succ u1} (Units.{u1} Î± _inst_1) Î± (CoeTCâ‚“.coe.{succ u1, succ u1} (Units.{u1} Î± _inst_1) Î± (coeBase.{succ u1, succ u1} (Units.{u1} Î± _inst_1) Î± (Units.hasCoe.{u1} Î± _inst_1)))) (Inv.inv.{u1} (Units.{u1} Î± _inst_1) (Units.hasInv.{u1} Î± _inst_1) x)))
but is expected to have type
  forall (Î± : Type.{u1}) [_inst_1 : Monoid.{u1} Î±] (x : Units.{u1} Î± _inst_1), Eq.{succ u1} (Quiver.Hom.{succ u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.CategoryStruct.toQuiver.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.Category.toCategoryStruct.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.category.{u1} Î± _inst_1))) (CategoryTheory.SingleObj.star.{u1} Î±) (CategoryTheory.SingleObj.star.{u1} Î±)) (CategoryTheory.Iso.inv.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.category.{u1} Î± _inst_1) (CategoryTheory.SingleObj.star.{u1} Î±) (CategoryTheory.SingleObj.star.{u1} Î±) (FunLike.coe.{succ u1, succ u1, succ u1} (MulEquiv.{u1, u1} (Units.{u1} Î± _inst_1) (CategoryTheory.Aut.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.category.{u1} Î± _inst_1) (CategoryTheory.SingleObj.star.{u1} Î±)) (MulOneClass.toMul.{u1} (Units.{u1} Î± _inst_1) (Units.instMulOneClassUnits.{u1} Î± _inst_1)) (MulOneClass.toMul.{u1} (CategoryTheory.Aut.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.category.{u1} Î± _inst_1) (CategoryTheory.SingleObj.star.{u1} Î±)) (Monoid.toMulOneClass.{u1} (CategoryTheory.Aut.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.category.{u1} Î± _inst_1) (CategoryTheory.SingleObj.star.{u1} Î±)) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Aut.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.category.{u1} Î± _inst_1) (CategoryTheory.SingleObj.star.{u1} Î±)) (Group.toDivInvMonoid.{u1} (CategoryTheory.Aut.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.category.{u1} Î± _inst_1) (CategoryTheory.SingleObj.star.{u1} Î±)) (CategoryTheory.Aut.instGroupAut.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.category.{u1} Î± _inst_1) (CategoryTheory.SingleObj.star.{u1} Î±))))))) (Units.{u1} Î± _inst_1) (fun (_x : Units.{u1} Î± _inst_1) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Units.{u1} Î± _inst_1) => CategoryTheory.Aut.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.category.{u1} Î± _inst_1) (CategoryTheory.SingleObj.star.{u1} Î±)) _x) (EmbeddingLike.toFunLike.{succ u1, succ u1, succ u1} (MulEquiv.{u1, u1} (Units.{u1} Î± _inst_1) (CategoryTheory.Aut.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.category.{u1} Î± _inst_1) (CategoryTheory.SingleObj.star.{u1} Î±)) (MulOneClass.toMul.{u1} (Units.{u1} Î± _inst_1) (Units.instMulOneClassUnits.{u1} Î± _inst_1)) (MulOneClass.toMul.{u1} (CategoryTheory.Aut.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.category.{u1} Î± _inst_1) (CategoryTheory.SingleObj.star.{u1} Î±)) (Monoid.toMulOneClass.{u1} (CategoryTheory.Aut.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.category.{u1} Î± _inst_1) (CategoryTheory.SingleObj.star.{u1} Î±)) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Aut.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.category.{u1} Î± _inst_1) (CategoryTheory.SingleObj.star.{u1} Î±)) (Group.toDivInvMonoid.{u1} (CategoryTheory.Aut.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.category.{u1} Î± _inst_1) (CategoryTheory.SingleObj.star.{u1} Î±)) (CategoryTheory.Aut.instGroupAut.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.category.{u1} Î± _inst_1) (CategoryTheory.SingleObj.star.{u1} Î±))))))) (Units.{u1} Î± _inst_1) (CategoryTheory.Aut.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.category.{u1} Î± _inst_1) (CategoryTheory.SingleObj.star.{u1} Î±)) (EquivLike.toEmbeddingLike.{succ u1, succ u1, succ u1} (MulEquiv.{u1, u1} (Units.{u1} Î± _inst_1) (CategoryTheory.Aut.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.category.{u1} Î± _inst_1) (CategoryTheory.SingleObj.star.{u1} Î±)) (MulOneClass.toMul.{u1} (Units.{u1} Î± _inst_1) (Units.instMulOneClassUnits.{u1} Î± _inst_1)) (MulOneClass.toMul.{u1} (CategoryTheory.Aut.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.category.{u1} Î± _inst_1) (CategoryTheory.SingleObj.star.{u1} Î±)) (Monoid.toMulOneClass.{u1} (CategoryTheory.Aut.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.category.{u1} Î± _inst_1) (CategoryTheory.SingleObj.star.{u1} Î±)) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Aut.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.category.{u1} Î± _inst_1) (CategoryTheory.SingleObj.star.{u1} Î±)) (Group.toDivInvMonoid.{u1} (CategoryTheory.Aut.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.category.{u1} Î± _inst_1) (CategoryTheory.SingleObj.star.{u1} Î±)) (CategoryTheory.Aut.instGroupAut.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.category.{u1} Î± _inst_1) (CategoryTheory.SingleObj.star.{u1} Î±))))))) (Units.{u1} Î± _inst_1) (CategoryTheory.Aut.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.category.{u1} Î± _inst_1) (CategoryTheory.SingleObj.star.{u1} Î±)) (MulEquivClass.toEquivLike.{u1, u1, u1} (MulEquiv.{u1, u1} (Units.{u1} Î± _inst_1) (CategoryTheory.Aut.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.category.{u1} Î± _inst_1) (CategoryTheory.SingleObj.star.{u1} Î±)) (MulOneClass.toMul.{u1} (Units.{u1} Î± _inst_1) (Units.instMulOneClassUnits.{u1} Î± _inst_1)) (MulOneClass.toMul.{u1} (CategoryTheory.Aut.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.category.{u1} Î± _inst_1) (CategoryTheory.SingleObj.star.{u1} Î±)) (Monoid.toMulOneClass.{u1} (CategoryTheory.Aut.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.category.{u1} Î± _inst_1) (CategoryTheory.SingleObj.star.{u1} Î±)) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Aut.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.category.{u1} Î± _inst_1) (CategoryTheory.SingleObj.star.{u1} Î±)) (Group.toDivInvMonoid.{u1} (CategoryTheory.Aut.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.category.{u1} Î± _inst_1) (CategoryTheory.SingleObj.star.{u1} Î±)) (CategoryTheory.Aut.instGroupAut.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.category.{u1} Î± _inst_1) (CategoryTheory.SingleObj.star.{u1} Î±))))))) (Units.{u1} Î± _inst_1) (CategoryTheory.Aut.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.category.{u1} Î± _inst_1) (CategoryTheory.SingleObj.star.{u1} Î±)) (MulOneClass.toMul.{u1} (Units.{u1} Î± _inst_1) (Units.instMulOneClassUnits.{u1} Î± _inst_1)) (MulOneClass.toMul.{u1} (CategoryTheory.Aut.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.category.{u1} Î± _inst_1) (CategoryTheory.SingleObj.star.{u1} Î±)) (Monoid.toMulOneClass.{u1} (CategoryTheory.Aut.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.category.{u1} Î± _inst_1) (CategoryTheory.SingleObj.star.{u1} Î±)) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Aut.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.category.{u1} Î± _inst_1) (CategoryTheory.SingleObj.star.{u1} Î±)) (Group.toDivInvMonoid.{u1} (CategoryTheory.Aut.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.category.{u1} Î± _inst_1) (CategoryTheory.SingleObj.star.{u1} Î±)) (CategoryTheory.Aut.instGroupAut.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.category.{u1} Î± _inst_1) (CategoryTheory.SingleObj.star.{u1} Î±)))))) (MulEquiv.instMulEquivClassMulEquiv.{u1, u1} (Units.{u1} Î± _inst_1) (CategoryTheory.Aut.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.category.{u1} Î± _inst_1) (CategoryTheory.SingleObj.star.{u1} Î±)) (MulOneClass.toMul.{u1} (Units.{u1} Î± _inst_1) (Units.instMulOneClassUnits.{u1} Î± _inst_1)) (MulOneClass.toMul.{u1} (CategoryTheory.Aut.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.category.{u1} Î± _inst_1) (CategoryTheory.SingleObj.star.{u1} Î±)) (Monoid.toMulOneClass.{u1} (CategoryTheory.Aut.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.category.{u1} Î± _inst_1) (CategoryTheory.SingleObj.star.{u1} Î±)) (DivInvMonoid.toMonoid.{u1} (CategoryTheory.Aut.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.category.{u1} Î± _inst_1) (CategoryTheory.SingleObj.star.{u1} Î±)) (Group.toDivInvMonoid.{u1} (CategoryTheory.Aut.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.category.{u1} Î± _inst_1) (CategoryTheory.SingleObj.star.{u1} Î±)) (CategoryTheory.Aut.instGroupAut.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.category.{u1} Î± _inst_1) (CategoryTheory.SingleObj.star.{u1} Î±)))))))))) (Units.toAut.{u1} Î± _inst_1) x)) (FunLike.coe.{succ u1, succ u1, succ u1} (MulEquiv.{u1, u1} Î± (CategoryTheory.End.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.categoryStruct.{u1} Î± (Monoid.toOne.{u1} Î± _inst_1) (MulOneClass.toMul.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1))) (CategoryTheory.SingleObj.star.{u1} Î±)) (MulOneClass.toMul.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1)) (CategoryTheory.End.mul.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.categoryStruct.{u1} Î± (Monoid.toOne.{u1} Î± _inst_1) (MulOneClass.toMul.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1))) (CategoryTheory.SingleObj.star.{u1} Î±))) Î± (fun (_x : Î±) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : Î±) => CategoryTheory.End.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.categoryStruct.{u1} Î± (Monoid.toOne.{u1} Î± _inst_1) (MulOneClass.toMul.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1))) (CategoryTheory.SingleObj.star.{u1} Î±)) _x) (EmbeddingLike.toFunLike.{succ u1, succ u1, succ u1} (MulEquiv.{u1, u1} Î± (CategoryTheory.End.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.categoryStruct.{u1} Î± (Monoid.toOne.{u1} Î± _inst_1) (MulOneClass.toMul.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1))) (CategoryTheory.SingleObj.star.{u1} Î±)) (MulOneClass.toMul.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1)) (CategoryTheory.End.mul.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.categoryStruct.{u1} Î± (Monoid.toOne.{u1} Î± _inst_1) (MulOneClass.toMul.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1))) (CategoryTheory.SingleObj.star.{u1} Î±))) Î± (CategoryTheory.End.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.categoryStruct.{u1} Î± (Monoid.toOne.{u1} Î± _inst_1) (MulOneClass.toMul.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1))) (CategoryTheory.SingleObj.star.{u1} Î±)) (EquivLike.toEmbeddingLike.{succ u1, succ u1, succ u1} (MulEquiv.{u1, u1} Î± (CategoryTheory.End.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.categoryStruct.{u1} Î± (Monoid.toOne.{u1} Î± _inst_1) (MulOneClass.toMul.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1))) (CategoryTheory.SingleObj.star.{u1} Î±)) (MulOneClass.toMul.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1)) (CategoryTheory.End.mul.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.categoryStruct.{u1} Î± (Monoid.toOne.{u1} Î± _inst_1) (MulOneClass.toMul.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1))) (CategoryTheory.SingleObj.star.{u1} Î±))) Î± (CategoryTheory.End.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.categoryStruct.{u1} Î± (Monoid.toOne.{u1} Î± _inst_1) (MulOneClass.toMul.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1))) (CategoryTheory.SingleObj.star.{u1} Î±)) (MulEquivClass.toEquivLike.{u1, u1, u1} (MulEquiv.{u1, u1} Î± (CategoryTheory.End.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.categoryStruct.{u1} Î± (Monoid.toOne.{u1} Î± _inst_1) (MulOneClass.toMul.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1))) (CategoryTheory.SingleObj.star.{u1} Î±)) (MulOneClass.toMul.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1)) (CategoryTheory.End.mul.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.categoryStruct.{u1} Î± (Monoid.toOne.{u1} Î± _inst_1) (MulOneClass.toMul.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1))) (CategoryTheory.SingleObj.star.{u1} Î±))) Î± (CategoryTheory.End.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.categoryStruct.{u1} Î± (Monoid.toOne.{u1} Î± _inst_1) (MulOneClass.toMul.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1))) (CategoryTheory.SingleObj.star.{u1} Î±)) (MulOneClass.toMul.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1)) (CategoryTheory.End.mul.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.categoryStruct.{u1} Î± (Monoid.toOne.{u1} Î± _inst_1) (MulOneClass.toMul.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1))) (CategoryTheory.SingleObj.star.{u1} Î±)) (MulEquiv.instMulEquivClassMulEquiv.{u1, u1} Î± (CategoryTheory.End.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.categoryStruct.{u1} Î± (Monoid.toOne.{u1} Î± _inst_1) (MulOneClass.toMul.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1))) (CategoryTheory.SingleObj.star.{u1} Î±)) (MulOneClass.toMul.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1)) (CategoryTheory.End.mul.{u1, 0} (CategoryTheory.SingleObj.{u1} Î±) (CategoryTheory.SingleObj.categoryStruct.{u1} Î± (Monoid.toOne.{u1} Î± _inst_1) (MulOneClass.toMul.{u1} Î± (Monoid.toMulOneClass.{u1} Î± _inst_1))) (CategoryTheory.SingleObj.star.{u1} Î±)))))) (CategoryTheory.SingleObj.toEnd.{u1} Î± _inst_1) (Units.val.{u1} Î± _inst_1 (Inv.inv.{u1} (Units.{u1} Î± _inst_1) (Units.instInv.{u1} Î± _inst_1) x)))
Case conversion may be inaccurate. Consider using '#align units.to_Aut_inv Units.toAut_invâ‚“'. -/
@[simp]
theorem toAut_inv (x : Î±Ë£) : (toAut Î± x).inv = SingleObj.toEnd Î± (xâ»Â¹ : Î±Ë£) :=
  rfl
#align units.to_Aut_inv Units.toAut_inv

end Units

namespace MonCat

open CategoryTheory

#print MonCat.toCat /-
/-- The fully faithful functor from `Mon` to `Cat`. -/
def toCat : MonCat â¥¤ Cat where
  obj x := Cat.of (SingleObj x)
  map x y f := SingleObj.mapHom x y f
#align Mon.to_Cat MonCat.toCat
-/

#print MonCat.toCatFull /-
instance toCatFull : Full toCat
    where
  preimage x y := (SingleObj.mapHom x y).invFun
  witness' x y := by apply Equiv.right_inv
#align Mon.to_Cat_full MonCat.toCatFull
-/

#print MonCat.toCat_faithful /-
instance toCat_faithful : Faithful toCat where map_injective' x y := by apply Equiv.injective
#align Mon.to_Cat_faithful MonCat.toCat_faithful
-/

end MonCat

