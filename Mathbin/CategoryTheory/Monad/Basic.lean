/-
Copyright (c) 2019 Scott Morrison. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Scott Morrison, Bhavik Mehta, Adam Topaz

! This file was ported from Lean 3 source module category_theory.monad.basic
! leanprover-community/mathlib commit 9c6816cab5872990d450d2c2e7832176167b1c07
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.CategoryTheory.Functor.Category
import Mathbin.CategoryTheory.Functor.FullyFaithful
import Mathbin.CategoryTheory.Functor.ReflectsIsomorphisms

/-!
# Monads

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

We construct the categories of monads and comonads, and their forgetful functors to endofunctors.

(Note that these are the category theorist's monads, not the programmers monads.
For the translation, see the file `category_theory.monad.types`.)

For the fact that monads are "just" monoids in the category of endofunctors, see the file
`category_theory.monad.equiv_mon`.
-/


namespace CategoryTheory

open Category

universe vâ‚ uâ‚

-- morphism levels before object levels. See note [category_theory universes].
variable (C : Type uâ‚) [Category.{vâ‚} C]

#print CategoryTheory.Monad /-
/- ./././Mathport/Syntax/Translate/Command.lean:393:30: infer kinds are unsupported in Lean 4: #[`Î·'] [] -/
/- ./././Mathport/Syntax/Translate/Command.lean:393:30: infer kinds are unsupported in Lean 4: #[`Î¼'] [] -/
/-- The data of a monad on C consists of an endofunctor T together with natural transformations
Î· : ðŸ­ C âŸ¶ T and Î¼ : T â‹™ T âŸ¶ T satisfying three equations:
- T Î¼_X â‰« Î¼_X = Î¼_(TX) â‰« Î¼_X (associativity)
- Î·_(TX) â‰« Î¼_X = 1_X (left unit)
- TÎ·_X â‰« Î¼_X = 1_X (right unit)
-/
structure Monad extends C â¥¤ C where
  Î·' : ðŸ­ _ âŸ¶ to_functor
  Î¼' : to_functor â‹™ to_functor âŸ¶ to_functor
  assoc' : âˆ€ X, to_functor.map (NatTrans.app Î¼' X) â‰« Î¼'.app _ = Î¼'.app _ â‰« Î¼'.app _ := by obviously
  left_unit' : âˆ€ X : C, Î·'.app (to_functor.obj X) â‰« Î¼'.app _ = ðŸ™ _ := by obviously
  right_unit' : âˆ€ X : C, to_functor.map (Î·'.app X) â‰« Î¼'.app _ = ðŸ™ _ := by obviously
#align category_theory.monad CategoryTheory.Monad
-/

#print CategoryTheory.Comonad /-
/- ./././Mathport/Syntax/Translate/Command.lean:393:30: infer kinds are unsupported in Lean 4: #[`Îµ'] [] -/
/- ./././Mathport/Syntax/Translate/Command.lean:393:30: infer kinds are unsupported in Lean 4: #[`Î´'] [] -/
/-- The data of a comonad on C consists of an endofunctor G together with natural transformations
Îµ : G âŸ¶ ðŸ­ C and Î´ : G âŸ¶ G â‹™ G satisfying three equations:
- Î´_X â‰« G Î´_X = Î´_X â‰« Î´_(GX) (coassociativity)
- Î´_X â‰« Îµ_(GX) = 1_X (left counit)
- Î´_X â‰« G Îµ_X = 1_X (right counit)
-/
structure Comonad extends C â¥¤ C where
  Îµ' : to_functor âŸ¶ ðŸ­ _
  Î´' : to_functor âŸ¶ to_functor â‹™ to_functor
  coassoc' : âˆ€ X, NatTrans.app Î´' _ â‰« to_functor.map (Î´'.app X) = Î´'.app _ â‰« Î´'.app _ := by
    obviously
  left_counit' : âˆ€ X : C, Î´'.app X â‰« Îµ'.app (to_functor.obj X) = ðŸ™ _ := by obviously
  right_counit' : âˆ€ X : C, Î´'.app X â‰« to_functor.map (Îµ'.app X) = ðŸ™ _ := by obviously
#align category_theory.comonad CategoryTheory.Comonad
-/

variable {C} (T : Monad C) (G : Comonad C)

#print CategoryTheory.coeMonad /-
instance coeMonad : Coe (Monad C) (C â¥¤ C) :=
  âŸ¨fun T => T.toFunctorâŸ©
#align category_theory.coe_monad CategoryTheory.coeMonad
-/

#print CategoryTheory.coeComonad /-
instance coeComonad : Coe (Comonad C) (C â¥¤ C) :=
  âŸ¨fun G => G.toFunctorâŸ©
#align category_theory.coe_comonad CategoryTheory.coeComonad
-/

@[simp]
theorem monad_toFunctor_eq_coe : T.toFunctor = T :=
  rfl
#align category_theory.monad_to_functor_eq_coe CategoryTheory.monad_toFunctor_eq_coe

@[simp]
theorem comonad_toFunctor_eq_coe : G.toFunctor = G :=
  rfl
#align category_theory.comonad_to_functor_eq_coe CategoryTheory.comonad_toFunctor_eq_coe

#print CategoryTheory.Monad.Î· /-
/-- The unit for the monad `T`. -/
def Monad.Î· : ðŸ­ _ âŸ¶ (T : C â¥¤ C) :=
  T.Î·'
#align category_theory.monad.Î· CategoryTheory.Monad.Î·
-/

#print CategoryTheory.Monad.Î¼ /-
/-- The multiplication for the monad `T`. -/
def Monad.Î¼ : (T : C â¥¤ C) â‹™ (T : C â¥¤ C) âŸ¶ T :=
  T.Î¼'
#align category_theory.monad.Î¼ CategoryTheory.Monad.Î¼
-/

#print CategoryTheory.Comonad.Îµ /-
/-- The counit for the comonad `G`. -/
def Comonad.Îµ : (G : C â¥¤ C) âŸ¶ ðŸ­ _ :=
  G.Îµ'
#align category_theory.comonad.Îµ CategoryTheory.Comonad.Îµ
-/

#print CategoryTheory.Comonad.Î´ /-
/-- The comultiplication for the comonad `G`. -/
def Comonad.Î´ : (G : C â¥¤ C) âŸ¶ (G : C â¥¤ C) â‹™ G :=
  G.Î´'
#align category_theory.comonad.Î´ CategoryTheory.Comonad.Î´
-/

#print CategoryTheory.Monad.Simps.coe /-
/-- A custom simps projection for the functor part of a monad, as a coercion. -/
def Monad.Simps.coe :=
  (T : C â¥¤ C)
#align category_theory.monad.simps.coe CategoryTheory.Monad.Simps.coe
-/

#print CategoryTheory.Monad.Simps.Î· /-
/-- A custom simps projection for the unit of a monad, in simp normal form. -/
def Monad.Simps.Î· : ðŸ­ _ âŸ¶ (T : C â¥¤ C) :=
  T.Î·
#align category_theory.monad.simps.Î· CategoryTheory.Monad.Simps.Î·
-/

#print CategoryTheory.Monad.Simps.Î¼ /-
/-- A custom simps projection for the multiplication of a monad, in simp normal form. -/
def Monad.Simps.Î¼ : (T : C â¥¤ C) â‹™ (T : C â¥¤ C) âŸ¶ (T : C â¥¤ C) :=
  T.Î¼
#align category_theory.monad.simps.Î¼ CategoryTheory.Monad.Simps.Î¼
-/

#print CategoryTheory.Comonad.Simps.coe /-
/-- A custom simps projection for the functor part of a comonad, as a coercion. -/
def Comonad.Simps.coe :=
  (G : C â¥¤ C)
#align category_theory.comonad.simps.coe CategoryTheory.Comonad.Simps.coe
-/

#print CategoryTheory.Comonad.Simps.Îµ /-
/-- A custom simps projection for the counit of a comonad, in simp normal form. -/
def Comonad.Simps.Îµ : (G : C â¥¤ C) âŸ¶ ðŸ­ _ :=
  G.Îµ
#align category_theory.comonad.simps.Îµ CategoryTheory.Comonad.Simps.Îµ
-/

#print CategoryTheory.Comonad.Simps.Î´ /-
/-- A custom simps projection for the comultiplication of a comonad, in simp normal form. -/
def Comonad.Simps.Î´ : (G : C â¥¤ C) âŸ¶ (G : C â¥¤ C) â‹™ (G : C â¥¤ C) :=
  G.Î´
#align category_theory.comonad.simps.Î´ CategoryTheory.Comonad.Simps.Î´
-/

initialize_simps_projections category_theory.monad (toFunctor â†’ coe, Î·' â†’ Î·, Î¼' â†’ Î¼)

initialize_simps_projections category_theory.comonad (toFunctor â†’ coe, Îµ' â†’ Îµ, Î´' â†’ Î´)

/- warning: category_theory.monad.assoc -> CategoryTheory.Monad.assoc is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] (T : CategoryTheory.Monad.{u1, u2} C _inst_1) (X : C), Eq.{succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) T) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.comp.{u1, u1, u1, u2, u2, u2} C _inst_1 C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) T) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) T)) X)) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) T) X)) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) T) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.comp.{u1, u1, u1, u2, u2, u2} C _inst_1 C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) T) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) T)) X)) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) T) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) T) X)) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) T) X) (CategoryTheory.Functor.map.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) T) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.comp.{u1, u1, u1, u2, u2, u2} C _inst_1 C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) T) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) T)) X) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) T) X) (CategoryTheory.NatTrans.app.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.comp.{u1, u1, u1, u2, u2, u2} C _inst_1 C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) T) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) T)) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) T) (CategoryTheory.Monad.Î¼.{u1, u2} C _inst_1 T) X)) (CategoryTheory.NatTrans.app.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.comp.{u1, u1, u1, u2, u2, u2} C _inst_1 C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) T) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) T)) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) T) (CategoryTheory.Monad.Î¼.{u1, u2} C _inst_1 T) X)) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) T) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.comp.{u1, u1, u1, u2, u2, u2} C _inst_1 C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) T) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) T)) X)) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) T) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) T) X)) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) T) X) (CategoryTheory.NatTrans.app.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.comp.{u1, u1, u1, u2, u2, u2} C _inst_1 C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) T) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) T)) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) T) (CategoryTheory.Monad.Î¼.{u1, u2} C _inst_1 T) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) T) X)) (CategoryTheory.NatTrans.app.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.comp.{u1, u1, u1, u2, u2, u2} C _inst_1 C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) T) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) T)) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) T) (CategoryTheory.Monad.Î¼.{u1, u2} C _inst_1 T) X))
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] (T : CategoryTheory.Monad.{u1, u2} C _inst_1) (X : C), Eq.{succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T)) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.comp.{u1, u1, u1, u2, u2, u2} C _inst_1 C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T))) X)) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T)) X)) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T)) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.comp.{u1, u1, u1, u2, u2, u2} C _inst_1 C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T))) X)) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T)) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T)) X)) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T)) X) (Prefunctor.map.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T)) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.comp.{u1, u1, u1, u2, u2, u2} C _inst_1 C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T))) X) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T)) X) (CategoryTheory.NatTrans.app.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.comp.{u1, u1, u1, u2, u2, u2} C _inst_1 C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T)) (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.Î¼.{u1, u2} C _inst_1 T) X)) (CategoryTheory.NatTrans.app.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.comp.{u1, u1, u1, u2, u2, u2} C _inst_1 C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T)) (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.Î¼.{u1, u2} C _inst_1 T) X)) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.comp.{u1, u1, u1, u2, u2, u2} C _inst_1 C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T))) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T)) X)) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T)) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T)) X)) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T)) X) (CategoryTheory.NatTrans.app.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.comp.{u1, u1, u1, u2, u2, u2} C _inst_1 C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T)) (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.Î¼.{u1, u2} C _inst_1 T) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T)) X)) (CategoryTheory.NatTrans.app.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.comp.{u1, u1, u1, u2, u2, u2} C _inst_1 C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T)) (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.Î¼.{u1, u2} C _inst_1 T) X))
Case conversion may be inaccurate. Consider using '#align category_theory.monad.assoc CategoryTheory.Monad.assocâ‚“'. -/
@[reassoc]
theorem Monad.assoc (T : Monad C) (X : C) :
    (T : C â¥¤ C).map (T.Î¼.app X) â‰« T.Î¼.app _ = T.Î¼.app _ â‰« T.Î¼.app _ :=
  T.assoc' X
#align category_theory.monad.assoc CategoryTheory.Monad.assoc

/- warning: category_theory.monad.left_unit -> CategoryTheory.Monad.left_unit is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] (T : CategoryTheory.Monad.{u1, u2} C _inst_1) (X : C), Eq.{succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) T) X)) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) T) X)) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) T) X)) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) T) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) T) X)) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) T) X) (CategoryTheory.NatTrans.app.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) T) (CategoryTheory.Monad.Î·.{u1, u2} C _inst_1 T) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) T) X)) (CategoryTheory.NatTrans.app.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.comp.{u1, u1, u1, u2, u2, u2} C _inst_1 C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) T) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) T)) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) T) (CategoryTheory.Monad.Î¼.{u1, u2} C _inst_1 T) X)) (CategoryTheory.CategoryStruct.id.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) T) X))
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] (T : CategoryTheory.Monad.{u1, u2} C _inst_1) (X : C), Eq.{succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1)) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T)) X)) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T)) X)) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1)) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T)) X)) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T)) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T)) X)) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T)) X) (CategoryTheory.NatTrans.app.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.Î·.{u1, u2} C _inst_1 T) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T)) X)) (CategoryTheory.NatTrans.app.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.comp.{u1, u1, u1, u2, u2, u2} C _inst_1 C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T)) (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.Î¼.{u1, u2} C _inst_1 T) X)) (CategoryTheory.CategoryStruct.id.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T)) X))
Case conversion may be inaccurate. Consider using '#align category_theory.monad.left_unit CategoryTheory.Monad.left_unitâ‚“'. -/
@[simp, reassoc]
theorem Monad.left_unit (T : Monad C) (X : C) :
    T.Î·.app ((T : C â¥¤ C).obj X) â‰« T.Î¼.app X = ðŸ™ ((T : C â¥¤ C).obj X) :=
  T.left_unit' X
#align category_theory.monad.left_unit CategoryTheory.Monad.left_unit

/- warning: category_theory.monad.right_unit -> CategoryTheory.Monad.right_unit is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] (T : CategoryTheory.Monad.{u1, u2} C _inst_1) (X : C), Eq.{succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) T) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) X)) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) T) X)) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) T) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) X)) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) T) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) T) X)) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) T) X) (CategoryTheory.Functor.map.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) T) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) X) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) T) X) (CategoryTheory.NatTrans.app.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) T) (CategoryTheory.Monad.Î·.{u1, u2} C _inst_1 T) X)) (CategoryTheory.NatTrans.app.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.comp.{u1, u1, u1, u2, u2, u2} C _inst_1 C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) T) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) T)) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) T) (CategoryTheory.Monad.Î¼.{u1, u2} C _inst_1 T) X)) (CategoryTheory.CategoryStruct.id.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) T) X))
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] (T : CategoryTheory.Monad.{u1, u2} C _inst_1) (X : C), Eq.{succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T)) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1)) X)) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T)) X)) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T)) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1)) X)) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T)) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T)) X)) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T)) X) (Prefunctor.map.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T)) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1)) X) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T)) X) (CategoryTheory.NatTrans.app.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.Î·.{u1, u2} C _inst_1 T) X)) (CategoryTheory.NatTrans.app.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.comp.{u1, u1, u1, u2, u2, u2} C _inst_1 C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T)) (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T) (CategoryTheory.Monad.Î¼.{u1, u2} C _inst_1 T) X)) (CategoryTheory.CategoryStruct.id.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 T)) X))
Case conversion may be inaccurate. Consider using '#align category_theory.monad.right_unit CategoryTheory.Monad.right_unitâ‚“'. -/
@[simp, reassoc]
theorem Monad.right_unit (T : Monad C) (X : C) :
    (T : C â¥¤ C).map (T.Î·.app X) â‰« T.Î¼.app X = ðŸ™ ((T : C â¥¤ C).obj X) :=
  T.right_unit' X
#align category_theory.monad.right_unit CategoryTheory.Monad.right_unit

/- warning: category_theory.comonad.coassoc -> CategoryTheory.Comonad.coassoc is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] (G : CategoryTheory.Comonad.{u1, u2} C _inst_1) (X : C), Eq.{succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) G) X) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) G) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.comp.{u1, u1, u1, u2, u2, u2} C _inst_1 C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) G) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) G)) X))) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) G) X) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.comp.{u1, u1, u1, u2, u2, u2} C _inst_1 C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) G) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) G)) X) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) G) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.comp.{u1, u1, u1, u2, u2, u2} C _inst_1 C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) G) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) G)) X)) (CategoryTheory.NatTrans.app.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) G) (CategoryTheory.Functor.comp.{u1, u1, u1, u2, u2, u2} C _inst_1 C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) G) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) G)) (CategoryTheory.Comonad.Î´.{u1, u2} C _inst_1 G) X) (CategoryTheory.Functor.map.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) G) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) G) X) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.comp.{u1, u1, u1, u2, u2, u2} C _inst_1 C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) G) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) G)) X) (CategoryTheory.NatTrans.app.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) G) (CategoryTheory.Functor.comp.{u1, u1, u1, u2, u2, u2} C _inst_1 C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) G) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) G)) (CategoryTheory.Comonad.Î´.{u1, u2} C _inst_1 G) X))) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) G) X) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.comp.{u1, u1, u1, u2, u2, u2} C _inst_1 C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) G) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) G)) X) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) G) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.comp.{u1, u1, u1, u2, u2, u2} C _inst_1 C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) G) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) G)) X)) (CategoryTheory.NatTrans.app.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) G) (CategoryTheory.Functor.comp.{u1, u1, u1, u2, u2, u2} C _inst_1 C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) G) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) G)) (CategoryTheory.Comonad.Î´.{u1, u2} C _inst_1 G) X) (CategoryTheory.NatTrans.app.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) G) (CategoryTheory.Functor.comp.{u1, u1, u1, u2, u2, u2} C _inst_1 C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) G) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) G)) (CategoryTheory.Comonad.Î´.{u1, u2} C _inst_1 G) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) G) X)))
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] (G : CategoryTheory.Comonad.{u1, u2} C _inst_1) (X : C), Eq.{succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 G)) X) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 G)) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.comp.{u1, u1, u1, u2, u2, u2} C _inst_1 C _inst_1 C _inst_1 (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 G) (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 G))) X))) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 G)) X) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.comp.{u1, u1, u1, u2, u2, u2} C _inst_1 C _inst_1 C _inst_1 (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 G) (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 G))) X) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 G)) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.comp.{u1, u1, u1, u2, u2, u2} C _inst_1 C _inst_1 C _inst_1 (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 G) (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 G))) X)) (CategoryTheory.NatTrans.app.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 G) (CategoryTheory.Functor.comp.{u1, u1, u1, u2, u2, u2} C _inst_1 C _inst_1 C _inst_1 (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 G) (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 G)) (CategoryTheory.Comonad.Î´.{u1, u2} C _inst_1 G) X) (Prefunctor.map.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 G)) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 G)) X) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.comp.{u1, u1, u1, u2, u2, u2} C _inst_1 C _inst_1 C _inst_1 (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 G) (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 G))) X) (CategoryTheory.NatTrans.app.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 G) (CategoryTheory.Functor.comp.{u1, u1, u1, u2, u2, u2} C _inst_1 C _inst_1 C _inst_1 (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 G) (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 G)) (CategoryTheory.Comonad.Î´.{u1, u2} C _inst_1 G) X))) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 G)) X) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.comp.{u1, u1, u1, u2, u2, u2} C _inst_1 C _inst_1 C _inst_1 (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 G) (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 G))) X) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.comp.{u1, u1, u1, u2, u2, u2} C _inst_1 C _inst_1 C _inst_1 (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 G) (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 G))) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 G)) X)) (CategoryTheory.NatTrans.app.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 G) (CategoryTheory.Functor.comp.{u1, u1, u1, u2, u2, u2} C _inst_1 C _inst_1 C _inst_1 (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 G) (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 G)) (CategoryTheory.Comonad.Î´.{u1, u2} C _inst_1 G) X) (CategoryTheory.NatTrans.app.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 G) (CategoryTheory.Functor.comp.{u1, u1, u1, u2, u2, u2} C _inst_1 C _inst_1 C _inst_1 (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 G) (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 G)) (CategoryTheory.Comonad.Î´.{u1, u2} C _inst_1 G) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 G)) X)))
Case conversion may be inaccurate. Consider using '#align category_theory.comonad.coassoc CategoryTheory.Comonad.coassocâ‚“'. -/
@[reassoc]
theorem Comonad.coassoc (G : Comonad C) (X : C) :
    G.Î´.app _ â‰« (G : C â¥¤ C).map (G.Î´.app X) = G.Î´.app _ â‰« G.Î´.app _ :=
  G.coassoc' X
#align category_theory.comonad.coassoc CategoryTheory.Comonad.coassoc

/- warning: category_theory.comonad.left_counit -> CategoryTheory.Comonad.left_counit is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] (G : CategoryTheory.Comonad.{u1, u2} C _inst_1) (X : C), Eq.{succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) G) X) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) G) X))) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) G) X) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.comp.{u1, u1, u1, u2, u2, u2} C _inst_1 C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) G) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) G)) X) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) G) X)) (CategoryTheory.NatTrans.app.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) G) (CategoryTheory.Functor.comp.{u1, u1, u1, u2, u2, u2} C _inst_1 C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) G) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) G)) (CategoryTheory.Comonad.Î´.{u1, u2} C _inst_1 G) X) (CategoryTheory.NatTrans.app.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) G) (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Comonad.Îµ.{u1, u2} C _inst_1 G) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) G) X))) (CategoryTheory.CategoryStruct.id.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) G) X))
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] (G : CategoryTheory.Comonad.{u1, u2} C _inst_1) (X : C), Eq.{succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 G)) X) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1)) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 G)) X))) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 G)) X) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.comp.{u1, u1, u1, u2, u2, u2} C _inst_1 C _inst_1 C _inst_1 (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 G) (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 G))) X) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1)) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 G)) X)) (CategoryTheory.NatTrans.app.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 G) (CategoryTheory.Functor.comp.{u1, u1, u1, u2, u2, u2} C _inst_1 C _inst_1 C _inst_1 (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 G) (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 G)) (CategoryTheory.Comonad.Î´.{u1, u2} C _inst_1 G) X) (CategoryTheory.NatTrans.app.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 G) (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Comonad.Îµ.{u1, u2} C _inst_1 G) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 G)) X))) (CategoryTheory.CategoryStruct.id.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 G)) X))
Case conversion may be inaccurate. Consider using '#align category_theory.comonad.left_counit CategoryTheory.Comonad.left_counitâ‚“'. -/
@[simp, reassoc]
theorem Comonad.left_counit (G : Comonad C) (X : C) :
    G.Î´.app X â‰« G.Îµ.app ((G : C â¥¤ C).obj X) = ðŸ™ ((G : C â¥¤ C).obj X) :=
  G.left_counit' X
#align category_theory.comonad.left_counit CategoryTheory.Comonad.left_counit

/- warning: category_theory.comonad.right_counit -> CategoryTheory.Comonad.right_counit is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] (G : CategoryTheory.Comonad.{u1, u2} C _inst_1) (X : C), Eq.{succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) G) X) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) G) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) X))) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) G) X) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.comp.{u1, u1, u1, u2, u2, u2} C _inst_1 C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) G) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) G)) X) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) G) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) X)) (CategoryTheory.NatTrans.app.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) G) (CategoryTheory.Functor.comp.{u1, u1, u1, u2, u2, u2} C _inst_1 C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) G) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) G)) (CategoryTheory.Comonad.Î´.{u1, u2} C _inst_1 G) X) (CategoryTheory.Functor.map.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) G) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) G) X) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) X) (CategoryTheory.NatTrans.app.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) G) (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Comonad.Îµ.{u1, u2} C _inst_1 G) X))) (CategoryTheory.CategoryStruct.id.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) G) X))
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] (G : CategoryTheory.Comonad.{u1, u2} C _inst_1) (X : C), Eq.{succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 G)) X) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 G)) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1)) X))) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 G)) X) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.comp.{u1, u1, u1, u2, u2, u2} C _inst_1 C _inst_1 C _inst_1 (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 G) (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 G))) X) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 G)) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1)) X)) (CategoryTheory.NatTrans.app.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 G) (CategoryTheory.Functor.comp.{u1, u1, u1, u2, u2, u2} C _inst_1 C _inst_1 C _inst_1 (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 G) (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 G)) (CategoryTheory.Comonad.Î´.{u1, u2} C _inst_1 G) X) (Prefunctor.map.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 G)) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 G)) X) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1)) X) (CategoryTheory.NatTrans.app.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 G) (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Comonad.Îµ.{u1, u2} C _inst_1 G) X))) (CategoryTheory.CategoryStruct.id.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 G)) X))
Case conversion may be inaccurate. Consider using '#align category_theory.comonad.right_counit CategoryTheory.Comonad.right_counitâ‚“'. -/
@[simp, reassoc]
theorem Comonad.right_counit (G : Comonad C) (X : C) :
    G.Î´.app X â‰« (G : C â¥¤ C).map (G.Îµ.app X) = ðŸ™ ((G : C â¥¤ C).obj X) :=
  G.right_counit' X
#align category_theory.comonad.right_counit CategoryTheory.Comonad.right_counit

#print CategoryTheory.MonadHom /-
/-- A morphism of monads is a natural transformation compatible with Î· and Î¼. -/
@[ext]
structure MonadHom (Tâ‚ Tâ‚‚ : Monad C) extends NatTrans (Tâ‚ : C â¥¤ C) Tâ‚‚ where
  app_Î·' : âˆ€ X, Tâ‚.Î·.app X â‰« app X = Tâ‚‚.Î·.app X := by obviously
  app_Î¼' : âˆ€ X, Tâ‚.Î¼.app X â‰« app X = ((Tâ‚ : C â¥¤ C).map (app X) â‰« app _) â‰« Tâ‚‚.Î¼.app X := by obviously
#align category_theory.monad_hom CategoryTheory.MonadHom
-/

#print CategoryTheory.ComonadHom /-
/-- A morphism of comonads is a natural transformation compatible with Îµ and Î´. -/
@[ext]
structure ComonadHom (M N : Comonad C) extends NatTrans (M : C â¥¤ C) N where
  app_Îµ' : âˆ€ X, app X â‰« N.Îµ.app X = M.Îµ.app X := by obviously
  app_Î´' : âˆ€ X, app X â‰« N.Î´.app X = M.Î´.app X â‰« app _ â‰« (N : C â¥¤ C).map (app X) := by obviously
#align category_theory.comonad_hom CategoryTheory.ComonadHom
-/

restate_axiom monad_hom.app_Î·'

restate_axiom monad_hom.app_Î¼'

attribute [simp, reassoc] monad_hom.app_Î· monad_hom.app_Î¼

restate_axiom comonad_hom.app_Îµ'

restate_axiom comonad_hom.app_Î´'

attribute [simp, reassoc] comonad_hom.app_Îµ comonad_hom.app_Î´

instance : Category (Monad C) where
  Hom := MonadHom
  id M := { toNatTrans := ðŸ™ (M : C â¥¤ C) }
  comp _ _ _ f g :=
    {
      toNatTrans :=
        { app := fun X => f.app X â‰« g.app X
          naturality' := fun X Y h => by rw [assoc, f.1.naturality_assoc, g.1.naturality] } }
  id_comp' _ _ _ := by
    ext
    apply id_comp
  comp_id' _ _ _ := by
    ext
    apply comp_id
  assoc' _ _ _ _ _ _ _ := by
    ext
    apply assoc

instance : Category (Comonad C) where
  Hom := ComonadHom
  id M := { toNatTrans := ðŸ™ (M : C â¥¤ C) }
  comp _ _ _ f g :=
    {
      toNatTrans :=
        { app := fun X => f.app X â‰« g.app X
          naturality' := fun X Y h => by rw [assoc, f.1.naturality_assoc, g.1.naturality] } }
  id_comp' _ _ _ := by
    ext
    apply id_comp
  comp_id' _ _ _ := by
    ext
    apply comp_id
  assoc' _ _ _ _ _ _ _ := by
    ext
    apply assoc

instance {T : Monad C} : Inhabited (MonadHom T T) :=
  âŸ¨ðŸ™ TâŸ©

#print CategoryTheory.MonadHom.id_toNatTrans /-
@[simp]
theorem MonadHom.id_toNatTrans (T : Monad C) : (ðŸ™ T : T âŸ¶ T).toNatTrans = ðŸ™ (T : C â¥¤ C) :=
  rfl
#align category_theory.monad_hom.id_to_nat_trans CategoryTheory.MonadHom.id_toNatTrans
-/

/- warning: category_theory.monad_hom.comp_to_nat_trans -> CategoryTheory.MonadHom.comp_toNatTrans is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {Tâ‚ : CategoryTheory.Monad.{u1, u2} C _inst_1} {Tâ‚‚ : CategoryTheory.Monad.{u1, u2} C _inst_1} {Tâ‚ƒ : CategoryTheory.Monad.{u1, u2} C _inst_1} (f : Quiver.Hom.{succ (max u2 u1), max u2 u1} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Monad.category.{u1, u2} C _inst_1))) Tâ‚ Tâ‚‚) (g : Quiver.Hom.{succ (max u2 u1), max u2 u1} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Monad.category.{u1, u2} C _inst_1))) Tâ‚‚ Tâ‚ƒ), Eq.{succ (max u2 u1)} (CategoryTheory.NatTrans.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) Tâ‚) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) Tâ‚ƒ)) (CategoryTheory.MonadHom.toNatTrans.{u1, u2} C _inst_1 Tâ‚ Tâ‚ƒ (CategoryTheory.CategoryStruct.comp.{max u2 u1, max u2 u1} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Monad.category.{u1, u2} C _inst_1)) Tâ‚ Tâ‚‚ Tâ‚ƒ f g)) (CategoryTheory.CategoryStruct.comp.{max u2 u1, max u1 u2} (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u1 u2} (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u2, u2} C _inst_1 C _inst_1)) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) Tâ‚) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) Tâ‚‚) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) Tâ‚ƒ) (CategoryTheory.MonadHom.toNatTrans.{u1, u2} C _inst_1 Tâ‚ Tâ‚‚ f) (CategoryTheory.MonadHom.toNatTrans.{u1, u2} C _inst_1 Tâ‚‚ Tâ‚ƒ g))
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {Tâ‚ : CategoryTheory.Monad.{u1, u2} C _inst_1} {Tâ‚‚ : CategoryTheory.Monad.{u1, u2} C _inst_1} {Tâ‚ƒ : CategoryTheory.Monad.{u1, u2} C _inst_1} (f : Quiver.Hom.{max (succ u2) (succ u1), max u2 u1} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.instCategoryMonad.{u1, u2} C _inst_1))) Tâ‚ Tâ‚‚) (g : Quiver.Hom.{max (succ u2) (succ u1), max u2 u1} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.instCategoryMonad.{u1, u2} C _inst_1))) Tâ‚‚ Tâ‚ƒ), Eq.{max (succ u2) (succ u1)} (CategoryTheory.NatTrans.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 Tâ‚) (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 Tâ‚ƒ)) (CategoryTheory.MonadHom.toNatTrans.{u1, u2} C _inst_1 Tâ‚ Tâ‚ƒ (CategoryTheory.CategoryStruct.comp.{max u2 u1, max u2 u1} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.instCategoryMonad.{u1, u2} C _inst_1)) Tâ‚ Tâ‚‚ Tâ‚ƒ f g)) (CategoryTheory.CategoryStruct.comp.{max u2 u1, max u2 u1} (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u2, u2} C _inst_1 C _inst_1)) (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 Tâ‚) (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 Tâ‚‚) (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 Tâ‚ƒ) (CategoryTheory.MonadHom.toNatTrans.{u1, u2} C _inst_1 Tâ‚ Tâ‚‚ f) (CategoryTheory.MonadHom.toNatTrans.{u1, u2} C _inst_1 Tâ‚‚ Tâ‚ƒ g))
Case conversion may be inaccurate. Consider using '#align category_theory.monad_hom.comp_to_nat_trans CategoryTheory.MonadHom.comp_toNatTransâ‚“'. -/
@[simp]
theorem MonadHom.comp_toNatTrans {Tâ‚ Tâ‚‚ Tâ‚ƒ : Monad C} (f : Tâ‚ âŸ¶ Tâ‚‚) (g : Tâ‚‚ âŸ¶ Tâ‚ƒ) :
    (f â‰« g).toNatTrans = ((f.toNatTrans : _ âŸ¶ (Tâ‚‚ : C â¥¤ C)) â‰« g.toNatTrans : (Tâ‚ : C â¥¤ C) âŸ¶ Tâ‚ƒ) :=
  rfl
#align category_theory.monad_hom.comp_to_nat_trans CategoryTheory.MonadHom.comp_toNatTrans

instance {G : Comonad C} : Inhabited (ComonadHom G G) :=
  âŸ¨ðŸ™ GâŸ©

#print CategoryTheory.ComonadHom.id_toNatTrans /-
@[simp]
theorem ComonadHom.id_toNatTrans (T : Comonad C) : (ðŸ™ T : T âŸ¶ T).toNatTrans = ðŸ™ (T : C â¥¤ C) :=
  rfl
#align category_theory.comonad_hom.id_to_nat_trans CategoryTheory.ComonadHom.id_toNatTrans
-/

/- warning: category_theory.comp_to_nat_trans -> CategoryTheory.comp_toNatTrans is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {Tâ‚ : CategoryTheory.Comonad.{u1, u2} C _inst_1} {Tâ‚‚ : CategoryTheory.Comonad.{u1, u2} C _inst_1} {Tâ‚ƒ : CategoryTheory.Comonad.{u1, u2} C _inst_1} (f : Quiver.Hom.{succ (max u2 u1), max u2 u1} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Comonad.category.{u1, u2} C _inst_1))) Tâ‚ Tâ‚‚) (g : Quiver.Hom.{succ (max u2 u1), max u2 u1} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Comonad.category.{u1, u2} C _inst_1))) Tâ‚‚ Tâ‚ƒ), Eq.{succ (max u2 u1)} (CategoryTheory.NatTrans.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) Tâ‚) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) Tâ‚ƒ)) (CategoryTheory.ComonadHom.toNatTrans.{u1, u2} C _inst_1 Tâ‚ Tâ‚ƒ (CategoryTheory.CategoryStruct.comp.{max u2 u1, max u2 u1} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Comonad.category.{u1, u2} C _inst_1)) Tâ‚ Tâ‚‚ Tâ‚ƒ f g)) (CategoryTheory.CategoryStruct.comp.{max u2 u1, max u1 u2} (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u1 u2} (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u2, u2} C _inst_1 C _inst_1)) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) Tâ‚) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) Tâ‚‚) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) Tâ‚ƒ) (CategoryTheory.ComonadHom.toNatTrans.{u1, u2} C _inst_1 Tâ‚ Tâ‚‚ f) (CategoryTheory.ComonadHom.toNatTrans.{u1, u2} C _inst_1 Tâ‚‚ Tâ‚ƒ g))
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {Tâ‚ : CategoryTheory.Comonad.{u1, u2} C _inst_1} {Tâ‚‚ : CategoryTheory.Comonad.{u1, u2} C _inst_1} {Tâ‚ƒ : CategoryTheory.Comonad.{u1, u2} C _inst_1} (f : Quiver.Hom.{max (succ u2) (succ u1), max u2 u1} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.instCategoryComonad.{u1, u2} C _inst_1))) Tâ‚ Tâ‚‚) (g : Quiver.Hom.{max (succ u2) (succ u1), max u2 u1} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.instCategoryComonad.{u1, u2} C _inst_1))) Tâ‚‚ Tâ‚ƒ), Eq.{max (succ u2) (succ u1)} (CategoryTheory.NatTrans.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 Tâ‚) (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 Tâ‚ƒ)) (CategoryTheory.ComonadHom.toNatTrans.{u1, u2} C _inst_1 Tâ‚ Tâ‚ƒ (CategoryTheory.CategoryStruct.comp.{max u2 u1, max u2 u1} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.instCategoryComonad.{u1, u2} C _inst_1)) Tâ‚ Tâ‚‚ Tâ‚ƒ f g)) (CategoryTheory.CategoryStruct.comp.{max u2 u1, max u2 u1} (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u2, u2} C _inst_1 C _inst_1)) (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 Tâ‚) (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 Tâ‚‚) (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 Tâ‚ƒ) (CategoryTheory.ComonadHom.toNatTrans.{u1, u2} C _inst_1 Tâ‚ Tâ‚‚ f) (CategoryTheory.ComonadHom.toNatTrans.{u1, u2} C _inst_1 Tâ‚‚ Tâ‚ƒ g))
Case conversion may be inaccurate. Consider using '#align category_theory.comp_to_nat_trans CategoryTheory.comp_toNatTransâ‚“'. -/
@[simp]
theorem comp_toNatTrans {Tâ‚ Tâ‚‚ Tâ‚ƒ : Comonad C} (f : Tâ‚ âŸ¶ Tâ‚‚) (g : Tâ‚‚ âŸ¶ Tâ‚ƒ) :
    (f â‰« g).toNatTrans = ((f.toNatTrans : _ âŸ¶ (Tâ‚‚ : C â¥¤ C)) â‰« g.toNatTrans : (Tâ‚ : C â¥¤ C) âŸ¶ Tâ‚ƒ) :=
  rfl
#align category_theory.comp_to_nat_trans CategoryTheory.comp_toNatTrans

/- warning: category_theory.monad_iso.mk -> CategoryTheory.MonadIso.mk is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {M : CategoryTheory.Monad.{u1, u2} C _inst_1} {N : CategoryTheory.Monad.{u1, u2} C _inst_1} (f : CategoryTheory.Iso.{max u2 u1, max u1 u2} (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u2, u2} C _inst_1 C _inst_1) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) M) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) N)), (forall (X : C), Eq.{succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) X) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) N) X)) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) X) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) M) X) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) N) X) (CategoryTheory.NatTrans.app.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) M) (CategoryTheory.Monad.Î·.{u1, u2} C _inst_1 M) X) (CategoryTheory.NatTrans.app.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) M) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) N) (CategoryTheory.Iso.hom.{max u2 u1, max u1 u2} (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u2, u2} C _inst_1 C _inst_1) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) M) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) N) f) X)) (CategoryTheory.NatTrans.app.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) N) (CategoryTheory.Monad.Î·.{u1, u2} C _inst_1 N) X)) -> (forall (X : C), Eq.{succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.comp.{u1, u1, u1, u2, u2, u2} C _inst_1 C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) M) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) M)) X) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) N) X)) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.comp.{u1, u1, u1, u2, u2, u2} C _inst_1 C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) M) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) M)) X) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) M) X) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) N) X) (CategoryTheory.NatTrans.app.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.comp.{u1, u1, u1, u2, u2, u2} C _inst_1 C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) M) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) M)) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) M) (CategoryTheory.Monad.Î¼.{u1, u2} C _inst_1 M) X) (CategoryTheory.NatTrans.app.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) M) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) N) (CategoryTheory.Iso.hom.{max u2 u1, max u1 u2} (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u2, u2} C _inst_1 C _inst_1) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) M) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) N) f) X)) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.comp.{u1, u1, u1, u2, u2, u2} C _inst_1 C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) M) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) M)) X) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) N) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) N) X)) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) N) X) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.comp.{u1, u1, u1, u2, u2, u2} C _inst_1 C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) M) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) M)) X) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) M) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) N) X)) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) N) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) N) X)) (CategoryTheory.Functor.map.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) M) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) M) X) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) N) X) (CategoryTheory.NatTrans.app.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) M) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) N) (CategoryTheory.Iso.hom.{max u2 u1, max u1 u2} (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u2, u2} C _inst_1 C _inst_1) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) M) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) N) f) X)) (CategoryTheory.NatTrans.app.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) M) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) N) (CategoryTheory.Iso.hom.{max u2 u1, max u1 u2} (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u2, u2} C _inst_1 C _inst_1) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) M) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) N) f) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) N) X))) (CategoryTheory.NatTrans.app.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.comp.{u1, u1, u1, u2, u2, u2} C _inst_1 C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) N) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) N)) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) N) (CategoryTheory.Monad.Î¼.{u1, u2} C _inst_1 N) X))) -> (CategoryTheory.Iso.{max u2 u1, max u2 u1} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Monad.category.{u1, u2} C _inst_1) M N)
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {M : CategoryTheory.Monad.{u1, u2} C _inst_1} {N : CategoryTheory.Monad.{u1, u2} C _inst_1} (f : CategoryTheory.Iso.{max u2 u1, max u2 u1} (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 M) (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 N)), (forall (X : C), Eq.{succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1)) X) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 N)) X)) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1)) X) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 M)) X) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 N)) X) (CategoryTheory.NatTrans.app.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 M) (CategoryTheory.Monad.Î·.{u1, u2} C _inst_1 M) X) (CategoryTheory.NatTrans.app.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 M) (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 N) (CategoryTheory.Iso.hom.{max u2 u1, max u2 u1} (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 M) (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 N) f) X)) (CategoryTheory.NatTrans.app.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 N) (CategoryTheory.Monad.Î·.{u1, u2} C _inst_1 N) X)) -> (forall (X : C), Eq.{succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.comp.{u1, u1, u1, u2, u2, u2} C _inst_1 C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 M) (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 M))) X) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 N)) X)) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.comp.{u1, u1, u1, u2, u2, u2} C _inst_1 C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 M) (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 M))) X) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 M)) X) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 N)) X) (CategoryTheory.NatTrans.app.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.comp.{u1, u1, u1, u2, u2, u2} C _inst_1 C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 M) (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 M)) (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 M) (CategoryTheory.Monad.Î¼.{u1, u2} C _inst_1 M) X) (CategoryTheory.NatTrans.app.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 M) (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 N) (CategoryTheory.Iso.hom.{max u2 u1, max u2 u1} (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 M) (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 N) f) X)) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 M)) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 M)) X)) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 N)) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 N)) X)) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 N)) X) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 M)) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 M)) X)) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 M)) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 N)) X)) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 N)) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 N)) X)) (Prefunctor.map.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 M)) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 M)) X) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 N)) X) (CategoryTheory.NatTrans.app.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 M) (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 N) (CategoryTheory.Iso.hom.{max u2 u1, max u2 u1} (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 M) (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 N) f) X)) (CategoryTheory.NatTrans.app.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 M) (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 N) (CategoryTheory.Iso.hom.{max u2 u1, max u2 u1} (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 M) (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 N) f) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 N)) X))) (CategoryTheory.NatTrans.app.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.comp.{u1, u1, u1, u2, u2, u2} C _inst_1 C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 N) (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 N)) (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 N) (CategoryTheory.Monad.Î¼.{u1, u2} C _inst_1 N) X))) -> (CategoryTheory.Iso.{max u2 u1, max u2 u1} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.instCategoryMonad.{u1, u2} C _inst_1) M N)
Case conversion may be inaccurate. Consider using '#align category_theory.monad_iso.mk CategoryTheory.MonadIso.mkâ‚“'. -/
/-- Construct a monad isomorphism from a natural isomorphism of functors where the forward
direction is a monad morphism. -/
@[simps]
def MonadIso.mk {M N : Monad C} (f : (M : C â¥¤ C) â‰… N) (f_Î· f_Î¼) : M â‰… N
    where
  Hom :=
    { toNatTrans := f.Hom
      app_Î·' := f_Î·
      app_Î¼' := f_Î¼ }
  inv :=
    { toNatTrans := f.inv
      app_Î·' := fun X => by simp [â† f_Î·]
      app_Î¼' := fun X => by
        rw [â† nat_iso.cancel_nat_iso_hom_right f]
        simp only [nat_trans.naturality, iso.inv_hom_id_app, assoc, comp_id, f_Î¼,
          nat_trans.naturality_assoc, iso.inv_hom_id_app_assoc, â† functor.map_comp_assoc]
        simp }
#align category_theory.monad_iso.mk CategoryTheory.MonadIso.mk

/- warning: category_theory.comonad_iso.mk -> CategoryTheory.ComonadIso.mk is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {M : CategoryTheory.Comonad.{u1, u2} C _inst_1} {N : CategoryTheory.Comonad.{u1, u2} C _inst_1} (f : CategoryTheory.Iso.{max u2 u1, max u1 u2} (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u2, u2} C _inst_1 C _inst_1) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) M) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) N)), (forall (X : C), Eq.{succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) M) X) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) X)) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) M) X) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) N) X) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) X) (CategoryTheory.NatTrans.app.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) M) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) N) (CategoryTheory.Iso.hom.{max u2 u1, max u1 u2} (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u2, u2} C _inst_1 C _inst_1) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) M) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) N) f) X) (CategoryTheory.NatTrans.app.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) N) (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Comonad.Îµ.{u1, u2} C _inst_1 N) X)) (CategoryTheory.NatTrans.app.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) M) (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Comonad.Îµ.{u1, u2} C _inst_1 M) X)) -> (forall (X : C), Eq.{succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) M) X) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.comp.{u1, u1, u1, u2, u2, u2} C _inst_1 C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) N) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) N)) X)) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) M) X) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) N) X) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.comp.{u1, u1, u1, u2, u2, u2} C _inst_1 C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) N) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) N)) X) (CategoryTheory.NatTrans.app.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) M) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) N) (CategoryTheory.Iso.hom.{max u2 u1, max u1 u2} (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u2, u2} C _inst_1 C _inst_1) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) M) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) N) f) X) (CategoryTheory.NatTrans.app.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) N) (CategoryTheory.Functor.comp.{u1, u1, u1, u2, u2, u2} C _inst_1 C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) N) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) N)) (CategoryTheory.Comonad.Î´.{u1, u2} C _inst_1 N) X)) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) M) X) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.comp.{u1, u1, u1, u2, u2, u2} C _inst_1 C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) M) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) M)) X) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.comp.{u1, u1, u1, u2, u2, u2} C _inst_1 C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) N) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) N)) X) (CategoryTheory.NatTrans.app.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) M) (CategoryTheory.Functor.comp.{u1, u1, u1, u2, u2, u2} C _inst_1 C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) M) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) M)) (CategoryTheory.Comonad.Î´.{u1, u2} C _inst_1 M) X) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.comp.{u1, u1, u1, u2, u2, u2} C _inst_1 C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) M) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) M)) X) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) N) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) M) X)) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.comp.{u1, u1, u1, u2, u2, u2} C _inst_1 C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) N) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) N)) X) (CategoryTheory.NatTrans.app.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) M) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) N) (CategoryTheory.Iso.hom.{max u2 u1, max u1 u2} (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u2, u2} C _inst_1 C _inst_1) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) M) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) N) f) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) M) X)) (CategoryTheory.Functor.map.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) N) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) M) X) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) N) X) (CategoryTheory.NatTrans.app.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) M) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) N) (CategoryTheory.Iso.hom.{max u2 u1, max u1 u2} (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u2, u2} C _inst_1 C _inst_1) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) M) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) N) f) X))))) -> (CategoryTheory.Iso.{max u2 u1, max u2 u1} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Comonad.category.{u1, u2} C _inst_1) M N)
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {M : CategoryTheory.Comonad.{u1, u2} C _inst_1} {N : CategoryTheory.Comonad.{u1, u2} C _inst_1} (f : CategoryTheory.Iso.{max u2 u1, max u2 u1} (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 M) (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 N)), (forall (X : C), Eq.{succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 M)) X) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1)) X)) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 M)) X) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 N)) X) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1)) X) (CategoryTheory.NatTrans.app.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 M) (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 N) (CategoryTheory.Iso.hom.{max u2 u1, max u2 u1} (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 M) (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 N) f) X) (CategoryTheory.NatTrans.app.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 N) (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Comonad.Îµ.{u1, u2} C _inst_1 N) X)) (CategoryTheory.NatTrans.app.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 M) (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Comonad.Îµ.{u1, u2} C _inst_1 M) X)) -> (forall (X : C), Eq.{succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 M)) X) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.comp.{u1, u1, u1, u2, u2, u2} C _inst_1 C _inst_1 C _inst_1 (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 N) (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 N))) X)) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 M)) X) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 N)) X) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.comp.{u1, u1, u1, u2, u2, u2} C _inst_1 C _inst_1 C _inst_1 (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 N) (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 N))) X) (CategoryTheory.NatTrans.app.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 M) (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 N) (CategoryTheory.Iso.hom.{max u2 u1, max u2 u1} (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 M) (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 N) f) X) (CategoryTheory.NatTrans.app.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 N) (CategoryTheory.Functor.comp.{u1, u1, u1, u2, u2, u2} C _inst_1 C _inst_1 C _inst_1 (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 N) (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 N)) (CategoryTheory.Comonad.Î´.{u1, u2} C _inst_1 N) X)) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 M)) X) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.comp.{u1, u1, u1, u2, u2, u2} C _inst_1 C _inst_1 C _inst_1 (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 M) (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 M))) X) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 N)) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 N)) X)) (CategoryTheory.NatTrans.app.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 M) (CategoryTheory.Functor.comp.{u1, u1, u1, u2, u2, u2} C _inst_1 C _inst_1 C _inst_1 (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 M) (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 M)) (CategoryTheory.Comonad.Î´.{u1, u2} C _inst_1 M) X) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.comp.{u1, u1, u1, u2, u2, u2} C _inst_1 C _inst_1 C _inst_1 (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 M) (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 M))) X) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 N)) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 M)) X)) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 N)) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 N)) X)) (CategoryTheory.NatTrans.app.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 M) (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 N) (CategoryTheory.Iso.hom.{max u2 u1, max u2 u1} (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 M) (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 N) f) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 M)) X)) (Prefunctor.map.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 N)) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 M)) X) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 N)) X) (CategoryTheory.NatTrans.app.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 M) (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 N) (CategoryTheory.Iso.hom.{max u2 u1, max u2 u1} (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 M) (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 N) f) X))))) -> (CategoryTheory.Iso.{max u2 u1, max u2 u1} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.instCategoryComonad.{u1, u2} C _inst_1) M N)
Case conversion may be inaccurate. Consider using '#align category_theory.comonad_iso.mk CategoryTheory.ComonadIso.mkâ‚“'. -/
/-- Construct a comonad isomorphism from a natural isomorphism of functors where the forward
direction is a comonad morphism. -/
@[simps]
def ComonadIso.mk {M N : Comonad C} (f : (M : C â¥¤ C) â‰… N) (f_Îµ f_Î´) : M â‰… N
    where
  Hom :=
    { toNatTrans := f.Hom
      app_Îµ' := f_Îµ
      app_Î´' := f_Î´ }
  inv :=
    { toNatTrans := f.inv
      app_Îµ' := fun X => by simp [â† f_Îµ]
      app_Î´' := fun X => by
        rw [â† nat_iso.cancel_nat_iso_hom_left f]
        simp only [reassoc_of (f_Î´ X), iso.hom_inv_id_app_assoc, nat_trans.naturality_assoc]
        rw [â† functor.map_comp, iso.hom_inv_id_app, Functor.map_id]
        apply (comp_id _).symm }
#align category_theory.comonad_iso.mk CategoryTheory.ComonadIso.mk

variable (C)

/- warning: category_theory.monad_to_functor -> CategoryTheory.monadToFunctor is a dubious translation:
lean 3 declaration is
  forall (C : Type.{u2}) [_inst_1 : CategoryTheory.Category.{u1, u2} C], CategoryTheory.Functor.{max u2 u1, max u2 u1, max u2 u1, max u1 u2} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Monad.category.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u2, u2} C _inst_1 C _inst_1)
but is expected to have type
  forall (C : Type.{u2}) [_inst_1 : CategoryTheory.Category.{u1, u2} C], CategoryTheory.Functor.{max u2 u1, max u2 u1, max u2 u1, max u2 u1} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.instCategoryMonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u2, u2} C _inst_1 C _inst_1)
Case conversion may be inaccurate. Consider using '#align category_theory.monad_to_functor CategoryTheory.monadToFunctorâ‚“'. -/
/-- The forgetful functor from the category of monads to the category of endofunctors.
-/
@[simps]
def monadToFunctor : Monad C â¥¤ C â¥¤ C where
  obj T := T
  map M N f := f.toNatTrans
#align category_theory.monad_to_functor CategoryTheory.monadToFunctor

instance : Faithful (monadToFunctor C) where

/- warning: category_theory.monad_to_functor_map_iso_monad_iso_mk -> CategoryTheory.monadToFunctor_mapIso_monad_iso_mk is a dubious translation:
lean 3 declaration is
  forall (C : Type.{u2}) [_inst_1 : CategoryTheory.Category.{u1, u2} C] {M : CategoryTheory.Monad.{u1, u2} C _inst_1} {N : CategoryTheory.Monad.{u1, u2} C _inst_1} (f : CategoryTheory.Iso.{max u2 u1, max u1 u2} (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u2, u2} C _inst_1 C _inst_1) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) M) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) N)) (f_Î· : forall (X : C), Eq.{succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) X) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) N) X)) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) X) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) M) X) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) N) X) (CategoryTheory.NatTrans.app.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) M) (CategoryTheory.Monad.Î·.{u1, u2} C _inst_1 M) X) (CategoryTheory.NatTrans.app.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) M) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) N) (CategoryTheory.Iso.hom.{max u2 u1, max u1 u2} (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u2, u2} C _inst_1 C _inst_1) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) M) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) N) f) X)) (CategoryTheory.NatTrans.app.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) N) (CategoryTheory.Monad.Î·.{u1, u2} C _inst_1 N) X)) (f_Î¼ : forall (X : C), Eq.{succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.comp.{u1, u1, u1, u2, u2, u2} C _inst_1 C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) M) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) M)) X) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) N) X)) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.comp.{u1, u1, u1, u2, u2, u2} C _inst_1 C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) M) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) M)) X) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) M) X) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) N) X) (CategoryTheory.NatTrans.app.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.comp.{u1, u1, u1, u2, u2, u2} C _inst_1 C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) M) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) M)) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) M) (CategoryTheory.Monad.Î¼.{u1, u2} C _inst_1 M) X) (CategoryTheory.NatTrans.app.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) M) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) N) (CategoryTheory.Iso.hom.{max u2 u1, max u1 u2} (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u2, u2} C _inst_1 C _inst_1) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) M) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) N) f) X)) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.comp.{u1, u1, u1, u2, u2, u2} C _inst_1 C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) M) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) M)) X) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) N) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) N) X)) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) N) X) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.comp.{u1, u1, u1, u2, u2, u2} C _inst_1 C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) M) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) M)) X) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) M) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) N) X)) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) N) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) N) X)) (CategoryTheory.Functor.map.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) M) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) M) X) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) N) X) (CategoryTheory.NatTrans.app.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) M) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) N) (CategoryTheory.Iso.hom.{max u2 u1, max u1 u2} (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u2, u2} C _inst_1 C _inst_1) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) M) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) N) f) X)) (CategoryTheory.NatTrans.app.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) M) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) N) (CategoryTheory.Iso.hom.{max u2 u1, max u1 u2} (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u2, u2} C _inst_1 C _inst_1) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) M) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) N) f) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) N) X))) (CategoryTheory.NatTrans.app.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.comp.{u1, u1, u1, u2, u2, u2} C _inst_1 C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) N) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) N)) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) N) (CategoryTheory.Monad.Î¼.{u1, u2} C _inst_1 N) X))), Eq.{succ (max u2 u1)} (CategoryTheory.Iso.{max u2 u1, max u1 u2} (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.Functor.obj.{max u2 u1, max u2 u1, max u2 u1, max u1 u2} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Monad.category.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.monadToFunctor.{u1, u2} C _inst_1) M) (CategoryTheory.Functor.obj.{max u2 u1, max u2 u1, max u2 u1, max u1 u2} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Monad.category.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.monadToFunctor.{u1, u2} C _inst_1) N)) (CategoryTheory.Functor.mapIso.{max u2 u1, max u2 u1, max u1 u2, max u2 u1} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Monad.category.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.monadToFunctor.{u1, u2} C _inst_1) M N (CategoryTheory.MonadIso.mk.{u1, u2} C _inst_1 M N f f_Î· f_Î¼)) f
but is expected to have type
  forall (C : Type.{u2}) [_inst_1 : CategoryTheory.Category.{u1, u2} C] {M : CategoryTheory.Monad.{u1, u2} C _inst_1} {N : CategoryTheory.Monad.{u1, u2} C _inst_1} (f : CategoryTheory.Iso.{max u2 u1, max u2 u1} (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 M) (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 N)) (f_Î· : forall (X : C), Eq.{succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1)) X) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 N)) X)) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1)) X) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 M)) X) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 N)) X) (CategoryTheory.NatTrans.app.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 M) (CategoryTheory.Monad.Î·.{u1, u2} C _inst_1 M) X) (CategoryTheory.NatTrans.app.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 M) (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 N) (CategoryTheory.Iso.hom.{max u2 u1, max u2 u1} (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 M) (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 N) f) X)) (CategoryTheory.NatTrans.app.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 N) (CategoryTheory.Monad.Î·.{u1, u2} C _inst_1 N) X)) (f_Î¼ : forall (X : C), Eq.{succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.comp.{u1, u1, u1, u2, u2, u2} C _inst_1 C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 M) (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 M))) X) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 N)) X)) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.comp.{u1, u1, u1, u2, u2, u2} C _inst_1 C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 M) (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 M))) X) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 M)) X) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 N)) X) (CategoryTheory.NatTrans.app.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.comp.{u1, u1, u1, u2, u2, u2} C _inst_1 C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 M) (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 M)) (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 M) (CategoryTheory.Monad.Î¼.{u1, u2} C _inst_1 M) X) (CategoryTheory.NatTrans.app.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 M) (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 N) (CategoryTheory.Iso.hom.{max u2 u1, max u2 u1} (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 M) (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 N) f) X)) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 M)) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 M)) X)) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 N)) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 N)) X)) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 N)) X) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 M)) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 M)) X)) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 M)) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 N)) X)) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 N)) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 N)) X)) (Prefunctor.map.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 M)) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 M)) X) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 N)) X) (CategoryTheory.NatTrans.app.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 M) (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 N) (CategoryTheory.Iso.hom.{max u2 u1, max u2 u1} (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 M) (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 N) f) X)) (CategoryTheory.NatTrans.app.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 M) (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 N) (CategoryTheory.Iso.hom.{max u2 u1, max u2 u1} (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 M) (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 N) f) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 N)) X))) (CategoryTheory.NatTrans.app.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.comp.{u1, u1, u1, u2, u2, u2} C _inst_1 C _inst_1 C _inst_1 (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 N) (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 N)) (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 N) (CategoryTheory.Monad.Î¼.{u1, u2} C _inst_1 N) X))), Eq.{max (succ u2) (succ u1)} (CategoryTheory.Iso.{max u2 u1, max u2 u1} (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u2, u2} C _inst_1 C _inst_1) (Prefunctor.obj.{succ (max u2 u1), succ (max u2 u1), max u2 u1, max u2 u1} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.instCategoryMonad.{u1, u2} C _inst_1))) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u2, u2} C _inst_1 C _inst_1))) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, max u2 u1, max u2 u1, max u2 u1} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.instCategoryMonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.monadToFunctor.{u1, u2} C _inst_1)) M) (Prefunctor.obj.{succ (max u2 u1), succ (max u2 u1), max u2 u1, max u2 u1} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.instCategoryMonad.{u1, u2} C _inst_1))) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u2, u2} C _inst_1 C _inst_1))) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, max u2 u1, max u2 u1, max u2 u1} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.instCategoryMonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.monadToFunctor.{u1, u2} C _inst_1)) N)) (CategoryTheory.Functor.mapIso.{max u2 u1, max u2 u1, max u2 u1, max u2 u1} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.instCategoryMonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.monadToFunctor.{u1, u2} C _inst_1) M N (CategoryTheory.MonadIso.mk.{u1, u2} C _inst_1 M N f f_Î· f_Î¼)) f
Case conversion may be inaccurate. Consider using '#align category_theory.monad_to_functor_map_iso_monad_iso_mk CategoryTheory.monadToFunctor_mapIso_monad_iso_mkâ‚“'. -/
theorem monadToFunctor_mapIso_monad_iso_mk {M N : Monad C} (f : (M : C â¥¤ C) â‰… N) (f_Î· f_Î¼) :
    (monadToFunctor _).mapIso (MonadIso.mk f f_Î· f_Î¼) = f :=
  by
  ext
  rfl
#align category_theory.monad_to_functor_map_iso_monad_iso_mk CategoryTheory.monadToFunctor_mapIso_monad_iso_mk

instance : ReflectsIsomorphisms (monadToFunctor C)
    where reflects M N f i := by
    skip
    convert is_iso.of_iso (monad_iso.mk (as_iso ((monad_to_functor C).map f)) f.app_Î· f.app_Î¼)
    ext <;> rfl

/- warning: category_theory.comonad_to_functor -> CategoryTheory.comonadToFunctor is a dubious translation:
lean 3 declaration is
  forall (C : Type.{u2}) [_inst_1 : CategoryTheory.Category.{u1, u2} C], CategoryTheory.Functor.{max u2 u1, max u2 u1, max u2 u1, max u1 u2} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Comonad.category.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u2, u2} C _inst_1 C _inst_1)
but is expected to have type
  forall (C : Type.{u2}) [_inst_1 : CategoryTheory.Category.{u1, u2} C], CategoryTheory.Functor.{max u2 u1, max u2 u1, max u2 u1, max u2 u1} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.instCategoryComonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u2, u2} C _inst_1 C _inst_1)
Case conversion may be inaccurate. Consider using '#align category_theory.comonad_to_functor CategoryTheory.comonadToFunctorâ‚“'. -/
/-- The forgetful functor from the category of comonads to the category of endofunctors.
-/
@[simps]
def comonadToFunctor : Comonad C â¥¤ C â¥¤ C where
  obj G := G
  map M N f := f.toNatTrans
#align category_theory.comonad_to_functor CategoryTheory.comonadToFunctor

instance : Faithful (comonadToFunctor C) where

/- warning: category_theory.comonad_to_functor_map_iso_comonad_iso_mk -> CategoryTheory.comonadToFunctor_mapIso_comonad_iso_mk is a dubious translation:
lean 3 declaration is
  forall (C : Type.{u2}) [_inst_1 : CategoryTheory.Category.{u1, u2} C] {M : CategoryTheory.Comonad.{u1, u2} C _inst_1} {N : CategoryTheory.Comonad.{u1, u2} C _inst_1} (f : CategoryTheory.Iso.{max u2 u1, max u1 u2} (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u2, u2} C _inst_1 C _inst_1) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) M) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) N)) (f_Îµ : forall (X : C), Eq.{succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) M) X) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) X)) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) M) X) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) N) X) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1) X) (CategoryTheory.NatTrans.app.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) M) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) N) (CategoryTheory.Iso.hom.{max u2 u1, max u1 u2} (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u2, u2} C _inst_1 C _inst_1) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) M) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) N) f) X) (CategoryTheory.NatTrans.app.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) N) (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Comonad.Îµ.{u1, u2} C _inst_1 N) X)) (CategoryTheory.NatTrans.app.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) M) (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Comonad.Îµ.{u1, u2} C _inst_1 M) X)) (f_Î´ : forall (X : C), Eq.{succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) M) X) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.comp.{u1, u1, u1, u2, u2, u2} C _inst_1 C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) N) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) N)) X)) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) M) X) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) N) X) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.comp.{u1, u1, u1, u2, u2, u2} C _inst_1 C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) N) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) N)) X) (CategoryTheory.NatTrans.app.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) M) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) N) (CategoryTheory.Iso.hom.{max u2 u1, max u1 u2} (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u2, u2} C _inst_1 C _inst_1) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) M) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) N) f) X) (CategoryTheory.NatTrans.app.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) N) (CategoryTheory.Functor.comp.{u1, u1, u1, u2, u2, u2} C _inst_1 C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) N) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) N)) (CategoryTheory.Comonad.Î´.{u1, u2} C _inst_1 N) X)) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) M) X) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.comp.{u1, u1, u1, u2, u2, u2} C _inst_1 C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) M) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) M)) X) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.comp.{u1, u1, u1, u2, u2, u2} C _inst_1 C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) N) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) N)) X) (CategoryTheory.NatTrans.app.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) M) (CategoryTheory.Functor.comp.{u1, u1, u1, u2, u2, u2} C _inst_1 C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) M) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) M)) (CategoryTheory.Comonad.Î´.{u1, u2} C _inst_1 M) X) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.comp.{u1, u1, u1, u2, u2, u2} C _inst_1 C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) M) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) M)) X) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) N) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) M) X)) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.comp.{u1, u1, u1, u2, u2, u2} C _inst_1 C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) N) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) N)) X) (CategoryTheory.NatTrans.app.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) M) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) N) (CategoryTheory.Iso.hom.{max u2 u1, max u1 u2} (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u2, u2} C _inst_1 C _inst_1) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) M) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) N) f) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) M) X)) (CategoryTheory.Functor.map.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) N) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) M) X) (CategoryTheory.Functor.obj.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) N) X) (CategoryTheory.NatTrans.app.{u1, u1, u2, u2} C _inst_1 C _inst_1 ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) M) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) N) (CategoryTheory.Iso.hom.{max u2 u1, max u1 u2} (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u2, u2} C _inst_1 C _inst_1) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) M) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) N) f) X))))), Eq.{succ (max u2 u1)} (CategoryTheory.Iso.{max u2 u1, max u1 u2} (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.Functor.obj.{max u2 u1, max u2 u1, max u2 u1, max u1 u2} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Comonad.category.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.comonadToFunctor.{u1, u2} C _inst_1) M) (CategoryTheory.Functor.obj.{max u2 u1, max u2 u1, max u2 u1, max u1 u2} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Comonad.category.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.comonadToFunctor.{u1, u2} C _inst_1) N)) (CategoryTheory.Functor.mapIso.{max u2 u1, max u2 u1, max u1 u2, max u2 u1} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Comonad.category.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.comonadToFunctor.{u1, u2} C _inst_1) M N (CategoryTheory.ComonadIso.mk.{u1, u2} C _inst_1 M N f f_Îµ f_Î´)) f
but is expected to have type
  forall (C : Type.{u2}) [_inst_1 : CategoryTheory.Category.{u1, u2} C] {M : CategoryTheory.Comonad.{u1, u2} C _inst_1} {N : CategoryTheory.Comonad.{u1, u2} C _inst_1} (f : CategoryTheory.Iso.{max u2 u1, max u2 u1} (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 M) (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 N)) (f_Îµ : forall (X : C), Eq.{succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 M)) X) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1)) X)) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 M)) X) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 N)) X) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.id.{u1, u2} C _inst_1)) X) (CategoryTheory.NatTrans.app.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 M) (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 N) (CategoryTheory.Iso.hom.{max u2 u1, max u2 u1} (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 M) (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 N) f) X) (CategoryTheory.NatTrans.app.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 N) (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Comonad.Îµ.{u1, u2} C _inst_1 N) X)) (CategoryTheory.NatTrans.app.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 M) (CategoryTheory.Functor.id.{u1, u2} C _inst_1) (CategoryTheory.Comonad.Îµ.{u1, u2} C _inst_1 M) X)) (f_Î´ : forall (X : C), Eq.{succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 M)) X) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.comp.{u1, u1, u1, u2, u2, u2} C _inst_1 C _inst_1 C _inst_1 (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 N) (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 N))) X)) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 M)) X) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 N)) X) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.comp.{u1, u1, u1, u2, u2, u2} C _inst_1 C _inst_1 C _inst_1 (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 N) (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 N))) X) (CategoryTheory.NatTrans.app.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 M) (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 N) (CategoryTheory.Iso.hom.{max u2 u1, max u2 u1} (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 M) (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 N) f) X) (CategoryTheory.NatTrans.app.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 N) (CategoryTheory.Functor.comp.{u1, u1, u1, u2, u2, u2} C _inst_1 C _inst_1 C _inst_1 (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 N) (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 N)) (CategoryTheory.Comonad.Î´.{u1, u2} C _inst_1 N) X)) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 M)) X) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.comp.{u1, u1, u1, u2, u2, u2} C _inst_1 C _inst_1 C _inst_1 (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 M) (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 M))) X) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 N)) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 N)) X)) (CategoryTheory.NatTrans.app.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 M) (CategoryTheory.Functor.comp.{u1, u1, u1, u2, u2, u2} C _inst_1 C _inst_1 C _inst_1 (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 M) (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 M)) (CategoryTheory.Comonad.Î´.{u1, u2} C _inst_1 M) X) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Functor.comp.{u1, u1, u1, u2, u2, u2} C _inst_1 C _inst_1 C _inst_1 (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 M) (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 M))) X) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 N)) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 M)) X)) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 N)) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 N)) X)) (CategoryTheory.NatTrans.app.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 M) (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 N) (CategoryTheory.Iso.hom.{max u2 u1, max u2 u1} (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 M) (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 N) f) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 M)) X)) (Prefunctor.map.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 N)) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 M)) X) (Prefunctor.obj.{succ u1, succ u1, u2, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 N)) X) (CategoryTheory.NatTrans.app.{u1, u1, u2, u2} C _inst_1 C _inst_1 (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 M) (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 N) (CategoryTheory.Iso.hom.{max u2 u1, max u2 u1} (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 M) (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 N) f) X))))), Eq.{max (succ u2) (succ u1)} (CategoryTheory.Iso.{max u2 u1, max u2 u1} (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u2, u2} C _inst_1 C _inst_1) (Prefunctor.obj.{succ (max u2 u1), succ (max u2 u1), max u2 u1, max u2 u1} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.instCategoryComonad.{u1, u2} C _inst_1))) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u2, u2} C _inst_1 C _inst_1))) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, max u2 u1, max u2 u1, max u2 u1} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.instCategoryComonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.comonadToFunctor.{u1, u2} C _inst_1)) M) (Prefunctor.obj.{succ (max u2 u1), succ (max u2 u1), max u2 u1, max u2 u1} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.instCategoryComonad.{u1, u2} C _inst_1))) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 u1} (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 u1} (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u2, u2} C _inst_1 C _inst_1))) (CategoryTheory.Functor.toPrefunctor.{max u2 u1, max u2 u1, max u2 u1, max u2 u1} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.instCategoryComonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.comonadToFunctor.{u1, u2} C _inst_1)) N)) (CategoryTheory.Functor.mapIso.{max u2 u1, max u2 u1, max u2 u1, max u2 u1} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.instCategoryComonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.comonadToFunctor.{u1, u2} C _inst_1) M N (CategoryTheory.ComonadIso.mk.{u1, u2} C _inst_1 M N f f_Îµ f_Î´)) f
Case conversion may be inaccurate. Consider using '#align category_theory.comonad_to_functor_map_iso_comonad_iso_mk CategoryTheory.comonadToFunctor_mapIso_comonad_iso_mkâ‚“'. -/
theorem comonadToFunctor_mapIso_comonad_iso_mk {M N : Comonad C} (f : (M : C â¥¤ C) â‰… N) (f_Îµ f_Î´) :
    (comonadToFunctor _).mapIso (ComonadIso.mk f f_Îµ f_Î´) = f :=
  by
  ext
  rfl
#align category_theory.comonad_to_functor_map_iso_comonad_iso_mk CategoryTheory.comonadToFunctor_mapIso_comonad_iso_mk

instance : ReflectsIsomorphisms (comonadToFunctor C)
    where reflects M N f i := by
    skip
    convert is_iso.of_iso (comonad_iso.mk (as_iso ((comonad_to_functor C).map f)) f.app_Îµ f.app_Î´)
    ext <;> rfl

variable {C}

/- warning: category_theory.monad_iso.to_nat_iso -> CategoryTheory.MonadIso.toNatIso is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {M : CategoryTheory.Monad.{u1, u2} C _inst_1} {N : CategoryTheory.Monad.{u1, u2} C _inst_1}, (CategoryTheory.Iso.{max u2 u1, max u2 u1} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Monad.category.{u1, u2} C _inst_1) M N) -> (CategoryTheory.Iso.{max u2 u1, max u1 u2} (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u2, u2} C _inst_1 C _inst_1) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) M) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeMonad.{u1, u2} C _inst_1)))) N))
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {M : CategoryTheory.Monad.{u1, u2} C _inst_1} {N : CategoryTheory.Monad.{u1, u2} C _inst_1}, (CategoryTheory.Iso.{max u2 u1, max u2 u1} (CategoryTheory.Monad.{u1, u2} C _inst_1) (CategoryTheory.instCategoryMonad.{u1, u2} C _inst_1) M N) -> (CategoryTheory.Iso.{max u2 u1, max u2 u1} (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 M) (CategoryTheory.Monad.toFunctor.{u1, u2} C _inst_1 N))
Case conversion may be inaccurate. Consider using '#align category_theory.monad_iso.to_nat_iso CategoryTheory.MonadIso.toNatIsoâ‚“'. -/
/-- An isomorphism of monads gives a natural isomorphism of the underlying functors.
-/
@[simps (config := { rhsMd := semireducible })]
def MonadIso.toNatIso {M N : Monad C} (h : M â‰… N) : (M : C â¥¤ C) â‰… N :=
  (monadToFunctor C).mapIso h
#align category_theory.monad_iso.to_nat_iso CategoryTheory.MonadIso.toNatIso

/- warning: category_theory.comonad_iso.to_nat_iso -> CategoryTheory.ComonadIso.toNatIso is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {M : CategoryTheory.Comonad.{u1, u2} C _inst_1} {N : CategoryTheory.Comonad.{u1, u2} C _inst_1}, (CategoryTheory.Iso.{max u2 u1, max u2 u1} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Comonad.category.{u1, u2} C _inst_1) M N) -> (CategoryTheory.Iso.{max u2 u1, max u1 u2} (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u2, u2} C _inst_1 C _inst_1) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) M) ((fun (a : Sort.{max (succ u2) (succ u1)}) (b : Type.{max u1 u2}) [self : HasLiftT.{max (succ u2) (succ u1), succ (max u1 u2)} a b] => self.0) (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (HasLiftT.mk.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CoeTCâ‚“.coe.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (coeBase.{max (succ u2) (succ u1), succ (max u1 u2)} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.coeComonad.{u1, u2} C _inst_1)))) N))
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {M : CategoryTheory.Comonad.{u1, u2} C _inst_1} {N : CategoryTheory.Comonad.{u1, u2} C _inst_1}, (CategoryTheory.Iso.{max u2 u1, max u2 u1} (CategoryTheory.Comonad.{u1, u2} C _inst_1) (CategoryTheory.instCategoryComonad.{u1, u2} C _inst_1) M N) -> (CategoryTheory.Iso.{max u2 u1, max u2 u1} (CategoryTheory.Functor.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.Functor.category.{u1, u1, u2, u2} C _inst_1 C _inst_1) (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 M) (CategoryTheory.Comonad.toFunctor.{u1, u2} C _inst_1 N))
Case conversion may be inaccurate. Consider using '#align category_theory.comonad_iso.to_nat_iso CategoryTheory.ComonadIso.toNatIsoâ‚“'. -/
/-- An isomorphism of comonads gives a natural isomorphism of the underlying functors.
-/
@[simps (config := { rhsMd := semireducible })]
def ComonadIso.toNatIso {M N : Comonad C} (h : M â‰… N) : (M : C â¥¤ C) â‰… N :=
  (comonadToFunctor C).mapIso h
#align category_theory.comonad_iso.to_nat_iso CategoryTheory.ComonadIso.toNatIso

variable (C)

namespace Monad

#print CategoryTheory.Monad.id /-
/-- The identity monad. -/
@[simps]
def id : Monad C where
  toFunctor := ðŸ­ C
  Î·' := ðŸ™ (ðŸ­ C)
  Î¼' := ðŸ™ (ðŸ­ C)
#align category_theory.monad.id CategoryTheory.Monad.id
-/

instance : Inhabited (Monad C) :=
  âŸ¨Monad.id CâŸ©

end Monad

namespace Comonad

#print CategoryTheory.Comonad.id /-
/-- The identity comonad. -/
@[simps]
def id : Comonad C where
  toFunctor := ðŸ­ _
  Îµ' := ðŸ™ (ðŸ­ C)
  Î´' := ðŸ™ (ðŸ­ C)
#align category_theory.comonad.id CategoryTheory.Comonad.id
-/

instance : Inhabited (Comonad C) :=
  âŸ¨Comonad.id CâŸ©

end Comonad

end CategoryTheory

