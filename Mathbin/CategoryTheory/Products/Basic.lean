/-
Copyright (c) 2017 Scott Morrison. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Stephen Morgan, Scott Morrison
-/
import Mathbin.CategoryTheory.EqToHom

/-!
# Cartesian products of categories

We define the category instance on `C Ã— D` when `C` and `D` are categories.

We define:
* `sectl C Z` : the functor `C â¥¤ C Ã— D` given by `X â†¦ âŸ¨X, ZâŸ©`
* `sectr Z D` : the functor `D â¥¤ C Ã— D` given by `Y â†¦ âŸ¨Z, YâŸ©`
* `fst`       : the functor `âŸ¨X, YâŸ© â†¦ X`
* `snd`       : the functor `âŸ¨X, YâŸ© â†¦ Y`
* `swap`      : the functor `C Ã— D â¥¤ D Ã— C` given by `âŸ¨X, YâŸ© â†¦ âŸ¨Y, XâŸ©`
    (and the fact this is an equivalence)

We further define `evaluation : C â¥¤ (C â¥¤ D) â¥¤ D` and `evaluation_uncurried : C Ã— (C â¥¤ D) â¥¤ D`,
and products of functors and natural transformations, written `F.prod G` and `Î±.prod Î²`.
-/


namespace CategoryTheory

-- declare the `v`'s first; see `category_theory.category` for an explanation
universe vâ‚ vâ‚‚ vâ‚ƒ vâ‚„ uâ‚ uâ‚‚ uâ‚ƒ uâ‚„

section

variable (C : Type uâ‚) [Category.{vâ‚} C] (D : Type uâ‚‚) [Category.{vâ‚‚} D]

/-- `prod C D` gives the cartesian product of two categories.

See https://stacks.math.columbia.edu/tag/001K.
-/
-- the generates simp lemmas like `id_fst` and `comp_snd`
@[simps (config := { notRecursive := [] })]
instance prod : Category.{max vâ‚ vâ‚‚} (C Ã— D) where
  Hom := fun X Y => (X.1 âŸ¶ Y.1) Ã— (X.2 âŸ¶ Y.2)
  id := fun X => âŸ¨ğŸ™ X.1, ğŸ™ X.2âŸ©
  comp := fun _ _ _ f g => (f.1 â‰« g.1, f.2 â‰« g.2)

/-- Two rfl lemmas that cannot be generated by `@[simps]`. -/
@[simp]
theorem prod_id (X : C) (Y : D) : ğŸ™ (X, Y) = (ğŸ™ X, ğŸ™ Y) :=
  rfl

@[simp]
theorem prod_comp {P Q R : C} {S T U : D} (f : (P, S) âŸ¶ (Q, T)) (g : (Q, T) âŸ¶ (R, U)) :
    f â‰« g = (f.1 â‰« g.1, f.2 â‰« g.2) :=
  rfl

theorem is_iso_prod_iff {P Q : C} {S T : D} {f : (P, S) âŸ¶ (Q, T)} : IsIso f â†” IsIso f.1 âˆ§ IsIso f.2 := by
  constructor
  Â· rintro âŸ¨g, hfg, hgfâŸ©
    simp at hfg hgf
    rcases hfg with âŸ¨hfgâ‚, hfgâ‚‚âŸ©
    rcases hgf with âŸ¨hgfâ‚, hgfâ‚‚âŸ©
    exact âŸ¨âŸ¨âŸ¨g.1, hfgâ‚, hgfâ‚âŸ©âŸ©, âŸ¨âŸ¨g.2, hfgâ‚‚, hgfâ‚‚âŸ©âŸ©âŸ©
    
  Â· rintro âŸ¨âŸ¨gâ‚, hfgâ‚, hgfâ‚âŸ©, âŸ¨gâ‚‚, hfgâ‚‚, hgfâ‚‚âŸ©âŸ©
    dsimp  at hfgâ‚ hgfâ‚ hfgâ‚‚ hgfâ‚‚
    refine' âŸ¨âŸ¨(gâ‚, gâ‚‚), _, _âŸ©âŸ© <;>
      Â· simp <;> constructor <;> assumption
        
    

section

variable {C D}

/-- Construct an isomorphism in `C Ã— D` out of two isomorphisms in `C` and `D`. -/
@[simps]
def Iso.prod {P Q : C} {S T : D} (f : P â‰… Q) (g : S â‰… T) : (P, S) â‰… (Q, T) where
  Hom := (f.Hom, g.Hom)
  inv := (f.inv, g.inv)

end

end

section

variable (C : Type uâ‚) [Category.{vâ‚} C] (D : Type uâ‚) [Category.{vâ‚} D]

/-- `prod.category.uniform C D` is an additional instance specialised so both factors have the same
universe levels. This helps typeclass resolution.
-/
instance uniformProd : Category (C Ã— D) :=
  CategoryTheory.prod C D

end

-- Next we define the natural functors into and out of product categories. For now this doesn't
-- address the universal properties.
namespace Prod

/-- `sectl C Z` is the functor `C â¥¤ C Ã— D` given by `X â†¦ (X, Z)`. -/
@[simps]
def sectl (C : Type uâ‚) [Category.{vâ‚} C] {D : Type uâ‚‚} [Category.{vâ‚‚} D] (Z : D) : C â¥¤ C Ã— D where
  obj := fun X => (X, Z)
  map := fun X Y f => (f, ğŸ™ Z)

/-- `sectr Z D` is the functor `D â¥¤ C Ã— D` given by `Y â†¦ (Z, Y)` . -/
@[simps]
def sectr {C : Type uâ‚} [Category.{vâ‚} C] (Z : C) (D : Type uâ‚‚) [Category.{vâ‚‚} D] : D â¥¤ C Ã— D where
  obj := fun X => (Z, X)
  map := fun X Y f => (ğŸ™ Z, f)

variable (C : Type uâ‚) [Category.{vâ‚} C] (D : Type uâ‚‚) [Category.{vâ‚‚} D]

/-- `fst` is the functor `(X, Y) â†¦ X`. -/
@[simps]
def fst : C Ã— D â¥¤ C where
  obj := fun X => X.1
  map := fun X Y f => f.1

/-- `snd` is the functor `(X, Y) â†¦ Y`. -/
@[simps]
def snd : C Ã— D â¥¤ D where
  obj := fun X => X.2
  map := fun X Y f => f.2

/-- The functor swapping the factors of a cartesian product of categories, `C Ã— D â¥¤ D Ã— C`. -/
@[simps]
def swap : C Ã— D â¥¤ D Ã— C where
  obj := fun X => (X.2, X.1)
  map := fun _ _ f => (f.2, f.1)

/-- Swapping the factors of a cartesion product of categories twice is naturally isomorphic
to the identity functor.
-/
@[simps]
def symmetry : swap C D â‹™ swap D C â‰… ğŸ­ (C Ã— D) where
  Hom := { app := fun X => ğŸ™ X }
  inv := { app := fun X => ğŸ™ X }

/-- The equivalence, given by swapping factors, between `C Ã— D` and `D Ã— C`.
-/
@[simps]
def braiding : C Ã— D â‰Œ D Ã— C :=
  Equivalence.mk (swap C D) (swap D C)
    (NatIso.ofComponents
      (fun X =>
        eqToIso
          (by
            simp ))
      (by
        tidy))
    (NatIso.ofComponents
      (fun X =>
        eqToIso
          (by
            simp ))
      (by
        tidy))

instance swapIsEquivalence : IsEquivalence (swap C D) :=
  (by
    infer_instance : IsEquivalence (braiding C D).Functor)

end Prod

section

variable (C : Type uâ‚) [Category.{vâ‚} C] (D : Type uâ‚‚) [Category.{vâ‚‚} D]

/-- The "evaluation at `X`" functor, such that
`(evaluation.obj X).obj F = F.obj X`,
which is functorial in both `X` and `F`.
-/
@[simps]
def evaluation : C â¥¤ (C â¥¤ D) â¥¤ D where
  obj := fun X => { obj := fun F => F.obj X, map := fun F G Î± => Î±.app X }
  map := fun X Y f => { app := fun F => F.map f, naturality' := fun F G Î± => Eq.symm (Î±.naturality f) }

/-- The "evaluation of `F` at `X`" functor,
as a functor `C Ã— (C â¥¤ D) â¥¤ D`.
-/
@[simps]
def evaluationUncurried : C Ã— (C â¥¤ D) â¥¤ D where
  obj := fun p => p.2.obj p.1
  map := fun x y f => x.2.map f.1 â‰« f.2.app y.1
  map_comp' := fun X Y Z f g => by
    cases g
    cases f
    cases Z
    cases Y
    cases X
    simp only [prod_comp, nat_trans.comp_app, functor.map_comp, category.assoc]
    rw [â† nat_trans.comp_app, nat_trans.naturality, nat_trans.comp_app, category.assoc, nat_trans.naturality]

end

variable {A : Type uâ‚} [Category.{vâ‚} A] {B : Type uâ‚‚} [Category.{vâ‚‚} B] {C : Type uâ‚ƒ} [Category.{vâ‚ƒ} C] {D : Type uâ‚„}
  [Category.{vâ‚„} D]

namespace Functor

/-- The cartesian product of two functors. -/
@[simps]
def prod (F : A â¥¤ B) (G : C â¥¤ D) : A Ã— C â¥¤ B Ã— D where
  obj := fun X => (F.obj X.1, G.obj X.2)
  map := fun _ _ f => (F.map f.1, G.map f.2)

/-- Similar to `prod`, but both functors start from the same category `A` -/
/- Because of limitations in Lean 3's handling of notations, we do not setup a notation `F Ã— G`.
   You can use `F.prod G` as a "poor man's infix", or just write `functor.prod F G`. -/
@[simps]
def prod' (F : A â¥¤ B) (G : A â¥¤ C) : A â¥¤ B Ã— C where
  obj := fun a => (F.obj a, G.obj a)
  map := fun x y f => (F.map f, G.map f)

section

variable (C)

/-- The diagonal functor. -/
def diag : C â¥¤ C Ã— C :=
  (ğŸ­ C).prod' (ğŸ­ C)

@[simp]
theorem diag_obj (X : C) : (diag C).obj X = (X, X) :=
  rfl

@[simp]
theorem diag_map {X Y : C} (f : X âŸ¶ Y) : (diag C).map f = (f, f) :=
  rfl

end

end Functor

namespace NatTrans

/-- The cartesian product of two natural transformations. -/
@[simps]
def prod {F G : A â¥¤ B} {H I : C â¥¤ D} (Î± : F âŸ¶ G) (Î² : H âŸ¶ I) : F.Prod H âŸ¶ G.Prod I where
  app := fun X => (Î±.app X.1, Î².app X.2)
  naturality' := fun X Y f => by
    cases X
    cases Y
    simp only [functor.prod_map, Prod.mk.inj_iffâ‚“, prod_comp]
    constructor <;> rw [naturality]

/- Again, it is inadvisable in Lean 3 to setup a notation `Î± Ã— Î²`;
   use instead `Î±.prod Î²` or `nat_trans.prod Î± Î²`. -/
end NatTrans

/-- `F.flip` composed with evaluation is the same as evaluating `F`. -/
@[simps]
def flipCompEvaluation (F : A â¥¤ B â¥¤ C) a : F.flip â‹™ (evaluation _ _).obj a â‰… F.obj a :=
  (NatIso.ofComponents fun b => eqToIso rfl) <| by
    tidy

end CategoryTheory

