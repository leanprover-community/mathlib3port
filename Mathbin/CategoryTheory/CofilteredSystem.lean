/-
Copyright (c) 2022 Kyle Miller, Adam Topaz, RÃ©mi Bottinelli, Junyan Xu. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Kyle Miller, Adam Topaz, RÃ©mi Bottinelli, Junyan Xu

! This file was ported from Lean 3 source module category_theory.cofiltered_system
! leanprover-community/mathlib commit 2ed2c6310e6f1c5562bdf6bfbda55ebbf6891abe
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.CategoryTheory.Filtered
import Mathbin.Data.Set.Finite
import Mathbin.Topology.Category.Top.Limits.Konig

/-!
# Cofiltered systems

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

This file deals with properties of cofiltered (and inverse) systems.

## Main definitions

Given a functor `F : J â¥¤ Type v`:

* For `j : J`, `F.eventual_range j` is the intersections of all ranges of morphisms `F.map f`
  where `f` has codomain `j`.
* `F.is_mittag_leffler` states that the functor `F` satisfies the Mittag-Leffler
  condition: the ranges of morphisms `F.map f` (with `f` having codomain `j`) stabilize.
* If `J` is cofiltered `F.to_eventual_ranges` is the subfunctor of `F` obtained by restriction
  to `F.eventual_range`.
* `F.to_preimages` restricts a functor to preimages of a given set in some `F.obj i`. If `J` is
  cofiltered, then it is Mittag-Leffler if `F` is, see `is_mittag_leffler.to_preimages`.

## Main statements

* `nonempty_sections_of_finite_cofiltered_system` shows that if `J` is cofiltered and each
  `F.obj j` is nonempty and finite, `F.sections` is nonempty.
* `nonempty_sections_of_finite_inverse_system` is a specialization of the above to `J` being a
   directed set (and `F : Jáµ’áµ– â¥¤ Type v`).
* `is_mittag_leffler_of_exists_finite_range` shows that if `J` is cofiltered and for all `j`,
  there exists some `i` and `f : i âŸ¶ j` such that the range of `F.map f` is finite, then
  `F` is Mittag-Leffler.
* `to_eventual_ranges_surjective` shows that if `F` is Mittag-Leffler, then `F.to_eventual_ranges`
  has all morphisms `F.map f` surjective.

## Todo

* Prove [Stacks: Lemma 0597](https://stacks.math.columbia.edu/tag/0597)

## References

* [Stacks: Mittag-Leffler systems](https://stacks.math.columbia.edu/tag/0594)

## Tags

Mittag-Leffler, surjective, eventual range, inverse system,

-/


universe u v w

open CategoryTheory CategoryTheory.IsCofiltered Set CategoryTheory.FunctorToTypes

section FiniteKonig

/- warning: nonempty_sections_of_finite_cofiltered_system.init -> nonempty_sections_of_finite_cofiltered_system.init is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u1}} [_inst_1 : CategoryTheory.SmallCategory.{u1} J] [_inst_2 : CategoryTheory.IsCofilteredOrEmpty.{u1, u1} J _inst_1] (F : CategoryTheory.Functor.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1}) [hf : forall (j : J), Finite.{succ u1} (CategoryTheory.Functor.obj.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1} F j)] [hne : forall (j : J), Nonempty.{succ u1} (CategoryTheory.Functor.obj.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1} F j)], Set.Nonempty.{u1} (forall (j : J), CategoryTheory.Functor.obj.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1} F j) (CategoryTheory.Functor.sections.{u1, u1, u1} J _inst_1 F)
but is expected to have type
  forall {J : Type.{u1}} [_inst_1 : CategoryTheory.SmallCategory.{u1} J] [_inst_2 : CategoryTheory.IsCofilteredOrEmpty.{u1, u1} J _inst_1] (F : CategoryTheory.Functor.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1}) [hf : forall (j : J), Finite.{succ u1} (Prefunctor.obj.{succ u1, succ u1, u1, succ u1} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1} F) j)] [hne : forall (j : J), Nonempty.{succ u1} (Prefunctor.obj.{succ u1, succ u1, u1, succ u1} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1} F) j)], Set.Nonempty.{u1} (forall (j : J), Prefunctor.obj.{succ u1, succ u1, u1, succ u1} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} J (CategoryTheory.Category.toCategoryStruct.{u1, u1} J _inst_1)) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u1, succ u1} J _inst_1 Type.{u1} CategoryTheory.types.{u1} F) j) (CategoryTheory.Functor.sections.{u1, u1, u1} J _inst_1 F)
Case conversion may be inaccurate. Consider using '#align nonempty_sections_of_finite_cofiltered_system.init nonempty_sections_of_finite_cofiltered_system.initâ‚“'. -/
/-- This bootstraps `nonempty_sections_of_finite_inverse_system`. In this version,
the `F` functor is between categories of the same universe, and it is an easy
corollary to `Top.nonempty_limit_cone_of_compact_t2_inverse_system`. -/
theorem nonempty_sections_of_finite_cofiltered_system.init {J : Type u} [SmallCategory J]
    [IsCofilteredOrEmpty J] (F : J â¥¤ Type u) [hf : âˆ€ j, Finite (F.obj j)]
    [hne : âˆ€ j, Nonempty (F.obj j)] : F.sections.Nonempty :=
  by
  let F' : J â¥¤ TopCat := F â‹™ TopCat.discrete
  haveI : âˆ€ j, DiscreteTopology (F'.obj j) := fun _ => âŸ¨rflâŸ©
  haveI : âˆ€ j, Finite (F'.obj j) := hf
  haveI : âˆ€ j, Nonempty (F'.obj j) := hne
  obtain âŸ¨âŸ¨u, huâŸ©âŸ© := TopCat.nonempty_limitCone_of_compact_t2_cofiltered_system F'
  exact âŸ¨u, fun _ _ => huâŸ©
#align nonempty_sections_of_finite_cofiltered_system.init nonempty_sections_of_finite_cofiltered_system.init

/- warning: nonempty_sections_of_finite_cofiltered_system -> nonempty_sections_of_finite_cofiltered_system is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u3, u1} J] [_inst_2 : CategoryTheory.IsCofilteredOrEmpty.{u3, u1} J _inst_1] (F : CategoryTheory.Functor.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2}) [_inst_3 : forall (j : J), Finite.{succ u2} (CategoryTheory.Functor.obj.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2} F j)] [_inst_4 : forall (j : J), Nonempty.{succ u2} (CategoryTheory.Functor.obj.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2} F j)], Set.Nonempty.{max u1 u2} (forall (j : J), CategoryTheory.Functor.obj.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2} F j) (CategoryTheory.Functor.sections.{u3, u2, u1} J _inst_1 F)
but is expected to have type
  forall {J : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u3, u1} J] [_inst_2 : CategoryTheory.IsCofilteredOrEmpty.{u3, u1} J _inst_1] (F : CategoryTheory.Functor.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2}) [_inst_3 : forall (j : J), Finite.{succ u2} (Prefunctor.obj.{succ u3, succ u2, u1, succ u2} J (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} J (CategoryTheory.Category.toCategoryStruct.{u3, u1} J _inst_1)) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2} F) j)] [_inst_4 : forall (j : J), Nonempty.{succ u2} (Prefunctor.obj.{succ u3, succ u2, u1, succ u2} J (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} J (CategoryTheory.Category.toCategoryStruct.{u3, u1} J _inst_1)) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2} F) j)], Set.Nonempty.{max u1 u2} (forall (j : J), Prefunctor.obj.{succ u3, succ u2, u1, succ u2} J (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} J (CategoryTheory.Category.toCategoryStruct.{u3, u1} J _inst_1)) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2} F) j) (CategoryTheory.Functor.sections.{u3, u2, u1} J _inst_1 F)
Case conversion may be inaccurate. Consider using '#align nonempty_sections_of_finite_cofiltered_system nonempty_sections_of_finite_cofiltered_systemâ‚“'. -/
/-- The cofiltered limit of nonempty finite types is nonempty.

See `nonempty_sections_of_finite_inverse_system` for a specialization to inverse limits. -/
theorem nonempty_sections_of_finite_cofiltered_system {J : Type u} [Category.{w} J]
    [IsCofilteredOrEmpty J] (F : J â¥¤ Type v) [âˆ€ j : J, Finite (F.obj j)]
    [âˆ€ j : J, Nonempty (F.obj j)] : F.sections.Nonempty :=
  by
  -- Step 1: lift everything to the `max u v w` universe.
  let J' : Type max w v u := AsSmall.{max w v} J
  let down : J' â¥¤ J := as_small.down
  let F' : J' â¥¤ Type max u v w := down â‹™ F â‹™ uliftFunctor.{max u w, v}
  haveI : âˆ€ i, Nonempty (F'.obj i) := fun i => âŸ¨âŸ¨Classical.arbitrary (F.obj (down.obj i))âŸ©âŸ©
  haveI : âˆ€ i, Finite (F'.obj i) := fun i => Finite.of_equiv (F.obj (down.obj i)) equiv.ulift.symm
  -- Step 2: apply the bootstrap theorem
  cases isEmpty_or_nonempty J
  Â· fconstructor <;> exact isEmptyElim
  haveI : is_cofiltered J := âŸ¨âŸ©
  obtain âŸ¨u, huâŸ© := nonempty_sections_of_finite_cofiltered_system.init F'
  -- Step 3: interpret the results
  use fun j => (u âŸ¨jâŸ©).down
  intro j j' f
  have h := @hu (âŸ¨jâŸ© : J') (âŸ¨j'âŸ© : J') (ULift.up f)
  simp only [as_small.down, functor.comp_map, ulift_functor_map, functor.op_map] at h
  simp_rw [â† h]
  rfl
#align nonempty_sections_of_finite_cofiltered_system nonempty_sections_of_finite_cofiltered_system

/- warning: nonempty_sections_of_finite_inverse_system -> nonempty_sections_of_finite_inverse_system is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u1}} [_inst_1 : Preorder.{u1} J] [_inst_2 : IsDirected.{u1} J (LE.le.{u1} J (Preorder.toHasLe.{u1} J _inst_1))] (F : CategoryTheory.Functor.{u1, u2, u1, succ u2} (Opposite.{succ u1} J) (CategoryTheory.Category.opposite.{u1, u1} J (Preorder.smallCategory.{u1} J _inst_1)) Type.{u2} CategoryTheory.types.{u2}) [_inst_3 : forall (j : Opposite.{succ u1} J), Finite.{succ u2} (CategoryTheory.Functor.obj.{u1, u2, u1, succ u2} (Opposite.{succ u1} J) (CategoryTheory.Category.opposite.{u1, u1} J (Preorder.smallCategory.{u1} J _inst_1)) Type.{u2} CategoryTheory.types.{u2} F j)] [_inst_4 : forall (j : Opposite.{succ u1} J), Nonempty.{succ u2} (CategoryTheory.Functor.obj.{u1, u2, u1, succ u2} (Opposite.{succ u1} J) (CategoryTheory.Category.opposite.{u1, u1} J (Preorder.smallCategory.{u1} J _inst_1)) Type.{u2} CategoryTheory.types.{u2} F j)], Set.Nonempty.{max u1 u2} (forall (j : Opposite.{succ u1} J), CategoryTheory.Functor.obj.{u1, u2, u1, succ u2} (Opposite.{succ u1} J) (CategoryTheory.Category.opposite.{u1, u1} J (Preorder.smallCategory.{u1} J _inst_1)) Type.{u2} CategoryTheory.types.{u2} F j) (CategoryTheory.Functor.sections.{u1, u2, u1} (Opposite.{succ u1} J) (CategoryTheory.Category.opposite.{u1, u1} J (Preorder.smallCategory.{u1} J _inst_1)) F)
but is expected to have type
  forall {J : Type.{u1}} [_inst_1 : Preorder.{u1} J] [_inst_2 : IsDirected.{u1} J (fun (x._@.Mathlib.CategoryTheory.CofilteredSystem._hyg.479 : J) (x._@.Mathlib.CategoryTheory.CofilteredSystem._hyg.481 : J) => LE.le.{u1} J (Preorder.toLE.{u1} J _inst_1) x._@.Mathlib.CategoryTheory.CofilteredSystem._hyg.479 x._@.Mathlib.CategoryTheory.CofilteredSystem._hyg.481)] (F : CategoryTheory.Functor.{u1, u2, u1, succ u2} (Opposite.{succ u1} J) (CategoryTheory.Category.opposite.{u1, u1} J (Preorder.smallCategory.{u1} J _inst_1)) Type.{u2} CategoryTheory.types.{u2}) [_inst_3 : forall (j : Opposite.{succ u1} J), Finite.{succ u2} (Prefunctor.obj.{succ u1, succ u2, u1, succ u2} (Opposite.{succ u1} J) (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} (Opposite.{succ u1} J) (CategoryTheory.Category.toCategoryStruct.{u1, u1} (Opposite.{succ u1} J) (CategoryTheory.Category.opposite.{u1, u1} J (Preorder.smallCategory.{u1} J _inst_1)))) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u1, succ u2} (Opposite.{succ u1} J) (CategoryTheory.Category.opposite.{u1, u1} J (Preorder.smallCategory.{u1} J _inst_1)) Type.{u2} CategoryTheory.types.{u2} F) j)] [_inst_4 : forall (j : Opposite.{succ u1} J), Nonempty.{succ u2} (Prefunctor.obj.{succ u1, succ u2, u1, succ u2} (Opposite.{succ u1} J) (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} (Opposite.{succ u1} J) (CategoryTheory.Category.toCategoryStruct.{u1, u1} (Opposite.{succ u1} J) (CategoryTheory.Category.opposite.{u1, u1} J (Preorder.smallCategory.{u1} J _inst_1)))) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u1, succ u2} (Opposite.{succ u1} J) (CategoryTheory.Category.opposite.{u1, u1} J (Preorder.smallCategory.{u1} J _inst_1)) Type.{u2} CategoryTheory.types.{u2} F) j)], Set.Nonempty.{max u1 u2} (forall (j : Opposite.{succ u1} J), Prefunctor.obj.{succ u1, succ u2, u1, succ u2} (Opposite.{succ u1} J) (CategoryTheory.CategoryStruct.toQuiver.{u1, u1} (Opposite.{succ u1} J) (CategoryTheory.Category.toCategoryStruct.{u1, u1} (Opposite.{succ u1} J) (CategoryTheory.Category.opposite.{u1, u1} J (Preorder.smallCategory.{u1} J _inst_1)))) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u1, succ u2} (Opposite.{succ u1} J) (CategoryTheory.Category.opposite.{u1, u1} J (Preorder.smallCategory.{u1} J _inst_1)) Type.{u2} CategoryTheory.types.{u2} F) j) (CategoryTheory.Functor.sections.{u1, u2, u1} (Opposite.{succ u1} J) (CategoryTheory.Category.opposite.{u1, u1} J (Preorder.smallCategory.{u1} J _inst_1)) F)
Case conversion may be inaccurate. Consider using '#align nonempty_sections_of_finite_inverse_system nonempty_sections_of_finite_inverse_systemâ‚“'. -/
/-- The inverse limit of nonempty finite types is nonempty.

See `nonempty_sections_of_finite_cofiltered_system` for a generalization to cofiltered limits.
That version applies in almost all cases, and the only difference is that this version
allows `J` to be empty.

This may be regarded as a generalization of KÅ‘nig's lemma.
To specialize: given a locally finite connected graph, take `Jáµ’áµ–` to be `â„•` and
`F j` to be length-`j` paths that start from an arbitrary fixed vertex.
Elements of `F.sections` can be read off as infinite rays in the graph. -/
theorem nonempty_sections_of_finite_inverse_system {J : Type u} [Preorder J] [IsDirected J (Â· â‰¤ Â·)]
    (F : Jáµ’áµ– â¥¤ Type v) [âˆ€ j : Jáµ’áµ–, Finite (F.obj j)] [âˆ€ j : Jáµ’áµ–, Nonempty (F.obj j)] :
    F.sections.Nonempty := by
  cases isEmpty_or_nonempty J
  Â· haveI : IsEmpty Jáµ’áµ– := âŸ¨fun j => isEmptyElim j.unopâŸ©
    -- TODO: this should be a global instance
    exact âŸ¨isEmptyElim, isEmptyElimâŸ©
  Â· exact nonempty_sections_of_finite_cofiltered_system _
#align nonempty_sections_of_finite_inverse_system nonempty_sections_of_finite_inverse_system

end FiniteKonig

namespace CategoryTheory

namespace Functor

variable {J : Type u} [Category J] (F : J â¥¤ Type v) {i j k : J} (s : Set (F.obj i))

/- warning: category_theory.functor.eventual_range -> CategoryTheory.Functor.eventualRange is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u3, u1} J] (F : CategoryTheory.Functor.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2}) (j : J), Set.{u2} (CategoryTheory.Functor.obj.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2} F j)
but is expected to have type
  forall {J : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u3, u1} J] (F : CategoryTheory.Functor.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2}) (j : J), Set.{u2} (Prefunctor.obj.{succ u3, succ u2, u1, succ u2} J (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} J (CategoryTheory.Category.toCategoryStruct.{u3, u1} J _inst_1)) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2} F) j)
Case conversion may be inaccurate. Consider using '#align category_theory.functor.eventual_range CategoryTheory.Functor.eventualRangeâ‚“'. -/
/-- The eventual range of the functor `F : J â¥¤ Type v` at index `j : J` is the intersection
of the ranges of all maps `F.map f` with `i : J` and `f : i âŸ¶ j`.
-/
def eventualRange (j : J) :=
  â‹‚ (i) (f : i âŸ¶ j), range (F.map f)
#align category_theory.functor.eventual_range CategoryTheory.Functor.eventualRange

/- warning: category_theory.functor.mem_eventual_range_iff -> CategoryTheory.Functor.mem_eventualRange_iff is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u3, u1} J] (F : CategoryTheory.Functor.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2}) {j : J} {x : CategoryTheory.Functor.obj.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2} F j}, Iff (Membership.Mem.{u2, u2} (CategoryTheory.Functor.obj.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2} F j) (Set.{u2} (CategoryTheory.Functor.obj.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2} F j)) (Set.hasMem.{u2} (CategoryTheory.Functor.obj.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2} F j)) x (CategoryTheory.Functor.eventualRange.{u1, u2, u3} J _inst_1 F j)) (forall {{i : J}} (f : Quiver.Hom.{succ u3, u1} J (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} J (CategoryTheory.Category.toCategoryStruct.{u3, u1} J _inst_1)) i j), Membership.Mem.{u2, u2} (CategoryTheory.Functor.obj.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2} F j) (Set.{u2} (CategoryTheory.Functor.obj.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2} F j)) (Set.hasMem.{u2} (CategoryTheory.Functor.obj.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2} F j)) x (Set.range.{u2, succ u2} (CategoryTheory.Functor.obj.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2} F j) (CategoryTheory.Functor.obj.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2} F i) (CategoryTheory.Functor.map.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2} F i j f)))
but is expected to have type
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] (F : CategoryTheory.Functor.{u1, u3, u2, succ u3} J _inst_1 Type.{u3} CategoryTheory.types.{u3}) {j : J} {x : Prefunctor.obj.{succ u1, succ u3, u2, succ u3} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) Type.{u3} (CategoryTheory.CategoryStruct.toQuiver.{u3, succ u3} Type.{u3} (CategoryTheory.Category.toCategoryStruct.{u3, succ u3} Type.{u3} CategoryTheory.types.{u3})) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, succ u3} J _inst_1 Type.{u3} CategoryTheory.types.{u3} F) j}, Iff (Membership.mem.{u3, u3} (Prefunctor.obj.{succ u1, succ u3, u2, succ u3} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) Type.{u3} (CategoryTheory.CategoryStruct.toQuiver.{u3, succ u3} Type.{u3} (CategoryTheory.Category.toCategoryStruct.{u3, succ u3} Type.{u3} CategoryTheory.types.{u3})) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, succ u3} J _inst_1 Type.{u3} CategoryTheory.types.{u3} F) j) (Set.{u3} (Prefunctor.obj.{succ u1, succ u3, u2, succ u3} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) Type.{u3} (CategoryTheory.CategoryStruct.toQuiver.{u3, succ u3} Type.{u3} (CategoryTheory.Category.toCategoryStruct.{u3, succ u3} Type.{u3} CategoryTheory.types.{u3})) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, succ u3} J _inst_1 Type.{u3} CategoryTheory.types.{u3} F) j)) (Set.instMembershipSet.{u3} (Prefunctor.obj.{succ u1, succ u3, u2, succ u3} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) Type.{u3} (CategoryTheory.CategoryStruct.toQuiver.{u3, succ u3} Type.{u3} (CategoryTheory.Category.toCategoryStruct.{u3, succ u3} Type.{u3} CategoryTheory.types.{u3})) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, succ u3} J _inst_1 Type.{u3} CategoryTheory.types.{u3} F) j)) x (CategoryTheory.Functor.eventualRange.{u2, u3, u1} J _inst_1 F j)) (forall {{i : J}} (f : Quiver.Hom.{succ u1, u2} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) i j), Membership.mem.{u3, u3} (Prefunctor.obj.{succ u1, succ u3, u2, succ u3} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) Type.{u3} (CategoryTheory.CategoryStruct.toQuiver.{u3, succ u3} Type.{u3} (CategoryTheory.Category.toCategoryStruct.{u3, succ u3} Type.{u3} CategoryTheory.types.{u3})) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, succ u3} J _inst_1 Type.{u3} CategoryTheory.types.{u3} F) j) (Set.{u3} (Prefunctor.obj.{succ u1, succ u3, u2, succ u3} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) Type.{u3} (CategoryTheory.CategoryStruct.toQuiver.{u3, succ u3} Type.{u3} (CategoryTheory.Category.toCategoryStruct.{u3, succ u3} Type.{u3} CategoryTheory.types.{u3})) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, succ u3} J _inst_1 Type.{u3} CategoryTheory.types.{u3} F) j)) (Set.instMembershipSet.{u3} (Prefunctor.obj.{succ u1, succ u3, u2, succ u3} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) Type.{u3} (CategoryTheory.CategoryStruct.toQuiver.{u3, succ u3} Type.{u3} (CategoryTheory.Category.toCategoryStruct.{u3, succ u3} Type.{u3} CategoryTheory.types.{u3})) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, succ u3} J _inst_1 Type.{u3} CategoryTheory.types.{u3} F) j)) x (Set.range.{u3, succ u3} (Prefunctor.obj.{succ u1, succ u3, u2, succ u3} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) Type.{u3} (CategoryTheory.CategoryStruct.toQuiver.{u3, succ u3} Type.{u3} (CategoryTheory.Category.toCategoryStruct.{u3, succ u3} Type.{u3} CategoryTheory.types.{u3})) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, succ u3} J _inst_1 Type.{u3} CategoryTheory.types.{u3} F) j) (Prefunctor.obj.{succ u1, succ u3, u2, succ u3} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) Type.{u3} (CategoryTheory.CategoryStruct.toQuiver.{u3, succ u3} Type.{u3} (CategoryTheory.Category.toCategoryStruct.{u3, succ u3} Type.{u3} CategoryTheory.types.{u3})) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, succ u3} J _inst_1 Type.{u3} CategoryTheory.types.{u3} F) i) (Prefunctor.map.{succ u1, succ u3, u2, succ u3} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) Type.{u3} (CategoryTheory.CategoryStruct.toQuiver.{u3, succ u3} Type.{u3} (CategoryTheory.Category.toCategoryStruct.{u3, succ u3} Type.{u3} CategoryTheory.types.{u3})) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, succ u3} J _inst_1 Type.{u3} CategoryTheory.types.{u3} F) i j f)))
Case conversion may be inaccurate. Consider using '#align category_theory.functor.mem_eventual_range_iff CategoryTheory.Functor.mem_eventualRange_iffâ‚“'. -/
theorem mem_eventualRange_iff {x : F.obj j} :
    x âˆˆ F.eventualRange j â†” âˆ€ â¦ƒiâ¦„ (f : i âŸ¶ j), x âˆˆ range (F.map f) :=
  mem_iInterâ‚‚
#align category_theory.functor.mem_eventual_range_iff CategoryTheory.Functor.mem_eventualRange_iff

#print CategoryTheory.Functor.IsMittagLeffler /-
/-- The functor `F : J â¥¤ Type v` satisfies the Mittag-Leffler condition if for all `j : J`,
there exists some `i : J` and `f : i âŸ¶ j` such that for all `k : J` and `g : k âŸ¶ j`, the range
of `F.map f` is contained in that of `F.map g`;
in other words (see `is_mittag_leffler_iff_eventual_range`), the eventual range at `j` is attained
by some `f : i âŸ¶ j`.
-/
def IsMittagLeffler : Prop :=
  âˆ€ j : J, âˆƒ (i : _)(f : i âŸ¶ j), âˆ€ â¦ƒkâ¦„ (g : k âŸ¶ j), range (F.map f) âŠ† range (F.map g)
#align category_theory.functor.is_mittag_leffler CategoryTheory.Functor.IsMittagLeffler
-/

/- warning: category_theory.functor.is_mittag_leffler_iff_eventual_range -> CategoryTheory.Functor.isMittagLeffler_iff_eventualRange is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u3, u1} J] (F : CategoryTheory.Functor.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2}), Iff (CategoryTheory.Functor.IsMittagLeffler.{u1, u2, u3} J _inst_1 F) (forall (j : J), Exists.{succ u1} J (fun (i : J) => Exists.{succ u3} (Quiver.Hom.{succ u3, u1} J (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} J (CategoryTheory.Category.toCategoryStruct.{u3, u1} J _inst_1)) i j) (fun (f : Quiver.Hom.{succ u3, u1} J (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} J (CategoryTheory.Category.toCategoryStruct.{u3, u1} J _inst_1)) i j) => Eq.{succ u2} (Set.{u2} (CategoryTheory.Functor.obj.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2} F j)) (CategoryTheory.Functor.eventualRange.{u1, u2, u3} J _inst_1 F j) (Set.range.{u2, succ u2} (CategoryTheory.Functor.obj.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2} F j) (CategoryTheory.Functor.obj.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2} F i) (CategoryTheory.Functor.map.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2} F i j f)))))
but is expected to have type
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] (F : CategoryTheory.Functor.{u1, u3, u2, succ u3} J _inst_1 Type.{u3} CategoryTheory.types.{u3}), Iff (CategoryTheory.Functor.IsMittagLeffler.{u2, u3, u1} J _inst_1 F) (forall (j : J), Exists.{succ u2} J (fun (i : J) => Exists.{succ u1} (Quiver.Hom.{succ u1, u2} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) i j) (fun (f : Quiver.Hom.{succ u1, u2} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) i j) => Eq.{succ u3} (Set.{u3} (Prefunctor.obj.{succ u1, succ u3, u2, succ u3} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) Type.{u3} (CategoryTheory.CategoryStruct.toQuiver.{u3, succ u3} Type.{u3} (CategoryTheory.Category.toCategoryStruct.{u3, succ u3} Type.{u3} CategoryTheory.types.{u3})) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, succ u3} J _inst_1 Type.{u3} CategoryTheory.types.{u3} F) j)) (CategoryTheory.Functor.eventualRange.{u2, u3, u1} J _inst_1 F j) (Set.range.{u3, succ u3} (Prefunctor.obj.{succ u1, succ u3, u2, succ u3} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) Type.{u3} (CategoryTheory.CategoryStruct.toQuiver.{u3, succ u3} Type.{u3} (CategoryTheory.Category.toCategoryStruct.{u3, succ u3} Type.{u3} CategoryTheory.types.{u3})) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, succ u3} J _inst_1 Type.{u3} CategoryTheory.types.{u3} F) j) (Prefunctor.obj.{succ u1, succ u3, u2, succ u3} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) Type.{u3} (CategoryTheory.CategoryStruct.toQuiver.{u3, succ u3} Type.{u3} (CategoryTheory.Category.toCategoryStruct.{u3, succ u3} Type.{u3} CategoryTheory.types.{u3})) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, succ u3} J _inst_1 Type.{u3} CategoryTheory.types.{u3} F) i) (Prefunctor.map.{succ u1, succ u3, u2, succ u3} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) Type.{u3} (CategoryTheory.CategoryStruct.toQuiver.{u3, succ u3} Type.{u3} (CategoryTheory.Category.toCategoryStruct.{u3, succ u3} Type.{u3} CategoryTheory.types.{u3})) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, succ u3} J _inst_1 Type.{u3} CategoryTheory.types.{u3} F) i j f)))))
Case conversion may be inaccurate. Consider using '#align category_theory.functor.is_mittag_leffler_iff_eventual_range CategoryTheory.Functor.isMittagLeffler_iff_eventualRangeâ‚“'. -/
theorem isMittagLeffler_iff_eventualRange :
    F.IsMittagLeffler â†” âˆ€ j : J, âˆƒ (i : _)(f : i âŸ¶ j), F.eventualRange j = range (F.map f) :=
  forall_congr' fun j =>
    existsâ‚‚_congr fun i f =>
      âŸ¨fun h => (iInterâ‚‚_subset _ _).antisymm <| subset_iInterâ‚‚ h, fun h => h â–¸ iInterâ‚‚_subsetâŸ©
#align category_theory.functor.is_mittag_leffler_iff_eventual_range CategoryTheory.Functor.isMittagLeffler_iff_eventualRange

/- warning: category_theory.functor.is_mittag_leffler.subset_image_eventual_range -> CategoryTheory.Functor.IsMittagLeffler.subset_image_eventualRange is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u3, u1} J] (F : CategoryTheory.Functor.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2}) {i : J} {j : J}, (CategoryTheory.Functor.IsMittagLeffler.{u1, u2, u3} J _inst_1 F) -> (forall (f : Quiver.Hom.{succ u3, u1} J (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} J (CategoryTheory.Category.toCategoryStruct.{u3, u1} J _inst_1)) j i), HasSubset.Subset.{u2} (Set.{u2} (CategoryTheory.Functor.obj.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2} F i)) (Set.hasSubset.{u2} (CategoryTheory.Functor.obj.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2} F i)) (CategoryTheory.Functor.eventualRange.{u1, u2, u3} J _inst_1 F i) (Set.image.{u2, u2} (CategoryTheory.Functor.obj.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2} F j) (CategoryTheory.Functor.obj.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2} F i) (CategoryTheory.Functor.map.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2} F j i f) (CategoryTheory.Functor.eventualRange.{u1, u2, u3} J _inst_1 F j)))
but is expected to have type
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] (F : CategoryTheory.Functor.{u1, u3, u2, succ u3} J _inst_1 Type.{u3} CategoryTheory.types.{u3}) {i : J} {j : J}, (CategoryTheory.Functor.IsMittagLeffler.{u2, u3, u1} J _inst_1 F) -> (forall (f : Quiver.Hom.{succ u1, u2} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) j i), HasSubset.Subset.{u3} (Set.{u3} (Prefunctor.obj.{succ u1, succ u3, u2, succ u3} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) Type.{u3} (CategoryTheory.CategoryStruct.toQuiver.{u3, succ u3} Type.{u3} (CategoryTheory.Category.toCategoryStruct.{u3, succ u3} Type.{u3} CategoryTheory.types.{u3})) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, succ u3} J _inst_1 Type.{u3} CategoryTheory.types.{u3} F) i)) (Set.instHasSubsetSet.{u3} (Prefunctor.obj.{succ u1, succ u3, u2, succ u3} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) Type.{u3} (CategoryTheory.CategoryStruct.toQuiver.{u3, succ u3} Type.{u3} (CategoryTheory.Category.toCategoryStruct.{u3, succ u3} Type.{u3} CategoryTheory.types.{u3})) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, succ u3} J _inst_1 Type.{u3} CategoryTheory.types.{u3} F) i)) (CategoryTheory.Functor.eventualRange.{u2, u3, u1} J _inst_1 F i) (Set.image.{u3, u3} (Prefunctor.obj.{succ u1, succ u3, u2, succ u3} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) Type.{u3} (CategoryTheory.CategoryStruct.toQuiver.{u3, succ u3} Type.{u3} (CategoryTheory.Category.toCategoryStruct.{u3, succ u3} Type.{u3} CategoryTheory.types.{u3})) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, succ u3} J _inst_1 Type.{u3} CategoryTheory.types.{u3} F) j) (Prefunctor.obj.{succ u1, succ u3, u2, succ u3} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) Type.{u3} (CategoryTheory.CategoryStruct.toQuiver.{u3, succ u3} Type.{u3} (CategoryTheory.Category.toCategoryStruct.{u3, succ u3} Type.{u3} CategoryTheory.types.{u3})) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, succ u3} J _inst_1 Type.{u3} CategoryTheory.types.{u3} F) i) (Prefunctor.map.{succ u1, succ u3, u2, succ u3} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) Type.{u3} (CategoryTheory.CategoryStruct.toQuiver.{u3, succ u3} Type.{u3} (CategoryTheory.Category.toCategoryStruct.{u3, succ u3} Type.{u3} CategoryTheory.types.{u3})) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, succ u3} J _inst_1 Type.{u3} CategoryTheory.types.{u3} F) j i f) (CategoryTheory.Functor.eventualRange.{u2, u3, u1} J _inst_1 F j)))
Case conversion may be inaccurate. Consider using '#align category_theory.functor.is_mittag_leffler.subset_image_eventual_range CategoryTheory.Functor.IsMittagLeffler.subset_image_eventualRangeâ‚“'. -/
theorem IsMittagLeffler.subset_image_eventualRange (h : F.IsMittagLeffler) (f : j âŸ¶ i) :
    F.eventualRange i âŠ† F.map f '' F.eventualRange j :=
  by
  obtain âŸ¨k, g, hgâŸ© := F.is_mittag_leffler_iff_eventual_range.1 h j
  rw [hg]; intro x hx
  obtain âŸ¨x, rflâŸ© := F.mem_eventual_range_iff.1 hx (g â‰« f)
  refine' âŸ¨_, âŸ¨x, rflâŸ©, by simpa only [F.map_comp] âŸ©
#align category_theory.functor.is_mittag_leffler.subset_image_eventual_range CategoryTheory.Functor.IsMittagLeffler.subset_image_eventualRange

/- warning: category_theory.functor.eventual_range_eq_range_precomp -> CategoryTheory.Functor.eventualRange_eq_range_precomp is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u3, u1} J] (F : CategoryTheory.Functor.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2}) {i : J} {j : J} {k : J} (f : Quiver.Hom.{succ u3, u1} J (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} J (CategoryTheory.Category.toCategoryStruct.{u3, u1} J _inst_1)) i j) (g : Quiver.Hom.{succ u3, u1} J (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} J (CategoryTheory.Category.toCategoryStruct.{u3, u1} J _inst_1)) j k), (Eq.{succ u2} (Set.{u2} (CategoryTheory.Functor.obj.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2} F k)) (CategoryTheory.Functor.eventualRange.{u1, u2, u3} J _inst_1 F k) (Set.range.{u2, succ u2} (CategoryTheory.Functor.obj.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2} F k) (CategoryTheory.Functor.obj.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2} F j) (CategoryTheory.Functor.map.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2} F j k g))) -> (Eq.{succ u2} (Set.{u2} (CategoryTheory.Functor.obj.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2} F k)) (CategoryTheory.Functor.eventualRange.{u1, u2, u3} J _inst_1 F k) (Set.range.{u2, succ u2} (CategoryTheory.Functor.obj.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2} F k) (CategoryTheory.Functor.obj.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2} F i) (CategoryTheory.Functor.map.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2} F i k (CategoryTheory.CategoryStruct.comp.{u3, u1} J (CategoryTheory.Category.toCategoryStruct.{u3, u1} J _inst_1) i j k f g))))
but is expected to have type
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] (F : CategoryTheory.Functor.{u1, u3, u2, succ u3} J _inst_1 Type.{u3} CategoryTheory.types.{u3}) {i : J} {j : J} {k : J} (f : Quiver.Hom.{succ u1, u2} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) i j) (g : Quiver.Hom.{succ u1, u2} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) j k), (Eq.{succ u3} (Set.{u3} (Prefunctor.obj.{succ u1, succ u3, u2, succ u3} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) Type.{u3} (CategoryTheory.CategoryStruct.toQuiver.{u3, succ u3} Type.{u3} (CategoryTheory.Category.toCategoryStruct.{u3, succ u3} Type.{u3} CategoryTheory.types.{u3})) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, succ u3} J _inst_1 Type.{u3} CategoryTheory.types.{u3} F) k)) (CategoryTheory.Functor.eventualRange.{u2, u3, u1} J _inst_1 F k) (Set.range.{u3, succ u3} (Prefunctor.obj.{succ u1, succ u3, u2, succ u3} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) Type.{u3} (CategoryTheory.CategoryStruct.toQuiver.{u3, succ u3} Type.{u3} (CategoryTheory.Category.toCategoryStruct.{u3, succ u3} Type.{u3} CategoryTheory.types.{u3})) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, succ u3} J _inst_1 Type.{u3} CategoryTheory.types.{u3} F) k) (Prefunctor.obj.{succ u1, succ u3, u2, succ u3} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) Type.{u3} (CategoryTheory.CategoryStruct.toQuiver.{u3, succ u3} Type.{u3} (CategoryTheory.Category.toCategoryStruct.{u3, succ u3} Type.{u3} CategoryTheory.types.{u3})) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, succ u3} J _inst_1 Type.{u3} CategoryTheory.types.{u3} F) j) (Prefunctor.map.{succ u1, succ u3, u2, succ u3} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) Type.{u3} (CategoryTheory.CategoryStruct.toQuiver.{u3, succ u3} Type.{u3} (CategoryTheory.Category.toCategoryStruct.{u3, succ u3} Type.{u3} CategoryTheory.types.{u3})) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, succ u3} J _inst_1 Type.{u3} CategoryTheory.types.{u3} F) j k g))) -> (Eq.{succ u3} (Set.{u3} (Prefunctor.obj.{succ u1, succ u3, u2, succ u3} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) Type.{u3} (CategoryTheory.CategoryStruct.toQuiver.{u3, succ u3} Type.{u3} (CategoryTheory.Category.toCategoryStruct.{u3, succ u3} Type.{u3} CategoryTheory.types.{u3})) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, succ u3} J _inst_1 Type.{u3} CategoryTheory.types.{u3} F) k)) (CategoryTheory.Functor.eventualRange.{u2, u3, u1} J _inst_1 F k) (Set.range.{u3, succ u3} (Prefunctor.obj.{succ u1, succ u3, u2, succ u3} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) Type.{u3} (CategoryTheory.CategoryStruct.toQuiver.{u3, succ u3} Type.{u3} (CategoryTheory.Category.toCategoryStruct.{u3, succ u3} Type.{u3} CategoryTheory.types.{u3})) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, succ u3} J _inst_1 Type.{u3} CategoryTheory.types.{u3} F) k) (Prefunctor.obj.{succ u1, succ u3, u2, succ u3} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) Type.{u3} (CategoryTheory.CategoryStruct.toQuiver.{u3, succ u3} Type.{u3} (CategoryTheory.Category.toCategoryStruct.{u3, succ u3} Type.{u3} CategoryTheory.types.{u3})) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, succ u3} J _inst_1 Type.{u3} CategoryTheory.types.{u3} F) i) (Prefunctor.map.{succ u1, succ u3, u2, succ u3} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) Type.{u3} (CategoryTheory.CategoryStruct.toQuiver.{u3, succ u3} Type.{u3} (CategoryTheory.Category.toCategoryStruct.{u3, succ u3} Type.{u3} CategoryTheory.types.{u3})) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, succ u3} J _inst_1 Type.{u3} CategoryTheory.types.{u3} F) i k (CategoryTheory.CategoryStruct.comp.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1) i j k f g))))
Case conversion may be inaccurate. Consider using '#align category_theory.functor.eventual_range_eq_range_precomp CategoryTheory.Functor.eventualRange_eq_range_precompâ‚“'. -/
theorem eventualRange_eq_range_precomp (f : i âŸ¶ j) (g : j âŸ¶ k)
    (h : F.eventualRange k = range (F.map g)) : F.eventualRange k = range (F.map <| f â‰« g) :=
  by
  apply subset_antisymm
  Â· apply Interâ‚‚_subset
  Â· rw [h, F.map_comp]; apply range_comp_subset_range
#align category_theory.functor.eventual_range_eq_range_precomp CategoryTheory.Functor.eventualRange_eq_range_precomp

/- warning: category_theory.functor.is_mittag_leffler_of_surjective -> CategoryTheory.Functor.isMittagLeffler_of_surjective is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u3, u1} J] (F : CategoryTheory.Functor.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2}), (forall {{i : J}} {{j : J}} (f : Quiver.Hom.{succ u3, u1} J (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} J (CategoryTheory.Category.toCategoryStruct.{u3, u1} J _inst_1)) i j), Function.Surjective.{succ u2, succ u2} (CategoryTheory.Functor.obj.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2} F i) (CategoryTheory.Functor.obj.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2} F j) (CategoryTheory.Functor.map.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2} F i j f)) -> (CategoryTheory.Functor.IsMittagLeffler.{u1, u2, u3} J _inst_1 F)
but is expected to have type
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] (F : CategoryTheory.Functor.{u1, u3, u2, succ u3} J _inst_1 Type.{u3} CategoryTheory.types.{u3}), (forall {{i : J}} {{j : J}} (f : Quiver.Hom.{succ u1, u2} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) i j), Function.Surjective.{succ u3, succ u3} (Prefunctor.obj.{succ u1, succ u3, u2, succ u3} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) Type.{u3} (CategoryTheory.CategoryStruct.toQuiver.{u3, succ u3} Type.{u3} (CategoryTheory.Category.toCategoryStruct.{u3, succ u3} Type.{u3} CategoryTheory.types.{u3})) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, succ u3} J _inst_1 Type.{u3} CategoryTheory.types.{u3} F) i) (Prefunctor.obj.{succ u1, succ u3, u2, succ u3} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) Type.{u3} (CategoryTheory.CategoryStruct.toQuiver.{u3, succ u3} Type.{u3} (CategoryTheory.Category.toCategoryStruct.{u3, succ u3} Type.{u3} CategoryTheory.types.{u3})) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, succ u3} J _inst_1 Type.{u3} CategoryTheory.types.{u3} F) j) (Prefunctor.map.{succ u1, succ u3, u2, succ u3} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) Type.{u3} (CategoryTheory.CategoryStruct.toQuiver.{u3, succ u3} Type.{u3} (CategoryTheory.Category.toCategoryStruct.{u3, succ u3} Type.{u3} CategoryTheory.types.{u3})) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, succ u3} J _inst_1 Type.{u3} CategoryTheory.types.{u3} F) i j f)) -> (CategoryTheory.Functor.IsMittagLeffler.{u2, u3, u1} J _inst_1 F)
Case conversion may be inaccurate. Consider using '#align category_theory.functor.is_mittag_leffler_of_surjective CategoryTheory.Functor.isMittagLeffler_of_surjectiveâ‚“'. -/
theorem isMittagLeffler_of_surjective (h : âˆ€ â¦ƒi j : Jâ¦„ (f : i âŸ¶ j), (F.map f).Surjective) :
    F.IsMittagLeffler := fun j =>
  âŸ¨j, ðŸ™ j, fun k g => by rw [map_id, types_id, range_id, (h g).range_eq]âŸ©
#align category_theory.functor.is_mittag_leffler_of_surjective CategoryTheory.Functor.isMittagLeffler_of_surjective

/- warning: category_theory.functor.to_preimages -> CategoryTheory.Functor.toPreimages is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u3, u1} J] (F : CategoryTheory.Functor.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2}) {i : J}, (Set.{u2} (CategoryTheory.Functor.obj.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2} F i)) -> (CategoryTheory.Functor.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2})
but is expected to have type
  forall {J : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u3, u1} J] (F : CategoryTheory.Functor.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2}) {i : J}, (Set.{u2} (Prefunctor.obj.{succ u3, succ u2, u1, succ u2} J (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} J (CategoryTheory.Category.toCategoryStruct.{u3, u1} J _inst_1)) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2} F) i)) -> (CategoryTheory.Functor.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2})
Case conversion may be inaccurate. Consider using '#align category_theory.functor.to_preimages CategoryTheory.Functor.toPreimagesâ‚“'. -/
/-- The subfunctor of `F` obtained by restricting to the preimages of a set `s âˆˆ F.obj i`. -/
@[simps]
def toPreimages : J â¥¤ Type v where
  obj j := â‹‚ f : j âŸ¶ i, F.map f â»Â¹' s
  map j k g :=
    MapsTo.restrict (F.map g) _ _ fun x h =>
      by
      rw [mem_Inter] at hâŠ¢; intro f
      rw [â† mem_preimage, preimage_preimage]
      convert h (g â‰« f); rw [F.map_comp]; rfl
  map_id' j := by simp_rw [F.map_id]; ext; rfl
  map_comp' j k l f g := by simp_rw [F.map_comp]; rfl
#align category_theory.functor.to_preimages CategoryTheory.Functor.toPreimages

/- warning: category_theory.functor.to_preimages_finite -> CategoryTheory.Functor.toPreimages_finite is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u3, u1} J] (F : CategoryTheory.Functor.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2}) {i : J} (s : Set.{u2} (CategoryTheory.Functor.obj.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2} F i)) [_inst_2 : forall (j : J), Finite.{succ u2} (CategoryTheory.Functor.obj.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2} F j)] (j : J), Finite.{succ u2} (CategoryTheory.Functor.obj.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.Functor.toPreimages.{u1, u2, u3} J _inst_1 F i s) j)
but is expected to have type
  forall {J : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u3, u1} J] (F : CategoryTheory.Functor.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2}) {i : J} (s : Set.{u2} (Prefunctor.obj.{succ u3, succ u2, u1, succ u2} J (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} J (CategoryTheory.Category.toCategoryStruct.{u3, u1} J _inst_1)) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2} F) i)) [_inst_2 : forall (j : J), Finite.{succ u2} (Prefunctor.obj.{succ u3, succ u2, u1, succ u2} J (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} J (CategoryTheory.Category.toCategoryStruct.{u3, u1} J _inst_1)) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2} F) j)] (j : J), Finite.{succ u2} (Prefunctor.obj.{succ u3, succ u2, u1, succ u2} J (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} J (CategoryTheory.Category.toCategoryStruct.{u3, u1} J _inst_1)) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.Functor.toPreimages.{u1, u2, u3} J _inst_1 F i s)) j)
Case conversion may be inaccurate. Consider using '#align category_theory.functor.to_preimages_finite CategoryTheory.Functor.toPreimages_finiteâ‚“'. -/
instance toPreimages_finite [âˆ€ j, Finite (F.obj j)] : âˆ€ j, Finite ((F.toPreimages s).obj j) :=
  fun j => Subtype.finite
#align category_theory.functor.to_preimages_finite CategoryTheory.Functor.toPreimages_finite

variable [IsCofilteredOrEmpty J]

/- warning: category_theory.functor.eventual_range_maps_to -> CategoryTheory.Functor.eventualRange_mapsTo is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u3, u1} J] (F : CategoryTheory.Functor.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2}) {i : J} {j : J} [_inst_2 : CategoryTheory.IsCofilteredOrEmpty.{u3, u1} J _inst_1] (f : Quiver.Hom.{succ u3, u1} J (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} J (CategoryTheory.Category.toCategoryStruct.{u3, u1} J _inst_1)) j i), Set.MapsTo.{u2, u2} (CategoryTheory.Functor.obj.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2} F j) (CategoryTheory.Functor.obj.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2} F i) (CategoryTheory.Functor.map.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2} F j i f) (CategoryTheory.Functor.eventualRange.{u1, u2, u3} J _inst_1 F j) (CategoryTheory.Functor.eventualRange.{u1, u2, u3} J _inst_1 F i)
but is expected to have type
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] (F : CategoryTheory.Functor.{u1, u3, u2, succ u3} J _inst_1 Type.{u3} CategoryTheory.types.{u3}) {i : J} {j : J} [_inst_2 : CategoryTheory.IsCofilteredOrEmpty.{u1, u2} J _inst_1] (f : Quiver.Hom.{succ u1, u2} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) j i), Set.MapsTo.{u3, u3} (Prefunctor.obj.{succ u1, succ u3, u2, succ u3} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) Type.{u3} (CategoryTheory.CategoryStruct.toQuiver.{u3, succ u3} Type.{u3} (CategoryTheory.Category.toCategoryStruct.{u3, succ u3} Type.{u3} CategoryTheory.types.{u3})) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, succ u3} J _inst_1 Type.{u3} CategoryTheory.types.{u3} F) j) (Prefunctor.obj.{succ u1, succ u3, u2, succ u3} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) Type.{u3} (CategoryTheory.CategoryStruct.toQuiver.{u3, succ u3} Type.{u3} (CategoryTheory.Category.toCategoryStruct.{u3, succ u3} Type.{u3} CategoryTheory.types.{u3})) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, succ u3} J _inst_1 Type.{u3} CategoryTheory.types.{u3} F) i) (Prefunctor.map.{succ u1, succ u3, u2, succ u3} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) Type.{u3} (CategoryTheory.CategoryStruct.toQuiver.{u3, succ u3} Type.{u3} (CategoryTheory.Category.toCategoryStruct.{u3, succ u3} Type.{u3} CategoryTheory.types.{u3})) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, succ u3} J _inst_1 Type.{u3} CategoryTheory.types.{u3} F) j i f) (CategoryTheory.Functor.eventualRange.{u2, u3, u1} J _inst_1 F j) (CategoryTheory.Functor.eventualRange.{u2, u3, u1} J _inst_1 F i)
Case conversion may be inaccurate. Consider using '#align category_theory.functor.eventual_range_maps_to CategoryTheory.Functor.eventualRange_mapsToâ‚“'. -/
theorem eventualRange_mapsTo (f : j âŸ¶ i) :
    (F.eventualRange j).MapsTo (F.map f) (F.eventualRange i) := fun x hx =>
  by
  rw [mem_eventual_range_iff] at hxâŠ¢
  intro k f'
  obtain âŸ¨l, g, g', heâŸ© := cospan f f'
  obtain âŸ¨x, rflâŸ© := hx g
  rw [â† map_comp_apply, he, F.map_comp]
  exact âŸ¨_, rflâŸ©
#align category_theory.functor.eventual_range_maps_to CategoryTheory.Functor.eventualRange_mapsTo

/- warning: category_theory.functor.is_mittag_leffler.eq_image_eventual_range -> CategoryTheory.Functor.IsMittagLeffler.eq_image_eventualRange is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u3, u1} J] (F : CategoryTheory.Functor.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2}) {i : J} {j : J} [_inst_2 : CategoryTheory.IsCofilteredOrEmpty.{u3, u1} J _inst_1], (CategoryTheory.Functor.IsMittagLeffler.{u1, u2, u3} J _inst_1 F) -> (forall (f : Quiver.Hom.{succ u3, u1} J (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} J (CategoryTheory.Category.toCategoryStruct.{u3, u1} J _inst_1)) j i), Eq.{succ u2} (Set.{u2} (CategoryTheory.Functor.obj.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2} F i)) (CategoryTheory.Functor.eventualRange.{u1, u2, u3} J _inst_1 F i) (Set.image.{u2, u2} (CategoryTheory.Functor.obj.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2} F j) (CategoryTheory.Functor.obj.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2} F i) (CategoryTheory.Functor.map.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2} F j i f) (CategoryTheory.Functor.eventualRange.{u1, u2, u3} J _inst_1 F j)))
but is expected to have type
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] (F : CategoryTheory.Functor.{u1, u3, u2, succ u3} J _inst_1 Type.{u3} CategoryTheory.types.{u3}) {i : J} {j : J} [_inst_2 : CategoryTheory.IsCofilteredOrEmpty.{u1, u2} J _inst_1], (CategoryTheory.Functor.IsMittagLeffler.{u2, u3, u1} J _inst_1 F) -> (forall (f : Quiver.Hom.{succ u1, u2} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) j i), Eq.{succ u3} (Set.{u3} (Prefunctor.obj.{succ u1, succ u3, u2, succ u3} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) Type.{u3} (CategoryTheory.CategoryStruct.toQuiver.{u3, succ u3} Type.{u3} (CategoryTheory.Category.toCategoryStruct.{u3, succ u3} Type.{u3} CategoryTheory.types.{u3})) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, succ u3} J _inst_1 Type.{u3} CategoryTheory.types.{u3} F) i)) (CategoryTheory.Functor.eventualRange.{u2, u3, u1} J _inst_1 F i) (Set.image.{u3, u3} (Prefunctor.obj.{succ u1, succ u3, u2, succ u3} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) Type.{u3} (CategoryTheory.CategoryStruct.toQuiver.{u3, succ u3} Type.{u3} (CategoryTheory.Category.toCategoryStruct.{u3, succ u3} Type.{u3} CategoryTheory.types.{u3})) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, succ u3} J _inst_1 Type.{u3} CategoryTheory.types.{u3} F) j) (Prefunctor.obj.{succ u1, succ u3, u2, succ u3} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) Type.{u3} (CategoryTheory.CategoryStruct.toQuiver.{u3, succ u3} Type.{u3} (CategoryTheory.Category.toCategoryStruct.{u3, succ u3} Type.{u3} CategoryTheory.types.{u3})) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, succ u3} J _inst_1 Type.{u3} CategoryTheory.types.{u3} F) i) (Prefunctor.map.{succ u1, succ u3, u2, succ u3} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) Type.{u3} (CategoryTheory.CategoryStruct.toQuiver.{u3, succ u3} Type.{u3} (CategoryTheory.Category.toCategoryStruct.{u3, succ u3} Type.{u3} CategoryTheory.types.{u3})) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, succ u3} J _inst_1 Type.{u3} CategoryTheory.types.{u3} F) j i f) (CategoryTheory.Functor.eventualRange.{u2, u3, u1} J _inst_1 F j)))
Case conversion may be inaccurate. Consider using '#align category_theory.functor.is_mittag_leffler.eq_image_eventual_range CategoryTheory.Functor.IsMittagLeffler.eq_image_eventualRangeâ‚“'. -/
theorem IsMittagLeffler.eq_image_eventualRange (h : F.IsMittagLeffler) (f : j âŸ¶ i) :
    F.eventualRange i = F.map f '' F.eventualRange j :=
  (h.subset_image_eventualRange F f).antisymm <| mapsTo'.1 (F.eventualRange_mapsTo f)
#align category_theory.functor.is_mittag_leffler.eq_image_eventual_range CategoryTheory.Functor.IsMittagLeffler.eq_image_eventualRange

/- warning: category_theory.functor.eventual_range_eq_iff -> CategoryTheory.Functor.eventualRange_eq_iff is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u3, u1} J] (F : CategoryTheory.Functor.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2}) {i : J} {j : J} [_inst_2 : CategoryTheory.IsCofilteredOrEmpty.{u3, u1} J _inst_1] {f : Quiver.Hom.{succ u3, u1} J (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} J (CategoryTheory.Category.toCategoryStruct.{u3, u1} J _inst_1)) i j}, Iff (Eq.{succ u2} (Set.{u2} (CategoryTheory.Functor.obj.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2} F j)) (CategoryTheory.Functor.eventualRange.{u1, u2, u3} J _inst_1 F j) (Set.range.{u2, succ u2} (CategoryTheory.Functor.obj.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2} F j) (CategoryTheory.Functor.obj.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2} F i) (CategoryTheory.Functor.map.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2} F i j f))) (forall {{k : J}} (g : Quiver.Hom.{succ u3, u1} J (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} J (CategoryTheory.Category.toCategoryStruct.{u3, u1} J _inst_1)) k i), HasSubset.Subset.{u2} (Set.{u2} (CategoryTheory.Functor.obj.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2} F j)) (Set.hasSubset.{u2} (CategoryTheory.Functor.obj.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2} F j)) (Set.range.{u2, succ u2} (CategoryTheory.Functor.obj.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2} F j) (CategoryTheory.Functor.obj.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2} F i) (CategoryTheory.Functor.map.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2} F i j f)) (Set.range.{u2, succ u2} (CategoryTheory.Functor.obj.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2} F j) (CategoryTheory.Functor.obj.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2} F k) (CategoryTheory.Functor.map.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2} F k j (CategoryTheory.CategoryStruct.comp.{u3, u1} J (CategoryTheory.Category.toCategoryStruct.{u3, u1} J _inst_1) k i j g f))))
but is expected to have type
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] (F : CategoryTheory.Functor.{u1, u3, u2, succ u3} J _inst_1 Type.{u3} CategoryTheory.types.{u3}) {i : J} {j : J} [_inst_2 : CategoryTheory.IsCofilteredOrEmpty.{u1, u2} J _inst_1] {f : Quiver.Hom.{succ u1, u2} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) i j}, Iff (Eq.{succ u3} (Set.{u3} (Prefunctor.obj.{succ u1, succ u3, u2, succ u3} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) Type.{u3} (CategoryTheory.CategoryStruct.toQuiver.{u3, succ u3} Type.{u3} (CategoryTheory.Category.toCategoryStruct.{u3, succ u3} Type.{u3} CategoryTheory.types.{u3})) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, succ u3} J _inst_1 Type.{u3} CategoryTheory.types.{u3} F) j)) (CategoryTheory.Functor.eventualRange.{u2, u3, u1} J _inst_1 F j) (Set.range.{u3, succ u3} (Prefunctor.obj.{succ u1, succ u3, u2, succ u3} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) Type.{u3} (CategoryTheory.CategoryStruct.toQuiver.{u3, succ u3} Type.{u3} (CategoryTheory.Category.toCategoryStruct.{u3, succ u3} Type.{u3} CategoryTheory.types.{u3})) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, succ u3} J _inst_1 Type.{u3} CategoryTheory.types.{u3} F) j) (Prefunctor.obj.{succ u1, succ u3, u2, succ u3} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) Type.{u3} (CategoryTheory.CategoryStruct.toQuiver.{u3, succ u3} Type.{u3} (CategoryTheory.Category.toCategoryStruct.{u3, succ u3} Type.{u3} CategoryTheory.types.{u3})) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, succ u3} J _inst_1 Type.{u3} CategoryTheory.types.{u3} F) i) (Prefunctor.map.{succ u1, succ u3, u2, succ u3} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) Type.{u3} (CategoryTheory.CategoryStruct.toQuiver.{u3, succ u3} Type.{u3} (CategoryTheory.Category.toCategoryStruct.{u3, succ u3} Type.{u3} CategoryTheory.types.{u3})) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, succ u3} J _inst_1 Type.{u3} CategoryTheory.types.{u3} F) i j f))) (forall {{k : J}} (g : Quiver.Hom.{succ u1, u2} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) k i), HasSubset.Subset.{u3} (Set.{u3} (Prefunctor.obj.{succ u1, succ u3, u2, succ u3} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) Type.{u3} (CategoryTheory.CategoryStruct.toQuiver.{u3, succ u3} Type.{u3} (CategoryTheory.Category.toCategoryStruct.{u3, succ u3} Type.{u3} CategoryTheory.types.{u3})) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, succ u3} J _inst_1 Type.{u3} CategoryTheory.types.{u3} F) j)) (Set.instHasSubsetSet.{u3} (Prefunctor.obj.{succ u1, succ u3, u2, succ u3} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) Type.{u3} (CategoryTheory.CategoryStruct.toQuiver.{u3, succ u3} Type.{u3} (CategoryTheory.Category.toCategoryStruct.{u3, succ u3} Type.{u3} CategoryTheory.types.{u3})) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, succ u3} J _inst_1 Type.{u3} CategoryTheory.types.{u3} F) j)) (Set.range.{u3, succ u3} (Prefunctor.obj.{succ u1, succ u3, u2, succ u3} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) Type.{u3} (CategoryTheory.CategoryStruct.toQuiver.{u3, succ u3} Type.{u3} (CategoryTheory.Category.toCategoryStruct.{u3, succ u3} Type.{u3} CategoryTheory.types.{u3})) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, succ u3} J _inst_1 Type.{u3} CategoryTheory.types.{u3} F) j) (Prefunctor.obj.{succ u1, succ u3, u2, succ u3} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) Type.{u3} (CategoryTheory.CategoryStruct.toQuiver.{u3, succ u3} Type.{u3} (CategoryTheory.Category.toCategoryStruct.{u3, succ u3} Type.{u3} CategoryTheory.types.{u3})) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, succ u3} J _inst_1 Type.{u3} CategoryTheory.types.{u3} F) i) (Prefunctor.map.{succ u1, succ u3, u2, succ u3} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) Type.{u3} (CategoryTheory.CategoryStruct.toQuiver.{u3, succ u3} Type.{u3} (CategoryTheory.Category.toCategoryStruct.{u3, succ u3} Type.{u3} CategoryTheory.types.{u3})) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, succ u3} J _inst_1 Type.{u3} CategoryTheory.types.{u3} F) i j f)) (Set.range.{u3, succ u3} (Prefunctor.obj.{succ u1, succ u3, u2, succ u3} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) Type.{u3} (CategoryTheory.CategoryStruct.toQuiver.{u3, succ u3} Type.{u3} (CategoryTheory.Category.toCategoryStruct.{u3, succ u3} Type.{u3} CategoryTheory.types.{u3})) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, succ u3} J _inst_1 Type.{u3} CategoryTheory.types.{u3} F) j) (Prefunctor.obj.{succ u1, succ u3, u2, succ u3} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) Type.{u3} (CategoryTheory.CategoryStruct.toQuiver.{u3, succ u3} Type.{u3} (CategoryTheory.Category.toCategoryStruct.{u3, succ u3} Type.{u3} CategoryTheory.types.{u3})) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, succ u3} J _inst_1 Type.{u3} CategoryTheory.types.{u3} F) k) (Prefunctor.map.{succ u1, succ u3, u2, succ u3} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) Type.{u3} (CategoryTheory.CategoryStruct.toQuiver.{u3, succ u3} Type.{u3} (CategoryTheory.Category.toCategoryStruct.{u3, succ u3} Type.{u3} CategoryTheory.types.{u3})) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, succ u3} J _inst_1 Type.{u3} CategoryTheory.types.{u3} F) k j (CategoryTheory.CategoryStruct.comp.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1) k i j g f))))
Case conversion may be inaccurate. Consider using '#align category_theory.functor.eventual_range_eq_iff CategoryTheory.Functor.eventualRange_eq_iffâ‚“'. -/
theorem eventualRange_eq_iff {f : i âŸ¶ j} :
    F.eventualRange j = range (F.map f) â†”
      âˆ€ â¦ƒkâ¦„ (g : k âŸ¶ i), range (F.map f) âŠ† range (F.map <| g â‰« f) :=
  by
  rw [subset_antisymm_iff, eventual_range, and_iff_right (Interâ‚‚_subset _ _), subset_Interâ‚‚_iff]
  refine' âŸ¨fun h k g => h _ _, fun h j' f' => _âŸ©
  obtain âŸ¨k, g, g', heâŸ© := cospan f f'
  refine' (h g).trans _
  rw [he, F.map_comp]
  apply range_comp_subset_range
#align category_theory.functor.eventual_range_eq_iff CategoryTheory.Functor.eventualRange_eq_iff

/- warning: category_theory.functor.is_mittag_leffler_iff_subset_range_comp -> CategoryTheory.Functor.isMittagLeffler_iff_subset_range_comp is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u3, u1} J] (F : CategoryTheory.Functor.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2}) [_inst_2 : CategoryTheory.IsCofilteredOrEmpty.{u3, u1} J _inst_1], Iff (CategoryTheory.Functor.IsMittagLeffler.{u1, u2, u3} J _inst_1 F) (forall (j : J), Exists.{succ u1} J (fun (i : J) => Exists.{succ u3} (Quiver.Hom.{succ u3, u1} J (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} J (CategoryTheory.Category.toCategoryStruct.{u3, u1} J _inst_1)) i j) (fun (f : Quiver.Hom.{succ u3, u1} J (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} J (CategoryTheory.Category.toCategoryStruct.{u3, u1} J _inst_1)) i j) => forall {{k : J}} (g : Quiver.Hom.{succ u3, u1} J (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} J (CategoryTheory.Category.toCategoryStruct.{u3, u1} J _inst_1)) k i), HasSubset.Subset.{u2} (Set.{u2} (CategoryTheory.Functor.obj.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2} F j)) (Set.hasSubset.{u2} (CategoryTheory.Functor.obj.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2} F j)) (Set.range.{u2, succ u2} (CategoryTheory.Functor.obj.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2} F j) (CategoryTheory.Functor.obj.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2} F i) (CategoryTheory.Functor.map.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2} F i j f)) (Set.range.{u2, succ u2} (CategoryTheory.Functor.obj.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2} F j) (CategoryTheory.Functor.obj.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2} F k) (CategoryTheory.Functor.map.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2} F k j (CategoryTheory.CategoryStruct.comp.{u3, u1} J (CategoryTheory.Category.toCategoryStruct.{u3, u1} J _inst_1) k i j g f))))))
but is expected to have type
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] (F : CategoryTheory.Functor.{u1, u3, u2, succ u3} J _inst_1 Type.{u3} CategoryTheory.types.{u3}) [_inst_2 : CategoryTheory.IsCofilteredOrEmpty.{u1, u2} J _inst_1], Iff (CategoryTheory.Functor.IsMittagLeffler.{u2, u3, u1} J _inst_1 F) (forall (j : J), Exists.{succ u2} J (fun (i : J) => Exists.{succ u1} (Quiver.Hom.{succ u1, u2} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) i j) (fun (f : Quiver.Hom.{succ u1, u2} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) i j) => forall {{k : J}} (g : Quiver.Hom.{succ u1, u2} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) k i), HasSubset.Subset.{u3} (Set.{u3} (Prefunctor.obj.{succ u1, succ u3, u2, succ u3} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) Type.{u3} (CategoryTheory.CategoryStruct.toQuiver.{u3, succ u3} Type.{u3} (CategoryTheory.Category.toCategoryStruct.{u3, succ u3} Type.{u3} CategoryTheory.types.{u3})) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, succ u3} J _inst_1 Type.{u3} CategoryTheory.types.{u3} F) j)) (Set.instHasSubsetSet.{u3} (Prefunctor.obj.{succ u1, succ u3, u2, succ u3} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) Type.{u3} (CategoryTheory.CategoryStruct.toQuiver.{u3, succ u3} Type.{u3} (CategoryTheory.Category.toCategoryStruct.{u3, succ u3} Type.{u3} CategoryTheory.types.{u3})) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, succ u3} J _inst_1 Type.{u3} CategoryTheory.types.{u3} F) j)) (Set.range.{u3, succ u3} (Prefunctor.obj.{succ u1, succ u3, u2, succ u3} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) Type.{u3} (CategoryTheory.CategoryStruct.toQuiver.{u3, succ u3} Type.{u3} (CategoryTheory.Category.toCategoryStruct.{u3, succ u3} Type.{u3} CategoryTheory.types.{u3})) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, succ u3} J _inst_1 Type.{u3} CategoryTheory.types.{u3} F) j) (Prefunctor.obj.{succ u1, succ u3, u2, succ u3} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) Type.{u3} (CategoryTheory.CategoryStruct.toQuiver.{u3, succ u3} Type.{u3} (CategoryTheory.Category.toCategoryStruct.{u3, succ u3} Type.{u3} CategoryTheory.types.{u3})) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, succ u3} J _inst_1 Type.{u3} CategoryTheory.types.{u3} F) i) (Prefunctor.map.{succ u1, succ u3, u2, succ u3} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) Type.{u3} (CategoryTheory.CategoryStruct.toQuiver.{u3, succ u3} Type.{u3} (CategoryTheory.Category.toCategoryStruct.{u3, succ u3} Type.{u3} CategoryTheory.types.{u3})) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, succ u3} J _inst_1 Type.{u3} CategoryTheory.types.{u3} F) i j f)) (Set.range.{u3, succ u3} (Prefunctor.obj.{succ u1, succ u3, u2, succ u3} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) Type.{u3} (CategoryTheory.CategoryStruct.toQuiver.{u3, succ u3} Type.{u3} (CategoryTheory.Category.toCategoryStruct.{u3, succ u3} Type.{u3} CategoryTheory.types.{u3})) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, succ u3} J _inst_1 Type.{u3} CategoryTheory.types.{u3} F) j) (Prefunctor.obj.{succ u1, succ u3, u2, succ u3} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) Type.{u3} (CategoryTheory.CategoryStruct.toQuiver.{u3, succ u3} Type.{u3} (CategoryTheory.Category.toCategoryStruct.{u3, succ u3} Type.{u3} CategoryTheory.types.{u3})) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, succ u3} J _inst_1 Type.{u3} CategoryTheory.types.{u3} F) k) (Prefunctor.map.{succ u1, succ u3, u2, succ u3} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) Type.{u3} (CategoryTheory.CategoryStruct.toQuiver.{u3, succ u3} Type.{u3} (CategoryTheory.Category.toCategoryStruct.{u3, succ u3} Type.{u3} CategoryTheory.types.{u3})) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, succ u3} J _inst_1 Type.{u3} CategoryTheory.types.{u3} F) k j (CategoryTheory.CategoryStruct.comp.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1) k i j g f))))))
Case conversion may be inaccurate. Consider using '#align category_theory.functor.is_mittag_leffler_iff_subset_range_comp CategoryTheory.Functor.isMittagLeffler_iff_subset_range_compâ‚“'. -/
theorem isMittagLeffler_iff_subset_range_comp :
    F.IsMittagLeffler â†”
      âˆ€ j : J, âˆƒ (i : _)(f : i âŸ¶ j), âˆ€ â¦ƒkâ¦„ (g : k âŸ¶ i), range (F.map f) âŠ† range (F.map <| g â‰« f) :=
  by simp_rw [is_mittag_leffler_iff_eventual_range, eventual_range_eq_iff]
#align category_theory.functor.is_mittag_leffler_iff_subset_range_comp CategoryTheory.Functor.isMittagLeffler_iff_subset_range_comp

/- warning: category_theory.functor.is_mittag_leffler.to_preimages -> CategoryTheory.Functor.IsMittagLeffler.toPreimages is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u3, u1} J] (F : CategoryTheory.Functor.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2}) {i : J} (s : Set.{u2} (CategoryTheory.Functor.obj.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2} F i)) [_inst_2 : CategoryTheory.IsCofilteredOrEmpty.{u3, u1} J _inst_1], (CategoryTheory.Functor.IsMittagLeffler.{u1, u2, u3} J _inst_1 F) -> (CategoryTheory.Functor.IsMittagLeffler.{u1, u2, u3} J _inst_1 (CategoryTheory.Functor.toPreimages.{u1, u2, u3} J _inst_1 F i s))
but is expected to have type
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] (F : CategoryTheory.Functor.{u1, u3, u2, succ u3} J _inst_1 Type.{u3} CategoryTheory.types.{u3}) {i : J} (s : Set.{u3} (Prefunctor.obj.{succ u1, succ u3, u2, succ u3} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) Type.{u3} (CategoryTheory.CategoryStruct.toQuiver.{u3, succ u3} Type.{u3} (CategoryTheory.Category.toCategoryStruct.{u3, succ u3} Type.{u3} CategoryTheory.types.{u3})) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, succ u3} J _inst_1 Type.{u3} CategoryTheory.types.{u3} F) i)) [_inst_2 : CategoryTheory.IsCofilteredOrEmpty.{u1, u2} J _inst_1], (CategoryTheory.Functor.IsMittagLeffler.{u2, u3, u1} J _inst_1 F) -> (CategoryTheory.Functor.IsMittagLeffler.{u2, u3, u1} J _inst_1 (CategoryTheory.Functor.toPreimages.{u2, u3, u1} J _inst_1 F i s))
Case conversion may be inaccurate. Consider using '#align category_theory.functor.is_mittag_leffler.to_preimages CategoryTheory.Functor.IsMittagLeffler.toPreimagesâ‚“'. -/
theorem IsMittagLeffler.toPreimages (h : F.IsMittagLeffler) : (F.toPreimages s).IsMittagLeffler :=
  (isMittagLeffler_iff_subset_range_comp _).2 fun j =>
    by
    obtain âŸ¨jâ‚, gâ‚, fâ‚, -âŸ© := cone_objs i j
    obtain âŸ¨jâ‚‚, fâ‚‚, hâ‚‚âŸ© := F.is_mittag_leffler_iff_eventual_range.1 h jâ‚
    refine' âŸ¨jâ‚‚, fâ‚‚ â‰« fâ‚, fun jâ‚ƒ fâ‚ƒ => _âŸ©
    rintro _ âŸ¨âŸ¨x, hxâŸ©, rflâŸ©
    have : F.map fâ‚‚ x âˆˆ F.eventual_range jâ‚ := by rw [hâ‚‚]; exact âŸ¨_, rflâŸ©
    obtain âŸ¨y, hy, hâ‚ƒâŸ© := h.subset_image_eventual_range F (fâ‚ƒ â‰« fâ‚‚) this
    refine' âŸ¨âŸ¨y, mem_Inter.2 fun gâ‚‚ => _âŸ©, Subtype.ext _âŸ©
    Â· obtain âŸ¨jâ‚„, fâ‚„, hâ‚„âŸ© := cone_maps gâ‚‚ ((fâ‚ƒ â‰« fâ‚‚) â‰« gâ‚)
      obtain âŸ¨y, rflâŸ© := F.mem_eventual_range_iff.1 hy fâ‚„
      rw [â† map_comp_apply] at hâ‚ƒ
      rw [mem_preimage, â† map_comp_apply, hâ‚„, â† category.assoc, map_comp_apply, hâ‚ƒ, â†
        map_comp_apply]
      apply mem_Inter.1 hx
    Â· simp_rw [to_preimages_map, maps_to.coe_restrict_apply, Subtype.coe_mk]
      rw [â† category.assoc, map_comp_apply, hâ‚ƒ, map_comp_apply]
#align category_theory.functor.is_mittag_leffler.to_preimages CategoryTheory.Functor.IsMittagLeffler.toPreimages

/- warning: category_theory.functor.is_mittag_leffler_of_exists_finite_range -> CategoryTheory.Functor.isMittagLeffler_of_exists_finite_range is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u3, u1} J] (F : CategoryTheory.Functor.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2}) [_inst_2 : CategoryTheory.IsCofilteredOrEmpty.{u3, u1} J _inst_1], (forall (j : J), Exists.{succ u1} J (fun (i : J) => Exists.{succ u3} (Quiver.Hom.{succ u3, u1} J (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} J (CategoryTheory.Category.toCategoryStruct.{u3, u1} J _inst_1)) i j) (fun (f : Quiver.Hom.{succ u3, u1} J (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} J (CategoryTheory.Category.toCategoryStruct.{u3, u1} J _inst_1)) i j) => Set.Finite.{u2} (CategoryTheory.Functor.obj.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2} F j) (Set.range.{u2, succ u2} (CategoryTheory.Functor.obj.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2} F j) (CategoryTheory.Functor.obj.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2} F i) (CategoryTheory.Functor.map.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2} F i j f))))) -> (CategoryTheory.Functor.IsMittagLeffler.{u1, u2, u3} J _inst_1 F)
but is expected to have type
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] (F : CategoryTheory.Functor.{u1, u3, u2, succ u3} J _inst_1 Type.{u3} CategoryTheory.types.{u3}) [_inst_2 : CategoryTheory.IsCofilteredOrEmpty.{u1, u2} J _inst_1], (forall (j : J), Exists.{succ u2} J (fun (i : J) => Exists.{succ u1} (Quiver.Hom.{succ u1, u2} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) i j) (fun (f : Quiver.Hom.{succ u1, u2} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) i j) => Set.Finite.{u3} (Prefunctor.obj.{succ u1, succ u3, u2, succ u3} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) Type.{u3} (CategoryTheory.CategoryStruct.toQuiver.{u3, succ u3} Type.{u3} (CategoryTheory.Category.toCategoryStruct.{u3, succ u3} Type.{u3} CategoryTheory.types.{u3})) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, succ u3} J _inst_1 Type.{u3} CategoryTheory.types.{u3} F) j) (Set.range.{u3, succ u3} (Prefunctor.obj.{succ u1, succ u3, u2, succ u3} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) Type.{u3} (CategoryTheory.CategoryStruct.toQuiver.{u3, succ u3} Type.{u3} (CategoryTheory.Category.toCategoryStruct.{u3, succ u3} Type.{u3} CategoryTheory.types.{u3})) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, succ u3} J _inst_1 Type.{u3} CategoryTheory.types.{u3} F) j) (Prefunctor.obj.{succ u1, succ u3, u2, succ u3} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) Type.{u3} (CategoryTheory.CategoryStruct.toQuiver.{u3, succ u3} Type.{u3} (CategoryTheory.Category.toCategoryStruct.{u3, succ u3} Type.{u3} CategoryTheory.types.{u3})) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, succ u3} J _inst_1 Type.{u3} CategoryTheory.types.{u3} F) i) (Prefunctor.map.{succ u1, succ u3, u2, succ u3} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) Type.{u3} (CategoryTheory.CategoryStruct.toQuiver.{u3, succ u3} Type.{u3} (CategoryTheory.Category.toCategoryStruct.{u3, succ u3} Type.{u3} CategoryTheory.types.{u3})) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, succ u3} J _inst_1 Type.{u3} CategoryTheory.types.{u3} F) i j f))))) -> (CategoryTheory.Functor.IsMittagLeffler.{u2, u3, u1} J _inst_1 F)
Case conversion may be inaccurate. Consider using '#align category_theory.functor.is_mittag_leffler_of_exists_finite_range CategoryTheory.Functor.isMittagLeffler_of_exists_finite_rangeâ‚“'. -/
theorem isMittagLeffler_of_exists_finite_range
    (h : âˆ€ j : J, âˆƒ (i : _)(f : i âŸ¶ j), (range <| F.map f).Finite) : F.IsMittagLeffler := fun j =>
  by
  obtain âŸ¨i, hi, hfâŸ© := h j
  obtain âŸ¨m, âŸ¨i, f, hmâŸ©, hminâŸ© :=
    finset.is_well_founded_lt.wf.has_min
      { s : Finset (F.obj j) | âˆƒ (i : _)(f : i âŸ¶ j), â†‘s = range (F.map f) }
      âŸ¨_, i, hi, hf.coe_to_finsetâŸ©
  refine'
    âŸ¨i, f, fun k g =>
      (directed_on_range.mp <| F.ranges_directed j).is_bot_of_is_min âŸ¨âŸ¨i, fâŸ©, rflâŸ© _ _
        âŸ¨âŸ¨k, gâŸ©, rflâŸ©âŸ©
  rintro _ âŸ¨âŸ¨k', g'âŸ©, rflâŸ© hl
  refine' (eq_of_le_of_not_lt hl _).ge
  have := hmin _ âŸ¨k', g', (m.finite_to_set.subset <| hm.substr hl).coe_toFinsetâŸ©
  rwa [Finset.lt_iff_ssubset, â† Finset.coe_ssubset, Set.Finite.coe_toFinset, hm] at this
#align category_theory.functor.is_mittag_leffler_of_exists_finite_range CategoryTheory.Functor.isMittagLeffler_of_exists_finite_range

#print CategoryTheory.Functor.toEventualRanges /-
/-- The subfunctor of `F` obtained by restricting to the eventual range at each index.
-/
@[simps]
def toEventualRanges : J â¥¤ Type v
    where
  obj j := F.eventualRange j
  map i j f := (F.eventualRange_mapsTo f).restrict _ _ _
  map_id' i := by simp_rw [F.map_id]; ext; rfl
  map_comp' _ _ _ _ _ := by simp_rw [F.map_comp]; rfl
#align category_theory.functor.to_eventual_ranges CategoryTheory.Functor.toEventualRanges
-/

/- warning: category_theory.functor.to_eventual_ranges_finite -> CategoryTheory.Functor.toEventualRanges_finite is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u3, u1} J] (F : CategoryTheory.Functor.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2}) [_inst_2 : CategoryTheory.IsCofilteredOrEmpty.{u3, u1} J _inst_1] [_inst_3 : forall (j : J), Finite.{succ u2} (CategoryTheory.Functor.obj.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2} F j)] (j : J), Finite.{succ u2} (CategoryTheory.Functor.obj.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.Functor.toEventualRanges.{u1, u2, u3} J _inst_1 F _inst_2) j)
but is expected to have type
  forall {J : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u3, u1} J] (F : CategoryTheory.Functor.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2}) [_inst_2 : CategoryTheory.IsCofilteredOrEmpty.{u3, u1} J _inst_1] [_inst_3 : forall (j : J), Finite.{succ u2} (Prefunctor.obj.{succ u3, succ u2, u1, succ u2} J (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} J (CategoryTheory.Category.toCategoryStruct.{u3, u1} J _inst_1)) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2} F) j)] (j : J), Finite.{succ u2} (Prefunctor.obj.{succ u3, succ u2, u1, succ u2} J (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} J (CategoryTheory.Category.toCategoryStruct.{u3, u1} J _inst_1)) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.Functor.toEventualRanges.{u1, u2, u3} J _inst_1 F _inst_2)) j)
Case conversion may be inaccurate. Consider using '#align category_theory.functor.to_eventual_ranges_finite CategoryTheory.Functor.toEventualRanges_finiteâ‚“'. -/
instance toEventualRanges_finite [âˆ€ j, Finite (F.obj j)] : âˆ€ j, Finite (F.toEventualRanges.obj j) :=
  fun j => Subtype.finite
#align category_theory.functor.to_eventual_ranges_finite CategoryTheory.Functor.toEventualRanges_finite

/- warning: category_theory.functor.to_eventual_ranges_sections_equiv -> CategoryTheory.Functor.toEventualRangesSectionsEquiv is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u3, u1} J] (F : CategoryTheory.Functor.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2}) [_inst_2 : CategoryTheory.IsCofilteredOrEmpty.{u3, u1} J _inst_1], Equiv.{succ (max u1 u2), succ (max u1 u2)} (coeSort.{succ (max u1 u2), succ (succ (max u1 u2))} (Set.{max u1 u2} (forall (j : J), CategoryTheory.Functor.obj.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.Functor.toEventualRanges.{u1, u2, u3} J _inst_1 F _inst_2) j)) Type.{max u1 u2} (Set.hasCoeToSort.{max u1 u2} (forall (j : J), CategoryTheory.Functor.obj.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.Functor.toEventualRanges.{u1, u2, u3} J _inst_1 F _inst_2) j)) (CategoryTheory.Functor.sections.{u3, u2, u1} J _inst_1 (CategoryTheory.Functor.toEventualRanges.{u1, u2, u3} J _inst_1 F _inst_2))) (coeSort.{succ (max u1 u2), succ (succ (max u1 u2))} (Set.{max u1 u2} (forall (j : J), CategoryTheory.Functor.obj.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2} F j)) Type.{max u1 u2} (Set.hasCoeToSort.{max u1 u2} (forall (j : J), CategoryTheory.Functor.obj.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2} F j)) (CategoryTheory.Functor.sections.{u3, u2, u1} J _inst_1 F))
but is expected to have type
  forall {J : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u3, u1} J] (F : CategoryTheory.Functor.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2}) [_inst_2 : CategoryTheory.IsCofilteredOrEmpty.{u3, u1} J _inst_1], Equiv.{max (succ u1) (succ u2), max (succ u1) (succ u2)} (Set.Elem.{max u1 u2} (forall (j : J), Prefunctor.obj.{succ u3, succ u2, u1, succ u2} J (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} J (CategoryTheory.Category.toCategoryStruct.{u3, u1} J _inst_1)) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.Functor.toEventualRanges.{u1, u2, u3} J _inst_1 F _inst_2)) j) (CategoryTheory.Functor.sections.{u3, u2, u1} J _inst_1 (CategoryTheory.Functor.toEventualRanges.{u1, u2, u3} J _inst_1 F _inst_2))) (Set.Elem.{max u1 u2} (forall (j : J), Prefunctor.obj.{succ u3, succ u2, u1, succ u2} J (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} J (CategoryTheory.Category.toCategoryStruct.{u3, u1} J _inst_1)) Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.toPrefunctor.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2} F) j) (CategoryTheory.Functor.sections.{u3, u2, u1} J _inst_1 F))
Case conversion may be inaccurate. Consider using '#align category_theory.functor.to_eventual_ranges_sections_equiv CategoryTheory.Functor.toEventualRangesSectionsEquivâ‚“'. -/
/-- The sections of the functor `F : J â¥¤ Type v` are in bijection with the sections of
`F.eventual_ranges`.
-/
def toEventualRangesSectionsEquiv : F.toEventualRanges.sections â‰ƒ F.sections
    where
  toFun s := âŸ¨_, fun i j f => Subtype.coe_inj.2 <| s.Prop fâŸ©
  invFun s :=
    âŸ¨fun j => âŸ¨_, mem_iInterâ‚‚.2 fun i f => âŸ¨_, s.Prop fâŸ©âŸ©, fun i j f => Subtype.ext <| s.Prop fâŸ©
  left_inv _ := by ext; rfl
  right_inv _ := by ext; rfl
#align category_theory.functor.to_eventual_ranges_sections_equiv CategoryTheory.Functor.toEventualRangesSectionsEquiv

/- warning: category_theory.functor.surjective_to_eventual_ranges -> CategoryTheory.Functor.surjective_toEventualRanges is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u3, u1} J] (F : CategoryTheory.Functor.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2}) [_inst_2 : CategoryTheory.IsCofilteredOrEmpty.{u3, u1} J _inst_1], (CategoryTheory.Functor.IsMittagLeffler.{u1, u2, u3} J _inst_1 F) -> (forall {{i : J}} {{j : J}} (f : Quiver.Hom.{succ u3, u1} J (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} J (CategoryTheory.Category.toCategoryStruct.{u3, u1} J _inst_1)) i j), Function.Surjective.{succ u2, succ u2} (CategoryTheory.Functor.obj.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.Functor.toEventualRanges.{u1, u2, u3} J _inst_1 F _inst_2) i) (CategoryTheory.Functor.obj.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.Functor.toEventualRanges.{u1, u2, u3} J _inst_1 F _inst_2) j) (CategoryTheory.Functor.map.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.Functor.toEventualRanges.{u1, u2, u3} J _inst_1 F _inst_2) i j f))
but is expected to have type
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] (F : CategoryTheory.Functor.{u1, u3, u2, succ u3} J _inst_1 Type.{u3} CategoryTheory.types.{u3}) [_inst_2 : CategoryTheory.IsCofilteredOrEmpty.{u1, u2} J _inst_1], (CategoryTheory.Functor.IsMittagLeffler.{u2, u3, u1} J _inst_1 F) -> (forall {{i : J}} {{j : J}} (f : Quiver.Hom.{succ u1, u2} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) i j), Function.Surjective.{succ u3, succ u3} (Prefunctor.obj.{succ u1, succ u3, u2, succ u3} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) Type.{u3} (CategoryTheory.CategoryStruct.toQuiver.{u3, succ u3} Type.{u3} (CategoryTheory.Category.toCategoryStruct.{u3, succ u3} Type.{u3} CategoryTheory.types.{u3})) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, succ u3} J _inst_1 Type.{u3} CategoryTheory.types.{u3} (CategoryTheory.Functor.toEventualRanges.{u2, u3, u1} J _inst_1 F _inst_2)) i) (Prefunctor.obj.{succ u1, succ u3, u2, succ u3} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) Type.{u3} (CategoryTheory.CategoryStruct.toQuiver.{u3, succ u3} Type.{u3} (CategoryTheory.Category.toCategoryStruct.{u3, succ u3} Type.{u3} CategoryTheory.types.{u3})) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, succ u3} J _inst_1 Type.{u3} CategoryTheory.types.{u3} (CategoryTheory.Functor.toEventualRanges.{u2, u3, u1} J _inst_1 F _inst_2)) j) (Prefunctor.map.{succ u1, succ u3, u2, succ u3} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) Type.{u3} (CategoryTheory.CategoryStruct.toQuiver.{u3, succ u3} Type.{u3} (CategoryTheory.Category.toCategoryStruct.{u3, succ u3} Type.{u3} CategoryTheory.types.{u3})) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, succ u3} J _inst_1 Type.{u3} CategoryTheory.types.{u3} (CategoryTheory.Functor.toEventualRanges.{u2, u3, u1} J _inst_1 F _inst_2)) i j f))
Case conversion may be inaccurate. Consider using '#align category_theory.functor.surjective_to_eventual_ranges CategoryTheory.Functor.surjective_toEventualRangesâ‚“'. -/
/--
If `F` satisfies the Mittag-Leffler condition, its restriction to eventual ranges is a surjective
functor.
-/
theorem surjective_toEventualRanges (h : F.IsMittagLeffler) â¦ƒi jâ¦„ (f : i âŸ¶ j) :
    (F.toEventualRanges.map f).Surjective := fun âŸ¨x, hxâŸ© => by
  obtain âŸ¨y, hy, rflâŸ© := h.subset_image_eventual_range F f hx; exact âŸ¨âŸ¨y, hyâŸ©, rflâŸ©
#align category_theory.functor.surjective_to_eventual_ranges CategoryTheory.Functor.surjective_toEventualRanges

/- warning: category_theory.functor.to_eventual_ranges_nonempty -> CategoryTheory.Functor.toEventualRanges_nonempty is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u3, u1} J] (F : CategoryTheory.Functor.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2}) [_inst_2 : CategoryTheory.IsCofilteredOrEmpty.{u3, u1} J _inst_1], (CategoryTheory.Functor.IsMittagLeffler.{u1, u2, u3} J _inst_1 F) -> (forall [_inst_3 : forall (j : J), Nonempty.{succ u2} (CategoryTheory.Functor.obj.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2} F j)] (j : J), Nonempty.{succ u2} (CategoryTheory.Functor.obj.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.Functor.toEventualRanges.{u1, u2, u3} J _inst_1 F _inst_2) j))
but is expected to have type
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] (F : CategoryTheory.Functor.{u1, u3, u2, succ u3} J _inst_1 Type.{u3} CategoryTheory.types.{u3}) [_inst_2 : CategoryTheory.IsCofilteredOrEmpty.{u1, u2} J _inst_1], (CategoryTheory.Functor.IsMittagLeffler.{u2, u3, u1} J _inst_1 F) -> (forall [_inst_3 : forall (j : J), Nonempty.{succ u3} (Prefunctor.obj.{succ u1, succ u3, u2, succ u3} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) Type.{u3} (CategoryTheory.CategoryStruct.toQuiver.{u3, succ u3} Type.{u3} (CategoryTheory.Category.toCategoryStruct.{u3, succ u3} Type.{u3} CategoryTheory.types.{u3})) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, succ u3} J _inst_1 Type.{u3} CategoryTheory.types.{u3} F) j)] (j : J), Nonempty.{succ u3} (Prefunctor.obj.{succ u1, succ u3, u2, succ u3} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) Type.{u3} (CategoryTheory.CategoryStruct.toQuiver.{u3, succ u3} Type.{u3} (CategoryTheory.Category.toCategoryStruct.{u3, succ u3} Type.{u3} CategoryTheory.types.{u3})) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, succ u3} J _inst_1 Type.{u3} CategoryTheory.types.{u3} (CategoryTheory.Functor.toEventualRanges.{u2, u3, u1} J _inst_1 F _inst_2)) j))
Case conversion may be inaccurate. Consider using '#align category_theory.functor.to_eventual_ranges_nonempty CategoryTheory.Functor.toEventualRanges_nonemptyâ‚“'. -/
/-- If `F` is nonempty at each index and Mittag-Leffler, then so is `F.to_eventual_ranges`. -/
theorem toEventualRanges_nonempty (h : F.IsMittagLeffler) [âˆ€ j : J, Nonempty (F.obj j)] (j : J) :
    Nonempty (F.toEventualRanges.obj j) :=
  by
  let âŸ¨i, f, hâŸ© := F.isMittagLeffler_iff_eventualRange.1 h j
  rw [to_eventual_ranges_obj, h]; infer_instance
#align category_theory.functor.to_eventual_ranges_nonempty CategoryTheory.Functor.toEventualRanges_nonempty

/- warning: category_theory.functor.thin_diagram_of_surjective -> CategoryTheory.Functor.thin_diagram_of_surjective is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u3, u1} J] (F : CategoryTheory.Functor.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2}) [_inst_2 : CategoryTheory.IsCofilteredOrEmpty.{u3, u1} J _inst_1], (forall {{i : J}} {{j : J}} (f : Quiver.Hom.{succ u3, u1} J (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} J (CategoryTheory.Category.toCategoryStruct.{u3, u1} J _inst_1)) i j), Function.Surjective.{succ u2, succ u2} (CategoryTheory.Functor.obj.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2} F i) (CategoryTheory.Functor.obj.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2} F j) (CategoryTheory.Functor.map.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2} F i j f)) -> (forall {i : J} {j : J} (f : Quiver.Hom.{succ u3, u1} J (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} J (CategoryTheory.Category.toCategoryStruct.{u3, u1} J _inst_1)) i j) (g : Quiver.Hom.{succ u3, u1} J (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} J (CategoryTheory.Category.toCategoryStruct.{u3, u1} J _inst_1)) i j), Eq.{succ u2} (Quiver.Hom.{succ u2, succ u2} Type.{u2} (CategoryTheory.CategoryStruct.toQuiver.{u2, succ u2} Type.{u2} (CategoryTheory.Category.toCategoryStruct.{u2, succ u2} Type.{u2} CategoryTheory.types.{u2})) (CategoryTheory.Functor.obj.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2} F i) (CategoryTheory.Functor.obj.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2} F j)) (CategoryTheory.Functor.map.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2} F i j f) (CategoryTheory.Functor.map.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2} F i j g))
but is expected to have type
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] (F : CategoryTheory.Functor.{u1, u3, u2, succ u3} J _inst_1 Type.{u3} CategoryTheory.types.{u3}) [_inst_2 : CategoryTheory.IsCofilteredOrEmpty.{u1, u2} J _inst_1], (forall {{i : J}} {{j : J}} (f : Quiver.Hom.{succ u1, u2} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) i j), Function.Surjective.{succ u3, succ u3} (Prefunctor.obj.{succ u1, succ u3, u2, succ u3} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) Type.{u3} (CategoryTheory.CategoryStruct.toQuiver.{u3, succ u3} Type.{u3} (CategoryTheory.Category.toCategoryStruct.{u3, succ u3} Type.{u3} CategoryTheory.types.{u3})) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, succ u3} J _inst_1 Type.{u3} CategoryTheory.types.{u3} F) i) (Prefunctor.obj.{succ u1, succ u3, u2, succ u3} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) Type.{u3} (CategoryTheory.CategoryStruct.toQuiver.{u3, succ u3} Type.{u3} (CategoryTheory.Category.toCategoryStruct.{u3, succ u3} Type.{u3} CategoryTheory.types.{u3})) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, succ u3} J _inst_1 Type.{u3} CategoryTheory.types.{u3} F) j) (Prefunctor.map.{succ u1, succ u3, u2, succ u3} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) Type.{u3} (CategoryTheory.CategoryStruct.toQuiver.{u3, succ u3} Type.{u3} (CategoryTheory.Category.toCategoryStruct.{u3, succ u3} Type.{u3} CategoryTheory.types.{u3})) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, succ u3} J _inst_1 Type.{u3} CategoryTheory.types.{u3} F) i j f)) -> (forall {i : J} {j : J} (f : Quiver.Hom.{succ u1, u2} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) i j) (g : Quiver.Hom.{succ u1, u2} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) i j), Eq.{succ u3} (Quiver.Hom.{succ u3, succ u3} Type.{u3} (CategoryTheory.CategoryStruct.toQuiver.{u3, succ u3} Type.{u3} (CategoryTheory.Category.toCategoryStruct.{u3, succ u3} Type.{u3} CategoryTheory.types.{u3})) (Prefunctor.obj.{succ u1, succ u3, u2, succ u3} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) Type.{u3} (CategoryTheory.CategoryStruct.toQuiver.{u3, succ u3} Type.{u3} (CategoryTheory.Category.toCategoryStruct.{u3, succ u3} Type.{u3} CategoryTheory.types.{u3})) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, succ u3} J _inst_1 Type.{u3} CategoryTheory.types.{u3} F) i) (Prefunctor.obj.{succ u1, succ u3, u2, succ u3} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) Type.{u3} (CategoryTheory.CategoryStruct.toQuiver.{u3, succ u3} Type.{u3} (CategoryTheory.Category.toCategoryStruct.{u3, succ u3} Type.{u3} CategoryTheory.types.{u3})) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, succ u3} J _inst_1 Type.{u3} CategoryTheory.types.{u3} F) j)) (Prefunctor.map.{succ u1, succ u3, u2, succ u3} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) Type.{u3} (CategoryTheory.CategoryStruct.toQuiver.{u3, succ u3} Type.{u3} (CategoryTheory.Category.toCategoryStruct.{u3, succ u3} Type.{u3} CategoryTheory.types.{u3})) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, succ u3} J _inst_1 Type.{u3} CategoryTheory.types.{u3} F) i j f) (Prefunctor.map.{succ u1, succ u3, u2, succ u3} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) Type.{u3} (CategoryTheory.CategoryStruct.toQuiver.{u3, succ u3} Type.{u3} (CategoryTheory.Category.toCategoryStruct.{u3, succ u3} Type.{u3} CategoryTheory.types.{u3})) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, succ u3} J _inst_1 Type.{u3} CategoryTheory.types.{u3} F) i j g))
Case conversion may be inaccurate. Consider using '#align category_theory.functor.thin_diagram_of_surjective CategoryTheory.Functor.thin_diagram_of_surjectiveâ‚“'. -/
/-- If `F` has all arrows surjective, then it "factors through a poset". -/
theorem thin_diagram_of_surjective (Fsur : âˆ€ â¦ƒi j : Jâ¦„ (f : i âŸ¶ j), (F.map f).Surjective) {i j}
    (f g : i âŸ¶ j) : F.map f = F.map g :=
  let âŸ¨k, Ï†, hÏ†âŸ© := cone_maps f g
  (Fsur Ï†).injective_comp_right <| by simp_rw [â† types_comp, â† F.map_comp, hÏ†]
#align category_theory.functor.thin_diagram_of_surjective CategoryTheory.Functor.thin_diagram_of_surjective

/- warning: category_theory.functor.to_preimages_nonempty_of_surjective -> CategoryTheory.Functor.toPreimages_nonempty_of_surjective is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u3, u1} J] (F : CategoryTheory.Functor.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2}) {i : J} (s : Set.{u2} (CategoryTheory.Functor.obj.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2} F i)) [_inst_2 : CategoryTheory.IsCofilteredOrEmpty.{u3, u1} J _inst_1] [hFn : forall (j : J), Nonempty.{succ u2} (CategoryTheory.Functor.obj.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2} F j)], (forall {{i : J}} {{j : J}} (f : Quiver.Hom.{succ u3, u1} J (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} J (CategoryTheory.Category.toCategoryStruct.{u3, u1} J _inst_1)) i j), Function.Surjective.{succ u2, succ u2} (CategoryTheory.Functor.obj.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2} F i) (CategoryTheory.Functor.obj.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2} F j) (CategoryTheory.Functor.map.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2} F i j f)) -> (Set.Nonempty.{u2} (CategoryTheory.Functor.obj.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2} F i) s) -> (forall (j : J), Nonempty.{succ u2} (CategoryTheory.Functor.obj.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2} (CategoryTheory.Functor.toPreimages.{u1, u2, u3} J _inst_1 F i s) j))
but is expected to have type
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] (F : CategoryTheory.Functor.{u1, u3, u2, succ u3} J _inst_1 Type.{u3} CategoryTheory.types.{u3}) {i : J} (s : Set.{u3} (Prefunctor.obj.{succ u1, succ u3, u2, succ u3} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) Type.{u3} (CategoryTheory.CategoryStruct.toQuiver.{u3, succ u3} Type.{u3} (CategoryTheory.Category.toCategoryStruct.{u3, succ u3} Type.{u3} CategoryTheory.types.{u3})) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, succ u3} J _inst_1 Type.{u3} CategoryTheory.types.{u3} F) i)) [_inst_2 : CategoryTheory.IsCofilteredOrEmpty.{u1, u2} J _inst_1] [hFn : forall (j : J), Nonempty.{succ u3} (Prefunctor.obj.{succ u1, succ u3, u2, succ u3} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) Type.{u3} (CategoryTheory.CategoryStruct.toQuiver.{u3, succ u3} Type.{u3} (CategoryTheory.Category.toCategoryStruct.{u3, succ u3} Type.{u3} CategoryTheory.types.{u3})) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, succ u3} J _inst_1 Type.{u3} CategoryTheory.types.{u3} F) j)], (forall {{i : J}} {{j : J}} (f : Quiver.Hom.{succ u1, u2} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) i j), Function.Surjective.{succ u3, succ u3} (Prefunctor.obj.{succ u1, succ u3, u2, succ u3} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) Type.{u3} (CategoryTheory.CategoryStruct.toQuiver.{u3, succ u3} Type.{u3} (CategoryTheory.Category.toCategoryStruct.{u3, succ u3} Type.{u3} CategoryTheory.types.{u3})) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, succ u3} J _inst_1 Type.{u3} CategoryTheory.types.{u3} F) i) (Prefunctor.obj.{succ u1, succ u3, u2, succ u3} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) Type.{u3} (CategoryTheory.CategoryStruct.toQuiver.{u3, succ u3} Type.{u3} (CategoryTheory.Category.toCategoryStruct.{u3, succ u3} Type.{u3} CategoryTheory.types.{u3})) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, succ u3} J _inst_1 Type.{u3} CategoryTheory.types.{u3} F) j) (Prefunctor.map.{succ u1, succ u3, u2, succ u3} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) Type.{u3} (CategoryTheory.CategoryStruct.toQuiver.{u3, succ u3} Type.{u3} (CategoryTheory.Category.toCategoryStruct.{u3, succ u3} Type.{u3} CategoryTheory.types.{u3})) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, succ u3} J _inst_1 Type.{u3} CategoryTheory.types.{u3} F) i j f)) -> (Set.Nonempty.{u3} (Prefunctor.obj.{succ u1, succ u3, u2, succ u3} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) Type.{u3} (CategoryTheory.CategoryStruct.toQuiver.{u3, succ u3} Type.{u3} (CategoryTheory.Category.toCategoryStruct.{u3, succ u3} Type.{u3} CategoryTheory.types.{u3})) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, succ u3} J _inst_1 Type.{u3} CategoryTheory.types.{u3} F) i) s) -> (forall (j : J), Nonempty.{succ u3} (Prefunctor.obj.{succ u1, succ u3, u2, succ u3} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) Type.{u3} (CategoryTheory.CategoryStruct.toQuiver.{u3, succ u3} Type.{u3} (CategoryTheory.Category.toCategoryStruct.{u3, succ u3} Type.{u3} CategoryTheory.types.{u3})) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, succ u3} J _inst_1 Type.{u3} CategoryTheory.types.{u3} (CategoryTheory.Functor.toPreimages.{u2, u3, u1} J _inst_1 F i s)) j))
Case conversion may be inaccurate. Consider using '#align category_theory.functor.to_preimages_nonempty_of_surjective CategoryTheory.Functor.toPreimages_nonempty_of_surjectiveâ‚“'. -/
theorem toPreimages_nonempty_of_surjective [hFn : âˆ€ j : J, Nonempty (F.obj j)]
    (Fsur : âˆ€ â¦ƒi j : Jâ¦„ (f : i âŸ¶ j), (F.map f).Surjective) (hs : s.Nonempty) (j) :
    Nonempty ((F.toPreimages s).obj j) :=
  by
  simp only [to_preimages_obj, nonempty_coe_sort, nonempty_Inter, mem_preimage]
  obtain h | âŸ¨âŸ¨jiâŸ©âŸ© := isEmpty_or_nonempty (j âŸ¶ i)
  Â· exact âŸ¨(hFn j).some, fun ji => h.elim jiâŸ©
  Â· obtain âŸ¨y, ysâŸ© := hs
    obtain âŸ¨x, rflâŸ© := Fsur ji y
    exact âŸ¨x, fun ji' => (F.thin_diagram_of_surjective Fsur ji' ji).symm â–¸ ysâŸ©
#align category_theory.functor.to_preimages_nonempty_of_surjective CategoryTheory.Functor.toPreimages_nonempty_of_surjective

/- warning: category_theory.functor.eval_section_injective_of_eventually_injective -> CategoryTheory.Functor.eval_section_injective_of_eventually_injective is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u3, u1} J] (F : CategoryTheory.Functor.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2}) [_inst_2 : CategoryTheory.IsCofilteredOrEmpty.{u3, u1} J _inst_1] {j : J}, (forall (i : J) (f : Quiver.Hom.{succ u3, u1} J (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} J (CategoryTheory.Category.toCategoryStruct.{u3, u1} J _inst_1)) i j), Function.Injective.{succ u2, succ u2} (CategoryTheory.Functor.obj.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2} F i) (CategoryTheory.Functor.obj.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2} F j) (CategoryTheory.Functor.map.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2} F i j f)) -> (forall (i : J), (Quiver.Hom.{succ u3, u1} J (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} J (CategoryTheory.Category.toCategoryStruct.{u3, u1} J _inst_1)) i j) -> (Function.Injective.{succ (max u1 u2), succ u2} (coeSort.{succ (max u1 u2), succ (succ (max u1 u2))} (Set.{max u1 u2} (forall (j : J), CategoryTheory.Functor.obj.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2} F j)) Type.{max u1 u2} (Set.hasCoeToSort.{max u1 u2} (forall (j : J), CategoryTheory.Functor.obj.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2} F j)) (CategoryTheory.Functor.sections.{u3, u2, u1} J _inst_1 F)) (CategoryTheory.Functor.obj.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2} F j) (fun (s : coeSort.{succ (max u1 u2), succ (succ (max u1 u2))} (Set.{max u1 u2} (forall (j : J), CategoryTheory.Functor.obj.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2} F j)) Type.{max u1 u2} (Set.hasCoeToSort.{max u1 u2} (forall (j : J), CategoryTheory.Functor.obj.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2} F j)) (CategoryTheory.Functor.sections.{u3, u2, u1} J _inst_1 F)) => Subtype.val.{succ (max u1 u2)} (forall (j : J), CategoryTheory.Functor.obj.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2} F j) (fun (x : forall (j : J), CategoryTheory.Functor.obj.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2} F j) => Membership.Mem.{max u1 u2, max u1 u2} (forall (j : J), CategoryTheory.Functor.obj.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2} F j) (Set.{max u1 u2} (forall (j : J), CategoryTheory.Functor.obj.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2} F j)) (Set.hasMem.{max u1 u2} (forall (j : J), CategoryTheory.Functor.obj.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2} F j)) x (CategoryTheory.Functor.sections.{u3, u2, u1} J _inst_1 F)) s j)))
but is expected to have type
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] (F : CategoryTheory.Functor.{u1, u3, u2, succ u3} J _inst_1 Type.{u3} CategoryTheory.types.{u3}) [_inst_2 : CategoryTheory.IsCofilteredOrEmpty.{u1, u2} J _inst_1] {j : J}, (forall (i : J) (f : Quiver.Hom.{succ u1, u2} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) i j), Function.Injective.{succ u3, succ u3} (Prefunctor.obj.{succ u1, succ u3, u2, succ u3} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) Type.{u3} (CategoryTheory.CategoryStruct.toQuiver.{u3, succ u3} Type.{u3} (CategoryTheory.Category.toCategoryStruct.{u3, succ u3} Type.{u3} CategoryTheory.types.{u3})) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, succ u3} J _inst_1 Type.{u3} CategoryTheory.types.{u3} F) i) (Prefunctor.obj.{succ u1, succ u3, u2, succ u3} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) Type.{u3} (CategoryTheory.CategoryStruct.toQuiver.{u3, succ u3} Type.{u3} (CategoryTheory.Category.toCategoryStruct.{u3, succ u3} Type.{u3} CategoryTheory.types.{u3})) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, succ u3} J _inst_1 Type.{u3} CategoryTheory.types.{u3} F) j) (Prefunctor.map.{succ u1, succ u3, u2, succ u3} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) Type.{u3} (CategoryTheory.CategoryStruct.toQuiver.{u3, succ u3} Type.{u3} (CategoryTheory.Category.toCategoryStruct.{u3, succ u3} Type.{u3} CategoryTheory.types.{u3})) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, succ u3} J _inst_1 Type.{u3} CategoryTheory.types.{u3} F) i j f)) -> (forall (i : J), (Quiver.Hom.{succ u1, u2} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) i j) -> (Function.Injective.{max (succ u2) (succ u3), succ u3} (Set.Elem.{max u2 u3} (forall (j : J), Prefunctor.obj.{succ u1, succ u3, u2, succ u3} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) Type.{u3} (CategoryTheory.CategoryStruct.toQuiver.{u3, succ u3} Type.{u3} (CategoryTheory.Category.toCategoryStruct.{u3, succ u3} Type.{u3} CategoryTheory.types.{u3})) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, succ u3} J _inst_1 Type.{u3} CategoryTheory.types.{u3} F) j) (CategoryTheory.Functor.sections.{u1, u3, u2} J _inst_1 F)) (Prefunctor.obj.{succ u1, succ u3, u2, succ u3} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) Type.{u3} (CategoryTheory.CategoryStruct.toQuiver.{u3, succ u3} Type.{u3} (CategoryTheory.Category.toCategoryStruct.{u3, succ u3} Type.{u3} CategoryTheory.types.{u3})) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, succ u3} J _inst_1 Type.{u3} CategoryTheory.types.{u3} F) j) (fun (s : Set.Elem.{max u2 u3} (forall (j : J), Prefunctor.obj.{succ u1, succ u3, u2, succ u3} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) Type.{u3} (CategoryTheory.CategoryStruct.toQuiver.{u3, succ u3} Type.{u3} (CategoryTheory.Category.toCategoryStruct.{u3, succ u3} Type.{u3} CategoryTheory.types.{u3})) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, succ u3} J _inst_1 Type.{u3} CategoryTheory.types.{u3} F) j) (CategoryTheory.Functor.sections.{u1, u3, u2} J _inst_1 F)) => Subtype.val.{max (succ u2) (succ u3)} (forall (j : J), Prefunctor.obj.{succ u1, succ u3, u2, succ u3} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) Type.{u3} (CategoryTheory.CategoryStruct.toQuiver.{u3, succ u3} Type.{u3} (CategoryTheory.Category.toCategoryStruct.{u3, succ u3} Type.{u3} CategoryTheory.types.{u3})) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, succ u3} J _inst_1 Type.{u3} CategoryTheory.types.{u3} F) j) (fun (x : forall (j : J), Prefunctor.obj.{succ u1, succ u3, u2, succ u3} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) Type.{u3} (CategoryTheory.CategoryStruct.toQuiver.{u3, succ u3} Type.{u3} (CategoryTheory.Category.toCategoryStruct.{u3, succ u3} Type.{u3} CategoryTheory.types.{u3})) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, succ u3} J _inst_1 Type.{u3} CategoryTheory.types.{u3} F) j) => Membership.mem.{max u2 u3, max u2 u3} (forall (j : J), Prefunctor.obj.{succ u1, succ u3, u2, succ u3} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) Type.{u3} (CategoryTheory.CategoryStruct.toQuiver.{u3, succ u3} Type.{u3} (CategoryTheory.Category.toCategoryStruct.{u3, succ u3} Type.{u3} CategoryTheory.types.{u3})) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, succ u3} J _inst_1 Type.{u3} CategoryTheory.types.{u3} F) j) (Set.{max u2 u3} (forall (j : J), Prefunctor.obj.{succ u1, succ u3, u2, succ u3} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) Type.{u3} (CategoryTheory.CategoryStruct.toQuiver.{u3, succ u3} Type.{u3} (CategoryTheory.Category.toCategoryStruct.{u3, succ u3} Type.{u3} CategoryTheory.types.{u3})) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, succ u3} J _inst_1 Type.{u3} CategoryTheory.types.{u3} F) j)) (Set.instMembershipSet.{max u2 u3} (forall (j : J), Prefunctor.obj.{succ u1, succ u3, u2, succ u3} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) Type.{u3} (CategoryTheory.CategoryStruct.toQuiver.{u3, succ u3} Type.{u3} (CategoryTheory.Category.toCategoryStruct.{u3, succ u3} Type.{u3} CategoryTheory.types.{u3})) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, succ u3} J _inst_1 Type.{u3} CategoryTheory.types.{u3} F) j)) x (CategoryTheory.Functor.sections.{u1, u3, u2} J _inst_1 F)) s j)))
Case conversion may be inaccurate. Consider using '#align category_theory.functor.eval_section_injective_of_eventually_injective CategoryTheory.Functor.eval_section_injective_of_eventually_injectiveâ‚“'. -/
theorem eval_section_injective_of_eventually_injective {j}
    (Finj : âˆ€ (i) (f : i âŸ¶ j), (F.map f).Injective) (i) (f : i âŸ¶ j) :
    (fun s : F.sections => s.val j).Injective :=
  by
  refine' fun sâ‚€ sâ‚ h => Subtype.ext <| funext fun k => _
  obtain âŸ¨m, mi, mk, _âŸ© := cone_objs i k
  dsimp at h
  rw [â† sâ‚€.prop (mi â‰« f), â† sâ‚.prop (mi â‰« f)] at h
  rw [â† sâ‚€.prop mk, â† sâ‚.prop mk]
  refine' congr_arg _ (Finj m (mi â‰« f) h)
#align category_theory.functor.eval_section_injective_of_eventually_injective CategoryTheory.Functor.eval_section_injective_of_eventually_injective

section FiniteCofilteredSystem

variable [âˆ€ j : J, Nonempty (F.obj j)] [âˆ€ j : J, Finite (F.obj j)]
  (Fsur : âˆ€ â¦ƒi j : Jâ¦„ (f : i âŸ¶ j), (F.map f).Surjective)

include Fsur

/- warning: category_theory.functor.eval_section_surjective_of_surjective -> CategoryTheory.Functor.eval_section_surjective_of_surjective is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u3, u1} J] (F : CategoryTheory.Functor.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2}) [_inst_2 : CategoryTheory.IsCofilteredOrEmpty.{u3, u1} J _inst_1] [_inst_3 : forall (j : J), Nonempty.{succ u2} (CategoryTheory.Functor.obj.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2} F j)] [_inst_4 : forall (j : J), Finite.{succ u2} (CategoryTheory.Functor.obj.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2} F j)], (forall {{i : J}} {{j : J}} (f : Quiver.Hom.{succ u3, u1} J (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} J (CategoryTheory.Category.toCategoryStruct.{u3, u1} J _inst_1)) i j), Function.Surjective.{succ u2, succ u2} (CategoryTheory.Functor.obj.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2} F i) (CategoryTheory.Functor.obj.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2} F j) (CategoryTheory.Functor.map.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2} F i j f)) -> (forall (i : J), Function.Surjective.{succ (max u1 u2), succ u2} (coeSort.{succ (max u1 u2), succ (succ (max u1 u2))} (Set.{max u1 u2} (forall (j : J), CategoryTheory.Functor.obj.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2} F j)) Type.{max u1 u2} (Set.hasCoeToSort.{max u1 u2} (forall (j : J), CategoryTheory.Functor.obj.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2} F j)) (CategoryTheory.Functor.sections.{u3, u2, u1} J _inst_1 F)) (CategoryTheory.Functor.obj.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2} F i) (fun (s : coeSort.{succ (max u1 u2), succ (succ (max u1 u2))} (Set.{max u1 u2} (forall (j : J), CategoryTheory.Functor.obj.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2} F j)) Type.{max u1 u2} (Set.hasCoeToSort.{max u1 u2} (forall (j : J), CategoryTheory.Functor.obj.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2} F j)) (CategoryTheory.Functor.sections.{u3, u2, u1} J _inst_1 F)) => Subtype.val.{succ (max u1 u2)} (forall (j : J), CategoryTheory.Functor.obj.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2} F j) (fun (x : forall (j : J), CategoryTheory.Functor.obj.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2} F j) => Membership.Mem.{max u1 u2, max u1 u2} (forall (j : J), CategoryTheory.Functor.obj.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2} F j) (Set.{max u1 u2} (forall (j : J), CategoryTheory.Functor.obj.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2} F j)) (Set.hasMem.{max u1 u2} (forall (j : J), CategoryTheory.Functor.obj.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2} F j)) x (CategoryTheory.Functor.sections.{u3, u2, u1} J _inst_1 F)) s i))
but is expected to have type
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] (F : CategoryTheory.Functor.{u1, u3, u2, succ u3} J _inst_1 Type.{u3} CategoryTheory.types.{u3}) [_inst_2 : CategoryTheory.IsCofilteredOrEmpty.{u1, u2} J _inst_1] [_inst_3 : forall (j : J), Nonempty.{succ u3} (Prefunctor.obj.{succ u1, succ u3, u2, succ u3} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) Type.{u3} (CategoryTheory.CategoryStruct.toQuiver.{u3, succ u3} Type.{u3} (CategoryTheory.Category.toCategoryStruct.{u3, succ u3} Type.{u3} CategoryTheory.types.{u3})) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, succ u3} J _inst_1 Type.{u3} CategoryTheory.types.{u3} F) j)] [_inst_4 : forall (j : J), Finite.{succ u3} (Prefunctor.obj.{succ u1, succ u3, u2, succ u3} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) Type.{u3} (CategoryTheory.CategoryStruct.toQuiver.{u3, succ u3} Type.{u3} (CategoryTheory.Category.toCategoryStruct.{u3, succ u3} Type.{u3} CategoryTheory.types.{u3})) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, succ u3} J _inst_1 Type.{u3} CategoryTheory.types.{u3} F) j)], (forall {{i : J}} {{j : J}} (f : Quiver.Hom.{succ u1, u2} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) i j), Function.Surjective.{succ u3, succ u3} (Prefunctor.obj.{succ u1, succ u3, u2, succ u3} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) Type.{u3} (CategoryTheory.CategoryStruct.toQuiver.{u3, succ u3} Type.{u3} (CategoryTheory.Category.toCategoryStruct.{u3, succ u3} Type.{u3} CategoryTheory.types.{u3})) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, succ u3} J _inst_1 Type.{u3} CategoryTheory.types.{u3} F) i) (Prefunctor.obj.{succ u1, succ u3, u2, succ u3} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) Type.{u3} (CategoryTheory.CategoryStruct.toQuiver.{u3, succ u3} Type.{u3} (CategoryTheory.Category.toCategoryStruct.{u3, succ u3} Type.{u3} CategoryTheory.types.{u3})) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, succ u3} J _inst_1 Type.{u3} CategoryTheory.types.{u3} F) j) (Prefunctor.map.{succ u1, succ u3, u2, succ u3} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) Type.{u3} (CategoryTheory.CategoryStruct.toQuiver.{u3, succ u3} Type.{u3} (CategoryTheory.Category.toCategoryStruct.{u3, succ u3} Type.{u3} CategoryTheory.types.{u3})) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, succ u3} J _inst_1 Type.{u3} CategoryTheory.types.{u3} F) i j f)) -> (forall (i : J), Function.Surjective.{max (succ u2) (succ u3), succ u3} (Set.Elem.{max u2 u3} (forall (j : J), Prefunctor.obj.{succ u1, succ u3, u2, succ u3} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) Type.{u3} (CategoryTheory.CategoryStruct.toQuiver.{u3, succ u3} Type.{u3} (CategoryTheory.Category.toCategoryStruct.{u3, succ u3} Type.{u3} CategoryTheory.types.{u3})) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, succ u3} J _inst_1 Type.{u3} CategoryTheory.types.{u3} F) j) (CategoryTheory.Functor.sections.{u1, u3, u2} J _inst_1 F)) (Prefunctor.obj.{succ u1, succ u3, u2, succ u3} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) Type.{u3} (CategoryTheory.CategoryStruct.toQuiver.{u3, succ u3} Type.{u3} (CategoryTheory.Category.toCategoryStruct.{u3, succ u3} Type.{u3} CategoryTheory.types.{u3})) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, succ u3} J _inst_1 Type.{u3} CategoryTheory.types.{u3} F) i) (fun (s : Set.Elem.{max u2 u3} (forall (j : J), Prefunctor.obj.{succ u1, succ u3, u2, succ u3} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) Type.{u3} (CategoryTheory.CategoryStruct.toQuiver.{u3, succ u3} Type.{u3} (CategoryTheory.Category.toCategoryStruct.{u3, succ u3} Type.{u3} CategoryTheory.types.{u3})) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, succ u3} J _inst_1 Type.{u3} CategoryTheory.types.{u3} F) j) (CategoryTheory.Functor.sections.{u1, u3, u2} J _inst_1 F)) => Subtype.val.{max (succ u2) (succ u3)} (forall (j : J), Prefunctor.obj.{succ u1, succ u3, u2, succ u3} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) Type.{u3} (CategoryTheory.CategoryStruct.toQuiver.{u3, succ u3} Type.{u3} (CategoryTheory.Category.toCategoryStruct.{u3, succ u3} Type.{u3} CategoryTheory.types.{u3})) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, succ u3} J _inst_1 Type.{u3} CategoryTheory.types.{u3} F) j) (fun (x : forall (j : J), Prefunctor.obj.{succ u1, succ u3, u2, succ u3} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) Type.{u3} (CategoryTheory.CategoryStruct.toQuiver.{u3, succ u3} Type.{u3} (CategoryTheory.Category.toCategoryStruct.{u3, succ u3} Type.{u3} CategoryTheory.types.{u3})) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, succ u3} J _inst_1 Type.{u3} CategoryTheory.types.{u3} F) j) => Membership.mem.{max u2 u3, max u2 u3} (forall (j : J), Prefunctor.obj.{succ u1, succ u3, u2, succ u3} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) Type.{u3} (CategoryTheory.CategoryStruct.toQuiver.{u3, succ u3} Type.{u3} (CategoryTheory.Category.toCategoryStruct.{u3, succ u3} Type.{u3} CategoryTheory.types.{u3})) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, succ u3} J _inst_1 Type.{u3} CategoryTheory.types.{u3} F) j) (Set.{max u2 u3} (forall (j : J), Prefunctor.obj.{succ u1, succ u3, u2, succ u3} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) Type.{u3} (CategoryTheory.CategoryStruct.toQuiver.{u3, succ u3} Type.{u3} (CategoryTheory.Category.toCategoryStruct.{u3, succ u3} Type.{u3} CategoryTheory.types.{u3})) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, succ u3} J _inst_1 Type.{u3} CategoryTheory.types.{u3} F) j)) (Set.instMembershipSet.{max u2 u3} (forall (j : J), Prefunctor.obj.{succ u1, succ u3, u2, succ u3} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) Type.{u3} (CategoryTheory.CategoryStruct.toQuiver.{u3, succ u3} Type.{u3} (CategoryTheory.Category.toCategoryStruct.{u3, succ u3} Type.{u3} CategoryTheory.types.{u3})) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, succ u3} J _inst_1 Type.{u3} CategoryTheory.types.{u3} F) j)) x (CategoryTheory.Functor.sections.{u1, u3, u2} J _inst_1 F)) s i))
Case conversion may be inaccurate. Consider using '#align category_theory.functor.eval_section_surjective_of_surjective CategoryTheory.Functor.eval_section_surjective_of_surjectiveâ‚“'. -/
theorem eval_section_surjective_of_surjective (i : J) :
    (fun s : F.sections => s.val i).Surjective := fun x =>
  by
  let s : Set (F.obj i) := {x}
  haveI := F.to_preimages_nonempty_of_surjective s Fsur (singleton_nonempty x)
  obtain âŸ¨sec, hâŸ© := nonempty_sections_of_finite_cofiltered_system (F.to_preimages s)
  refine' âŸ¨âŸ¨fun j => (sec j).val, fun j k jk => by simpa [Subtype.ext_iff] using h jkâŸ©, _âŸ©
  Â· have := (sec i).Prop
    simp only [mem_Inter, mem_preimage, mem_singleton_iff] at this
    replace this := this (ðŸ™ i); rwa [map_id_apply] at this
#align category_theory.functor.eval_section_surjective_of_surjective CategoryTheory.Functor.eval_section_surjective_of_surjective

/- warning: category_theory.functor.eventually_injective -> CategoryTheory.Functor.eventually_injective is a dubious translation:
lean 3 declaration is
  forall {J : Type.{u1}} [_inst_1 : CategoryTheory.Category.{u3, u1} J] (F : CategoryTheory.Functor.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2}) [_inst_2 : CategoryTheory.IsCofilteredOrEmpty.{u3, u1} J _inst_1] [_inst_3 : forall (j : J), Nonempty.{succ u2} (CategoryTheory.Functor.obj.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2} F j)] [_inst_4 : forall (j : J), Finite.{succ u2} (CategoryTheory.Functor.obj.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2} F j)], (forall {{i : J}} {{j : J}} (f : Quiver.Hom.{succ u3, u1} J (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} J (CategoryTheory.Category.toCategoryStruct.{u3, u1} J _inst_1)) i j), Function.Surjective.{succ u2, succ u2} (CategoryTheory.Functor.obj.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2} F i) (CategoryTheory.Functor.obj.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2} F j) (CategoryTheory.Functor.map.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2} F i j f)) -> (forall [_inst_5 : Nonempty.{succ u1} J] [_inst_6 : Finite.{succ (max u1 u2)} (coeSort.{succ (max u1 u2), succ (succ (max u1 u2))} (Set.{max u1 u2} (forall (j : J), CategoryTheory.Functor.obj.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2} F j)) Type.{max u1 u2} (Set.hasCoeToSort.{max u1 u2} (forall (j : J), CategoryTheory.Functor.obj.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2} F j)) (CategoryTheory.Functor.sections.{u3, u2, u1} J _inst_1 F))], Exists.{succ u1} J (fun (j : J) => forall (i : J) (f : Quiver.Hom.{succ u3, u1} J (CategoryTheory.CategoryStruct.toQuiver.{u3, u1} J (CategoryTheory.Category.toCategoryStruct.{u3, u1} J _inst_1)) i j), Function.Injective.{succ u2, succ u2} (CategoryTheory.Functor.obj.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2} F i) (CategoryTheory.Functor.obj.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2} F j) (CategoryTheory.Functor.map.{u3, u2, u1, succ u2} J _inst_1 Type.{u2} CategoryTheory.types.{u2} F i j f)))
but is expected to have type
  forall {J : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} J] (F : CategoryTheory.Functor.{u1, u3, u2, succ u3} J _inst_1 Type.{u3} CategoryTheory.types.{u3}) [_inst_2 : CategoryTheory.IsCofilteredOrEmpty.{u1, u2} J _inst_1] [_inst_3 : forall (j : J), Nonempty.{succ u3} (Prefunctor.obj.{succ u1, succ u3, u2, succ u3} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) Type.{u3} (CategoryTheory.CategoryStruct.toQuiver.{u3, succ u3} Type.{u3} (CategoryTheory.Category.toCategoryStruct.{u3, succ u3} Type.{u3} CategoryTheory.types.{u3})) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, succ u3} J _inst_1 Type.{u3} CategoryTheory.types.{u3} F) j)] [_inst_4 : forall (j : J), Finite.{succ u3} (Prefunctor.obj.{succ u1, succ u3, u2, succ u3} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) Type.{u3} (CategoryTheory.CategoryStruct.toQuiver.{u3, succ u3} Type.{u3} (CategoryTheory.Category.toCategoryStruct.{u3, succ u3} Type.{u3} CategoryTheory.types.{u3})) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, succ u3} J _inst_1 Type.{u3} CategoryTheory.types.{u3} F) j)], (forall {{i : J}} {{j : J}} (f : Quiver.Hom.{succ u1, u2} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) i j), Function.Surjective.{succ u3, succ u3} (Prefunctor.obj.{succ u1, succ u3, u2, succ u3} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) Type.{u3} (CategoryTheory.CategoryStruct.toQuiver.{u3, succ u3} Type.{u3} (CategoryTheory.Category.toCategoryStruct.{u3, succ u3} Type.{u3} CategoryTheory.types.{u3})) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, succ u3} J _inst_1 Type.{u3} CategoryTheory.types.{u3} F) i) (Prefunctor.obj.{succ u1, succ u3, u2, succ u3} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) Type.{u3} (CategoryTheory.CategoryStruct.toQuiver.{u3, succ u3} Type.{u3} (CategoryTheory.Category.toCategoryStruct.{u3, succ u3} Type.{u3} CategoryTheory.types.{u3})) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, succ u3} J _inst_1 Type.{u3} CategoryTheory.types.{u3} F) j) (Prefunctor.map.{succ u1, succ u3, u2, succ u3} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) Type.{u3} (CategoryTheory.CategoryStruct.toQuiver.{u3, succ u3} Type.{u3} (CategoryTheory.Category.toCategoryStruct.{u3, succ u3} Type.{u3} CategoryTheory.types.{u3})) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, succ u3} J _inst_1 Type.{u3} CategoryTheory.types.{u3} F) i j f)) -> (forall [_inst_5 : Nonempty.{succ u2} J] [_inst_6 : Finite.{max (succ u2) (succ u3)} (Set.Elem.{max u2 u3} (forall (j : J), Prefunctor.obj.{succ u1, succ u3, u2, succ u3} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) Type.{u3} (CategoryTheory.CategoryStruct.toQuiver.{u3, succ u3} Type.{u3} (CategoryTheory.Category.toCategoryStruct.{u3, succ u3} Type.{u3} CategoryTheory.types.{u3})) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, succ u3} J _inst_1 Type.{u3} CategoryTheory.types.{u3} F) j) (CategoryTheory.Functor.sections.{u1, u3, u2} J _inst_1 F))], Exists.{succ u2} J (fun (j : J) => forall (i : J) (f : Quiver.Hom.{succ u1, u2} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) i j), Function.Injective.{succ u3, succ u3} (Prefunctor.obj.{succ u1, succ u3, u2, succ u3} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) Type.{u3} (CategoryTheory.CategoryStruct.toQuiver.{u3, succ u3} Type.{u3} (CategoryTheory.Category.toCategoryStruct.{u3, succ u3} Type.{u3} CategoryTheory.types.{u3})) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, succ u3} J _inst_1 Type.{u3} CategoryTheory.types.{u3} F) i) (Prefunctor.obj.{succ u1, succ u3, u2, succ u3} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) Type.{u3} (CategoryTheory.CategoryStruct.toQuiver.{u3, succ u3} Type.{u3} (CategoryTheory.Category.toCategoryStruct.{u3, succ u3} Type.{u3} CategoryTheory.types.{u3})) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, succ u3} J _inst_1 Type.{u3} CategoryTheory.types.{u3} F) j) (Prefunctor.map.{succ u1, succ u3, u2, succ u3} J (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} J (CategoryTheory.Category.toCategoryStruct.{u1, u2} J _inst_1)) Type.{u3} (CategoryTheory.CategoryStruct.toQuiver.{u3, succ u3} Type.{u3} (CategoryTheory.Category.toCategoryStruct.{u3, succ u3} Type.{u3} CategoryTheory.types.{u3})) (CategoryTheory.Functor.toPrefunctor.{u1, u3, u2, succ u3} J _inst_1 Type.{u3} CategoryTheory.types.{u3} F) i j f)))
Case conversion may be inaccurate. Consider using '#align category_theory.functor.eventually_injective CategoryTheory.Functor.eventually_injectiveâ‚“'. -/
theorem eventually_injective [Nonempty J] [Finite F.sections] :
    âˆƒ j, âˆ€ (i) (f : i âŸ¶ j), (F.map f).Injective :=
  by
  haveI : âˆ€ j, Fintype (F.obj j) := fun j => Fintype.ofFinite (F.obj j)
  haveI : Fintype F.sections := Fintype.ofFinite F.sections
  have card_le : âˆ€ j, Fintype.card (F.obj j) â‰¤ Fintype.card F.sections := fun j =>
    Fintype.card_le_of_surjective _ (F.eval_section_surjective_of_surjective Fsur j)
  let fn j := Fintype.card F.sections - Fintype.card (F.obj j)
  refine'
    âŸ¨fn.argmin nat.well_founded_lt.wf, fun i f =>
      ((Fintype.bijective_iff_surjective_and_card _).2
          âŸ¨Fsur f, le_antisymm _ (Fintype.card_le_of_surjective _ <| Fsur f)âŸ©).1âŸ©
  rw [â† Nat.sub_sub_self (card_le i), tsub_le_iff_tsub_le]
  apply fn.argmin_le
#align category_theory.functor.eventually_injective CategoryTheory.Functor.eventually_injective

end FiniteCofilteredSystem

end Functor

end CategoryTheory

