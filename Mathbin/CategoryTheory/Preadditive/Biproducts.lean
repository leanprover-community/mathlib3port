/-
Copyright (c) 2020 Scott Morrison. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Scott Morrison

! This file was ported from Lean 3 source module category_theory.preadditive.biproducts
! leanprover-community/mathlib commit 69c6a5a12d8a2b159f20933e60115a4f2de62b58
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.Algebra.Group.Ext
import Mathbin.CategoryTheory.Limits.Shapes.Biproducts
import Mathbin.CategoryTheory.Limits.Preserves.Shapes.BinaryProducts
import Mathbin.CategoryTheory.Limits.Preserves.Shapes.Biproducts
import Mathbin.CategoryTheory.Limits.Preserves.Shapes.Products
import Mathbin.CategoryTheory.Preadditive.Basic
import Mathbin.Tactic.Abel

/-!
# Basic facts about biproducts in preadditive categories.

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

In (or between) preadditive categories,

* Any biproduct satisfies the equality
  `total : ‚àë j : J, biproduct.œÄ f j ‚â´ biproduct.Œπ f j = ùüô (‚®Å f)`,
  or, in the binary case, `total : fst ‚â´ inl + snd ‚â´ inr = ùüô X`.

* Any (binary) `product` or (binary) `coproduct` is a (binary) `biproduct`.

* In any category (with zero morphisms), if `biprod.map f g` is an isomorphism,
  then both `f` and `g` are isomorphisms.

* If `f` is a morphism `X‚ÇÅ ‚äû X‚ÇÇ ‚ü∂ Y‚ÇÅ ‚äû Y‚ÇÇ` whose `X‚ÇÅ ‚ü∂ Y‚ÇÅ` entry is an isomorphism,
  then we can construct isomorphisms `L : X‚ÇÅ ‚äû X‚ÇÇ ‚âÖ X‚ÇÅ ‚äû X‚ÇÇ` and `R : Y‚ÇÅ ‚äû Y‚ÇÇ ‚âÖ Y‚ÇÅ ‚äû Y‚ÇÇ`
  so that `L.hom ‚â´ g ‚â´ R.hom` is diagonal (with `X‚ÇÅ ‚ü∂ Y‚ÇÅ` component still `f`),
  via Gaussian elimination.

* As a corollary of the previous two facts,
  if we have an isomorphism `X‚ÇÅ ‚äû X‚ÇÇ ‚âÖ Y‚ÇÅ ‚äû Y‚ÇÇ` whose `X‚ÇÅ ‚ü∂ Y‚ÇÅ` entry is an isomorphism,
  we can construct an isomorphism `X‚ÇÇ ‚âÖ Y‚ÇÇ`.

* If `f : W ‚äû X ‚ü∂ Y ‚äû Z` is an isomorphism, either `ùüô W = 0`,
  or at least one of the component maps `W ‚ü∂ Y` and `W ‚ü∂ Z` is nonzero.

* If `f : ‚®Å S ‚ü∂ ‚®Å T` is an isomorphism,
  then every column (corresponding to a nonzero summand in the domain)
  has some nonzero matrix entry.

* A functor preserves a biproduct if and only if it preserves
  the corresponding product if and only if it preserves the corresponding coproduct.
-/


open CategoryTheory

open CategoryTheory.Preadditive

open CategoryTheory.Limits

open CategoryTheory.Functor

open CategoryTheory.Preadditive

open Classical

open BigOperators

universe v v' u u'

noncomputable section

namespace CategoryTheory

variable {C : Type u} [Category.{v} C] [Preadditive C]

namespace Limits

variable {J : Type} [Fintype J]

#print CategoryTheory.Limits.isBilimitOfTotal /-
/-- In a preadditive category, we can construct a biproduct for `f : J ‚Üí C` from
any bicone `b` for `f` satisfying `total : ‚àë j : J, b.œÄ j ‚â´ b.Œπ j = ùüô b.X`.

(That is, such a bicone is a limit cone and a colimit cocone.)
-/
def isBilimitOfTotal {f : J ‚Üí C} (b : Bicone f) (total : (‚àë j : J, b.œÄ j ‚â´ b.Œπ j) = ùüô b.pt) :
    b.IsBilimit
    where
  IsLimit :=
    { lift := fun s => ‚àë j : J, s.œÄ.app ‚ü®j‚ü© ‚â´ b.Œπ j
      uniq := fun s m h => by
        erw [‚Üê category.comp_id m, ‚Üê Total, comp_sum]
        apply Finset.sum_congr rfl
        intro j m
        erw [reassoc_of (h ‚ü®j‚ü©)]
      fac := fun s j => by
        cases j
        simp only [sum_comp, category.assoc, bicone.to_cone_œÄ_app, b.Œπ_œÄ, comp_dite]
        -- See note [dsimp, simp].
        dsimp;
        simp }
  IsColimit :=
    { desc := fun s => ‚àë j : J, b.œÄ j ‚â´ s.Œπ.app ‚ü®j‚ü©
      uniq := fun s m h => by
        erw [‚Üê category.id_comp m, ‚Üê Total, sum_comp]
        apply Finset.sum_congr rfl
        intro j m
        erw [category.assoc, h ‚ü®j‚ü©]
      fac := fun s j => by
        cases j
        simp only [comp_sum, ‚Üê category.assoc, bicone.to_cocone_Œπ_app, b.Œπ_œÄ, dite_comp]
        dsimp; simp }
#align category_theory.limits.is_bilimit_of_total CategoryTheory.Limits.isBilimitOfTotal
-/

#print CategoryTheory.Limits.IsBilimit.total /-
theorem IsBilimit.total {f : J ‚Üí C} {b : Bicone f} (i : b.IsBilimit) :
    (‚àë j : J, b.œÄ j ‚â´ b.Œπ j) = ùüô b.pt :=
  i.IsLimit.hom_ext fun j => by
    cases j
    simp [sum_comp, b.Œπ_œÄ, comp_dite]
#align category_theory.limits.is_bilimit.total CategoryTheory.Limits.IsBilimit.total
-/

#print CategoryTheory.Limits.hasBiproduct_of_total /-
/-- In a preadditive category, we can construct a biproduct for `f : J ‚Üí C` from
any bicone `b` for `f` satisfying `total : ‚àë j : J, b.œÄ j ‚â´ b.Œπ j = ùüô b.X`.

(That is, such a bicone is a limit cone and a colimit cocone.)
-/
theorem hasBiproduct_of_total {f : J ‚Üí C} (b : Bicone f)
    (total : (‚àë j : J, b.œÄ j ‚â´ b.Œπ j) = ùüô b.pt) : HasBiproduct f :=
  HasBiproduct.mk
    { Bicone := b
      IsBilimit := isBilimitOfTotal b Total }
#align category_theory.limits.has_biproduct_of_total CategoryTheory.Limits.hasBiproduct_of_total
-/

#print CategoryTheory.Limits.isBilimitOfIsLimit /-
/-- In a preadditive category, any finite bicone which is a limit cone is in fact a bilimit
    bicone. -/
def isBilimitOfIsLimit {f : J ‚Üí C} (t : Bicone f) (ht : IsLimit t.toCone) : t.IsBilimit :=
  isBilimitOfTotal _ <|
    ht.hom_ext fun j => by
      cases j
      simp [sum_comp, t.Œπ_œÄ, dite_comp, comp_dite]
#align category_theory.limits.is_bilimit_of_is_limit CategoryTheory.Limits.isBilimitOfIsLimit
-/

#print CategoryTheory.Limits.biconeIsBilimitOfLimitConeOfIsLimit /-
/-- We can turn any limit cone over a pair into a bilimit bicone. -/
def biconeIsBilimitOfLimitConeOfIsLimit {f : J ‚Üí C} {t : Cone (Discrete.functor f)}
    (ht : IsLimit t) : (Bicone.ofLimitCone ht).IsBilimit :=
  isBilimitOfIsLimit _ <|
    IsLimit.ofIsoLimit ht <|
      Cones.ext (Iso.refl _)
        (by
          rintro ‚ü®j‚ü©
          tidy)
#align category_theory.limits.bicone_is_bilimit_of_limit_cone_of_is_limit CategoryTheory.Limits.biconeIsBilimitOfLimitConeOfIsLimit
-/

#print CategoryTheory.Limits.HasBiproduct.of_hasProduct /-
/-- In a preadditive category, if the product over `f : J ‚Üí C` exists,
    then the biproduct over `f` exists. -/
theorem HasBiproduct.of_hasProduct {J : Type} [Finite J] (f : J ‚Üí C) [HasProduct f] :
    HasBiproduct f := by
  cases nonempty_fintype J <;>
    exact
      has_biproduct.mk
        { Bicone := _
          IsBilimit := bicone_is_bilimit_of_limit_cone_of_is_limit (limit.is_limit _) }
#align category_theory.limits.has_biproduct.of_has_product CategoryTheory.Limits.HasBiproduct.of_hasProduct
-/

#print CategoryTheory.Limits.isBilimitOfIsColimit /-
/-- In a preadditive category, any finite bicone which is a colimit cocone is in fact a bilimit
    bicone. -/
def isBilimitOfIsColimit {f : J ‚Üí C} (t : Bicone f) (ht : IsColimit t.toCocone) : t.IsBilimit :=
  isBilimitOfTotal _ <|
    ht.hom_ext fun j => by
      cases j
      simp_rw [bicone.to_cocone_Œπ_app, comp_sum, ‚Üê category.assoc, t.Œπ_œÄ, dite_comp]
      tidy
#align category_theory.limits.is_bilimit_of_is_colimit CategoryTheory.Limits.isBilimitOfIsColimit
-/

#print CategoryTheory.Limits.biconeIsBilimitOfColimitCoconeOfIsColimit /-
/-- We can turn any limit cone over a pair into a bilimit bicone. -/
def biconeIsBilimitOfColimitCoconeOfIsColimit {f : J ‚Üí C} {t : Cocone (Discrete.functor f)}
    (ht : IsColimit t) : (Bicone.ofColimitCocone ht).IsBilimit :=
  isBilimitOfIsColimit _ <|
    IsColimit.ofIsoColimit ht <|
      Cocones.ext (Iso.refl _)
        (by
          rintro ‚ü®j‚ü©
          tidy)
#align category_theory.limits.bicone_is_bilimit_of_colimit_cocone_of_is_colimit CategoryTheory.Limits.biconeIsBilimitOfColimitCoconeOfIsColimit
-/

#print CategoryTheory.Limits.HasBiproduct.of_hasCoproduct /-
/-- In a preadditive category, if the coproduct over `f : J ‚Üí C` exists,
    then the biproduct over `f` exists. -/
theorem HasBiproduct.of_hasCoproduct {J : Type} [Finite J] (f : J ‚Üí C) [HasCoproduct f] :
    HasBiproduct f := by
  cases nonempty_fintype J <;>
    exact
      has_biproduct.mk
        { Bicone := _
          IsBilimit := bicone_is_bilimit_of_colimit_cocone_of_is_colimit (colimit.is_colimit _) }
#align category_theory.limits.has_biproduct.of_has_coproduct CategoryTheory.Limits.HasBiproduct.of_hasCoproduct
-/

#print CategoryTheory.Limits.HasFiniteBiproducts.of_hasFiniteProducts /-
/-- A preadditive category with finite products has finite biproducts. -/
theorem HasFiniteBiproducts.of_hasFiniteProducts [HasFiniteProducts C] : HasFiniteBiproducts C :=
  ‚ü®fun n => { HasBiproduct := fun F => HasBiproduct.of_hasProduct _ }‚ü©
#align category_theory.limits.has_finite_biproducts.of_has_finite_products CategoryTheory.Limits.HasFiniteBiproducts.of_hasFiniteProducts
-/

#print CategoryTheory.Limits.HasFiniteBiproducts.of_hasFiniteCoproducts /-
/-- A preadditive category with finite coproducts has finite biproducts. -/
theorem HasFiniteBiproducts.of_hasFiniteCoproducts [HasFiniteCoproducts C] :
    HasFiniteBiproducts C :=
  ‚ü®fun n => { HasBiproduct := fun F => HasBiproduct.of_hasCoproduct _ }‚ü©
#align category_theory.limits.has_finite_biproducts.of_has_finite_coproducts CategoryTheory.Limits.HasFiniteBiproducts.of_hasFiniteCoproducts
-/

section

variable {f : J ‚Üí C} [HasBiproduct f]

#print CategoryTheory.Limits.biproduct.total /-
/-- In any preadditive category, any biproduct satsifies
`‚àë j : J, biproduct.œÄ f j ‚â´ biproduct.Œπ f j = ùüô (‚®Å f)`
-/
@[simp]
theorem biproduct.total : (‚àë j : J, biproduct.œÄ f j ‚â´ biproduct.Œπ f j) = ùüô (‚®Å f) :=
  IsBilimit.total (biproduct.isBilimit _)
#align category_theory.limits.biproduct.total CategoryTheory.Limits.biproduct.total
-/

#print CategoryTheory.Limits.biproduct.lift_eq /-
theorem biproduct.lift_eq {T : C} {g : ‚àÄ j, T ‚ü∂ f j} :
    biproduct.lift g = ‚àë j, g j ‚â´ biproduct.Œπ f j :=
  by
  ext j
  simp only [sum_comp, biproduct.Œπ_œÄ, comp_dite, biproduct.lift_œÄ, category.assoc, comp_zero,
    Finset.sum_dite_eq', Finset.mem_univ, eq_to_hom_refl, category.comp_id, if_true]
#align category_theory.limits.biproduct.lift_eq CategoryTheory.Limits.biproduct.lift_eq
-/

#print CategoryTheory.Limits.biproduct.desc_eq /-
theorem biproduct.desc_eq {T : C} {g : ‚àÄ j, f j ‚ü∂ T} :
    biproduct.desc g = ‚àë j, biproduct.œÄ f j ‚â´ g j :=
  by
  ext j
  simp [comp_sum, biproduct.Œπ_œÄ_assoc, dite_comp]
#align category_theory.limits.biproduct.desc_eq CategoryTheory.Limits.biproduct.desc_eq
-/

#print CategoryTheory.Limits.biproduct.lift_desc /-
@[simp, reassoc.1]
theorem biproduct.lift_desc {T U : C} {g : ‚àÄ j, T ‚ü∂ f j} {h : ‚àÄ j, f j ‚ü∂ U} :
    biproduct.lift g ‚â´ biproduct.desc h = ‚àë j : J, g j ‚â´ h j := by
  simp [biproduct.lift_eq, biproduct.desc_eq, comp_sum, sum_comp, biproduct.Œπ_œÄ_assoc, comp_dite,
    dite_comp]
#align category_theory.limits.biproduct.lift_desc CategoryTheory.Limits.biproduct.lift_desc
-/

#print CategoryTheory.Limits.biproduct.map_eq /-
theorem biproduct.map_eq [HasFiniteBiproducts C] {f g : J ‚Üí C} {h : ‚àÄ j, f j ‚ü∂ g j} :
    biproduct.map h = ‚àë j : J, biproduct.œÄ f j ‚â´ h j ‚â´ biproduct.Œπ g j :=
  by
  ext
  simp [biproduct.Œπ_œÄ, biproduct.Œπ_œÄ_assoc, comp_sum, sum_comp, comp_dite, dite_comp]
#align category_theory.limits.biproduct.map_eq CategoryTheory.Limits.biproduct.map_eq
-/

#print CategoryTheory.Limits.biproduct.matrix_desc /-
@[simp, reassoc.1]
theorem biproduct.matrix_desc {K : Type} [Fintype K] [HasFiniteBiproducts C] {f : J ‚Üí C} {g : K ‚Üí C}
    (m : ‚àÄ j k, f j ‚ü∂ g k) {P} (x : ‚àÄ k, g k ‚ü∂ P) :
    biproduct.matrix m ‚â´ biproduct.desc x = biproduct.desc fun j => ‚àë k, m j k ‚â´ x k :=
  by
  ext
  simp
#align category_theory.limits.biproduct.matrix_desc CategoryTheory.Limits.biproduct.matrix_desc
-/

#print CategoryTheory.Limits.biproduct.lift_matrix /-
@[simp, reassoc.1]
theorem biproduct.lift_matrix {K : Type} [Fintype K] [HasFiniteBiproducts C] {f : J ‚Üí C} {g : K ‚Üí C}
    {P} (x : ‚àÄ j, P ‚ü∂ f j) (m : ‚àÄ j k, f j ‚ü∂ g k) :
    biproduct.lift x ‚â´ biproduct.matrix m = biproduct.lift fun k => ‚àë j, x j ‚â´ m j k :=
  by
  ext
  simp
#align category_theory.limits.biproduct.lift_matrix CategoryTheory.Limits.biproduct.lift_matrix
-/

#print CategoryTheory.Limits.biproduct.matrix_map /-
@[reassoc.1]
theorem biproduct.matrix_map {K : Type} [Fintype K] [HasFiniteBiproducts C] {f : J ‚Üí C} {g : K ‚Üí C}
    {h : K ‚Üí C} (m : ‚àÄ j k, f j ‚ü∂ g k) (n : ‚àÄ k, g k ‚ü∂ h k) :
    biproduct.matrix m ‚â´ biproduct.map n = biproduct.matrix fun j k => m j k ‚â´ n k :=
  by
  ext
  simp
#align category_theory.limits.biproduct.matrix_map CategoryTheory.Limits.biproduct.matrix_map
-/

#print CategoryTheory.Limits.biproduct.map_matrix /-
@[reassoc.1]
theorem biproduct.map_matrix {K : Type} [Fintype K] [HasFiniteBiproducts C] {f : J ‚Üí C} {g : J ‚Üí C}
    {h : K ‚Üí C} (m : ‚àÄ k, f k ‚ü∂ g k) (n : ‚àÄ j k, g j ‚ü∂ h k) :
    biproduct.map m ‚â´ biproduct.matrix n = biproduct.matrix fun j k => m j ‚â´ n j k :=
  by
  ext
  simp
#align category_theory.limits.biproduct.map_matrix CategoryTheory.Limits.biproduct.map_matrix
-/

end

#print CategoryTheory.Limits.biproduct.reindex /-
/-- Reindex a categorical biproduct via an equivalence of the index types. -/
@[simps]
def biproduct.reindex {Œ≤ Œ≥ : Type} [Fintype Œ≤] [DecidableEq Œ≤] [DecidableEq Œ≥] (Œµ : Œ≤ ‚âÉ Œ≥)
    (f : Œ≥ ‚Üí C) [HasBiproduct f] [HasBiproduct (f ‚àò Œµ)] : ‚®Å f ‚àò Œµ ‚âÖ ‚®Å f
    where
  hom := biproduct.desc fun b => biproduct.Œπ f (Œµ b)
  inv := biproduct.lift fun b => biproduct.œÄ f (Œµ b)
  hom_inv_id' := by
    ext (b b')
    by_cases h : b = b'
    ¬∑ subst h
      simp
    ¬∑ simp [h]
  inv_hom_id' := by
    ext (g g')
    by_cases h : g = g' <;>
      simp [preadditive.sum_comp, preadditive.comp_sum, biproduct.Œπ_œÄ, biproduct.Œπ_œÄ_assoc,
        comp_dite, Equiv.apply_eq_iff_eq_symm_apply, Finset.sum_dite_eq' Finset.univ (Œµ.symm g') _,
        h]
#align category_theory.limits.biproduct.reindex CategoryTheory.Limits.biproduct.reindex
-/

/- warning: category_theory.limits.is_binary_bilimit_of_total -> CategoryTheory.Limits.isBinaryBilimitOfTotal is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_2 : CategoryTheory.Preadditive.{u1, u2} C _inst_1] {X : C} {Y : C} (b : CategoryTheory.Limits.BinaryBicone.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y), (Eq.{succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.BinaryBicone.x.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b) (CategoryTheory.Limits.BinaryBicone.x.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b)) (HAdd.hAdd.{u1, u1, u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.BinaryBicone.x.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b) (CategoryTheory.Limits.BinaryBicone.x.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b)) (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.BinaryBicone.x.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b) (CategoryTheory.Limits.BinaryBicone.x.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b)) (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.BinaryBicone.x.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b) (CategoryTheory.Limits.BinaryBicone.x.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b)) (instHAdd.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.BinaryBicone.x.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b) (CategoryTheory.Limits.BinaryBicone.x.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b)) (AddZeroClass.toHasAdd.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.BinaryBicone.x.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b) (CategoryTheory.Limits.BinaryBicone.x.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b)) (AddMonoid.toAddZeroClass.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.BinaryBicone.x.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b) (CategoryTheory.Limits.BinaryBicone.x.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b)) (SubNegMonoid.toAddMonoid.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.BinaryBicone.x.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b) (CategoryTheory.Limits.BinaryBicone.x.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b)) (AddGroup.toSubNegMonoid.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.BinaryBicone.x.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b) (CategoryTheory.Limits.BinaryBicone.x.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b)) (AddCommGroup.toAddGroup.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.BinaryBicone.x.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b) (CategoryTheory.Limits.BinaryBicone.x.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b)) (CategoryTheory.Preadditive.homGroup.{u1, u2} C _inst_1 _inst_2 (CategoryTheory.Limits.BinaryBicone.x.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b) (CategoryTheory.Limits.BinaryBicone.x.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b)))))))) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) (CategoryTheory.Limits.BinaryBicone.x.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b) X (CategoryTheory.Limits.BinaryBicone.x.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b) (CategoryTheory.Limits.BinaryBicone.fst.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b) (CategoryTheory.Limits.BinaryBicone.inl.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b)) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) (CategoryTheory.Limits.BinaryBicone.x.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b) Y (CategoryTheory.Limits.BinaryBicone.x.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b) (CategoryTheory.Limits.BinaryBicone.snd.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b) (CategoryTheory.Limits.BinaryBicone.inr.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b))) (CategoryTheory.CategoryStruct.id.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) (CategoryTheory.Limits.BinaryBicone.x.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b))) -> (CategoryTheory.Limits.BinaryBicone.IsBilimit.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b)
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_2 : CategoryTheory.Preadditive.{u1, u2} C _inst_1] {X : C} {Y : C} (b : CategoryTheory.Limits.BinaryBicone.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y), (Eq.{succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.BinaryBicone.pt.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b) (CategoryTheory.Limits.BinaryBicone.pt.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b)) (HAdd.hAdd.{u1, u1, u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.BinaryBicone.pt.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b) (CategoryTheory.Limits.BinaryBicone.pt.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b)) (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.BinaryBicone.pt.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b) (CategoryTheory.Limits.BinaryBicone.pt.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b)) (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.BinaryBicone.pt.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b) (CategoryTheory.Limits.BinaryBicone.pt.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b)) (instHAdd.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.BinaryBicone.pt.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b) (CategoryTheory.Limits.BinaryBicone.pt.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b)) (AddZeroClass.toAdd.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.BinaryBicone.pt.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b) (CategoryTheory.Limits.BinaryBicone.pt.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b)) (AddMonoid.toAddZeroClass.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.BinaryBicone.pt.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b) (CategoryTheory.Limits.BinaryBicone.pt.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b)) (SubNegMonoid.toAddMonoid.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.BinaryBicone.pt.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b) (CategoryTheory.Limits.BinaryBicone.pt.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b)) (AddGroup.toSubNegMonoid.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.BinaryBicone.pt.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b) (CategoryTheory.Limits.BinaryBicone.pt.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b)) (AddCommGroup.toAddGroup.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.BinaryBicone.pt.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b) (CategoryTheory.Limits.BinaryBicone.pt.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b)) (CategoryTheory.Preadditive.homGroup.{u1, u2} C _inst_1 _inst_2 (CategoryTheory.Limits.BinaryBicone.pt.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b) (CategoryTheory.Limits.BinaryBicone.pt.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b)))))))) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) (CategoryTheory.Limits.BinaryBicone.pt.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b) X (CategoryTheory.Limits.BinaryBicone.pt.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b) (CategoryTheory.Limits.BinaryBicone.fst.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b) (CategoryTheory.Limits.BinaryBicone.inl.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b)) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) (CategoryTheory.Limits.BinaryBicone.pt.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b) Y (CategoryTheory.Limits.BinaryBicone.pt.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b) (CategoryTheory.Limits.BinaryBicone.snd.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b) (CategoryTheory.Limits.BinaryBicone.inr.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b))) (CategoryTheory.CategoryStruct.id.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) (CategoryTheory.Limits.BinaryBicone.pt.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b))) -> (CategoryTheory.Limits.BinaryBicone.IsBilimit.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b)
Case conversion may be inaccurate. Consider using '#align category_theory.limits.is_binary_bilimit_of_total CategoryTheory.Limits.isBinaryBilimitOfTotal‚Çì'. -/
/-- In a preadditive category, we can construct a binary biproduct for `X Y : C` from
any binary bicone `b` satisfying `total : b.fst ‚â´ b.inl + b.snd ‚â´ b.inr = ùüô b.X`.

(That is, such a bicone is a limit cone and a colimit cocone.)
-/
def isBinaryBilimitOfTotal {X Y : C} (b : BinaryBicone X Y)
    (total : b.fst ‚â´ b.inl + b.snd ‚â´ b.inr = ùüô b.pt) : b.IsBilimit
    where
  IsLimit :=
    { lift := fun s => BinaryFan.fst s ‚â´ b.inl + BinaryFan.snd s ‚â´ b.inr
      uniq := fun s m h => by
        erw [‚Üê category.comp_id m, ‚Üê Total, comp_add, reassoc_of (h ‚ü®walking_pair.left‚ü©),
          reassoc_of (h ‚ü®walking_pair.right‚ü©)]
      fac := fun s j => by rcases j with ‚ü®‚ü®‚ü©‚ü© <;> simp }
  IsColimit :=
    { desc := fun s => b.fst ‚â´ BinaryCofan.inl s + b.snd ‚â´ BinaryCofan.inr s
      uniq := fun s m h => by
        erw [‚Üê category.id_comp m, ‚Üê Total, add_comp, category.assoc, category.assoc,
          h ‚ü®walking_pair.left‚ü©, h ‚ü®walking_pair.right‚ü©]
      fac := fun s j => by rcases j with ‚ü®‚ü®‚ü©‚ü© <;> simp }
#align category_theory.limits.is_binary_bilimit_of_total CategoryTheory.Limits.isBinaryBilimitOfTotal

/- warning: category_theory.limits.is_bilimit.binary_total -> CategoryTheory.Limits.IsBilimit.binary_total is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_2 : CategoryTheory.Preadditive.{u1, u2} C _inst_1] {X : C} {Y : C} {b : CategoryTheory.Limits.BinaryBicone.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y}, (CategoryTheory.Limits.BinaryBicone.IsBilimit.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b) -> (Eq.{succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.BinaryBicone.x.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b) (CategoryTheory.Limits.BinaryBicone.x.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b)) (HAdd.hAdd.{u1, u1, u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.BinaryBicone.x.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b) (CategoryTheory.Limits.BinaryBicone.x.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b)) (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.BinaryBicone.x.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b) (CategoryTheory.Limits.BinaryBicone.x.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b)) (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.BinaryBicone.x.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b) (CategoryTheory.Limits.BinaryBicone.x.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b)) (instHAdd.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.BinaryBicone.x.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b) (CategoryTheory.Limits.BinaryBicone.x.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b)) (AddZeroClass.toHasAdd.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.BinaryBicone.x.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b) (CategoryTheory.Limits.BinaryBicone.x.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b)) (AddMonoid.toAddZeroClass.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.BinaryBicone.x.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b) (CategoryTheory.Limits.BinaryBicone.x.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b)) (SubNegMonoid.toAddMonoid.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.BinaryBicone.x.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b) (CategoryTheory.Limits.BinaryBicone.x.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b)) (AddGroup.toSubNegMonoid.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.BinaryBicone.x.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b) (CategoryTheory.Limits.BinaryBicone.x.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b)) (AddCommGroup.toAddGroup.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.BinaryBicone.x.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b) (CategoryTheory.Limits.BinaryBicone.x.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b)) (CategoryTheory.Preadditive.homGroup.{u1, u2} C _inst_1 _inst_2 (CategoryTheory.Limits.BinaryBicone.x.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b) (CategoryTheory.Limits.BinaryBicone.x.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b)))))))) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) (CategoryTheory.Limits.BinaryBicone.x.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b) X (CategoryTheory.Limits.BinaryBicone.x.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b) (CategoryTheory.Limits.BinaryBicone.fst.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b) (CategoryTheory.Limits.BinaryBicone.inl.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b)) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) (CategoryTheory.Limits.BinaryBicone.x.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b) Y (CategoryTheory.Limits.BinaryBicone.x.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b) (CategoryTheory.Limits.BinaryBicone.snd.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b) (CategoryTheory.Limits.BinaryBicone.inr.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b))) (CategoryTheory.CategoryStruct.id.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) (CategoryTheory.Limits.BinaryBicone.x.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b)))
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_2 : CategoryTheory.Preadditive.{u1, u2} C _inst_1] {X : C} {Y : C} {b : CategoryTheory.Limits.BinaryBicone.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y}, (CategoryTheory.Limits.BinaryBicone.IsBilimit.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b) -> (Eq.{succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.BinaryBicone.pt.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b) (CategoryTheory.Limits.BinaryBicone.pt.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b)) (HAdd.hAdd.{u1, u1, u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.BinaryBicone.pt.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b) (CategoryTheory.Limits.BinaryBicone.pt.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b)) (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.BinaryBicone.pt.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b) (CategoryTheory.Limits.BinaryBicone.pt.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b)) (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.BinaryBicone.pt.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b) (CategoryTheory.Limits.BinaryBicone.pt.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b)) (instHAdd.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.BinaryBicone.pt.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b) (CategoryTheory.Limits.BinaryBicone.pt.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b)) (AddZeroClass.toAdd.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.BinaryBicone.pt.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b) (CategoryTheory.Limits.BinaryBicone.pt.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b)) (AddMonoid.toAddZeroClass.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.BinaryBicone.pt.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b) (CategoryTheory.Limits.BinaryBicone.pt.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b)) (SubNegMonoid.toAddMonoid.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.BinaryBicone.pt.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b) (CategoryTheory.Limits.BinaryBicone.pt.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b)) (AddGroup.toSubNegMonoid.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.BinaryBicone.pt.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b) (CategoryTheory.Limits.BinaryBicone.pt.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b)) (AddCommGroup.toAddGroup.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.BinaryBicone.pt.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b) (CategoryTheory.Limits.BinaryBicone.pt.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b)) (CategoryTheory.Preadditive.homGroup.{u1, u2} C _inst_1 _inst_2 (CategoryTheory.Limits.BinaryBicone.pt.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b) (CategoryTheory.Limits.BinaryBicone.pt.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b)))))))) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) (CategoryTheory.Limits.BinaryBicone.pt.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b) X (CategoryTheory.Limits.BinaryBicone.pt.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b) (CategoryTheory.Limits.BinaryBicone.fst.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b) (CategoryTheory.Limits.BinaryBicone.inl.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b)) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) (CategoryTheory.Limits.BinaryBicone.pt.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b) Y (CategoryTheory.Limits.BinaryBicone.pt.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b) (CategoryTheory.Limits.BinaryBicone.snd.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b) (CategoryTheory.Limits.BinaryBicone.inr.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b))) (CategoryTheory.CategoryStruct.id.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) (CategoryTheory.Limits.BinaryBicone.pt.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b)))
Case conversion may be inaccurate. Consider using '#align category_theory.limits.is_bilimit.binary_total CategoryTheory.Limits.IsBilimit.binary_total‚Çì'. -/
theorem IsBilimit.binary_total {X Y : C} {b : BinaryBicone X Y} (i : b.IsBilimit) :
    b.fst ‚â´ b.inl + b.snd ‚â´ b.inr = ùüô b.pt :=
  i.IsLimit.hom_ext fun j => by rcases j with ‚ü®‚ü®‚ü©‚ü© <;> simp
#align category_theory.limits.is_bilimit.binary_total CategoryTheory.Limits.IsBilimit.binary_total

/- warning: category_theory.limits.has_binary_biproduct_of_total -> CategoryTheory.Limits.hasBinaryBiproduct_of_total is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_2 : CategoryTheory.Preadditive.{u1, u2} C _inst_1] {X : C} {Y : C} (b : CategoryTheory.Limits.BinaryBicone.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y), (Eq.{succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.BinaryBicone.x.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b) (CategoryTheory.Limits.BinaryBicone.x.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b)) (HAdd.hAdd.{u1, u1, u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.BinaryBicone.x.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b) (CategoryTheory.Limits.BinaryBicone.x.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b)) (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.BinaryBicone.x.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b) (CategoryTheory.Limits.BinaryBicone.x.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b)) (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.BinaryBicone.x.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b) (CategoryTheory.Limits.BinaryBicone.x.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b)) (instHAdd.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.BinaryBicone.x.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b) (CategoryTheory.Limits.BinaryBicone.x.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b)) (AddZeroClass.toHasAdd.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.BinaryBicone.x.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b) (CategoryTheory.Limits.BinaryBicone.x.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b)) (AddMonoid.toAddZeroClass.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.BinaryBicone.x.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b) (CategoryTheory.Limits.BinaryBicone.x.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b)) (SubNegMonoid.toAddMonoid.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.BinaryBicone.x.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b) (CategoryTheory.Limits.BinaryBicone.x.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b)) (AddGroup.toSubNegMonoid.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.BinaryBicone.x.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b) (CategoryTheory.Limits.BinaryBicone.x.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b)) (AddCommGroup.toAddGroup.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.BinaryBicone.x.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b) (CategoryTheory.Limits.BinaryBicone.x.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b)) (CategoryTheory.Preadditive.homGroup.{u1, u2} C _inst_1 _inst_2 (CategoryTheory.Limits.BinaryBicone.x.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b) (CategoryTheory.Limits.BinaryBicone.x.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b)))))))) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) (CategoryTheory.Limits.BinaryBicone.x.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b) X (CategoryTheory.Limits.BinaryBicone.x.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b) (CategoryTheory.Limits.BinaryBicone.fst.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b) (CategoryTheory.Limits.BinaryBicone.inl.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b)) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) (CategoryTheory.Limits.BinaryBicone.x.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b) Y (CategoryTheory.Limits.BinaryBicone.x.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b) (CategoryTheory.Limits.BinaryBicone.snd.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b) (CategoryTheory.Limits.BinaryBicone.inr.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b))) (CategoryTheory.CategoryStruct.id.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) (CategoryTheory.Limits.BinaryBicone.x.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b))) -> (CategoryTheory.Limits.HasBinaryBiproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y)
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_2 : CategoryTheory.Preadditive.{u1, u2} C _inst_1] {X : C} {Y : C} (b : CategoryTheory.Limits.BinaryBicone.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y), (Eq.{succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.BinaryBicone.pt.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b) (CategoryTheory.Limits.BinaryBicone.pt.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b)) (HAdd.hAdd.{u1, u1, u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.BinaryBicone.pt.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b) (CategoryTheory.Limits.BinaryBicone.pt.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b)) (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.BinaryBicone.pt.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b) (CategoryTheory.Limits.BinaryBicone.pt.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b)) (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.BinaryBicone.pt.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b) (CategoryTheory.Limits.BinaryBicone.pt.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b)) (instHAdd.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.BinaryBicone.pt.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b) (CategoryTheory.Limits.BinaryBicone.pt.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b)) (AddZeroClass.toAdd.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.BinaryBicone.pt.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b) (CategoryTheory.Limits.BinaryBicone.pt.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b)) (AddMonoid.toAddZeroClass.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.BinaryBicone.pt.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b) (CategoryTheory.Limits.BinaryBicone.pt.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b)) (SubNegMonoid.toAddMonoid.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.BinaryBicone.pt.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b) (CategoryTheory.Limits.BinaryBicone.pt.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b)) (AddGroup.toSubNegMonoid.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.BinaryBicone.pt.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b) (CategoryTheory.Limits.BinaryBicone.pt.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b)) (AddCommGroup.toAddGroup.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.BinaryBicone.pt.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b) (CategoryTheory.Limits.BinaryBicone.pt.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b)) (CategoryTheory.Preadditive.homGroup.{u1, u2} C _inst_1 _inst_2 (CategoryTheory.Limits.BinaryBicone.pt.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b) (CategoryTheory.Limits.BinaryBicone.pt.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b)))))))) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) (CategoryTheory.Limits.BinaryBicone.pt.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b) X (CategoryTheory.Limits.BinaryBicone.pt.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b) (CategoryTheory.Limits.BinaryBicone.fst.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b) (CategoryTheory.Limits.BinaryBicone.inl.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b)) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) (CategoryTheory.Limits.BinaryBicone.pt.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b) Y (CategoryTheory.Limits.BinaryBicone.pt.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b) (CategoryTheory.Limits.BinaryBicone.snd.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b) (CategoryTheory.Limits.BinaryBicone.inr.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b))) (CategoryTheory.CategoryStruct.id.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) (CategoryTheory.Limits.BinaryBicone.pt.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y b))) -> (CategoryTheory.Limits.HasBinaryBiproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y)
Case conversion may be inaccurate. Consider using '#align category_theory.limits.has_binary_biproduct_of_total CategoryTheory.Limits.hasBinaryBiproduct_of_total‚Çì'. -/
/-- In a preadditive category, we can construct a binary biproduct for `X Y : C` from
any binary bicone `b` satisfying `total : b.fst ‚â´ b.inl + b.snd ‚â´ b.inr = ùüô b.X`.

(That is, such a bicone is a limit cone and a colimit cocone.)
-/
theorem hasBinaryBiproduct_of_total {X Y : C} (b : BinaryBicone X Y)
    (total : b.fst ‚â´ b.inl + b.snd ‚â´ b.inr = ùüô b.pt) : HasBinaryBiproduct X Y :=
  HasBinaryBiproduct.mk
    { Bicone := b
      IsBilimit := isBinaryBilimitOfTotal b Total }
#align category_theory.limits.has_binary_biproduct_of_total CategoryTheory.Limits.hasBinaryBiproduct_of_total

#print CategoryTheory.Limits.BinaryBicone.ofLimitCone /-
/-- We can turn any limit cone over a pair into a bicone. -/
@[simps]
def BinaryBicone.ofLimitCone {X Y : C} {t : Cone (pair X Y)} (ht : IsLimit t) : BinaryBicone X Y
    where
  pt := t.pt
  fst := t.œÄ.app ‚ü®WalkingPair.left‚ü©
  snd := t.œÄ.app ‚ü®WalkingPair.right‚ü©
  inl := ht.lift (BinaryFan.mk (ùüô X) 0)
  inr := ht.lift (BinaryFan.mk 0 (ùüô Y))
#align category_theory.limits.binary_bicone.of_limit_cone CategoryTheory.Limits.BinaryBicone.ofLimitCone
-/

#print CategoryTheory.Limits.inl_of_isLimit /-
theorem inl_of_isLimit {X Y : C} {t : BinaryBicone X Y} (ht : IsLimit t.toCone) :
    t.inl = ht.lift (BinaryFan.mk (ùüô X) 0) := by
  apply ht.uniq (binary_fan.mk (ùüô X) 0) <;> rintro ‚ü®‚ü®‚ü©‚ü© <;> dsimp <;> simp
#align category_theory.limits.inl_of_is_limit CategoryTheory.Limits.inl_of_isLimit
-/

#print CategoryTheory.Limits.inr_of_isLimit /-
theorem inr_of_isLimit {X Y : C} {t : BinaryBicone X Y} (ht : IsLimit t.toCone) :
    t.inr = ht.lift (BinaryFan.mk 0 (ùüô Y)) := by
  apply ht.uniq (binary_fan.mk 0 (ùüô Y)) <;> rintro ‚ü®‚ü®‚ü©‚ü© <;> dsimp <;> simp
#align category_theory.limits.inr_of_is_limit CategoryTheory.Limits.inr_of_isLimit
-/

#print CategoryTheory.Limits.isBinaryBilimitOfIsLimit /-
/-- In a preadditive category, any binary bicone which is a limit cone is in fact a bilimit
    bicone. -/
def isBinaryBilimitOfIsLimit {X Y : C} (t : BinaryBicone X Y) (ht : IsLimit t.toCone) :
    t.IsBilimit :=
  isBinaryBilimitOfTotal _ (by refine' binary_fan.is_limit.hom_ext ht _ _ <;> simp)
#align category_theory.limits.is_binary_bilimit_of_is_limit CategoryTheory.Limits.isBinaryBilimitOfIsLimit
-/

#print CategoryTheory.Limits.binaryBiconeIsBilimitOfLimitConeOfIsLimit /-
/-- We can turn any limit cone over a pair into a bilimit bicone. -/
def binaryBiconeIsBilimitOfLimitConeOfIsLimit {X Y : C} {t : Cone (pair X Y)} (ht : IsLimit t) :
    (BinaryBicone.ofLimitCone ht).IsBilimit :=
  isBinaryBilimitOfTotal _ <| BinaryFan.IsLimit.hom_ext ht (by simp) (by simp)
#align category_theory.limits.binary_bicone_is_bilimit_of_limit_cone_of_is_limit CategoryTheory.Limits.binaryBiconeIsBilimitOfLimitConeOfIsLimit
-/

#print CategoryTheory.Limits.HasBinaryBiproduct.of_hasBinaryProduct /-
/-- In a preadditive category, if the product of `X` and `Y` exists, then the
    binary biproduct of `X` and `Y` exists. -/
theorem HasBinaryBiproduct.of_hasBinaryProduct (X Y : C) [HasBinaryProduct X Y] :
    HasBinaryBiproduct X Y :=
  HasBinaryBiproduct.mk
    { Bicone := _
      IsBilimit := binaryBiconeIsBilimitOfLimitConeOfIsLimit (limit.isLimit _) }
#align category_theory.limits.has_binary_biproduct.of_has_binary_product CategoryTheory.Limits.HasBinaryBiproduct.of_hasBinaryProduct
-/

#print CategoryTheory.Limits.HasBinaryBiproducts.of_hasBinaryProducts /-
/-- In a preadditive category, if all binary products exist, then all binary biproducts exist. -/
theorem HasBinaryBiproducts.of_hasBinaryProducts [HasBinaryProducts C] : HasBinaryBiproducts C :=
  { HasBinaryBiproduct := fun X Y => HasBinaryBiproduct.of_hasBinaryProduct X Y }
#align category_theory.limits.has_binary_biproducts.of_has_binary_products CategoryTheory.Limits.HasBinaryBiproducts.of_hasBinaryProducts
-/

#print CategoryTheory.Limits.BinaryBicone.ofColimitCocone /-
/-- We can turn any colimit cocone over a pair into a bicone. -/
@[simps]
def BinaryBicone.ofColimitCocone {X Y : C} {t : Cocone (pair X Y)} (ht : IsColimit t) :
    BinaryBicone X Y where
  pt := t.pt
  fst := ht.desc (BinaryCofan.mk (ùüô X) 0)
  snd := ht.desc (BinaryCofan.mk 0 (ùüô Y))
  inl := t.Œπ.app ‚ü®WalkingPair.left‚ü©
  inr := t.Œπ.app ‚ü®WalkingPair.right‚ü©
#align category_theory.limits.binary_bicone.of_colimit_cocone CategoryTheory.Limits.BinaryBicone.ofColimitCocone
-/

#print CategoryTheory.Limits.fst_of_isColimit /-
theorem fst_of_isColimit {X Y : C} {t : BinaryBicone X Y} (ht : IsColimit t.toCocone) :
    t.fst = ht.desc (BinaryCofan.mk (ùüô X) 0) :=
  by
  apply ht.uniq (binary_cofan.mk (ùüô X) 0)
  rintro ‚ü®‚ü®‚ü©‚ü© <;> dsimp <;> simp
#align category_theory.limits.fst_of_is_colimit CategoryTheory.Limits.fst_of_isColimit
-/

#print CategoryTheory.Limits.snd_of_isColimit /-
theorem snd_of_isColimit {X Y : C} {t : BinaryBicone X Y} (ht : IsColimit t.toCocone) :
    t.snd = ht.desc (BinaryCofan.mk 0 (ùüô Y)) :=
  by
  apply ht.uniq (binary_cofan.mk 0 (ùüô Y))
  rintro ‚ü®‚ü®‚ü©‚ü© <;> dsimp <;> simp
#align category_theory.limits.snd_of_is_colimit CategoryTheory.Limits.snd_of_isColimit
-/

#print CategoryTheory.Limits.isBinaryBilimitOfIsColimit /-
/-- In a preadditive category, any binary bicone which is a colimit cocone is in fact a
    bilimit bicone. -/
def isBinaryBilimitOfIsColimit {X Y : C} (t : BinaryBicone X Y) (ht : IsColimit t.toCocone) :
    t.IsBilimit :=
  isBinaryBilimitOfTotal _
    (by
      refine' binary_cofan.is_colimit.hom_ext ht _ _ <;> simp
      ¬∑ rw [category.comp_id t.inl]
      ¬∑ rw [category.comp_id t.inr])
#align category_theory.limits.is_binary_bilimit_of_is_colimit CategoryTheory.Limits.isBinaryBilimitOfIsColimit
-/

#print CategoryTheory.Limits.binaryBiconeIsBilimitOfColimitCoconeOfIsColimit /-
/-- We can turn any colimit cocone over a pair into a bilimit bicone. -/
def binaryBiconeIsBilimitOfColimitCoconeOfIsColimit {X Y : C} {t : Cocone (pair X Y)}
    (ht : IsColimit t) : (BinaryBicone.ofColimitCocone ht).IsBilimit :=
  isBinaryBilimitOfIsColimit (BinaryBicone.ofColimitCocone ht) <|
    IsColimit.ofIsoColimit ht <|
      Cocones.ext (Iso.refl _) fun j => by
        rcases j with ‚ü®‚ü®‚ü©‚ü©
        tidy
#align category_theory.limits.binary_bicone_is_bilimit_of_colimit_cocone_of_is_colimit CategoryTheory.Limits.binaryBiconeIsBilimitOfColimitCoconeOfIsColimit
-/

#print CategoryTheory.Limits.HasBinaryBiproduct.of_hasBinaryCoproduct /-
/-- In a preadditive category, if the coproduct of `X` and `Y` exists, then the
    binary biproduct of `X` and `Y` exists. -/
theorem HasBinaryBiproduct.of_hasBinaryCoproduct (X Y : C) [HasBinaryCoproduct X Y] :
    HasBinaryBiproduct X Y :=
  HasBinaryBiproduct.mk
    { Bicone := _
      IsBilimit := binaryBiconeIsBilimitOfColimitCoconeOfIsColimit (colimit.isColimit _) }
#align category_theory.limits.has_binary_biproduct.of_has_binary_coproduct CategoryTheory.Limits.HasBinaryBiproduct.of_hasBinaryCoproduct
-/

#print CategoryTheory.Limits.HasBinaryBiproducts.of_hasBinaryCoproducts /-
/-- In a preadditive category, if all binary coproducts exist, then all binary biproducts exist. -/
theorem HasBinaryBiproducts.of_hasBinaryCoproducts [HasBinaryCoproducts C] :
    HasBinaryBiproducts C :=
  { HasBinaryBiproduct := fun X Y => HasBinaryBiproduct.of_hasBinaryCoproduct X Y }
#align category_theory.limits.has_binary_biproducts.of_has_binary_coproducts CategoryTheory.Limits.HasBinaryBiproducts.of_hasBinaryCoproducts
-/

section

variable {X Y : C} [HasBinaryBiproduct X Y]

/- warning: category_theory.limits.biprod.total -> CategoryTheory.Limits.biprod.total is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_2 : CategoryTheory.Preadditive.{u1, u2} C _inst_1] {X : C} {Y : C} [_inst_4 : CategoryTheory.Limits.HasBinaryBiproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y], Eq.{succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y _inst_4) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y _inst_4)) (HAdd.hAdd.{u1, u1, u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y _inst_4) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y _inst_4)) (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y _inst_4) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y _inst_4)) (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y _inst_4) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y _inst_4)) (instHAdd.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y _inst_4) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y _inst_4)) (AddZeroClass.toHasAdd.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y _inst_4) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y _inst_4)) (AddMonoid.toAddZeroClass.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y _inst_4) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y _inst_4)) (SubNegMonoid.toAddMonoid.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y _inst_4) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y _inst_4)) (AddGroup.toSubNegMonoid.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y _inst_4) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y _inst_4)) (AddCommGroup.toAddGroup.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y _inst_4) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y _inst_4)) (CategoryTheory.Preadditive.homGroup.{u1, u2} C _inst_1 _inst_2 (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y _inst_4) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y _inst_4)))))))) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y _inst_4) X (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y _inst_4) (CategoryTheory.Limits.biprod.fst.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y _inst_4) (CategoryTheory.Limits.biprod.inl.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y _inst_4)) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y _inst_4) Y (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y _inst_4) (CategoryTheory.Limits.biprod.snd.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y _inst_4) (CategoryTheory.Limits.biprod.inr.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y _inst_4))) (CategoryTheory.CategoryStruct.id.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y _inst_4))
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_2 : CategoryTheory.Preadditive.{u1, u2} C _inst_1] {X : C} {Y : C} [_inst_4 : CategoryTheory.Limits.HasBinaryBiproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y], Eq.{succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y _inst_4) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y _inst_4)) (HAdd.hAdd.{u1, u1, u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y _inst_4) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y _inst_4)) (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y _inst_4) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y _inst_4)) (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y _inst_4) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y _inst_4)) (instHAdd.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y _inst_4) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y _inst_4)) (AddZeroClass.toAdd.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y _inst_4) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y _inst_4)) (AddMonoid.toAddZeroClass.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y _inst_4) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y _inst_4)) (SubNegMonoid.toAddMonoid.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y _inst_4) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y _inst_4)) (AddGroup.toSubNegMonoid.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y _inst_4) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y _inst_4)) (AddCommGroup.toAddGroup.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y _inst_4) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y _inst_4)) (CategoryTheory.Preadditive.homGroup.{u1, u2} C _inst_1 _inst_2 (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y _inst_4) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y _inst_4)))))))) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y _inst_4) X (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y _inst_4) (CategoryTheory.Limits.biprod.fst.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y _inst_4) (CategoryTheory.Limits.biprod.inl.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y _inst_4)) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y _inst_4) Y (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y _inst_4) (CategoryTheory.Limits.biprod.snd.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y _inst_4) (CategoryTheory.Limits.biprod.inr.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y _inst_4))) (CategoryTheory.CategoryStruct.id.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y _inst_4))
Case conversion may be inaccurate. Consider using '#align category_theory.limits.biprod.total CategoryTheory.Limits.biprod.total‚Çì'. -/
/-- In any preadditive category, any binary biproduct satsifies
`biprod.fst ‚â´ biprod.inl + biprod.snd ‚â´ biprod.inr = ùüô (X ‚äû Y)`.
-/
@[simp]
theorem biprod.total : biprod.fst ‚â´ biprod.inl + biprod.snd ‚â´ biprod.inr = ùüô (X ‚äû Y) := by
  ext <;> simp [add_comp]
#align category_theory.limits.biprod.total CategoryTheory.Limits.biprod.total

/- warning: category_theory.limits.biprod.lift_eq -> CategoryTheory.Limits.biprod.lift_eq is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_2 : CategoryTheory.Preadditive.{u1, u2} C _inst_1] {X : C} {Y : C} [_inst_4 : CategoryTheory.Limits.HasBinaryBiproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y] {T : C} {f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) T X} {g : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) T Y}, Eq.{succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) T (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y _inst_4)) (CategoryTheory.Limits.biprod.lift.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) T X Y _inst_4 f g) (HAdd.hAdd.{u1, u1, u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) T (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y _inst_4)) (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) T (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y _inst_4)) (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) T (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y _inst_4)) (instHAdd.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) T (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y _inst_4)) (AddZeroClass.toHasAdd.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) T (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y _inst_4)) (AddMonoid.toAddZeroClass.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) T (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y _inst_4)) (SubNegMonoid.toAddMonoid.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) T (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y _inst_4)) (AddGroup.toSubNegMonoid.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) T (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y _inst_4)) (AddCommGroup.toAddGroup.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) T (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y _inst_4)) (CategoryTheory.Preadditive.homGroup.{u1, u2} C _inst_1 _inst_2 T (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y _inst_4)))))))) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) T X (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y _inst_4) f (CategoryTheory.Limits.biprod.inl.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y _inst_4)) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) T Y (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y _inst_4) g (CategoryTheory.Limits.biprod.inr.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y _inst_4)))
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_2 : CategoryTheory.Preadditive.{u1, u2} C _inst_1] {X : C} {Y : C} [_inst_4 : CategoryTheory.Limits.HasBinaryBiproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y] {T : C} {f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) T X} {g : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) T Y}, Eq.{succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) T (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y _inst_4)) (CategoryTheory.Limits.biprod.lift.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) T X Y _inst_4 f g) (HAdd.hAdd.{u1, u1, u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) T (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y _inst_4)) (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) T (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y _inst_4)) (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) T (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y _inst_4)) (instHAdd.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) T (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y _inst_4)) (AddZeroClass.toAdd.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) T (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y _inst_4)) (AddMonoid.toAddZeroClass.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) T (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y _inst_4)) (SubNegMonoid.toAddMonoid.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) T (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y _inst_4)) (AddGroup.toSubNegMonoid.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) T (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y _inst_4)) (AddCommGroup.toAddGroup.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) T (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y _inst_4)) (CategoryTheory.Preadditive.homGroup.{u1, u2} C _inst_1 _inst_2 T (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y _inst_4)))))))) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) T X (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y _inst_4) f (CategoryTheory.Limits.biprod.inl.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y _inst_4)) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) T Y (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y _inst_4) g (CategoryTheory.Limits.biprod.inr.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y _inst_4)))
Case conversion may be inaccurate. Consider using '#align category_theory.limits.biprod.lift_eq CategoryTheory.Limits.biprod.lift_eq‚Çì'. -/
theorem biprod.lift_eq {T : C} {f : T ‚ü∂ X} {g : T ‚ü∂ Y} :
    biprod.lift f g = f ‚â´ biprod.inl + g ‚â´ biprod.inr := by ext <;> simp [add_comp]
#align category_theory.limits.biprod.lift_eq CategoryTheory.Limits.biprod.lift_eq

/- warning: category_theory.limits.biprod.desc_eq -> CategoryTheory.Limits.biprod.desc_eq is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_2 : CategoryTheory.Preadditive.{u1, u2} C _inst_1] {X : C} {Y : C} [_inst_4 : CategoryTheory.Limits.HasBinaryBiproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y] {T : C} {f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X T} {g : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) Y T}, Eq.{succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y _inst_4) T) (CategoryTheory.Limits.biprod.desc.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) T X Y _inst_4 f g) (HAdd.hAdd.{u1, u1, u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y _inst_4) T) (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y _inst_4) T) (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y _inst_4) T) (instHAdd.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y _inst_4) T) (AddZeroClass.toHasAdd.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y _inst_4) T) (AddMonoid.toAddZeroClass.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y _inst_4) T) (SubNegMonoid.toAddMonoid.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y _inst_4) T) (AddGroup.toSubNegMonoid.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y _inst_4) T) (AddCommGroup.toAddGroup.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y _inst_4) T) (CategoryTheory.Preadditive.homGroup.{u1, u2} C _inst_1 _inst_2 (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y _inst_4) T))))))) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y _inst_4) X T (CategoryTheory.Limits.biprod.fst.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y _inst_4) f) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y _inst_4) Y T (CategoryTheory.Limits.biprod.snd.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y _inst_4) g))
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_2 : CategoryTheory.Preadditive.{u1, u2} C _inst_1] {X : C} {Y : C} [_inst_4 : CategoryTheory.Limits.HasBinaryBiproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y] {T : C} {f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X T} {g : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) Y T}, Eq.{succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y _inst_4) T) (CategoryTheory.Limits.biprod.desc.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) T X Y _inst_4 f g) (HAdd.hAdd.{u1, u1, u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y _inst_4) T) (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y _inst_4) T) (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y _inst_4) T) (instHAdd.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y _inst_4) T) (AddZeroClass.toAdd.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y _inst_4) T) (AddMonoid.toAddZeroClass.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y _inst_4) T) (SubNegMonoid.toAddMonoid.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y _inst_4) T) (AddGroup.toSubNegMonoid.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y _inst_4) T) (AddCommGroup.toAddGroup.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y _inst_4) T) (CategoryTheory.Preadditive.homGroup.{u1, u2} C _inst_1 _inst_2 (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y _inst_4) T))))))) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y _inst_4) X T (CategoryTheory.Limits.biprod.fst.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y _inst_4) f) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y _inst_4) Y T (CategoryTheory.Limits.biprod.snd.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y _inst_4) g))
Case conversion may be inaccurate. Consider using '#align category_theory.limits.biprod.desc_eq CategoryTheory.Limits.biprod.desc_eq‚Çì'. -/
theorem biprod.desc_eq {T : C} {f : X ‚ü∂ T} {g : Y ‚ü∂ T} :
    biprod.desc f g = biprod.fst ‚â´ f + biprod.snd ‚â´ g := by ext <;> simp [add_comp]
#align category_theory.limits.biprod.desc_eq CategoryTheory.Limits.biprod.desc_eq

/- warning: category_theory.limits.biprod.lift_desc -> CategoryTheory.Limits.biprod.lift_desc is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_2 : CategoryTheory.Preadditive.{u1, u2} C _inst_1] {X : C} {Y : C} [_inst_4 : CategoryTheory.Limits.HasBinaryBiproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y] {T : C} {U : C} {f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) T X} {g : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) T Y} {h : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X U} {i : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) Y U}, Eq.{succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) T U) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) T (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y _inst_4) U (CategoryTheory.Limits.biprod.lift.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) T X Y _inst_4 f g) (CategoryTheory.Limits.biprod.desc.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) U X Y _inst_4 h i)) (HAdd.hAdd.{u1, u1, u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) T U) (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) T U) (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) T U) (instHAdd.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) T U) (AddZeroClass.toHasAdd.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) T U) (AddMonoid.toAddZeroClass.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) T U) (SubNegMonoid.toAddMonoid.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) T U) (AddGroup.toSubNegMonoid.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) T U) (AddCommGroup.toAddGroup.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) T U) (CategoryTheory.Preadditive.homGroup.{u1, u2} C _inst_1 _inst_2 T U))))))) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) T X U f h) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) T Y U g i))
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_2 : CategoryTheory.Preadditive.{u1, u2} C _inst_1] {X : C} {Y : C} [_inst_4 : CategoryTheory.Limits.HasBinaryBiproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y] {T : C} {U : C} {f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) T X} {g : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) T Y} {h : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X U} {i : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) Y U}, Eq.{succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) T U) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) T (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y _inst_4) U (CategoryTheory.Limits.biprod.lift.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) T X Y _inst_4 f g) (CategoryTheory.Limits.biprod.desc.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) U X Y _inst_4 h i)) (HAdd.hAdd.{u1, u1, u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) T U) (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) T U) (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) T U) (instHAdd.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) T U) (AddZeroClass.toAdd.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) T U) (AddMonoid.toAddZeroClass.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) T U) (SubNegMonoid.toAddMonoid.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) T U) (AddGroup.toSubNegMonoid.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) T U) (AddCommGroup.toAddGroup.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) T U) (CategoryTheory.Preadditive.homGroup.{u1, u2} C _inst_1 _inst_2 T U))))))) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) T X U f h) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) T Y U g i))
Case conversion may be inaccurate. Consider using '#align category_theory.limits.biprod.lift_desc CategoryTheory.Limits.biprod.lift_desc‚Çì'. -/
@[simp, reassoc.1]
theorem biprod.lift_desc {T U : C} {f : T ‚ü∂ X} {g : T ‚ü∂ Y} {h : X ‚ü∂ U} {i : Y ‚ü∂ U} :
    biprod.lift f g ‚â´ biprod.desc h i = f ‚â´ h + g ‚â´ i := by simp [biprod.lift_eq, biprod.desc_eq]
#align category_theory.limits.biprod.lift_desc CategoryTheory.Limits.biprod.lift_desc

/- warning: category_theory.limits.biprod.map_eq -> CategoryTheory.Limits.biprod.map_eq is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_2 : CategoryTheory.Preadditive.{u1, u2} C _inst_1] [_inst_5 : CategoryTheory.Limits.HasBinaryBiproducts.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2)] {W : C} {X : C} {Y : C} {Z : C} {f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) W Y} {g : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Z}, Eq.{succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) W X (CategoryTheory.Limits.HasBinaryBiproducts.hasBinaryBiproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_5 W X)) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) Y Z (CategoryTheory.Limits.HasBinaryBiproducts.hasBinaryBiproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_5 Y Z))) (CategoryTheory.Limits.biprod.map.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) W X Y Z (CategoryTheory.Limits.HasBinaryBiproducts.hasBinaryBiproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_5 W X) (CategoryTheory.Limits.HasBinaryBiproducts.hasBinaryBiproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_5 Y Z) f g) (HAdd.hAdd.{u1, u1, u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) W X (CategoryTheory.Limits.HasBinaryBiproducts.hasBinaryBiproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_5 W X)) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) Y Z (CategoryTheory.Limits.HasBinaryBiproducts.hasBinaryBiproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_5 Y Z))) (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) W X (CategoryTheory.Limits.HasBinaryBiproducts.hasBinaryBiproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_5 W X)) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) Y Z (CategoryTheory.Limits.HasBinaryBiproducts.hasBinaryBiproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_5 Y Z))) (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) W X (CategoryTheory.Limits.HasBinaryBiproducts.hasBinaryBiproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_5 W X)) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) Y Z (CategoryTheory.Limits.HasBinaryBiproducts.hasBinaryBiproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_5 Y Z))) (instHAdd.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) W X (CategoryTheory.Limits.HasBinaryBiproducts.hasBinaryBiproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_5 W X)) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) Y Z (CategoryTheory.Limits.HasBinaryBiproducts.hasBinaryBiproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_5 Y Z))) (AddZeroClass.toHasAdd.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) W X (CategoryTheory.Limits.HasBinaryBiproducts.hasBinaryBiproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_5 W X)) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) Y Z (CategoryTheory.Limits.HasBinaryBiproducts.hasBinaryBiproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_5 Y Z))) (AddMonoid.toAddZeroClass.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) W X (CategoryTheory.Limits.HasBinaryBiproducts.hasBinaryBiproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_5 W X)) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) Y Z (CategoryTheory.Limits.HasBinaryBiproducts.hasBinaryBiproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_5 Y Z))) (SubNegMonoid.toAddMonoid.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) W X (CategoryTheory.Limits.HasBinaryBiproducts.hasBinaryBiproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_5 W X)) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) Y Z (CategoryTheory.Limits.HasBinaryBiproducts.hasBinaryBiproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_5 Y Z))) (AddGroup.toSubNegMonoid.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) W X (CategoryTheory.Limits.HasBinaryBiproducts.hasBinaryBiproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_5 W X)) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) Y Z (CategoryTheory.Limits.HasBinaryBiproducts.hasBinaryBiproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_5 Y Z))) (AddCommGroup.toAddGroup.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) W X (CategoryTheory.Limits.HasBinaryBiproducts.hasBinaryBiproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_5 W X)) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) Y Z (CategoryTheory.Limits.HasBinaryBiproducts.hasBinaryBiproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_5 Y Z))) (CategoryTheory.Preadditive.homGroup.{u1, u2} C _inst_1 _inst_2 (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) W X (CategoryTheory.Limits.HasBinaryBiproducts.hasBinaryBiproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_5 W X)) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) Y Z (CategoryTheory.Limits.HasBinaryBiproducts.hasBinaryBiproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_5 Y Z))))))))) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) W X (CategoryTheory.Limits.HasBinaryBiproducts.hasBinaryBiproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_5 W X)) W (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) Y Z (CategoryTheory.Limits.HasBinaryBiproducts.hasBinaryBiproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_5 Y Z)) (CategoryTheory.Limits.biprod.fst.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) W X (CategoryTheory.Limits.HasBinaryBiproducts.hasBinaryBiproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_5 W X)) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) W Y (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) Y Z (CategoryTheory.Limits.HasBinaryBiproducts.hasBinaryBiproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_5 Y Z)) f (CategoryTheory.Limits.biprod.inl.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) Y Z (CategoryTheory.Limits.HasBinaryBiproducts.hasBinaryBiproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_5 Y Z)))) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) W X (CategoryTheory.Limits.HasBinaryBiproducts.hasBinaryBiproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_5 W X)) X (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) Y Z (CategoryTheory.Limits.HasBinaryBiproducts.hasBinaryBiproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_5 Y Z)) (CategoryTheory.Limits.biprod.snd.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) W X (CategoryTheory.Limits.HasBinaryBiproducts.hasBinaryBiproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_5 W X)) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) X Z (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) Y Z (CategoryTheory.Limits.HasBinaryBiproducts.hasBinaryBiproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_5 Y Z)) g (CategoryTheory.Limits.biprod.inr.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) Y Z (CategoryTheory.Limits.HasBinaryBiproducts.hasBinaryBiproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_5 Y Z)))))
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_2 : CategoryTheory.Preadditive.{u1, u2} C _inst_1] [_inst_5 : CategoryTheory.Limits.HasBinaryBiproducts.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2)] {W : C} {X : C} {Y : C} {Z : C} {f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) W Y} {g : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Z}, Eq.{succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) W X (CategoryTheory.Limits.HasBinaryBiproducts.has_binary_biproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_5 W X)) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) Y Z (CategoryTheory.Limits.HasBinaryBiproducts.has_binary_biproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_5 Y Z))) (CategoryTheory.Limits.biprod.map.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) W X Y Z (CategoryTheory.Limits.HasBinaryBiproducts.has_binary_biproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_5 W X) (CategoryTheory.Limits.HasBinaryBiproducts.has_binary_biproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_5 Y Z) f g) (HAdd.hAdd.{u1, u1, u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) W X (CategoryTheory.Limits.HasBinaryBiproducts.has_binary_biproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_5 W X)) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) Y Z (CategoryTheory.Limits.HasBinaryBiproducts.has_binary_biproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_5 Y Z))) (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) W X (CategoryTheory.Limits.HasBinaryBiproducts.has_binary_biproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_5 W X)) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) Y Z (CategoryTheory.Limits.HasBinaryBiproducts.has_binary_biproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_5 Y Z))) (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) W X (CategoryTheory.Limits.HasBinaryBiproducts.has_binary_biproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_5 W X)) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) Y Z (CategoryTheory.Limits.HasBinaryBiproducts.has_binary_biproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_5 Y Z))) (instHAdd.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) W X (CategoryTheory.Limits.HasBinaryBiproducts.has_binary_biproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_5 W X)) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) Y Z (CategoryTheory.Limits.HasBinaryBiproducts.has_binary_biproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_5 Y Z))) (AddZeroClass.toAdd.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) W X (CategoryTheory.Limits.HasBinaryBiproducts.has_binary_biproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_5 W X)) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) Y Z (CategoryTheory.Limits.HasBinaryBiproducts.has_binary_biproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_5 Y Z))) (AddMonoid.toAddZeroClass.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) W X (CategoryTheory.Limits.HasBinaryBiproducts.has_binary_biproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_5 W X)) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) Y Z (CategoryTheory.Limits.HasBinaryBiproducts.has_binary_biproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_5 Y Z))) (SubNegMonoid.toAddMonoid.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) W X (CategoryTheory.Limits.HasBinaryBiproducts.has_binary_biproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_5 W X)) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) Y Z (CategoryTheory.Limits.HasBinaryBiproducts.has_binary_biproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_5 Y Z))) (AddGroup.toSubNegMonoid.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) W X (CategoryTheory.Limits.HasBinaryBiproducts.has_binary_biproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_5 W X)) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) Y Z (CategoryTheory.Limits.HasBinaryBiproducts.has_binary_biproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_5 Y Z))) (AddCommGroup.toAddGroup.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) W X (CategoryTheory.Limits.HasBinaryBiproducts.has_binary_biproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_5 W X)) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) Y Z (CategoryTheory.Limits.HasBinaryBiproducts.has_binary_biproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_5 Y Z))) (CategoryTheory.Preadditive.homGroup.{u1, u2} C _inst_1 _inst_2 (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) W X (CategoryTheory.Limits.HasBinaryBiproducts.has_binary_biproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_5 W X)) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) Y Z (CategoryTheory.Limits.HasBinaryBiproducts.has_binary_biproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_5 Y Z))))))))) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) W X (CategoryTheory.Limits.HasBinaryBiproducts.has_binary_biproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_5 W X)) W (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) Y Z (CategoryTheory.Limits.HasBinaryBiproducts.has_binary_biproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_5 Y Z)) (CategoryTheory.Limits.biprod.fst.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) W X (CategoryTheory.Limits.HasBinaryBiproducts.has_binary_biproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_5 W X)) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) W Y (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) Y Z (CategoryTheory.Limits.HasBinaryBiproducts.has_binary_biproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_5 Y Z)) f (CategoryTheory.Limits.biprod.inl.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) Y Z (CategoryTheory.Limits.HasBinaryBiproducts.has_binary_biproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_5 Y Z)))) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) W X (CategoryTheory.Limits.HasBinaryBiproducts.has_binary_biproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_5 W X)) X (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) Y Z (CategoryTheory.Limits.HasBinaryBiproducts.has_binary_biproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_5 Y Z)) (CategoryTheory.Limits.biprod.snd.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) W X (CategoryTheory.Limits.HasBinaryBiproducts.has_binary_biproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_5 W X)) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) X Z (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) Y Z (CategoryTheory.Limits.HasBinaryBiproducts.has_binary_biproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_5 Y Z)) g (CategoryTheory.Limits.biprod.inr.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) Y Z (CategoryTheory.Limits.HasBinaryBiproducts.has_binary_biproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_5 Y Z)))))
Case conversion may be inaccurate. Consider using '#align category_theory.limits.biprod.map_eq CategoryTheory.Limits.biprod.map_eq‚Çì'. -/
theorem biprod.map_eq [HasBinaryBiproducts C] {W X Y Z : C} {f : W ‚ü∂ Y} {g : X ‚ü∂ Z} :
    biprod.map f g = biprod.fst ‚â´ f ‚â´ biprod.inl + biprod.snd ‚â´ g ‚â´ biprod.inr := by
  apply biprod.hom_ext <;> apply biprod.hom_ext' <;> simp
#align category_theory.limits.biprod.map_eq CategoryTheory.Limits.biprod.map_eq

#print CategoryTheory.Limits.binaryBiconeOfIsSplitMonoOfCokernel /-
/-- Every split mono `f` with a cokernel induces a binary bicone with `f` as its `inl` and
the cokernel map as its `snd`.
We will show in `is_bilimit_binary_bicone_of_split_mono_of_cokernel` that this binary bicone is in
fact already a biproduct. -/
@[simps]
def binaryBiconeOfIsSplitMonoOfCokernel {X Y : C} {f : X ‚ü∂ Y} [IsSplitMono f] {c : CokernelCofork f}
    (i : IsColimit c) : BinaryBicone X c.pt
    where
  pt := Y
  fst := retraction f
  snd := c.œÄ
  inl := f
  inr :=
    let c' : CokernelCofork (ùüô Y - (ùüô Y - retraction f ‚â´ f)) :=
      CokernelCofork.ofœÄ (Cofork.œÄ c) (by simp)
    let i' : IsColimit c' := isCokernelEpiComp i (retraction f) (by simp)
    let i'' := isColimitCoforkOfCokernelCofork i'
    (splitEpiOfIdempotentOfIsColimitCofork C (by simp) i'').section_
  inl_fst := by simp
  inl_snd := by simp
  inr_fst := by
    dsimp only
    rw [split_epi_of_idempotent_of_is_colimit_cofork_section_,
      is_colimit_cofork_of_cokernel_cofork_desc, is_cokernel_epi_comp_desc]
    dsimp only [cokernel_cofork_of_cofork_of_œÄ]
    letI := epi_of_is_colimit_cofork i
    apply zero_of_epi_comp c.œÄ
    simp only [sub_comp, comp_sub, category.comp_id, category.assoc, is_split_mono.id, sub_self,
      cofork.is_colimit.œÄ_desc_assoc, cokernel_cofork.œÄ_of_œÄ, is_split_mono.id_assoc]
    apply sub_eq_zero_of_eq
    apply category.id_comp
  inr_snd := by apply split_epi.id
#align category_theory.limits.binary_bicone_of_is_split_mono_of_cokernel CategoryTheory.Limits.binaryBiconeOfIsSplitMonoOfCokernel
-/

#print CategoryTheory.Limits.isBilimitBinaryBiconeOfIsSplitMonoOfCokernel /-
/-- The bicone constructed in `binary_bicone_of_split_mono_of_cokernel` is a bilimit.
This is a version of the splitting lemma that holds in all preadditive categories. -/
def isBilimitBinaryBiconeOfIsSplitMonoOfCokernel {X Y : C} {f : X ‚ü∂ Y} [IsSplitMono f]
    {c : CokernelCofork f} (i : IsColimit c) : (binaryBiconeOfIsSplitMonoOfCokernel i).IsBilimit :=
  isBinaryBilimitOfTotal _
    (by
      simp only [binary_bicone_of_is_split_mono_of_cokernel_fst,
        binary_bicone_of_is_split_mono_of_cokernel_inr,
        binary_bicone_of_is_split_mono_of_cokernel_snd,
        split_epi_of_idempotent_of_is_colimit_cofork_section_]
      dsimp only [binary_bicone_of_is_split_mono_of_cokernel_X]
      rw [is_colimit_cofork_of_cokernel_cofork_desc, is_cokernel_epi_comp_desc]
      simp only [binary_bicone_of_is_split_mono_of_cokernel_inl, cofork.is_colimit.œÄ_desc,
        cokernel_cofork_of_cofork_œÄ, cofork.œÄ_of_œÄ, add_sub_cancel'_right])
#align category_theory.limits.is_bilimit_binary_bicone_of_is_split_mono_of_cokernel CategoryTheory.Limits.isBilimitBinaryBiconeOfIsSplitMonoOfCokernel
-/

#print CategoryTheory.Limits.BinaryBicone.isBilimitOfKernelInl /-
/-- If `b` is a binary bicone such that `b.inl` is a kernel of `b.snd`, then `b` is a bilimit
    bicone. -/
def BinaryBicone.isBilimitOfKernelInl {X Y : C} (b : BinaryBicone X Y)
    (hb : IsLimit b.sndKernelFork) : b.IsBilimit :=
  isBinaryBilimitOfIsLimit _ <|
    BinaryFan.IsLimit.mk _ (fun T f g => f ‚â´ b.inl + g ‚â´ b.inr) (fun T f g => by simp)
      (fun T f g => by simp) fun T f g m h‚ÇÅ h‚ÇÇ =>
      by
      have h‚ÇÅ' : (m - (f ‚â´ b.inl + g ‚â´ b.inr)) ‚â´ b.fst = 0 := by simpa using sub_eq_zero.2 h‚ÇÅ
      have h‚ÇÇ' : (m - (f ‚â´ b.inl + g ‚â´ b.inr)) ‚â´ b.snd = 0 := by simpa using sub_eq_zero.2 h‚ÇÇ
      obtain ‚ü®q : T ‚ü∂ X, hq : q ‚â´ b.inl = m - (f ‚â´ b.inl + g ‚â´ b.inr)‚ü© :=
        kernel_fork.is_limit.lift' hb _ h‚ÇÇ'
      rw [‚Üê sub_eq_zero, ‚Üê hq, ‚Üê category.comp_id q, ‚Üê b.inl_fst, ‚Üê category.assoc, hq, h‚ÇÅ',
        zero_comp]
#align category_theory.limits.binary_bicone.is_bilimit_of_kernel_inl CategoryTheory.Limits.BinaryBicone.isBilimitOfKernelInl
-/

#print CategoryTheory.Limits.BinaryBicone.isBilimitOfKernelInr /-
/-- If `b` is a binary bicone such that `b.inr` is a kernel of `b.fst`, then `b` is a bilimit
    bicone. -/
def BinaryBicone.isBilimitOfKernelInr {X Y : C} (b : BinaryBicone X Y)
    (hb : IsLimit b.fstKernelFork) : b.IsBilimit :=
  isBinaryBilimitOfIsLimit _ <|
    BinaryFan.IsLimit.mk _ (fun T f g => f ‚â´ b.inl + g ‚â´ b.inr) (fun t f g => by simp)
      (fun t f g => by simp) fun T f g m h‚ÇÅ h‚ÇÇ =>
      by
      have h‚ÇÅ' : (m - (f ‚â´ b.inl + g ‚â´ b.inr)) ‚â´ b.fst = 0 := by simpa using sub_eq_zero.2 h‚ÇÅ
      have h‚ÇÇ' : (m - (f ‚â´ b.inl + g ‚â´ b.inr)) ‚â´ b.snd = 0 := by simpa using sub_eq_zero.2 h‚ÇÇ
      obtain ‚ü®q : T ‚ü∂ Y, hq : q ‚â´ b.inr = m - (f ‚â´ b.inl + g ‚â´ b.inr)‚ü© :=
        kernel_fork.is_limit.lift' hb _ h‚ÇÅ'
      rw [‚Üê sub_eq_zero, ‚Üê hq, ‚Üê category.comp_id q, ‚Üê b.inr_snd, ‚Üê category.assoc, hq, h‚ÇÇ',
        zero_comp]
#align category_theory.limits.binary_bicone.is_bilimit_of_kernel_inr CategoryTheory.Limits.BinaryBicone.isBilimitOfKernelInr
-/

#print CategoryTheory.Limits.BinaryBicone.isBilimitOfCokernelFst /-
/-- If `b` is a binary bicone such that `b.fst` is a cokernel of `b.inr`, then `b` is a bilimit
    bicone. -/
def BinaryBicone.isBilimitOfCokernelFst {X Y : C} (b : BinaryBicone X Y)
    (hb : IsColimit b.inrCokernelCofork) : b.IsBilimit :=
  isBinaryBilimitOfIsColimit _ <|
    BinaryCofan.IsColimit.mk _ (fun T f g => b.fst ‚â´ f + b.snd ‚â´ g) (fun T f g => by simp)
      (fun T f g => by simp) fun T f g m h‚ÇÅ h‚ÇÇ =>
      by
      have h‚ÇÅ' : b.inl ‚â´ (m - (b.fst ‚â´ f + b.snd ‚â´ g)) = 0 := by simpa using sub_eq_zero.2 h‚ÇÅ
      have h‚ÇÇ' : b.inr ‚â´ (m - (b.fst ‚â´ f + b.snd ‚â´ g)) = 0 := by simpa using sub_eq_zero.2 h‚ÇÇ
      obtain ‚ü®q : X ‚ü∂ T, hq : b.fst ‚â´ q = m - (b.fst ‚â´ f + b.snd ‚â´ g)‚ü© :=
        cokernel_cofork.is_colimit.desc' hb _ h‚ÇÇ'
      rw [‚Üê sub_eq_zero, ‚Üê hq, ‚Üê category.id_comp q, ‚Üê b.inl_fst, category.assoc, hq, h‚ÇÅ',
        comp_zero]
#align category_theory.limits.binary_bicone.is_bilimit_of_cokernel_fst CategoryTheory.Limits.BinaryBicone.isBilimitOfCokernelFst
-/

#print CategoryTheory.Limits.BinaryBicone.isBilimitOfCokernelSnd /-
/-- If `b` is a binary bicone such that `b.snd` is a cokernel of `b.inl`, then `b` is a bilimit
    bicone. -/
def BinaryBicone.isBilimitOfCokernelSnd {X Y : C} (b : BinaryBicone X Y)
    (hb : IsColimit b.inlCokernelCofork) : b.IsBilimit :=
  isBinaryBilimitOfIsColimit _ <|
    BinaryCofan.IsColimit.mk _ (fun T f g => b.fst ‚â´ f + b.snd ‚â´ g) (fun T f g => by simp)
      (fun T f g => by simp) fun T f g m h‚ÇÅ h‚ÇÇ =>
      by
      have h‚ÇÅ' : b.inl ‚â´ (m - (b.fst ‚â´ f + b.snd ‚â´ g)) = 0 := by simpa using sub_eq_zero.2 h‚ÇÅ
      have h‚ÇÇ' : b.inr ‚â´ (m - (b.fst ‚â´ f + b.snd ‚â´ g)) = 0 := by simpa using sub_eq_zero.2 h‚ÇÇ
      obtain ‚ü®q : Y ‚ü∂ T, hq : b.snd ‚â´ q = m - (b.fst ‚â´ f + b.snd ‚â´ g)‚ü© :=
        cokernel_cofork.is_colimit.desc' hb _ h‚ÇÅ'
      rw [‚Üê sub_eq_zero, ‚Üê hq, ‚Üê category.id_comp q, ‚Üê b.inr_snd, category.assoc, hq, h‚ÇÇ',
        comp_zero]
#align category_theory.limits.binary_bicone.is_bilimit_of_cokernel_snd CategoryTheory.Limits.BinaryBicone.isBilimitOfCokernelSnd
-/

#print CategoryTheory.Limits.binaryBiconeOfIsSplitEpiOfKernel /-
/-- Every split epi `f` with a kernel induces a binary bicone with `f` as its `snd` and
the kernel map as its `inl`.
We will show in `binary_bicone_of_is_split_mono_of_cokernel` that this binary bicone is in fact
already a biproduct. -/
@[simps]
def binaryBiconeOfIsSplitEpiOfKernel {X Y : C} {f : X ‚ü∂ Y} [IsSplitEpi f] {c : KernelFork f}
    (i : IsLimit c) : BinaryBicone c.pt Y :=
  { pt
    fst :=
      let c' : KernelFork (ùüô X - (ùüô X - f ‚â´ section_ f)) := KernelFork.ofŒπ (Fork.Œπ c) (by simp)
      let i' : IsLimit c' := isKernelCompMono i (section_ f) (by simp)
      let i'' := isLimitForkOfKernelFork i'
      (splitMonoOfIdempotentOfIsLimitFork C (by simp) i'').retraction
    snd := f
    inl := c.Œπ
    inr := section_ f
    inl_fst := by apply split_mono.id
    inl_snd := by simp
    inr_fst := by
      dsimp only
      rw [split_mono_of_idempotent_of_is_limit_fork_retraction, is_limit_fork_of_kernel_fork_lift,
        is_kernel_comp_mono_lift]
      dsimp only [kernel_fork_of_fork_Œπ]
      letI := mono_of_is_limit_fork i
      apply zero_of_comp_mono c.Œπ
      simp only [comp_sub, category.comp_id, category.assoc, sub_self, fork.is_limit.lift_Œπ,
        fork.Œπ_of_Œπ, is_split_epi.id_assoc]
    inr_snd := by simp }
#align category_theory.limits.binary_bicone_of_is_split_epi_of_kernel CategoryTheory.Limits.binaryBiconeOfIsSplitEpiOfKernel
-/

#print CategoryTheory.Limits.isBilimitBinaryBiconeOfIsSplitEpiOfKernel /-
/-- The bicone constructed in `binary_bicone_of_is_split_epi_of_kernel` is a bilimit.
This is a version of the splitting lemma that holds in all preadditive categories. -/
def isBilimitBinaryBiconeOfIsSplitEpiOfKernel {X Y : C} {f : X ‚ü∂ Y} [IsSplitEpi f]
    {c : KernelFork f} (i : IsLimit c) : (binaryBiconeOfIsSplitEpiOfKernel i).IsBilimit :=
  BinaryBicone.isBilimitOfKernelInl _ <| i.ofIsoLimit <| Fork.ext (Iso.refl _) (by simp)
#align category_theory.limits.is_bilimit_binary_bicone_of_is_split_epi_of_kernel CategoryTheory.Limits.isBilimitBinaryBiconeOfIsSplitEpiOfKernel
-/

end

section

variable {X Y : C} (f g : X ‚ü∂ Y)

/- warning: category_theory.limits.biprod.add_eq_lift_id_desc -> CategoryTheory.Limits.biprod.add_eq_lift_id_desc is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_2 : CategoryTheory.Preadditive.{u1, u2} C _inst_1] {X : C} {Y : C} (f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) (g : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) [_inst_4 : CategoryTheory.Limits.HasBinaryBiproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X X], Eq.{succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) (HAdd.hAdd.{u1, u1, u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) (instHAdd.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) (AddZeroClass.toHasAdd.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) (AddMonoid.toAddZeroClass.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) (SubNegMonoid.toAddMonoid.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) (AddGroup.toSubNegMonoid.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) (AddCommGroup.toAddGroup.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) (CategoryTheory.Preadditive.homGroup.{u1, u2} C _inst_1 _inst_2 X Y))))))) f g) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) X (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X X _inst_4) Y (CategoryTheory.Limits.biprod.lift.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X X X _inst_4 (CategoryTheory.CategoryStruct.id.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) X) (CategoryTheory.CategoryStruct.id.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) X)) (CategoryTheory.Limits.biprod.desc.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) Y X X _inst_4 f g))
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_2 : CategoryTheory.Preadditive.{u1, u2} C _inst_1] {X : C} {Y : C} (f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) (g : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) [_inst_4 : CategoryTheory.Limits.HasBinaryBiproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X X], Eq.{succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) (HAdd.hAdd.{u1, u1, u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) (instHAdd.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) (AddZeroClass.toAdd.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) (AddMonoid.toAddZeroClass.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) (SubNegMonoid.toAddMonoid.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) (AddGroup.toSubNegMonoid.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) (AddCommGroup.toAddGroup.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) (CategoryTheory.Preadditive.homGroup.{u1, u2} C _inst_1 _inst_2 X Y))))))) f g) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) X (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X X _inst_4) Y (CategoryTheory.Limits.biprod.lift.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X X X _inst_4 (CategoryTheory.CategoryStruct.id.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) X) (CategoryTheory.CategoryStruct.id.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) X)) (CategoryTheory.Limits.biprod.desc.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) Y X X _inst_4 f g))
Case conversion may be inaccurate. Consider using '#align category_theory.limits.biprod.add_eq_lift_id_desc CategoryTheory.Limits.biprod.add_eq_lift_id_desc‚Çì'. -/
/-- The existence of binary biproducts implies that there is at most one preadditive structure. -/
theorem biprod.add_eq_lift_id_desc [HasBinaryBiproduct X X] :
    f + g = biprod.lift (ùüô X) (ùüô X) ‚â´ biprod.desc f g := by simp
#align category_theory.limits.biprod.add_eq_lift_id_desc CategoryTheory.Limits.biprod.add_eq_lift_id_desc

/- warning: category_theory.limits.biprod.add_eq_lift_desc_id -> CategoryTheory.Limits.biprod.add_eq_lift_desc_id is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_2 : CategoryTheory.Preadditive.{u1, u2} C _inst_1] {X : C} {Y : C} (f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) (g : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) [_inst_4 : CategoryTheory.Limits.HasBinaryBiproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) Y Y], Eq.{succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) (HAdd.hAdd.{u1, u1, u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) (instHAdd.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) (AddZeroClass.toHasAdd.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) (AddMonoid.toAddZeroClass.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) (SubNegMonoid.toAddMonoid.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) (AddGroup.toSubNegMonoid.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) (AddCommGroup.toAddGroup.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) (CategoryTheory.Preadditive.homGroup.{u1, u2} C _inst_1 _inst_2 X Y))))))) f g) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) X (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) Y Y _inst_4) Y (CategoryTheory.Limits.biprod.lift.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y Y _inst_4 f g) (CategoryTheory.Limits.biprod.desc.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) Y Y Y _inst_4 (CategoryTheory.CategoryStruct.id.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) Y) (CategoryTheory.CategoryStruct.id.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) Y)))
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_2 : CategoryTheory.Preadditive.{u1, u2} C _inst_1] {X : C} {Y : C} (f : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) (g : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) [_inst_4 : CategoryTheory.Limits.HasBinaryBiproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) Y Y], Eq.{succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) (HAdd.hAdd.{u1, u1, u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) (instHAdd.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) (AddZeroClass.toAdd.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) (AddMonoid.toAddZeroClass.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) (SubNegMonoid.toAddMonoid.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) (AddGroup.toSubNegMonoid.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) (AddCommGroup.toAddGroup.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X Y) (CategoryTheory.Preadditive.homGroup.{u1, u2} C _inst_1 _inst_2 X Y))))))) f g) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) X (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) Y Y _inst_4) Y (CategoryTheory.Limits.biprod.lift.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X Y Y _inst_4 f g) (CategoryTheory.Limits.biprod.desc.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) Y Y Y _inst_4 (CategoryTheory.CategoryStruct.id.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) Y) (CategoryTheory.CategoryStruct.id.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) Y)))
Case conversion may be inaccurate. Consider using '#align category_theory.limits.biprod.add_eq_lift_desc_id CategoryTheory.Limits.biprod.add_eq_lift_desc_id‚Çì'. -/
/-- The existence of binary biproducts implies that there is at most one preadditive structure. -/
theorem biprod.add_eq_lift_desc_id [HasBinaryBiproduct Y Y] :
    f + g = biprod.lift f g ‚â´ biprod.desc (ùüô Y) (ùüô Y) := by simp
#align category_theory.limits.biprod.add_eq_lift_desc_id CategoryTheory.Limits.biprod.add_eq_lift_desc_id

end

end Limits

open CategoryTheory.Limits

section

attribute [local ext] preadditive

#print CategoryTheory.subsingleton_preadditive_of_hasBinaryBiproducts /-
/-- The existence of binary biproducts implies that there is at most one preadditive structure. -/
instance subsingleton_preadditive_of_hasBinaryBiproducts {C : Type u} [Category.{v} C]
    [HasZeroMorphisms C] [HasBinaryBiproducts C] : Subsingleton (Preadditive C) :=
  Subsingleton.intro fun a b => by
    ext (X Y f g)
    have h‚ÇÅ :=
      @biprod.add_eq_lift_id_desc _ _ a _ _ f g
        (by convert(inferInstance : has_binary_biproduct X X))
    have h‚ÇÇ :=
      @biprod.add_eq_lift_id_desc _ _ b _ _ f g
        (by convert(inferInstance : has_binary_biproduct X X))
    refine' h‚ÇÅ.trans (Eq.trans _ h‚ÇÇ.symm)
    congr 2 <;> exact Subsingleton.elim _ _
#align category_theory.subsingleton_preadditive_of_has_binary_biproducts CategoryTheory.subsingleton_preadditive_of_hasBinaryBiproducts
-/

end

section

variable [HasBinaryBiproducts.{v} C]

variable {X‚ÇÅ X‚ÇÇ Y‚ÇÅ Y‚ÇÇ : C}

variable (f‚ÇÅ‚ÇÅ : X‚ÇÅ ‚ü∂ Y‚ÇÅ) (f‚ÇÅ‚ÇÇ : X‚ÇÅ ‚ü∂ Y‚ÇÇ) (f‚ÇÇ‚ÇÅ : X‚ÇÇ ‚ü∂ Y‚ÇÅ) (f‚ÇÇ‚ÇÇ : X‚ÇÇ ‚ü∂ Y‚ÇÇ)

#print CategoryTheory.Biprod.ofComponents /-
/-- The "matrix" morphism `X‚ÇÅ ‚äû X‚ÇÇ ‚ü∂ Y‚ÇÅ ‚äû Y‚ÇÇ` with specified components.
-/
def Biprod.ofComponents : X‚ÇÅ ‚äû X‚ÇÇ ‚ü∂ Y‚ÇÅ ‚äû Y‚ÇÇ :=
  biprod.fst ‚â´ f‚ÇÅ‚ÇÅ ‚â´ biprod.inl + biprod.fst ‚â´ f‚ÇÅ‚ÇÇ ‚â´ biprod.inr + biprod.snd ‚â´ f‚ÇÇ‚ÇÅ ‚â´ biprod.inl +
    biprod.snd ‚â´ f‚ÇÇ‚ÇÇ ‚â´ biprod.inr
#align category_theory.biprod.of_components CategoryTheory.Biprod.ofComponents
-/

/- warning: category_theory.biprod.inl_of_components -> CategoryTheory.Biprod.inl_ofComponents is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_2 : CategoryTheory.Preadditive.{u1, u2} C _inst_1] [_inst_3 : CategoryTheory.Limits.HasBinaryBiproducts.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2)] {X‚ÇÅ : C} {X‚ÇÇ : C} {Y‚ÇÅ : C} {Y‚ÇÇ : C} (f‚ÇÅ‚ÇÅ : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÅ Y‚ÇÅ) (f‚ÇÅ‚ÇÇ : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÅ Y‚ÇÇ) (f‚ÇÇ‚ÇÅ : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÇ Y‚ÇÅ) (f‚ÇÇ‚ÇÇ : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÇ Y‚ÇÇ), Eq.{succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÅ (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) Y‚ÇÅ Y‚ÇÇ (CategoryTheory.Biprod.ofComponents._proof_2.{u2, u1} C _inst_1 _inst_2 _inst_3 Y‚ÇÅ Y‚ÇÇ))) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) X‚ÇÅ (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X‚ÇÅ X‚ÇÇ (CategoryTheory.Biprod.ofComponents._proof_1.{u2, u1} C _inst_1 _inst_2 _inst_3 X‚ÇÅ X‚ÇÇ)) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) Y‚ÇÅ Y‚ÇÇ (CategoryTheory.Biprod.ofComponents._proof_2.{u2, u1} C _inst_1 _inst_2 _inst_3 Y‚ÇÅ Y‚ÇÇ)) (CategoryTheory.Limits.biprod.inl.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X‚ÇÅ X‚ÇÇ (CategoryTheory.Biprod.ofComponents._proof_1.{u2, u1} C _inst_1 _inst_2 _inst_3 X‚ÇÅ X‚ÇÇ)) (CategoryTheory.Biprod.ofComponents.{u1, u2} C _inst_1 _inst_2 _inst_3 X‚ÇÅ X‚ÇÇ Y‚ÇÅ Y‚ÇÇ f‚ÇÅ‚ÇÅ f‚ÇÅ‚ÇÇ f‚ÇÇ‚ÇÅ f‚ÇÇ‚ÇÇ)) (HAdd.hAdd.{u1, u1, u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÅ (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) Y‚ÇÅ Y‚ÇÇ (CategoryTheory.Biprod.ofComponents._proof_2.{u2, u1} C _inst_1 _inst_2 _inst_3 Y‚ÇÅ Y‚ÇÇ))) (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÅ (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) Y‚ÇÅ Y‚ÇÇ (CategoryTheory.Biprod.ofComponents._proof_2.{u2, u1} C _inst_1 _inst_2 _inst_3 Y‚ÇÅ Y‚ÇÇ))) (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÅ (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) Y‚ÇÅ Y‚ÇÇ (CategoryTheory.Biprod.ofComponents._proof_2.{u2, u1} C _inst_1 _inst_2 _inst_3 Y‚ÇÅ Y‚ÇÇ))) (instHAdd.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÅ (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) Y‚ÇÅ Y‚ÇÇ (CategoryTheory.Biprod.ofComponents._proof_2.{u2, u1} C _inst_1 _inst_2 _inst_3 Y‚ÇÅ Y‚ÇÇ))) (AddZeroClass.toHasAdd.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÅ (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) Y‚ÇÅ Y‚ÇÇ (CategoryTheory.Biprod.ofComponents._proof_2.{u2, u1} C _inst_1 _inst_2 _inst_3 Y‚ÇÅ Y‚ÇÇ))) (AddMonoid.toAddZeroClass.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÅ (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) Y‚ÇÅ Y‚ÇÇ (CategoryTheory.Biprod.ofComponents._proof_2.{u2, u1} C _inst_1 _inst_2 _inst_3 Y‚ÇÅ Y‚ÇÇ))) (SubNegMonoid.toAddMonoid.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÅ (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) Y‚ÇÅ Y‚ÇÇ (CategoryTheory.Biprod.ofComponents._proof_2.{u2, u1} C _inst_1 _inst_2 _inst_3 Y‚ÇÅ Y‚ÇÇ))) (AddGroup.toSubNegMonoid.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÅ (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) Y‚ÇÅ Y‚ÇÇ (CategoryTheory.Biprod.ofComponents._proof_2.{u2, u1} C _inst_1 _inst_2 _inst_3 Y‚ÇÅ Y‚ÇÇ))) (AddCommGroup.toAddGroup.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÅ (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) Y‚ÇÅ Y‚ÇÇ (CategoryTheory.Biprod.ofComponents._proof_2.{u2, u1} C _inst_1 _inst_2 _inst_3 Y‚ÇÅ Y‚ÇÇ))) (CategoryTheory.Preadditive.homGroup.{u1, u2} C _inst_1 _inst_2 X‚ÇÅ (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) Y‚ÇÅ Y‚ÇÇ (CategoryTheory.Biprod.ofComponents._proof_2.{u2, u1} C _inst_1 _inst_2 _inst_3 Y‚ÇÅ Y‚ÇÇ))))))))) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) X‚ÇÅ Y‚ÇÅ (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) Y‚ÇÅ Y‚ÇÇ (CategoryTheory.Biprod.ofComponents._proof_2.{u2, u1} C _inst_1 _inst_2 _inst_3 Y‚ÇÅ Y‚ÇÇ)) f‚ÇÅ‚ÇÅ (CategoryTheory.Limits.biprod.inl.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) Y‚ÇÅ Y‚ÇÇ (CategoryTheory.Biprod.ofComponents._proof_2.{u2, u1} C _inst_1 _inst_2 _inst_3 Y‚ÇÅ Y‚ÇÇ))) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) X‚ÇÅ Y‚ÇÇ (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) Y‚ÇÅ Y‚ÇÇ (CategoryTheory.Biprod.ofComponents._proof_2.{u2, u1} C _inst_1 _inst_2 _inst_3 Y‚ÇÅ Y‚ÇÇ)) f‚ÇÅ‚ÇÇ (CategoryTheory.Limits.biprod.inr.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) Y‚ÇÅ Y‚ÇÇ (CategoryTheory.Biprod.ofComponents._proof_2.{u2, u1} C _inst_1 _inst_2 _inst_3 Y‚ÇÅ Y‚ÇÇ))))
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_2 : CategoryTheory.Preadditive.{u1, u2} C _inst_1] [_inst_3 : CategoryTheory.Limits.HasBinaryBiproducts.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2)] {X‚ÇÅ : C} {X‚ÇÇ : C} {Y‚ÇÅ : C} {Y‚ÇÇ : C} (f‚ÇÅ‚ÇÅ : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÅ Y‚ÇÅ) (f‚ÇÅ‚ÇÇ : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÅ Y‚ÇÇ) (f‚ÇÇ‚ÇÅ : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÇ Y‚ÇÅ) (f‚ÇÇ‚ÇÇ : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÇ Y‚ÇÇ), Eq.{succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÅ (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) Y‚ÇÅ Y‚ÇÇ (CategoryTheory.Limits.HasBinaryBiproducts.has_binary_biproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_3 Y‚ÇÅ Y‚ÇÇ))) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) X‚ÇÅ (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X‚ÇÅ X‚ÇÇ (CategoryTheory.Limits.HasBinaryBiproducts.has_binary_biproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_3 X‚ÇÅ X‚ÇÇ)) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) Y‚ÇÅ Y‚ÇÇ (CategoryTheory.Limits.HasBinaryBiproducts.has_binary_biproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_3 Y‚ÇÅ Y‚ÇÇ)) (CategoryTheory.Limits.biprod.inl.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X‚ÇÅ X‚ÇÇ (CategoryTheory.Limits.HasBinaryBiproducts.has_binary_biproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_3 X‚ÇÅ X‚ÇÇ)) (CategoryTheory.Biprod.ofComponents.{u1, u2} C _inst_1 _inst_2 _inst_3 X‚ÇÅ X‚ÇÇ Y‚ÇÅ Y‚ÇÇ f‚ÇÅ‚ÇÅ f‚ÇÅ‚ÇÇ f‚ÇÇ‚ÇÅ f‚ÇÇ‚ÇÇ)) (HAdd.hAdd.{u1, u1, u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÅ (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) Y‚ÇÅ Y‚ÇÇ (CategoryTheory.Limits.HasBinaryBiproducts.has_binary_biproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_3 Y‚ÇÅ Y‚ÇÇ))) (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÅ (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) Y‚ÇÅ Y‚ÇÇ (CategoryTheory.Limits.HasBinaryBiproducts.has_binary_biproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_3 Y‚ÇÅ Y‚ÇÇ))) (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÅ (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) Y‚ÇÅ Y‚ÇÇ (CategoryTheory.Limits.HasBinaryBiproducts.has_binary_biproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_3 Y‚ÇÅ Y‚ÇÇ))) (instHAdd.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÅ (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) Y‚ÇÅ Y‚ÇÇ (CategoryTheory.Limits.HasBinaryBiproducts.has_binary_biproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_3 Y‚ÇÅ Y‚ÇÇ))) (AddZeroClass.toAdd.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÅ (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) Y‚ÇÅ Y‚ÇÇ (CategoryTheory.Limits.HasBinaryBiproducts.has_binary_biproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_3 Y‚ÇÅ Y‚ÇÇ))) (AddMonoid.toAddZeroClass.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÅ (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) Y‚ÇÅ Y‚ÇÇ (CategoryTheory.Limits.HasBinaryBiproducts.has_binary_biproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_3 Y‚ÇÅ Y‚ÇÇ))) (SubNegMonoid.toAddMonoid.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÅ (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) Y‚ÇÅ Y‚ÇÇ (CategoryTheory.Limits.HasBinaryBiproducts.has_binary_biproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_3 Y‚ÇÅ Y‚ÇÇ))) (AddGroup.toSubNegMonoid.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÅ (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) Y‚ÇÅ Y‚ÇÇ (CategoryTheory.Limits.HasBinaryBiproducts.has_binary_biproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_3 Y‚ÇÅ Y‚ÇÇ))) (AddCommGroup.toAddGroup.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÅ (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) Y‚ÇÅ Y‚ÇÇ (CategoryTheory.Limits.HasBinaryBiproducts.has_binary_biproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_3 Y‚ÇÅ Y‚ÇÇ))) (CategoryTheory.Preadditive.homGroup.{u1, u2} C _inst_1 _inst_2 X‚ÇÅ (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) Y‚ÇÅ Y‚ÇÇ (CategoryTheory.Limits.HasBinaryBiproducts.has_binary_biproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_3 Y‚ÇÅ Y‚ÇÇ))))))))) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) X‚ÇÅ Y‚ÇÅ (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) Y‚ÇÅ Y‚ÇÇ (CategoryTheory.Limits.HasBinaryBiproducts.has_binary_biproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_3 Y‚ÇÅ Y‚ÇÇ)) f‚ÇÅ‚ÇÅ (CategoryTheory.Limits.biprod.inl.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) Y‚ÇÅ Y‚ÇÇ (CategoryTheory.Limits.HasBinaryBiproducts.has_binary_biproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_3 Y‚ÇÅ Y‚ÇÇ))) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) X‚ÇÅ Y‚ÇÇ (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) Y‚ÇÅ Y‚ÇÇ (CategoryTheory.Limits.HasBinaryBiproducts.has_binary_biproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_3 Y‚ÇÅ Y‚ÇÇ)) f‚ÇÅ‚ÇÇ (CategoryTheory.Limits.biprod.inr.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) Y‚ÇÅ Y‚ÇÇ (CategoryTheory.Limits.HasBinaryBiproducts.has_binary_biproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_3 Y‚ÇÅ Y‚ÇÇ))))
Case conversion may be inaccurate. Consider using '#align category_theory.biprod.inl_of_components CategoryTheory.Biprod.inl_ofComponents‚Çì'. -/
@[simp]
theorem Biprod.inl_ofComponents :
    biprod.inl ‚â´ Biprod.ofComponents f‚ÇÅ‚ÇÅ f‚ÇÅ‚ÇÇ f‚ÇÇ‚ÇÅ f‚ÇÇ‚ÇÇ = f‚ÇÅ‚ÇÅ ‚â´ biprod.inl + f‚ÇÅ‚ÇÇ ‚â´ biprod.inr := by
  simp [biprod.of_components]
#align category_theory.biprod.inl_of_components CategoryTheory.Biprod.inl_ofComponents

/- warning: category_theory.biprod.inr_of_components -> CategoryTheory.Biprod.inr_ofComponents is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_2 : CategoryTheory.Preadditive.{u1, u2} C _inst_1] [_inst_3 : CategoryTheory.Limits.HasBinaryBiproducts.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2)] {X‚ÇÅ : C} {X‚ÇÇ : C} {Y‚ÇÅ : C} {Y‚ÇÇ : C} (f‚ÇÅ‚ÇÅ : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÅ Y‚ÇÅ) (f‚ÇÅ‚ÇÇ : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÅ Y‚ÇÇ) (f‚ÇÇ‚ÇÅ : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÇ Y‚ÇÅ) (f‚ÇÇ‚ÇÇ : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÇ Y‚ÇÇ), Eq.{succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÇ (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) Y‚ÇÅ Y‚ÇÇ (CategoryTheory.Biprod.ofComponents._proof_2.{u2, u1} C _inst_1 _inst_2 _inst_3 Y‚ÇÅ Y‚ÇÇ))) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) X‚ÇÇ (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X‚ÇÅ X‚ÇÇ (CategoryTheory.Biprod.ofComponents._proof_1.{u2, u1} C _inst_1 _inst_2 _inst_3 X‚ÇÅ X‚ÇÇ)) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) Y‚ÇÅ Y‚ÇÇ (CategoryTheory.Biprod.ofComponents._proof_2.{u2, u1} C _inst_1 _inst_2 _inst_3 Y‚ÇÅ Y‚ÇÇ)) (CategoryTheory.Limits.biprod.inr.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X‚ÇÅ X‚ÇÇ (CategoryTheory.Biprod.ofComponents._proof_1.{u2, u1} C _inst_1 _inst_2 _inst_3 X‚ÇÅ X‚ÇÇ)) (CategoryTheory.Biprod.ofComponents.{u1, u2} C _inst_1 _inst_2 _inst_3 X‚ÇÅ X‚ÇÇ Y‚ÇÅ Y‚ÇÇ f‚ÇÅ‚ÇÅ f‚ÇÅ‚ÇÇ f‚ÇÇ‚ÇÅ f‚ÇÇ‚ÇÇ)) (HAdd.hAdd.{u1, u1, u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÇ (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) Y‚ÇÅ Y‚ÇÇ (CategoryTheory.Biprod.ofComponents._proof_2.{u2, u1} C _inst_1 _inst_2 _inst_3 Y‚ÇÅ Y‚ÇÇ))) (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÇ (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) Y‚ÇÅ Y‚ÇÇ (CategoryTheory.Biprod.ofComponents._proof_2.{u2, u1} C _inst_1 _inst_2 _inst_3 Y‚ÇÅ Y‚ÇÇ))) (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÇ (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) Y‚ÇÅ Y‚ÇÇ (CategoryTheory.Biprod.ofComponents._proof_2.{u2, u1} C _inst_1 _inst_2 _inst_3 Y‚ÇÅ Y‚ÇÇ))) (instHAdd.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÇ (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) Y‚ÇÅ Y‚ÇÇ (CategoryTheory.Biprod.ofComponents._proof_2.{u2, u1} C _inst_1 _inst_2 _inst_3 Y‚ÇÅ Y‚ÇÇ))) (AddZeroClass.toHasAdd.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÇ (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) Y‚ÇÅ Y‚ÇÇ (CategoryTheory.Biprod.ofComponents._proof_2.{u2, u1} C _inst_1 _inst_2 _inst_3 Y‚ÇÅ Y‚ÇÇ))) (AddMonoid.toAddZeroClass.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÇ (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) Y‚ÇÅ Y‚ÇÇ (CategoryTheory.Biprod.ofComponents._proof_2.{u2, u1} C _inst_1 _inst_2 _inst_3 Y‚ÇÅ Y‚ÇÇ))) (SubNegMonoid.toAddMonoid.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÇ (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) Y‚ÇÅ Y‚ÇÇ (CategoryTheory.Biprod.ofComponents._proof_2.{u2, u1} C _inst_1 _inst_2 _inst_3 Y‚ÇÅ Y‚ÇÇ))) (AddGroup.toSubNegMonoid.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÇ (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) Y‚ÇÅ Y‚ÇÇ (CategoryTheory.Biprod.ofComponents._proof_2.{u2, u1} C _inst_1 _inst_2 _inst_3 Y‚ÇÅ Y‚ÇÇ))) (AddCommGroup.toAddGroup.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÇ (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) Y‚ÇÅ Y‚ÇÇ (CategoryTheory.Biprod.ofComponents._proof_2.{u2, u1} C _inst_1 _inst_2 _inst_3 Y‚ÇÅ Y‚ÇÇ))) (CategoryTheory.Preadditive.homGroup.{u1, u2} C _inst_1 _inst_2 X‚ÇÇ (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) Y‚ÇÅ Y‚ÇÇ (CategoryTheory.Biprod.ofComponents._proof_2.{u2, u1} C _inst_1 _inst_2 _inst_3 Y‚ÇÅ Y‚ÇÇ))))))))) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) X‚ÇÇ Y‚ÇÅ (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) Y‚ÇÅ Y‚ÇÇ (CategoryTheory.Biprod.ofComponents._proof_2.{u2, u1} C _inst_1 _inst_2 _inst_3 Y‚ÇÅ Y‚ÇÇ)) f‚ÇÇ‚ÇÅ (CategoryTheory.Limits.biprod.inl.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) Y‚ÇÅ Y‚ÇÇ (CategoryTheory.Biprod.ofComponents._proof_2.{u2, u1} C _inst_1 _inst_2 _inst_3 Y‚ÇÅ Y‚ÇÇ))) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) X‚ÇÇ Y‚ÇÇ (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) Y‚ÇÅ Y‚ÇÇ (CategoryTheory.Biprod.ofComponents._proof_2.{u2, u1} C _inst_1 _inst_2 _inst_3 Y‚ÇÅ Y‚ÇÇ)) f‚ÇÇ‚ÇÇ (CategoryTheory.Limits.biprod.inr.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) Y‚ÇÅ Y‚ÇÇ (CategoryTheory.Biprod.ofComponents._proof_2.{u2, u1} C _inst_1 _inst_2 _inst_3 Y‚ÇÅ Y‚ÇÇ))))
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_2 : CategoryTheory.Preadditive.{u1, u2} C _inst_1] [_inst_3 : CategoryTheory.Limits.HasBinaryBiproducts.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2)] {X‚ÇÅ : C} {X‚ÇÇ : C} {Y‚ÇÅ : C} {Y‚ÇÇ : C} (f‚ÇÅ‚ÇÅ : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÅ Y‚ÇÅ) (f‚ÇÅ‚ÇÇ : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÅ Y‚ÇÇ) (f‚ÇÇ‚ÇÅ : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÇ Y‚ÇÅ) (f‚ÇÇ‚ÇÇ : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÇ Y‚ÇÇ), Eq.{succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÇ (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) Y‚ÇÅ Y‚ÇÇ (CategoryTheory.Limits.HasBinaryBiproducts.has_binary_biproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_3 Y‚ÇÅ Y‚ÇÇ))) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) X‚ÇÇ (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X‚ÇÅ X‚ÇÇ (CategoryTheory.Limits.HasBinaryBiproducts.has_binary_biproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_3 X‚ÇÅ X‚ÇÇ)) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) Y‚ÇÅ Y‚ÇÇ (CategoryTheory.Limits.HasBinaryBiproducts.has_binary_biproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_3 Y‚ÇÅ Y‚ÇÇ)) (CategoryTheory.Limits.biprod.inr.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X‚ÇÅ X‚ÇÇ (CategoryTheory.Limits.HasBinaryBiproducts.has_binary_biproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_3 X‚ÇÅ X‚ÇÇ)) (CategoryTheory.Biprod.ofComponents.{u1, u2} C _inst_1 _inst_2 _inst_3 X‚ÇÅ X‚ÇÇ Y‚ÇÅ Y‚ÇÇ f‚ÇÅ‚ÇÅ f‚ÇÅ‚ÇÇ f‚ÇÇ‚ÇÅ f‚ÇÇ‚ÇÇ)) (HAdd.hAdd.{u1, u1, u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÇ (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) Y‚ÇÅ Y‚ÇÇ (CategoryTheory.Limits.HasBinaryBiproducts.has_binary_biproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_3 Y‚ÇÅ Y‚ÇÇ))) (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÇ (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) Y‚ÇÅ Y‚ÇÇ (CategoryTheory.Limits.HasBinaryBiproducts.has_binary_biproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_3 Y‚ÇÅ Y‚ÇÇ))) (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÇ (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) Y‚ÇÅ Y‚ÇÇ (CategoryTheory.Limits.HasBinaryBiproducts.has_binary_biproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_3 Y‚ÇÅ Y‚ÇÇ))) (instHAdd.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÇ (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) Y‚ÇÅ Y‚ÇÇ (CategoryTheory.Limits.HasBinaryBiproducts.has_binary_biproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_3 Y‚ÇÅ Y‚ÇÇ))) (AddZeroClass.toAdd.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÇ (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) Y‚ÇÅ Y‚ÇÇ (CategoryTheory.Limits.HasBinaryBiproducts.has_binary_biproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_3 Y‚ÇÅ Y‚ÇÇ))) (AddMonoid.toAddZeroClass.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÇ (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) Y‚ÇÅ Y‚ÇÇ (CategoryTheory.Limits.HasBinaryBiproducts.has_binary_biproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_3 Y‚ÇÅ Y‚ÇÇ))) (SubNegMonoid.toAddMonoid.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÇ (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) Y‚ÇÅ Y‚ÇÇ (CategoryTheory.Limits.HasBinaryBiproducts.has_binary_biproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_3 Y‚ÇÅ Y‚ÇÇ))) (AddGroup.toSubNegMonoid.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÇ (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) Y‚ÇÅ Y‚ÇÇ (CategoryTheory.Limits.HasBinaryBiproducts.has_binary_biproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_3 Y‚ÇÅ Y‚ÇÇ))) (AddCommGroup.toAddGroup.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÇ (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) Y‚ÇÅ Y‚ÇÇ (CategoryTheory.Limits.HasBinaryBiproducts.has_binary_biproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_3 Y‚ÇÅ Y‚ÇÇ))) (CategoryTheory.Preadditive.homGroup.{u1, u2} C _inst_1 _inst_2 X‚ÇÇ (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) Y‚ÇÅ Y‚ÇÇ (CategoryTheory.Limits.HasBinaryBiproducts.has_binary_biproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_3 Y‚ÇÅ Y‚ÇÇ))))))))) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) X‚ÇÇ Y‚ÇÅ (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) Y‚ÇÅ Y‚ÇÇ (CategoryTheory.Limits.HasBinaryBiproducts.has_binary_biproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_3 Y‚ÇÅ Y‚ÇÇ)) f‚ÇÇ‚ÇÅ (CategoryTheory.Limits.biprod.inl.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) Y‚ÇÅ Y‚ÇÇ (CategoryTheory.Limits.HasBinaryBiproducts.has_binary_biproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_3 Y‚ÇÅ Y‚ÇÇ))) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) X‚ÇÇ Y‚ÇÇ (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) Y‚ÇÅ Y‚ÇÇ (CategoryTheory.Limits.HasBinaryBiproducts.has_binary_biproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_3 Y‚ÇÅ Y‚ÇÇ)) f‚ÇÇ‚ÇÇ (CategoryTheory.Limits.biprod.inr.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) Y‚ÇÅ Y‚ÇÇ (CategoryTheory.Limits.HasBinaryBiproducts.has_binary_biproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_3 Y‚ÇÅ Y‚ÇÇ))))
Case conversion may be inaccurate. Consider using '#align category_theory.biprod.inr_of_components CategoryTheory.Biprod.inr_ofComponents‚Çì'. -/
@[simp]
theorem Biprod.inr_ofComponents :
    biprod.inr ‚â´ Biprod.ofComponents f‚ÇÅ‚ÇÅ f‚ÇÅ‚ÇÇ f‚ÇÇ‚ÇÅ f‚ÇÇ‚ÇÇ = f‚ÇÇ‚ÇÅ ‚â´ biprod.inl + f‚ÇÇ‚ÇÇ ‚â´ biprod.inr := by
  simp [biprod.of_components]
#align category_theory.biprod.inr_of_components CategoryTheory.Biprod.inr_ofComponents

/- warning: category_theory.biprod.of_components_fst -> CategoryTheory.Biprod.ofComponents_fst is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_2 : CategoryTheory.Preadditive.{u1, u2} C _inst_1] [_inst_3 : CategoryTheory.Limits.HasBinaryBiproducts.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2)] {X‚ÇÅ : C} {X‚ÇÇ : C} {Y‚ÇÅ : C} {Y‚ÇÇ : C} (f‚ÇÅ‚ÇÅ : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÅ Y‚ÇÅ) (f‚ÇÅ‚ÇÇ : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÅ Y‚ÇÇ) (f‚ÇÇ‚ÇÅ : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÇ Y‚ÇÅ) (f‚ÇÇ‚ÇÇ : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÇ Y‚ÇÇ), Eq.{succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X‚ÇÅ X‚ÇÇ (CategoryTheory.Biprod.ofComponents._proof_1.{u2, u1} C _inst_1 _inst_2 _inst_3 X‚ÇÅ X‚ÇÇ)) Y‚ÇÅ) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X‚ÇÅ X‚ÇÇ (CategoryTheory.Biprod.ofComponents._proof_1.{u2, u1} C _inst_1 _inst_2 _inst_3 X‚ÇÅ X‚ÇÇ)) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) Y‚ÇÅ Y‚ÇÇ (CategoryTheory.Biprod.ofComponents._proof_2.{u2, u1} C _inst_1 _inst_2 _inst_3 Y‚ÇÅ Y‚ÇÇ)) Y‚ÇÅ (CategoryTheory.Biprod.ofComponents.{u1, u2} C _inst_1 _inst_2 _inst_3 X‚ÇÅ X‚ÇÇ Y‚ÇÅ Y‚ÇÇ f‚ÇÅ‚ÇÅ f‚ÇÅ‚ÇÇ f‚ÇÇ‚ÇÅ f‚ÇÇ‚ÇÇ) (CategoryTheory.Limits.biprod.fst.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) Y‚ÇÅ Y‚ÇÇ (CategoryTheory.Biprod.ofComponents._proof_2.{u2, u1} C _inst_1 _inst_2 _inst_3 Y‚ÇÅ Y‚ÇÇ))) (HAdd.hAdd.{u1, u1, u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X‚ÇÅ X‚ÇÇ (CategoryTheory.Biprod.ofComponents._proof_1.{u2, u1} C _inst_1 _inst_2 _inst_3 X‚ÇÅ X‚ÇÇ)) Y‚ÇÅ) (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X‚ÇÅ X‚ÇÇ (CategoryTheory.Biprod.ofComponents._proof_1.{u2, u1} C _inst_1 _inst_2 _inst_3 X‚ÇÅ X‚ÇÇ)) Y‚ÇÅ) (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X‚ÇÅ X‚ÇÇ (CategoryTheory.Biprod.ofComponents._proof_1.{u2, u1} C _inst_1 _inst_2 _inst_3 X‚ÇÅ X‚ÇÇ)) Y‚ÇÅ) (instHAdd.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X‚ÇÅ X‚ÇÇ (CategoryTheory.Biprod.ofComponents._proof_1.{u2, u1} C _inst_1 _inst_2 _inst_3 X‚ÇÅ X‚ÇÇ)) Y‚ÇÅ) (AddZeroClass.toHasAdd.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X‚ÇÅ X‚ÇÇ (CategoryTheory.Biprod.ofComponents._proof_1.{u2, u1} C _inst_1 _inst_2 _inst_3 X‚ÇÅ X‚ÇÇ)) Y‚ÇÅ) (AddMonoid.toAddZeroClass.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X‚ÇÅ X‚ÇÇ (CategoryTheory.Biprod.ofComponents._proof_1.{u2, u1} C _inst_1 _inst_2 _inst_3 X‚ÇÅ X‚ÇÇ)) Y‚ÇÅ) (SubNegMonoid.toAddMonoid.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X‚ÇÅ X‚ÇÇ (CategoryTheory.Biprod.ofComponents._proof_1.{u2, u1} C _inst_1 _inst_2 _inst_3 X‚ÇÅ X‚ÇÇ)) Y‚ÇÅ) (AddGroup.toSubNegMonoid.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X‚ÇÅ X‚ÇÇ (CategoryTheory.Biprod.ofComponents._proof_1.{u2, u1} C _inst_1 _inst_2 _inst_3 X‚ÇÅ X‚ÇÇ)) Y‚ÇÅ) (AddCommGroup.toAddGroup.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X‚ÇÅ X‚ÇÇ (CategoryTheory.Biprod.ofComponents._proof_1.{u2, u1} C _inst_1 _inst_2 _inst_3 X‚ÇÅ X‚ÇÇ)) Y‚ÇÅ) (CategoryTheory.Preadditive.homGroup.{u1, u2} C _inst_1 _inst_2 (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X‚ÇÅ X‚ÇÇ (CategoryTheory.Biprod.ofComponents._proof_1.{u2, u1} C _inst_1 _inst_2 _inst_3 X‚ÇÅ X‚ÇÇ)) Y‚ÇÅ))))))) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X‚ÇÅ X‚ÇÇ (CategoryTheory.Biprod.ofComponents._proof_1.{u2, u1} C _inst_1 _inst_2 _inst_3 X‚ÇÅ X‚ÇÇ)) X‚ÇÅ Y‚ÇÅ (CategoryTheory.Limits.biprod.fst.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X‚ÇÅ X‚ÇÇ (CategoryTheory.Biprod.ofComponents._proof_1.{u2, u1} C _inst_1 _inst_2 _inst_3 X‚ÇÅ X‚ÇÇ)) f‚ÇÅ‚ÇÅ) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X‚ÇÅ X‚ÇÇ (CategoryTheory.Biprod.ofComponents._proof_1.{u2, u1} C _inst_1 _inst_2 _inst_3 X‚ÇÅ X‚ÇÇ)) X‚ÇÇ Y‚ÇÅ (CategoryTheory.Limits.biprod.snd.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X‚ÇÅ X‚ÇÇ (CategoryTheory.Biprod.ofComponents._proof_1.{u2, u1} C _inst_1 _inst_2 _inst_3 X‚ÇÅ X‚ÇÇ)) f‚ÇÇ‚ÇÅ))
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_2 : CategoryTheory.Preadditive.{u1, u2} C _inst_1] [_inst_3 : CategoryTheory.Limits.HasBinaryBiproducts.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2)] {X‚ÇÅ : C} {X‚ÇÇ : C} {Y‚ÇÅ : C} {Y‚ÇÇ : C} (f‚ÇÅ‚ÇÅ : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÅ Y‚ÇÅ) (f‚ÇÅ‚ÇÇ : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÅ Y‚ÇÇ) (f‚ÇÇ‚ÇÅ : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÇ Y‚ÇÅ) (f‚ÇÇ‚ÇÇ : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÇ Y‚ÇÇ), Eq.{succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X‚ÇÅ X‚ÇÇ (CategoryTheory.Limits.HasBinaryBiproducts.has_binary_biproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_3 X‚ÇÅ X‚ÇÇ)) Y‚ÇÅ) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X‚ÇÅ X‚ÇÇ (CategoryTheory.Limits.HasBinaryBiproducts.has_binary_biproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_3 X‚ÇÅ X‚ÇÇ)) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) Y‚ÇÅ Y‚ÇÇ (CategoryTheory.Limits.HasBinaryBiproducts.has_binary_biproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_3 Y‚ÇÅ Y‚ÇÇ)) Y‚ÇÅ (CategoryTheory.Biprod.ofComponents.{u1, u2} C _inst_1 _inst_2 _inst_3 X‚ÇÅ X‚ÇÇ Y‚ÇÅ Y‚ÇÇ f‚ÇÅ‚ÇÅ f‚ÇÅ‚ÇÇ f‚ÇÇ‚ÇÅ f‚ÇÇ‚ÇÇ) (CategoryTheory.Limits.biprod.fst.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) Y‚ÇÅ Y‚ÇÇ (CategoryTheory.Limits.HasBinaryBiproducts.has_binary_biproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_3 Y‚ÇÅ Y‚ÇÇ))) (HAdd.hAdd.{u1, u1, u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X‚ÇÅ X‚ÇÇ (CategoryTheory.Limits.HasBinaryBiproducts.has_binary_biproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_3 X‚ÇÅ X‚ÇÇ)) Y‚ÇÅ) (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X‚ÇÅ X‚ÇÇ (CategoryTheory.Limits.HasBinaryBiproducts.has_binary_biproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_3 X‚ÇÅ X‚ÇÇ)) Y‚ÇÅ) (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X‚ÇÅ X‚ÇÇ (CategoryTheory.Limits.HasBinaryBiproducts.has_binary_biproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_3 X‚ÇÅ X‚ÇÇ)) Y‚ÇÅ) (instHAdd.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X‚ÇÅ X‚ÇÇ (CategoryTheory.Limits.HasBinaryBiproducts.has_binary_biproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_3 X‚ÇÅ X‚ÇÇ)) Y‚ÇÅ) (AddZeroClass.toAdd.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X‚ÇÅ X‚ÇÇ (CategoryTheory.Limits.HasBinaryBiproducts.has_binary_biproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_3 X‚ÇÅ X‚ÇÇ)) Y‚ÇÅ) (AddMonoid.toAddZeroClass.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X‚ÇÅ X‚ÇÇ (CategoryTheory.Limits.HasBinaryBiproducts.has_binary_biproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_3 X‚ÇÅ X‚ÇÇ)) Y‚ÇÅ) (SubNegMonoid.toAddMonoid.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X‚ÇÅ X‚ÇÇ (CategoryTheory.Limits.HasBinaryBiproducts.has_binary_biproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_3 X‚ÇÅ X‚ÇÇ)) Y‚ÇÅ) (AddGroup.toSubNegMonoid.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X‚ÇÅ X‚ÇÇ (CategoryTheory.Limits.HasBinaryBiproducts.has_binary_biproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_3 X‚ÇÅ X‚ÇÇ)) Y‚ÇÅ) (AddCommGroup.toAddGroup.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X‚ÇÅ X‚ÇÇ (CategoryTheory.Limits.HasBinaryBiproducts.has_binary_biproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_3 X‚ÇÅ X‚ÇÇ)) Y‚ÇÅ) (CategoryTheory.Preadditive.homGroup.{u1, u2} C _inst_1 _inst_2 (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X‚ÇÅ X‚ÇÇ (CategoryTheory.Limits.HasBinaryBiproducts.has_binary_biproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_3 X‚ÇÅ X‚ÇÇ)) Y‚ÇÅ))))))) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X‚ÇÅ X‚ÇÇ (CategoryTheory.Limits.HasBinaryBiproducts.has_binary_biproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_3 X‚ÇÅ X‚ÇÇ)) X‚ÇÅ Y‚ÇÅ (CategoryTheory.Limits.biprod.fst.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X‚ÇÅ X‚ÇÇ (CategoryTheory.Limits.HasBinaryBiproducts.has_binary_biproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_3 X‚ÇÅ X‚ÇÇ)) f‚ÇÅ‚ÇÅ) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X‚ÇÅ X‚ÇÇ (CategoryTheory.Limits.HasBinaryBiproducts.has_binary_biproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_3 X‚ÇÅ X‚ÇÇ)) X‚ÇÇ Y‚ÇÅ (CategoryTheory.Limits.biprod.snd.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X‚ÇÅ X‚ÇÇ (CategoryTheory.Limits.HasBinaryBiproducts.has_binary_biproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_3 X‚ÇÅ X‚ÇÇ)) f‚ÇÇ‚ÇÅ))
Case conversion may be inaccurate. Consider using '#align category_theory.biprod.of_components_fst CategoryTheory.Biprod.ofComponents_fst‚Çì'. -/
@[simp]
theorem Biprod.ofComponents_fst :
    Biprod.ofComponents f‚ÇÅ‚ÇÅ f‚ÇÅ‚ÇÇ f‚ÇÇ‚ÇÅ f‚ÇÇ‚ÇÇ ‚â´ biprod.fst = biprod.fst ‚â´ f‚ÇÅ‚ÇÅ + biprod.snd ‚â´ f‚ÇÇ‚ÇÅ := by
  simp [biprod.of_components]
#align category_theory.biprod.of_components_fst CategoryTheory.Biprod.ofComponents_fst

/- warning: category_theory.biprod.of_components_snd -> CategoryTheory.Biprod.ofComponents_snd is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_2 : CategoryTheory.Preadditive.{u1, u2} C _inst_1] [_inst_3 : CategoryTheory.Limits.HasBinaryBiproducts.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2)] {X‚ÇÅ : C} {X‚ÇÇ : C} {Y‚ÇÅ : C} {Y‚ÇÇ : C} (f‚ÇÅ‚ÇÅ : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÅ Y‚ÇÅ) (f‚ÇÅ‚ÇÇ : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÅ Y‚ÇÇ) (f‚ÇÇ‚ÇÅ : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÇ Y‚ÇÅ) (f‚ÇÇ‚ÇÇ : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÇ Y‚ÇÇ), Eq.{succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X‚ÇÅ X‚ÇÇ (CategoryTheory.Biprod.ofComponents._proof_1.{u2, u1} C _inst_1 _inst_2 _inst_3 X‚ÇÅ X‚ÇÇ)) Y‚ÇÇ) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X‚ÇÅ X‚ÇÇ (CategoryTheory.Biprod.ofComponents._proof_1.{u2, u1} C _inst_1 _inst_2 _inst_3 X‚ÇÅ X‚ÇÇ)) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) Y‚ÇÅ Y‚ÇÇ (CategoryTheory.Biprod.ofComponents._proof_2.{u2, u1} C _inst_1 _inst_2 _inst_3 Y‚ÇÅ Y‚ÇÇ)) Y‚ÇÇ (CategoryTheory.Biprod.ofComponents.{u1, u2} C _inst_1 _inst_2 _inst_3 X‚ÇÅ X‚ÇÇ Y‚ÇÅ Y‚ÇÇ f‚ÇÅ‚ÇÅ f‚ÇÅ‚ÇÇ f‚ÇÇ‚ÇÅ f‚ÇÇ‚ÇÇ) (CategoryTheory.Limits.biprod.snd.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) Y‚ÇÅ Y‚ÇÇ (CategoryTheory.Biprod.ofComponents._proof_2.{u2, u1} C _inst_1 _inst_2 _inst_3 Y‚ÇÅ Y‚ÇÇ))) (HAdd.hAdd.{u1, u1, u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X‚ÇÅ X‚ÇÇ (CategoryTheory.Biprod.ofComponents._proof_1.{u2, u1} C _inst_1 _inst_2 _inst_3 X‚ÇÅ X‚ÇÇ)) Y‚ÇÇ) (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X‚ÇÅ X‚ÇÇ (CategoryTheory.Biprod.ofComponents._proof_1.{u2, u1} C _inst_1 _inst_2 _inst_3 X‚ÇÅ X‚ÇÇ)) Y‚ÇÇ) (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X‚ÇÅ X‚ÇÇ (CategoryTheory.Biprod.ofComponents._proof_1.{u2, u1} C _inst_1 _inst_2 _inst_3 X‚ÇÅ X‚ÇÇ)) Y‚ÇÇ) (instHAdd.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X‚ÇÅ X‚ÇÇ (CategoryTheory.Biprod.ofComponents._proof_1.{u2, u1} C _inst_1 _inst_2 _inst_3 X‚ÇÅ X‚ÇÇ)) Y‚ÇÇ) (AddZeroClass.toHasAdd.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X‚ÇÅ X‚ÇÇ (CategoryTheory.Biprod.ofComponents._proof_1.{u2, u1} C _inst_1 _inst_2 _inst_3 X‚ÇÅ X‚ÇÇ)) Y‚ÇÇ) (AddMonoid.toAddZeroClass.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X‚ÇÅ X‚ÇÇ (CategoryTheory.Biprod.ofComponents._proof_1.{u2, u1} C _inst_1 _inst_2 _inst_3 X‚ÇÅ X‚ÇÇ)) Y‚ÇÇ) (SubNegMonoid.toAddMonoid.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X‚ÇÅ X‚ÇÇ (CategoryTheory.Biprod.ofComponents._proof_1.{u2, u1} C _inst_1 _inst_2 _inst_3 X‚ÇÅ X‚ÇÇ)) Y‚ÇÇ) (AddGroup.toSubNegMonoid.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X‚ÇÅ X‚ÇÇ (CategoryTheory.Biprod.ofComponents._proof_1.{u2, u1} C _inst_1 _inst_2 _inst_3 X‚ÇÅ X‚ÇÇ)) Y‚ÇÇ) (AddCommGroup.toAddGroup.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X‚ÇÅ X‚ÇÇ (CategoryTheory.Biprod.ofComponents._proof_1.{u2, u1} C _inst_1 _inst_2 _inst_3 X‚ÇÅ X‚ÇÇ)) Y‚ÇÇ) (CategoryTheory.Preadditive.homGroup.{u1, u2} C _inst_1 _inst_2 (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X‚ÇÅ X‚ÇÇ (CategoryTheory.Biprod.ofComponents._proof_1.{u2, u1} C _inst_1 _inst_2 _inst_3 X‚ÇÅ X‚ÇÇ)) Y‚ÇÇ))))))) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X‚ÇÅ X‚ÇÇ (CategoryTheory.Biprod.ofComponents._proof_1.{u2, u1} C _inst_1 _inst_2 _inst_3 X‚ÇÅ X‚ÇÇ)) X‚ÇÅ Y‚ÇÇ (CategoryTheory.Limits.biprod.fst.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X‚ÇÅ X‚ÇÇ (CategoryTheory.Biprod.ofComponents._proof_1.{u2, u1} C _inst_1 _inst_2 _inst_3 X‚ÇÅ X‚ÇÇ)) f‚ÇÅ‚ÇÇ) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X‚ÇÅ X‚ÇÇ (CategoryTheory.Biprod.ofComponents._proof_1.{u2, u1} C _inst_1 _inst_2 _inst_3 X‚ÇÅ X‚ÇÇ)) X‚ÇÇ Y‚ÇÇ (CategoryTheory.Limits.biprod.snd.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X‚ÇÅ X‚ÇÇ (CategoryTheory.Biprod.ofComponents._proof_1.{u2, u1} C _inst_1 _inst_2 _inst_3 X‚ÇÅ X‚ÇÇ)) f‚ÇÇ‚ÇÇ))
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_2 : CategoryTheory.Preadditive.{u1, u2} C _inst_1] [_inst_3 : CategoryTheory.Limits.HasBinaryBiproducts.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2)] {X‚ÇÅ : C} {X‚ÇÇ : C} {Y‚ÇÅ : C} {Y‚ÇÇ : C} (f‚ÇÅ‚ÇÅ : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÅ Y‚ÇÅ) (f‚ÇÅ‚ÇÇ : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÅ Y‚ÇÇ) (f‚ÇÇ‚ÇÅ : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÇ Y‚ÇÅ) (f‚ÇÇ‚ÇÇ : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÇ Y‚ÇÇ), Eq.{succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X‚ÇÅ X‚ÇÇ (CategoryTheory.Limits.HasBinaryBiproducts.has_binary_biproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_3 X‚ÇÅ X‚ÇÇ)) Y‚ÇÇ) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X‚ÇÅ X‚ÇÇ (CategoryTheory.Limits.HasBinaryBiproducts.has_binary_biproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_3 X‚ÇÅ X‚ÇÇ)) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) Y‚ÇÅ Y‚ÇÇ (CategoryTheory.Limits.HasBinaryBiproducts.has_binary_biproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_3 Y‚ÇÅ Y‚ÇÇ)) Y‚ÇÇ (CategoryTheory.Biprod.ofComponents.{u1, u2} C _inst_1 _inst_2 _inst_3 X‚ÇÅ X‚ÇÇ Y‚ÇÅ Y‚ÇÇ f‚ÇÅ‚ÇÅ f‚ÇÅ‚ÇÇ f‚ÇÇ‚ÇÅ f‚ÇÇ‚ÇÇ) (CategoryTheory.Limits.biprod.snd.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) Y‚ÇÅ Y‚ÇÇ (CategoryTheory.Limits.HasBinaryBiproducts.has_binary_biproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_3 Y‚ÇÅ Y‚ÇÇ))) (HAdd.hAdd.{u1, u1, u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X‚ÇÅ X‚ÇÇ (CategoryTheory.Limits.HasBinaryBiproducts.has_binary_biproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_3 X‚ÇÅ X‚ÇÇ)) Y‚ÇÇ) (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X‚ÇÅ X‚ÇÇ (CategoryTheory.Limits.HasBinaryBiproducts.has_binary_biproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_3 X‚ÇÅ X‚ÇÇ)) Y‚ÇÇ) (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X‚ÇÅ X‚ÇÇ (CategoryTheory.Limits.HasBinaryBiproducts.has_binary_biproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_3 X‚ÇÅ X‚ÇÇ)) Y‚ÇÇ) (instHAdd.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X‚ÇÅ X‚ÇÇ (CategoryTheory.Limits.HasBinaryBiproducts.has_binary_biproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_3 X‚ÇÅ X‚ÇÇ)) Y‚ÇÇ) (AddZeroClass.toAdd.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X‚ÇÅ X‚ÇÇ (CategoryTheory.Limits.HasBinaryBiproducts.has_binary_biproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_3 X‚ÇÅ X‚ÇÇ)) Y‚ÇÇ) (AddMonoid.toAddZeroClass.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X‚ÇÅ X‚ÇÇ (CategoryTheory.Limits.HasBinaryBiproducts.has_binary_biproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_3 X‚ÇÅ X‚ÇÇ)) Y‚ÇÇ) (SubNegMonoid.toAddMonoid.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X‚ÇÅ X‚ÇÇ (CategoryTheory.Limits.HasBinaryBiproducts.has_binary_biproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_3 X‚ÇÅ X‚ÇÇ)) Y‚ÇÇ) (AddGroup.toSubNegMonoid.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X‚ÇÅ X‚ÇÇ (CategoryTheory.Limits.HasBinaryBiproducts.has_binary_biproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_3 X‚ÇÅ X‚ÇÇ)) Y‚ÇÇ) (AddCommGroup.toAddGroup.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X‚ÇÅ X‚ÇÇ (CategoryTheory.Limits.HasBinaryBiproducts.has_binary_biproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_3 X‚ÇÅ X‚ÇÇ)) Y‚ÇÇ) (CategoryTheory.Preadditive.homGroup.{u1, u2} C _inst_1 _inst_2 (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X‚ÇÅ X‚ÇÇ (CategoryTheory.Limits.HasBinaryBiproducts.has_binary_biproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_3 X‚ÇÅ X‚ÇÇ)) Y‚ÇÇ))))))) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X‚ÇÅ X‚ÇÇ (CategoryTheory.Limits.HasBinaryBiproducts.has_binary_biproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_3 X‚ÇÅ X‚ÇÇ)) X‚ÇÅ Y‚ÇÇ (CategoryTheory.Limits.biprod.fst.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X‚ÇÅ X‚ÇÇ (CategoryTheory.Limits.HasBinaryBiproducts.has_binary_biproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_3 X‚ÇÅ X‚ÇÇ)) f‚ÇÅ‚ÇÇ) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X‚ÇÅ X‚ÇÇ (CategoryTheory.Limits.HasBinaryBiproducts.has_binary_biproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_3 X‚ÇÅ X‚ÇÇ)) X‚ÇÇ Y‚ÇÇ (CategoryTheory.Limits.biprod.snd.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X‚ÇÅ X‚ÇÇ (CategoryTheory.Limits.HasBinaryBiproducts.has_binary_biproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_3 X‚ÇÅ X‚ÇÇ)) f‚ÇÇ‚ÇÇ))
Case conversion may be inaccurate. Consider using '#align category_theory.biprod.of_components_snd CategoryTheory.Biprod.ofComponents_snd‚Çì'. -/
@[simp]
theorem Biprod.ofComponents_snd :
    Biprod.ofComponents f‚ÇÅ‚ÇÅ f‚ÇÅ‚ÇÇ f‚ÇÇ‚ÇÅ f‚ÇÇ‚ÇÇ ‚â´ biprod.snd = biprod.fst ‚â´ f‚ÇÅ‚ÇÇ + biprod.snd ‚â´ f‚ÇÇ‚ÇÇ := by
  simp [biprod.of_components]
#align category_theory.biprod.of_components_snd CategoryTheory.Biprod.ofComponents_snd

#print CategoryTheory.Biprod.ofComponents_eq /-
@[simp]
theorem Biprod.ofComponents_eq (f : X‚ÇÅ ‚äû X‚ÇÇ ‚ü∂ Y‚ÇÅ ‚äû Y‚ÇÇ) :
    Biprod.ofComponents (biprod.inl ‚â´ f ‚â´ biprod.fst) (biprod.inl ‚â´ f ‚â´ biprod.snd)
        (biprod.inr ‚â´ f ‚â´ biprod.fst) (biprod.inr ‚â´ f ‚â´ biprod.snd) =
      f :=
  by
  ext <;>
    simp only [category.comp_id, biprod.inr_fst, biprod.inr_snd, biprod.inl_snd, add_zero, zero_add,
      biprod.inl_of_components, biprod.inr_of_components, eq_self_iff_true, category.assoc,
      comp_zero, biprod.inl_fst, preadditive.add_comp]
#align category_theory.biprod.of_components_eq CategoryTheory.Biprod.ofComponents_eq
-/

/- warning: category_theory.biprod.of_components_comp -> CategoryTheory.Biprod.ofComponents_comp is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_2 : CategoryTheory.Preadditive.{u1, u2} C _inst_1] [_inst_3 : CategoryTheory.Limits.HasBinaryBiproducts.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2)] {X‚ÇÅ : C} {X‚ÇÇ : C} {Y‚ÇÅ : C} {Y‚ÇÇ : C} {Z‚ÇÅ : C} {Z‚ÇÇ : C} (f‚ÇÅ‚ÇÅ : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÅ Y‚ÇÅ) (f‚ÇÅ‚ÇÇ : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÅ Y‚ÇÇ) (f‚ÇÇ‚ÇÅ : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÇ Y‚ÇÅ) (f‚ÇÇ‚ÇÇ : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÇ Y‚ÇÇ) (g‚ÇÅ‚ÇÅ : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) Y‚ÇÅ Z‚ÇÅ) (g‚ÇÅ‚ÇÇ : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) Y‚ÇÅ Z‚ÇÇ) (g‚ÇÇ‚ÇÅ : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) Y‚ÇÇ Z‚ÇÅ) (g‚ÇÇ‚ÇÇ : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) Y‚ÇÇ Z‚ÇÇ), Eq.{succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X‚ÇÅ X‚ÇÇ (CategoryTheory.Biprod.ofComponents._proof_1.{u2, u1} C _inst_1 _inst_2 _inst_3 X‚ÇÅ X‚ÇÇ)) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) Z‚ÇÅ Z‚ÇÇ (CategoryTheory.Biprod.ofComponents._proof_2.{u2, u1} C _inst_1 _inst_2 _inst_3 Z‚ÇÅ Z‚ÇÇ))) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X‚ÇÅ X‚ÇÇ (CategoryTheory.Biprod.ofComponents._proof_1.{u2, u1} C _inst_1 _inst_2 _inst_3 X‚ÇÅ X‚ÇÇ)) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) Y‚ÇÅ Y‚ÇÇ (CategoryTheory.Biprod.ofComponents._proof_2.{u2, u1} C _inst_1 _inst_2 _inst_3 Y‚ÇÅ Y‚ÇÇ)) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) Z‚ÇÅ Z‚ÇÇ (CategoryTheory.Biprod.ofComponents._proof_2.{u2, u1} C _inst_1 _inst_2 _inst_3 Z‚ÇÅ Z‚ÇÇ)) (CategoryTheory.Biprod.ofComponents.{u1, u2} C _inst_1 _inst_2 _inst_3 X‚ÇÅ X‚ÇÇ Y‚ÇÅ Y‚ÇÇ f‚ÇÅ‚ÇÅ f‚ÇÅ‚ÇÇ f‚ÇÇ‚ÇÅ f‚ÇÇ‚ÇÇ) (CategoryTheory.Biprod.ofComponents.{u1, u2} C _inst_1 _inst_2 _inst_3 Y‚ÇÅ Y‚ÇÇ Z‚ÇÅ Z‚ÇÇ g‚ÇÅ‚ÇÅ g‚ÇÅ‚ÇÇ g‚ÇÇ‚ÇÅ g‚ÇÇ‚ÇÇ)) (CategoryTheory.Biprod.ofComponents.{u1, u2} C _inst_1 _inst_2 _inst_3 X‚ÇÅ X‚ÇÇ Z‚ÇÅ Z‚ÇÇ (HAdd.hAdd.{u1, u1, u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÅ Z‚ÇÅ) (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÅ Z‚ÇÅ) (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÅ Z‚ÇÅ) (instHAdd.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÅ Z‚ÇÅ) (AddZeroClass.toHasAdd.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÅ Z‚ÇÅ) (AddMonoid.toAddZeroClass.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÅ Z‚ÇÅ) (SubNegMonoid.toAddMonoid.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÅ Z‚ÇÅ) (AddGroup.toSubNegMonoid.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÅ Z‚ÇÅ) (AddCommGroup.toAddGroup.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÅ Z‚ÇÅ) (CategoryTheory.Preadditive.homGroup.{u1, u2} C _inst_1 _inst_2 X‚ÇÅ Z‚ÇÅ))))))) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) X‚ÇÅ Y‚ÇÅ Z‚ÇÅ f‚ÇÅ‚ÇÅ g‚ÇÅ‚ÇÅ) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) X‚ÇÅ Y‚ÇÇ Z‚ÇÅ f‚ÇÅ‚ÇÇ g‚ÇÇ‚ÇÅ)) (HAdd.hAdd.{u1, u1, u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÅ Z‚ÇÇ) (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÅ Z‚ÇÇ) (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÅ Z‚ÇÇ) (instHAdd.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÅ Z‚ÇÇ) (AddZeroClass.toHasAdd.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÅ Z‚ÇÇ) (AddMonoid.toAddZeroClass.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÅ Z‚ÇÇ) (SubNegMonoid.toAddMonoid.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÅ Z‚ÇÇ) (AddGroup.toSubNegMonoid.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÅ Z‚ÇÇ) (AddCommGroup.toAddGroup.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÅ Z‚ÇÇ) (CategoryTheory.Preadditive.homGroup.{u1, u2} C _inst_1 _inst_2 X‚ÇÅ Z‚ÇÇ))))))) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) X‚ÇÅ Y‚ÇÅ Z‚ÇÇ f‚ÇÅ‚ÇÅ g‚ÇÅ‚ÇÇ) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) X‚ÇÅ Y‚ÇÇ Z‚ÇÇ f‚ÇÅ‚ÇÇ g‚ÇÇ‚ÇÇ)) (HAdd.hAdd.{u1, u1, u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÇ Z‚ÇÅ) (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÇ Z‚ÇÅ) (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÇ Z‚ÇÅ) (instHAdd.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÇ Z‚ÇÅ) (AddZeroClass.toHasAdd.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÇ Z‚ÇÅ) (AddMonoid.toAddZeroClass.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÇ Z‚ÇÅ) (SubNegMonoid.toAddMonoid.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÇ Z‚ÇÅ) (AddGroup.toSubNegMonoid.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÇ Z‚ÇÅ) (AddCommGroup.toAddGroup.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÇ Z‚ÇÅ) (CategoryTheory.Preadditive.homGroup.{u1, u2} C _inst_1 _inst_2 X‚ÇÇ Z‚ÇÅ))))))) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) X‚ÇÇ Y‚ÇÅ Z‚ÇÅ f‚ÇÇ‚ÇÅ g‚ÇÅ‚ÇÅ) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) X‚ÇÇ Y‚ÇÇ Z‚ÇÅ f‚ÇÇ‚ÇÇ g‚ÇÇ‚ÇÅ)) (HAdd.hAdd.{u1, u1, u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÇ Z‚ÇÇ) (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÇ Z‚ÇÇ) (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÇ Z‚ÇÇ) (instHAdd.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÇ Z‚ÇÇ) (AddZeroClass.toHasAdd.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÇ Z‚ÇÇ) (AddMonoid.toAddZeroClass.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÇ Z‚ÇÇ) (SubNegMonoid.toAddMonoid.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÇ Z‚ÇÇ) (AddGroup.toSubNegMonoid.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÇ Z‚ÇÇ) (AddCommGroup.toAddGroup.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÇ Z‚ÇÇ) (CategoryTheory.Preadditive.homGroup.{u1, u2} C _inst_1 _inst_2 X‚ÇÇ Z‚ÇÇ))))))) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) X‚ÇÇ Y‚ÇÅ Z‚ÇÇ f‚ÇÇ‚ÇÅ g‚ÇÅ‚ÇÇ) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) X‚ÇÇ Y‚ÇÇ Z‚ÇÇ f‚ÇÇ‚ÇÇ g‚ÇÇ‚ÇÇ)))
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] [_inst_2 : CategoryTheory.Preadditive.{u1, u2} C _inst_1] [_inst_3 : CategoryTheory.Limits.HasBinaryBiproducts.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2)] {X‚ÇÅ : C} {X‚ÇÇ : C} {Y‚ÇÅ : C} {Y‚ÇÇ : C} {Z‚ÇÅ : C} {Z‚ÇÇ : C} (f‚ÇÅ‚ÇÅ : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÅ Y‚ÇÅ) (f‚ÇÅ‚ÇÇ : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÅ Y‚ÇÇ) (f‚ÇÇ‚ÇÅ : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÇ Y‚ÇÅ) (f‚ÇÇ‚ÇÇ : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÇ Y‚ÇÇ) (g‚ÇÅ‚ÇÅ : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) Y‚ÇÅ Z‚ÇÅ) (g‚ÇÅ‚ÇÇ : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) Y‚ÇÅ Z‚ÇÇ) (g‚ÇÇ‚ÇÅ : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) Y‚ÇÇ Z‚ÇÅ) (g‚ÇÇ‚ÇÇ : Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) Y‚ÇÇ Z‚ÇÇ), Eq.{succ u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X‚ÇÅ X‚ÇÇ (CategoryTheory.Limits.HasBinaryBiproducts.has_binary_biproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_3 X‚ÇÅ X‚ÇÇ)) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) Z‚ÇÅ Z‚ÇÇ (CategoryTheory.Limits.HasBinaryBiproducts.has_binary_biproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_3 Z‚ÇÅ Z‚ÇÇ))) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) X‚ÇÅ X‚ÇÇ (CategoryTheory.Limits.HasBinaryBiproducts.has_binary_biproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_3 X‚ÇÅ X‚ÇÇ)) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) Y‚ÇÅ Y‚ÇÇ (CategoryTheory.Limits.HasBinaryBiproducts.has_binary_biproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_3 Y‚ÇÅ Y‚ÇÇ)) (CategoryTheory.Limits.biprod.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) Z‚ÇÅ Z‚ÇÇ (CategoryTheory.Limits.HasBinaryBiproducts.has_binary_biproduct.{u1, u2} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u2} C _inst_1 _inst_2) _inst_3 Z‚ÇÅ Z‚ÇÇ)) (CategoryTheory.Biprod.ofComponents.{u1, u2} C _inst_1 _inst_2 _inst_3 X‚ÇÅ X‚ÇÇ Y‚ÇÅ Y‚ÇÇ f‚ÇÅ‚ÇÅ f‚ÇÅ‚ÇÇ f‚ÇÇ‚ÇÅ f‚ÇÇ‚ÇÇ) (CategoryTheory.Biprod.ofComponents.{u1, u2} C _inst_1 _inst_2 _inst_3 Y‚ÇÅ Y‚ÇÇ Z‚ÇÅ Z‚ÇÇ g‚ÇÅ‚ÇÅ g‚ÇÅ‚ÇÇ g‚ÇÇ‚ÇÅ g‚ÇÇ‚ÇÇ)) (CategoryTheory.Biprod.ofComponents.{u1, u2} C _inst_1 _inst_2 _inst_3 X‚ÇÅ X‚ÇÇ Z‚ÇÅ Z‚ÇÇ (HAdd.hAdd.{u1, u1, u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÅ Z‚ÇÅ) (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÅ Z‚ÇÅ) (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÅ Z‚ÇÅ) (instHAdd.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÅ Z‚ÇÅ) (AddZeroClass.toAdd.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÅ Z‚ÇÅ) (AddMonoid.toAddZeroClass.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÅ Z‚ÇÅ) (SubNegMonoid.toAddMonoid.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÅ Z‚ÇÅ) (AddGroup.toSubNegMonoid.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÅ Z‚ÇÅ) (AddCommGroup.toAddGroup.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÅ Z‚ÇÅ) (CategoryTheory.Preadditive.homGroup.{u1, u2} C _inst_1 _inst_2 X‚ÇÅ Z‚ÇÅ))))))) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) X‚ÇÅ Y‚ÇÅ Z‚ÇÅ f‚ÇÅ‚ÇÅ g‚ÇÅ‚ÇÅ) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) X‚ÇÅ Y‚ÇÇ Z‚ÇÅ f‚ÇÅ‚ÇÇ g‚ÇÇ‚ÇÅ)) (HAdd.hAdd.{u1, u1, u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÅ Z‚ÇÇ) (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÅ Z‚ÇÇ) (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÅ Z‚ÇÇ) (instHAdd.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÅ Z‚ÇÇ) (AddZeroClass.toAdd.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÅ Z‚ÇÇ) (AddMonoid.toAddZeroClass.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÅ Z‚ÇÇ) (SubNegMonoid.toAddMonoid.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÅ Z‚ÇÇ) (AddGroup.toSubNegMonoid.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÅ Z‚ÇÇ) (AddCommGroup.toAddGroup.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÅ Z‚ÇÇ) (CategoryTheory.Preadditive.homGroup.{u1, u2} C _inst_1 _inst_2 X‚ÇÅ Z‚ÇÇ))))))) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) X‚ÇÅ Y‚ÇÅ Z‚ÇÇ f‚ÇÅ‚ÇÅ g‚ÇÅ‚ÇÇ) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) X‚ÇÅ Y‚ÇÇ Z‚ÇÇ f‚ÇÅ‚ÇÇ g‚ÇÇ‚ÇÇ)) (HAdd.hAdd.{u1, u1, u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÇ Z‚ÇÅ) (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÇ Z‚ÇÅ) (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÇ Z‚ÇÅ) (instHAdd.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÇ Z‚ÇÅ) (AddZeroClass.toAdd.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÇ Z‚ÇÅ) (AddMonoid.toAddZeroClass.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÇ Z‚ÇÅ) (SubNegMonoid.toAddMonoid.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÇ Z‚ÇÅ) (AddGroup.toSubNegMonoid.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÇ Z‚ÇÅ) (AddCommGroup.toAddGroup.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÇ Z‚ÇÅ) (CategoryTheory.Preadditive.homGroup.{u1, u2} C _inst_1 _inst_2 X‚ÇÇ Z‚ÇÅ))))))) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) X‚ÇÇ Y‚ÇÅ Z‚ÇÅ f‚ÇÇ‚ÇÅ g‚ÇÅ‚ÇÅ) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) X‚ÇÇ Y‚ÇÇ Z‚ÇÅ f‚ÇÇ‚ÇÇ g‚ÇÇ‚ÇÅ)) (HAdd.hAdd.{u1, u1, u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÇ Z‚ÇÇ) (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÇ Z‚ÇÇ) (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÇ Z‚ÇÇ) (instHAdd.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÇ Z‚ÇÇ) (AddZeroClass.toAdd.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÇ Z‚ÇÇ) (AddMonoid.toAddZeroClass.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÇ Z‚ÇÇ) (SubNegMonoid.toAddMonoid.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÇ Z‚ÇÇ) (AddGroup.toSubNegMonoid.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÇ Z‚ÇÇ) (AddCommGroup.toAddGroup.{u1} (Quiver.Hom.{succ u1, u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) X‚ÇÇ Z‚ÇÇ) (CategoryTheory.Preadditive.homGroup.{u1, u2} C _inst_1 _inst_2 X‚ÇÇ Z‚ÇÇ))))))) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) X‚ÇÇ Y‚ÇÅ Z‚ÇÇ f‚ÇÇ‚ÇÅ g‚ÇÅ‚ÇÇ) (CategoryTheory.CategoryStruct.comp.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1) X‚ÇÇ Y‚ÇÇ Z‚ÇÇ f‚ÇÇ‚ÇÇ g‚ÇÇ‚ÇÇ)))
Case conversion may be inaccurate. Consider using '#align category_theory.biprod.of_components_comp CategoryTheory.Biprod.ofComponents_comp‚Çì'. -/
@[simp]
theorem Biprod.ofComponents_comp {X‚ÇÅ X‚ÇÇ Y‚ÇÅ Y‚ÇÇ Z‚ÇÅ Z‚ÇÇ : C} (f‚ÇÅ‚ÇÅ : X‚ÇÅ ‚ü∂ Y‚ÇÅ) (f‚ÇÅ‚ÇÇ : X‚ÇÅ ‚ü∂ Y‚ÇÇ)
    (f‚ÇÇ‚ÇÅ : X‚ÇÇ ‚ü∂ Y‚ÇÅ) (f‚ÇÇ‚ÇÇ : X‚ÇÇ ‚ü∂ Y‚ÇÇ) (g‚ÇÅ‚ÇÅ : Y‚ÇÅ ‚ü∂ Z‚ÇÅ) (g‚ÇÅ‚ÇÇ : Y‚ÇÅ ‚ü∂ Z‚ÇÇ) (g‚ÇÇ‚ÇÅ : Y‚ÇÇ ‚ü∂ Z‚ÇÅ)
    (g‚ÇÇ‚ÇÇ : Y‚ÇÇ ‚ü∂ Z‚ÇÇ) :
    Biprod.ofComponents f‚ÇÅ‚ÇÅ f‚ÇÅ‚ÇÇ f‚ÇÇ‚ÇÅ f‚ÇÇ‚ÇÇ ‚â´ Biprod.ofComponents g‚ÇÅ‚ÇÅ g‚ÇÅ‚ÇÇ g‚ÇÇ‚ÇÅ g‚ÇÇ‚ÇÇ =
      Biprod.ofComponents (f‚ÇÅ‚ÇÅ ‚â´ g‚ÇÅ‚ÇÅ + f‚ÇÅ‚ÇÇ ‚â´ g‚ÇÇ‚ÇÅ) (f‚ÇÅ‚ÇÅ ‚â´ g‚ÇÅ‚ÇÇ + f‚ÇÅ‚ÇÇ ‚â´ g‚ÇÇ‚ÇÇ) (f‚ÇÇ‚ÇÅ ‚â´ g‚ÇÅ‚ÇÅ + f‚ÇÇ‚ÇÇ ‚â´ g‚ÇÇ‚ÇÅ)
        (f‚ÇÇ‚ÇÅ ‚â´ g‚ÇÅ‚ÇÇ + f‚ÇÇ‚ÇÇ ‚â´ g‚ÇÇ‚ÇÇ) :=
  by
  dsimp [biprod.of_components]
  apply biprod.hom_ext <;> apply biprod.hom_ext' <;>
    simp only [add_comp, comp_add, add_comp_assoc, add_zero, zero_add, biprod.inl_fst,
      biprod.inl_snd, biprod.inr_fst, biprod.inr_snd, biprod.inl_fst_assoc, biprod.inl_snd_assoc,
      biprod.inr_fst_assoc, biprod.inr_snd_assoc, comp_zero, zero_comp, category.comp_id,
      category.assoc]
#align category_theory.biprod.of_components_comp CategoryTheory.Biprod.ofComponents_comp

#print CategoryTheory.Biprod.unipotentUpper /-
/-- The unipotent upper triangular matrix
```
(1 r)
(0 1)
```
as an isomorphism.
-/
@[simps]
def Biprod.unipotentUpper {X‚ÇÅ X‚ÇÇ : C} (r : X‚ÇÅ ‚ü∂ X‚ÇÇ) : X‚ÇÅ ‚äû X‚ÇÇ ‚âÖ X‚ÇÅ ‚äû X‚ÇÇ
    where
  hom := Biprod.ofComponents (ùüô _) r 0 (ùüô _)
  inv := Biprod.ofComponents (ùüô _) (-r) 0 (ùüô _)
#align category_theory.biprod.unipotent_upper CategoryTheory.Biprod.unipotentUpper
-/

#print CategoryTheory.Biprod.unipotentLower /-
/-- The unipotent lower triangular matrix
```
(1 0)
(r 1)
```
as an isomorphism.
-/
@[simps]
def Biprod.unipotentLower {X‚ÇÅ X‚ÇÇ : C} (r : X‚ÇÇ ‚ü∂ X‚ÇÅ) : X‚ÇÅ ‚äû X‚ÇÇ ‚âÖ X‚ÇÅ ‚äû X‚ÇÇ
    where
  hom := Biprod.ofComponents (ùüô _) 0 r (ùüô _)
  inv := Biprod.ofComponents (ùüô _) 0 (-r) (ùüô _)
#align category_theory.biprod.unipotent_lower CategoryTheory.Biprod.unipotentLower
-/

#print CategoryTheory.Biprod.gaussian' /-
/-- If `f` is a morphism `X‚ÇÅ ‚äû X‚ÇÇ ‚ü∂ Y‚ÇÅ ‚äû Y‚ÇÇ` whose `X‚ÇÅ ‚ü∂ Y‚ÇÅ` entry is an isomorphism,
then we can construct isomorphisms `L : X‚ÇÅ ‚äû X‚ÇÇ ‚âÖ X‚ÇÅ ‚äû X‚ÇÇ` and `R : Y‚ÇÅ ‚äû Y‚ÇÇ ‚âÖ Y‚ÇÅ ‚äû Y‚ÇÇ`
so that `L.hom ‚â´ g ‚â´ R.hom` is diagonal (with `X‚ÇÅ ‚ü∂ Y‚ÇÅ` component still `f`),
via Gaussian elimination.

(This is the version of `biprod.gaussian` written in terms of components.)
-/
def Biprod.gaussian' [IsIso f‚ÇÅ‚ÇÅ] :
    Œ£'(L : X‚ÇÅ ‚äû X‚ÇÇ ‚âÖ X‚ÇÅ ‚äû X‚ÇÇ)(R : Y‚ÇÅ ‚äû Y‚ÇÇ ‚âÖ Y‚ÇÅ ‚äû Y‚ÇÇ)(g‚ÇÇ‚ÇÇ : X‚ÇÇ ‚ü∂ Y‚ÇÇ),
      L.hom ‚â´ Biprod.ofComponents f‚ÇÅ‚ÇÅ f‚ÇÅ‚ÇÇ f‚ÇÇ‚ÇÅ f‚ÇÇ‚ÇÇ ‚â´ R.hom = biprod.map f‚ÇÅ‚ÇÅ g‚ÇÇ‚ÇÇ :=
  ‚ü®Biprod.unipotentLower (-f‚ÇÇ‚ÇÅ ‚â´ inv f‚ÇÅ‚ÇÅ), Biprod.unipotentUpper (-inv f‚ÇÅ‚ÇÅ ‚â´ f‚ÇÅ‚ÇÇ),
    f‚ÇÇ‚ÇÇ - f‚ÇÇ‚ÇÅ ‚â´ inv f‚ÇÅ‚ÇÅ ‚â´ f‚ÇÅ‚ÇÇ, by ext <;> simp <;> abel‚ü©
#align category_theory.biprod.gaussian' CategoryTheory.Biprod.gaussian'
-/

#print CategoryTheory.Biprod.gaussian /-
/-- If `f` is a morphism `X‚ÇÅ ‚äû X‚ÇÇ ‚ü∂ Y‚ÇÅ ‚äû Y‚ÇÇ` whose `X‚ÇÅ ‚ü∂ Y‚ÇÅ` entry is an isomorphism,
then we can construct isomorphisms `L : X‚ÇÅ ‚äû X‚ÇÇ ‚âÖ X‚ÇÅ ‚äû X‚ÇÇ` and `R : Y‚ÇÅ ‚äû Y‚ÇÇ ‚âÖ Y‚ÇÅ ‚äû Y‚ÇÇ`
so that `L.hom ‚â´ g ‚â´ R.hom` is diagonal (with `X‚ÇÅ ‚ü∂ Y‚ÇÅ` component still `f`),
via Gaussian elimination.
-/
def Biprod.gaussian (f : X‚ÇÅ ‚äû X‚ÇÇ ‚ü∂ Y‚ÇÅ ‚äû Y‚ÇÇ) [IsIso (biprod.inl ‚â´ f ‚â´ biprod.fst)] :
    Œ£'(L : X‚ÇÅ ‚äû X‚ÇÇ ‚âÖ X‚ÇÅ ‚äû X‚ÇÇ)(R : Y‚ÇÅ ‚äû Y‚ÇÇ ‚âÖ Y‚ÇÅ ‚äû Y‚ÇÇ)(g‚ÇÇ‚ÇÇ : X‚ÇÇ ‚ü∂ Y‚ÇÇ),
      L.hom ‚â´ f ‚â´ R.hom = biprod.map (biprod.inl ‚â´ f ‚â´ biprod.fst) g‚ÇÇ‚ÇÇ :=
  by
  let this :=
    biprod.gaussian' (biprod.inl ‚â´ f ‚â´ biprod.fst) (biprod.inl ‚â´ f ‚â´ biprod.snd)
      (biprod.inr ‚â´ f ‚â´ biprod.fst) (biprod.inr ‚â´ f ‚â´ biprod.snd)
  simpa [biprod.of_components_eq]
#align category_theory.biprod.gaussian CategoryTheory.Biprod.gaussian
-/

#print CategoryTheory.Biprod.isoElim' /-
/-- If `X‚ÇÅ ‚äû X‚ÇÇ ‚âÖ Y‚ÇÅ ‚äû Y‚ÇÇ` via a two-by-two matrix whose `X‚ÇÅ ‚ü∂ Y‚ÇÅ` entry is an isomorphism,
then we can construct an isomorphism `X‚ÇÇ ‚âÖ Y‚ÇÇ`, via Gaussian elimination.
-/
def Biprod.isoElim' [IsIso f‚ÇÅ‚ÇÅ] [IsIso (Biprod.ofComponents f‚ÇÅ‚ÇÅ f‚ÇÅ‚ÇÇ f‚ÇÇ‚ÇÅ f‚ÇÇ‚ÇÇ)] : X‚ÇÇ ‚âÖ Y‚ÇÇ :=
  by
  obtain ‚ü®L, R, g, w‚ü© := biprod.gaussian' f‚ÇÅ‚ÇÅ f‚ÇÅ‚ÇÇ f‚ÇÇ‚ÇÅ f‚ÇÇ‚ÇÇ
  letI : is_iso (biprod.map f‚ÇÅ‚ÇÅ g) := by
    rw [‚Üê w]
    infer_instance
  letI : is_iso g := is_iso_right_of_is_iso_biprod_map f‚ÇÅ‚ÇÅ g
  exact as_iso g
#align category_theory.biprod.iso_elim' CategoryTheory.Biprod.isoElim'
-/

#print CategoryTheory.Biprod.isoElim /-
/-- If `f` is an isomorphism `X‚ÇÅ ‚äû X‚ÇÇ ‚âÖ Y‚ÇÅ ‚äû Y‚ÇÇ` whose `X‚ÇÅ ‚ü∂ Y‚ÇÅ` entry is an isomorphism,
then we can construct an isomorphism `X‚ÇÇ ‚âÖ Y‚ÇÇ`, via Gaussian elimination.
-/
def Biprod.isoElim (f : X‚ÇÅ ‚äû X‚ÇÇ ‚âÖ Y‚ÇÅ ‚äû Y‚ÇÇ) [IsIso (biprod.inl ‚â´ f.hom ‚â´ biprod.fst)] : X‚ÇÇ ‚âÖ Y‚ÇÇ :=
  letI :
    is_iso
      (biprod.of_components (biprod.inl ‚â´ f.hom ‚â´ biprod.fst) (biprod.inl ‚â´ f.hom ‚â´ biprod.snd)
        (biprod.inr ‚â´ f.hom ‚â´ biprod.fst) (biprod.inr ‚â´ f.hom ‚â´ biprod.snd)) :=
    by
    simp only [biprod.of_components_eq]
    infer_instance
  biprod.iso_elim' (biprod.inl ‚â´ f.hom ‚â´ biprod.fst) (biprod.inl ‚â´ f.hom ‚â´ biprod.snd)
    (biprod.inr ‚â´ f.hom ‚â´ biprod.fst) (biprod.inr ‚â´ f.hom ‚â´ biprod.snd)
#align category_theory.biprod.iso_elim CategoryTheory.Biprod.isoElim
-/

#print CategoryTheory.Biprod.column_nonzero_of_iso /-
theorem Biprod.column_nonzero_of_iso {W X Y Z : C} (f : W ‚äû X ‚ü∂ Y ‚äû Z) [IsIso f] :
    ùüô W = 0 ‚à® biprod.inl ‚â´ f ‚â´ biprod.fst ‚â† 0 ‚à® biprod.inl ‚â´ f ‚â´ biprod.snd ‚â† 0 :=
  by
  by_contra' h
  rcases h with ‚ü®nz, a‚ÇÅ, a‚ÇÇ‚ü©
  set x := biprod.inl ‚â´ f ‚â´ inv f ‚â´ biprod.fst
  have h‚ÇÅ : x = ùüô W := by simp [x]
  have h‚ÇÄ : x = 0 := by
    dsimp [x]
    rw [‚Üê category.id_comp (inv f), category.assoc, ‚Üê biprod.total]
    conv_lhs =>
      slice 2 3
      rw [comp_add]
    simp only [category.assoc]
    rw [comp_add_assoc, add_comp]
    conv_lhs =>
      congr
      skip
      slice 1 3
      rw [a‚ÇÇ]
    simp only [zero_comp, add_zero]
    conv_lhs =>
      slice 1 3
      rw [a‚ÇÅ]
    simp only [zero_comp]
  exact nz (h‚ÇÅ.symm.trans h‚ÇÄ)
#align category_theory.biprod.column_nonzero_of_iso CategoryTheory.Biprod.column_nonzero_of_iso
-/

end

#print CategoryTheory.Biproduct.column_nonzero_of_iso' /-
theorem Biproduct.column_nonzero_of_iso' {œÉ œÑ : Type} [Finite œÑ] {S : œÉ ‚Üí C} [HasBiproduct S]
    {T : œÑ ‚Üí C} [HasBiproduct T] (s : œÉ) (f : ‚®Å S ‚ü∂ ‚®Å T) [IsIso f] :
    (‚àÄ t : œÑ, biproduct.Œπ S s ‚â´ f ‚â´ biproduct.œÄ T t = 0) ‚Üí ùüô (S s) = 0 :=
  by
  cases nonempty_fintype œÑ
  intro z
  set x := biproduct.Œπ S s ‚â´ f ‚â´ inv f ‚â´ biproduct.œÄ S s
  have h‚ÇÅ : x = ùüô (S s) := by simp [x]
  have h‚ÇÄ : x = 0 := by
    dsimp [x]
    rw [‚Üê category.id_comp (inv f), category.assoc, ‚Üê biproduct.total]
    simp only [comp_sum_assoc]
    conv_lhs =>
      congr
      apply_congr
      skip
      simp only [reassoc_of z]
    simp
  exact h‚ÇÅ.symm.trans h‚ÇÄ
#align category_theory.biproduct.column_nonzero_of_iso' CategoryTheory.Biproduct.column_nonzero_of_iso'
-/

#print CategoryTheory.Biproduct.columnNonzeroOfIso /-
/-- If `f : ‚®Å S ‚ü∂ ‚®Å T` is an isomorphism, and `s` is a non-trivial summand of the source,
then there is some `t` in the target so that the `s, t` matrix entry of `f` is nonzero.
-/
def Biproduct.columnNonzeroOfIso {œÉ œÑ : Type} [Fintype œÑ] {S : œÉ ‚Üí C} [HasBiproduct S] {T : œÑ ‚Üí C}
    [HasBiproduct T] (s : œÉ) (nz : ùüô (S s) ‚â† 0) (f : ‚®Å S ‚ü∂ ‚®Å T) [IsIso f] :
    Trunc (Œ£'t : œÑ, biproduct.Œπ S s ‚â´ f ‚â´ biproduct.œÄ T t ‚â† 0) := by
  classical
    apply truncSigmaOfExists
    have t := Biproduct.column_nonzero_of_iso'.{v} s f
    by_contra h
    simp only [not_exists_not] at h
    exact nz (t h)
#align category_theory.biproduct.column_nonzero_of_iso CategoryTheory.Biproduct.columnNonzeroOfIso
-/

section Preadditive

variable {D : Type u'} [Category.{v'} D] [Preadditive.{v'} D]

variable (F : C ‚•§ D) [PreservesZeroMorphisms F]

namespace Limits

section Fintype

variable {J : Type} [Fintype J]

attribute [local tidy] tactic.discrete_cases

#print CategoryTheory.Limits.preservesProductOfPreservesBiproduct /-
/-- A functor between preadditive categories that preserves (zero morphisms and) finite biproducts
    preserves finite products. -/
def preservesProductOfPreservesBiproduct {f : J ‚Üí C} [PreservesBiproduct f F] :
    PreservesLimit (Discrete.functor f) F
    where preserves c hc :=
    IsLimit.ofIsoLimit
        ((IsLimit.postcomposeInvEquiv (Discrete.compNatIsoDiscrete _ _) _).symm
          (isBilimitOfPreserves F (biconeIsBilimitOfLimitConeOfIsLimit hc)).IsLimit) <|
      Cones.ext (Iso.refl _) (by tidy)
#align category_theory.limits.preserves_product_of_preserves_biproduct CategoryTheory.Limits.preservesProductOfPreservesBiproduct
-/

section

attribute [local instance] preserves_product_of_preserves_biproduct

#print CategoryTheory.Limits.preservesProductsOfShapeOfPreservesBiproductsOfShape /-
/-- A functor between preadditive categories that preserves (zero morphisms and) finite biproducts
    preserves finite products. -/
def preservesProductsOfShapeOfPreservesBiproductsOfShape [PreservesBiproductsOfShape J F] :
    PreservesLimitsOfShape (Discrete J) F
    where PreservesLimit f := preservesLimitOfIsoDiagram _ Discrete.natIsoFunctor.symm
#align category_theory.limits.preserves_products_of_shape_of_preserves_biproducts_of_shape CategoryTheory.Limits.preservesProductsOfShapeOfPreservesBiproductsOfShape
-/

end

#print CategoryTheory.Limits.preservesBiproductOfPreservesProduct /-
/-- A functor between preadditive categories that preserves (zero morphisms and) finite products
    preserves finite biproducts. -/
def preservesBiproductOfPreservesProduct {f : J ‚Üí C} [PreservesLimit (Discrete.functor f) F] :
    PreservesBiproduct f F
    where preserves b hb :=
    isBilimitOfIsLimit _ <|
      IsLimit.ofIsoLimit
          ((IsLimit.postcomposeHomEquiv (Discrete.compNatIsoDiscrete _ _) (F.mapCone b.toCone)).symm
            (isLimitOfPreserves F hb.IsLimit)) <|
        Cones.ext (Iso.refl _) (by tidy)
#align category_theory.limits.preserves_biproduct_of_preserves_product CategoryTheory.Limits.preservesBiproductOfPreservesProduct
-/

/- warning: category_theory.limits.preserves_biproduct_of_mono_biproduct_comparison -> CategoryTheory.Limits.preservesBiproductOfMonoBiproductComparison is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u1, u3} C] [_inst_2 : CategoryTheory.Preadditive.{u1, u3} C _inst_1] {D : Type.{u4}} [_inst_3 : CategoryTheory.Category.{u2, u4} D] [_inst_4 : CategoryTheory.Preadditive.{u2, u4} D _inst_3] (F : CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_3) [_inst_5 : CategoryTheory.Functor.PreservesZeroMorphisms.{u1, u2, u3, u4} C _inst_1 D _inst_3 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u3} C _inst_1 _inst_2) (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u4} D _inst_3 _inst_4) F] {J : Type} [_inst_6 : Fintype.{0} J] {f : J -> C} [_inst_7 : CategoryTheory.Limits.HasBiproduct.{0, u1, u3} J C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u3} C _inst_1 _inst_2) f] [_inst_8 : CategoryTheory.Limits.HasBiproduct.{0, u2, u4} J D _inst_3 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u4} D _inst_3 _inst_4) (Function.comp.{1, succ u3, succ u4} J C D (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_3 F) f)] [_inst_9 : CategoryTheory.Mono.{u2, u4} D _inst_3 (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_3 F (CategoryTheory.Limits.biproduct.{0, u1, u3} J C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u3} C _inst_1 _inst_2) f _inst_7)) (CategoryTheory.Limits.biproduct.{0, u2, u4} J D _inst_3 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u4} D _inst_3 _inst_4) (Function.comp.{1, succ u3, succ u4} J C D (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_3 F) f) _inst_8) (CategoryTheory.Functor.biproductComparison.{0, u1, u2, u3, u4} C _inst_1 D _inst_3 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u3} C _inst_1 _inst_2) (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u4} D _inst_3 _inst_4) J F f _inst_7 _inst_8)], CategoryTheory.Limits.PreservesBiproduct.{0, u1, u2, u3, u4} C _inst_1 D _inst_3 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u3} C _inst_1 _inst_2) (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u4} D _inst_3 _inst_4) J f F _inst_5
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u1, u3} C] [_inst_2 : CategoryTheory.Preadditive.{u1, u3} C _inst_1] {D : Type.{u4}} [_inst_3 : CategoryTheory.Category.{u2, u4} D] [_inst_4 : CategoryTheory.Preadditive.{u2, u4} D _inst_3] (F : CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_3) [_inst_5 : CategoryTheory.Functor.PreservesZeroMorphisms.{u1, u2, u3, u4} C _inst_1 D _inst_3 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u3} C _inst_1 _inst_2) (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u4} D _inst_3 _inst_4) F] {J : Type} [_inst_6 : Fintype.{0} J] {f : J -> C} [_inst_7 : CategoryTheory.Limits.HasBiproduct.{0, u1, u3} J C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u3} C _inst_1 _inst_2) f] [_inst_8 : CategoryTheory.Limits.HasBiproduct.{0, u2, u4} J D _inst_3 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u4} D _inst_3 _inst_4) (Function.comp.{1, succ u3, succ u4} J C D (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_3 F)) f)] [_inst_9 : CategoryTheory.Mono.{u2, u4} D _inst_3 (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_3 F) (CategoryTheory.Limits.biproduct.{0, u1, u3} J C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u3} C _inst_1 _inst_2) f _inst_7)) (CategoryTheory.Limits.biproduct.{0, u2, u4} J D _inst_3 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u4} D _inst_3 _inst_4) (Function.comp.{1, succ u3, succ u4} J C D (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_3 F)) f) _inst_8) (CategoryTheory.Functor.biproductComparison.{0, u1, u2, u3, u4} C _inst_1 D _inst_3 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u3} C _inst_1 _inst_2) (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u4} D _inst_3 _inst_4) J F f _inst_7 _inst_8)], CategoryTheory.Limits.PreservesBiproduct.{0, u1, u2, u3, u4} C _inst_1 D _inst_3 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u3} C _inst_1 _inst_2) (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u4} D _inst_3 _inst_4) J f F _inst_5
Case conversion may be inaccurate. Consider using '#align category_theory.limits.preserves_biproduct_of_mono_biproduct_comparison CategoryTheory.Limits.preservesBiproductOfMonoBiproductComparison‚Çì'. -/
/-- If the (product-like) biproduct comparison for `F` and `f` is a monomorphism, then `F`
    preserves the biproduct of `f`. For the converse, see `map_biproduct`. -/
def preservesBiproductOfMonoBiproductComparison {f : J ‚Üí C} [HasBiproduct f]
    [HasBiproduct (F.obj ‚àò f)] [Mono (biproductComparison F f)] : PreservesBiproduct f F :=
  by
  have :
    pi_comparison F f =
      (F.map_iso (biproduct.iso_product f)).inv ‚â´
        biproduct_comparison F f ‚â´ (biproduct.iso_product _).hom :=
    by
    ext
    convert pi_comparison_comp_œÄ F f j.as <;> simp [‚Üê functor.map_comp]
  haveI : is_iso (biproduct_comparison F f) := is_iso_of_mono_of_is_split_epi _
  haveI : is_iso (pi_comparison F f) := by
    rw [this]
    infer_instance
  haveI := preserves_product.of_iso_comparison F f
  apply preserves_biproduct_of_preserves_product
#align category_theory.limits.preserves_biproduct_of_mono_biproduct_comparison CategoryTheory.Limits.preservesBiproductOfMonoBiproductComparison

/- warning: category_theory.limits.preserves_biproduct_of_epi_biproduct_comparison' -> CategoryTheory.Limits.preservesBiproductOfEpiBiproductComparison' is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u1, u3} C] [_inst_2 : CategoryTheory.Preadditive.{u1, u3} C _inst_1] {D : Type.{u4}} [_inst_3 : CategoryTheory.Category.{u2, u4} D] [_inst_4 : CategoryTheory.Preadditive.{u2, u4} D _inst_3] (F : CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_3) [_inst_5 : CategoryTheory.Functor.PreservesZeroMorphisms.{u1, u2, u3, u4} C _inst_1 D _inst_3 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u3} C _inst_1 _inst_2) (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u4} D _inst_3 _inst_4) F] {J : Type} [_inst_6 : Fintype.{0} J] {f : J -> C} [_inst_7 : CategoryTheory.Limits.HasBiproduct.{0, u1, u3} J C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u3} C _inst_1 _inst_2) f] [_inst_8 : CategoryTheory.Limits.HasBiproduct.{0, u2, u4} J D _inst_3 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u4} D _inst_3 _inst_4) (Function.comp.{1, succ u3, succ u4} J C D (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_3 F) f)] [_inst_9 : CategoryTheory.Epi.{u2, u4} D _inst_3 (CategoryTheory.Limits.biproduct.{0, u2, u4} J D _inst_3 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u4} D _inst_3 _inst_4) (Function.comp.{1, succ u3, succ u4} J C D (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_3 F) f) _inst_8) (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_3 F (CategoryTheory.Limits.biproduct.{0, u1, u3} J C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u3} C _inst_1 _inst_2) f _inst_7)) (CategoryTheory.Functor.biproductComparison'.{0, u1, u2, u3, u4} C _inst_1 D _inst_3 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u3} C _inst_1 _inst_2) (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u4} D _inst_3 _inst_4) J F f _inst_7 _inst_8)], CategoryTheory.Limits.PreservesBiproduct.{0, u1, u2, u3, u4} C _inst_1 D _inst_3 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u3} C _inst_1 _inst_2) (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u4} D _inst_3 _inst_4) J f F _inst_5
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u1, u3} C] [_inst_2 : CategoryTheory.Preadditive.{u1, u3} C _inst_1] {D : Type.{u4}} [_inst_3 : CategoryTheory.Category.{u2, u4} D] [_inst_4 : CategoryTheory.Preadditive.{u2, u4} D _inst_3] (F : CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_3) [_inst_5 : CategoryTheory.Functor.PreservesZeroMorphisms.{u1, u2, u3, u4} C _inst_1 D _inst_3 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u3} C _inst_1 _inst_2) (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u4} D _inst_3 _inst_4) F] {J : Type} [_inst_6 : Fintype.{0} J] {f : J -> C} [_inst_7 : CategoryTheory.Limits.HasBiproduct.{0, u1, u3} J C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u3} C _inst_1 _inst_2) f] [_inst_8 : CategoryTheory.Limits.HasBiproduct.{0, u2, u4} J D _inst_3 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u4} D _inst_3 _inst_4) (Function.comp.{1, succ u3, succ u4} J C D (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_3 F)) f)] [_inst_9 : CategoryTheory.Epi.{u2, u4} D _inst_3 (CategoryTheory.Limits.biproduct.{0, u2, u4} J D _inst_3 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u4} D _inst_3 _inst_4) (Function.comp.{1, succ u3, succ u4} J C D (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_3 F)) f) _inst_8) (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_3 F) (CategoryTheory.Limits.biproduct.{0, u1, u3} J C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u3} C _inst_1 _inst_2) f _inst_7)) (CategoryTheory.Functor.biproductComparison'.{0, u1, u2, u3, u4} C _inst_1 D _inst_3 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u3} C _inst_1 _inst_2) (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u4} D _inst_3 _inst_4) J F f _inst_7 _inst_8)], CategoryTheory.Limits.PreservesBiproduct.{0, u1, u2, u3, u4} C _inst_1 D _inst_3 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u3} C _inst_1 _inst_2) (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u4} D _inst_3 _inst_4) J f F _inst_5
Case conversion may be inaccurate. Consider using '#align category_theory.limits.preserves_biproduct_of_epi_biproduct_comparison' CategoryTheory.Limits.preservesBiproductOfEpiBiproductComparison'‚Çì'. -/
/-- If the (coproduct-like) biproduct comparison for `F` and `f` is an epimorphism, then `F`
    preserves the biproduct of `F` and `f`. For the converse, see `map_biproduct`. -/
def preservesBiproductOfEpiBiproductComparison' {f : J ‚Üí C} [HasBiproduct f]
    [HasBiproduct (F.obj ‚àò f)] [Epi (biproductComparison' F f)] : PreservesBiproduct f F :=
  by
  haveI : epi (split_epi_biproduct_comparison F f).section_ := by simpa
  haveI : is_iso (biproduct_comparison F f) :=
    is_iso.of_epi_section' (split_epi_biproduct_comparison F f)
  apply preserves_biproduct_of_mono_biproduct_comparison
#align category_theory.limits.preserves_biproduct_of_epi_biproduct_comparison' CategoryTheory.Limits.preservesBiproductOfEpiBiproductComparison'

#print CategoryTheory.Limits.preservesBiproductsOfShapeOfPreservesProductsOfShape /-
/-- A functor between preadditive categories that preserves (zero morphisms and) finite products
    preserves finite biproducts. -/
def preservesBiproductsOfShapeOfPreservesProductsOfShape [PreservesLimitsOfShape (Discrete J) F] :
    PreservesBiproductsOfShape J F where preserves f := preservesBiproductOfPreservesProduct F
#align category_theory.limits.preserves_biproducts_of_shape_of_preserves_products_of_shape CategoryTheory.Limits.preservesBiproductsOfShapeOfPreservesProductsOfShape
-/

#print CategoryTheory.Limits.preservesCoproductOfPreservesBiproduct /-
/-- A functor between preadditive categories that preserves (zero morphisms and) finite biproducts
    preserves finite coproducts. -/
def preservesCoproductOfPreservesBiproduct {f : J ‚Üí C} [PreservesBiproduct f F] :
    PreservesColimit (Discrete.functor f) F
    where preserves c hc :=
    IsColimit.ofIsoColimit
        ((IsColimit.precomposeHomEquiv (Discrete.compNatIsoDiscrete _ _) _).symm
          (isBilimitOfPreserves F (biconeIsBilimitOfColimitCoconeOfIsColimit hc)).IsColimit) <|
      Cocones.ext (Iso.refl _) (by tidy)
#align category_theory.limits.preserves_coproduct_of_preserves_biproduct CategoryTheory.Limits.preservesCoproductOfPreservesBiproduct
-/

section

attribute [local instance] preserves_coproduct_of_preserves_biproduct

#print CategoryTheory.Limits.preservesCoproductsOfShapeOfPreservesBiproductsOfShape /-
/-- A functor between preadditive categories that preserves (zero morphisms and) finite biproducts
    preserves finite coproducts. -/
def preservesCoproductsOfShapeOfPreservesBiproductsOfShape [PreservesBiproductsOfShape J F] :
    PreservesColimitsOfShape (Discrete J) F
    where PreservesColimit f := preservesColimitOfIsoDiagram _ Discrete.natIsoFunctor.symm
#align category_theory.limits.preserves_coproducts_of_shape_of_preserves_biproducts_of_shape CategoryTheory.Limits.preservesCoproductsOfShapeOfPreservesBiproductsOfShape
-/

end

#print CategoryTheory.Limits.preservesBiproductOfPreservesCoproduct /-
/-- A functor between preadditive categories that preserves (zero morphisms and) finite coproducts
    preserves finite biproducts. -/
def preservesBiproductOfPreservesCoproduct {f : J ‚Üí C} [PreservesColimit (Discrete.functor f) F] :
    PreservesBiproduct f F
    where preserves b hb :=
    isBilimitOfIsColimit _ <|
      IsColimit.ofIsoColimit
          ((IsColimit.precomposeInvEquiv (Discrete.compNatIsoDiscrete _ _)
                (F.mapCocone b.toCocone)).symm
            (isColimitOfPreserves F hb.IsColimit)) <|
        Cocones.ext (Iso.refl _) (by tidy)
#align category_theory.limits.preserves_biproduct_of_preserves_coproduct CategoryTheory.Limits.preservesBiproductOfPreservesCoproduct
-/

#print CategoryTheory.Limits.preservesBiproductsOfShapeOfPreservesCoproductsOfShape /-
/-- A functor between preadditive categories that preserves (zero morphisms and) finite coproducts
    preserves finite biproducts. -/
def preservesBiproductsOfShapeOfPreservesCoproductsOfShape
    [PreservesColimitsOfShape (Discrete J) F] : PreservesBiproductsOfShape J F
    where preserves f := preservesBiproductOfPreservesCoproduct F
#align category_theory.limits.preserves_biproducts_of_shape_of_preserves_coproducts_of_shape CategoryTheory.Limits.preservesBiproductsOfShapeOfPreservesCoproductsOfShape
-/

end Fintype

#print CategoryTheory.Limits.preservesBinaryProductOfPreservesBinaryBiproduct /-
/-- A functor between preadditive categories that preserves (zero morphisms and) binary biproducts
    preserves binary products. -/
def preservesBinaryProductOfPreservesBinaryBiproduct {X Y : C} [PreservesBinaryBiproduct X Y F] :
    PreservesLimit (pair X Y) F
    where preserves c hc :=
    IsLimit.ofIsoLimit
        ((IsLimit.postcomposeInvEquiv (diagram_iso_pair _) _).symm
          (isBinaryBilimitOfPreserves F (binaryBiconeIsBilimitOfLimitConeOfIsLimit hc)).IsLimit) <|
      Cones.ext (Iso.refl _) fun j => by
        rcases j with ‚ü®‚ü®‚ü©‚ü©
        tidy
#align category_theory.limits.preserves_binary_product_of_preserves_binary_biproduct CategoryTheory.Limits.preservesBinaryProductOfPreservesBinaryBiproduct
-/

section

attribute [local instance] preserves_binary_product_of_preserves_binary_biproduct

#print CategoryTheory.Limits.preservesBinaryProductsOfPreservesBinaryBiproducts /-
/-- A functor between preadditive categories that preserves (zero morphisms and) binary biproducts
    preserves binary products. -/
def preservesBinaryProductsOfPreservesBinaryBiproducts [PreservesBinaryBiproducts F] :
    PreservesLimitsOfShape (Discrete WalkingPair) F
    where PreservesLimit K := preservesLimitOfIsoDiagram _ (diagramIsoPair _).symm
#align category_theory.limits.preserves_binary_products_of_preserves_binary_biproducts CategoryTheory.Limits.preservesBinaryProductsOfPreservesBinaryBiproducts
-/

end

#print CategoryTheory.Limits.preservesBinaryBiproductOfPreservesBinaryProduct /-
/-- A functor between preadditive categories that preserves (zero morphisms and) binary products
    preserves binary biproducts. -/
def preservesBinaryBiproductOfPreservesBinaryProduct {X Y : C} [PreservesLimit (pair X Y) F] :
    PreservesBinaryBiproduct X Y F
    where preserves b hb :=
    isBinaryBilimitOfIsLimit _ <|
      IsLimit.ofIsoLimit
          ((IsLimit.postcomposeHomEquiv (diagram_iso_pair _) (F.mapCone b.toCone)).symm
            (isLimitOfPreserves F hb.IsLimit)) <|
        Cones.ext (Iso.refl _) fun j => by
          rcases j with ‚ü®‚ü®‚ü©‚ü©
          tidy
#align category_theory.limits.preserves_binary_biproduct_of_preserves_binary_product CategoryTheory.Limits.preservesBinaryBiproductOfPreservesBinaryProduct
-/

/- warning: category_theory.limits.preserves_binary_biproduct_of_mono_biprod_comparison -> CategoryTheory.Limits.preservesBinaryBiproductOfMonoBiprodComparison is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u1, u3} C] [_inst_2 : CategoryTheory.Preadditive.{u1, u3} C _inst_1] {D : Type.{u4}} [_inst_3 : CategoryTheory.Category.{u2, u4} D] [_inst_4 : CategoryTheory.Preadditive.{u2, u4} D _inst_3] (F : CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_3) [_inst_5 : CategoryTheory.Functor.PreservesZeroMorphisms.{u1, u2, u3, u4} C _inst_1 D _inst_3 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u3} C _inst_1 _inst_2) (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u4} D _inst_3 _inst_4) F] {X : C} {Y : C} [_inst_6 : CategoryTheory.Limits.HasBinaryBiproduct.{u1, u3} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u3} C _inst_1 _inst_2) X Y] [_inst_7 : CategoryTheory.Limits.HasBinaryBiproduct.{u2, u4} D _inst_3 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u4} D _inst_3 _inst_4) (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_3 F X) (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_3 F Y)] [_inst_8 : CategoryTheory.Mono.{u2, u4} D _inst_3 (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_3 F (CategoryTheory.Limits.biprod.{u1, u3} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u3} C _inst_1 _inst_2) X Y _inst_6)) (CategoryTheory.Limits.biprod.{u2, u4} D _inst_3 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u4} D _inst_3 _inst_4) (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_3 F X) (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_3 F Y) _inst_7) (CategoryTheory.Functor.biprodComparison.{u1, u2, u3, u4} C _inst_1 D _inst_3 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u3} C _inst_1 _inst_2) (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u4} D _inst_3 _inst_4) F X Y _inst_6 _inst_7)], CategoryTheory.Limits.PreservesBinaryBiproduct.{u1, u2, u3, u4} C _inst_1 D _inst_3 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u3} C _inst_1 _inst_2) (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u4} D _inst_3 _inst_4) X Y F _inst_5
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u1, u3} C] [_inst_2 : CategoryTheory.Preadditive.{u1, u3} C _inst_1] {D : Type.{u4}} [_inst_3 : CategoryTheory.Category.{u2, u4} D] [_inst_4 : CategoryTheory.Preadditive.{u2, u4} D _inst_3] (F : CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_3) [_inst_5 : CategoryTheory.Functor.PreservesZeroMorphisms.{u1, u2, u3, u4} C _inst_1 D _inst_3 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u3} C _inst_1 _inst_2) (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u4} D _inst_3 _inst_4) F] {X : C} {Y : C} [_inst_6 : CategoryTheory.Limits.HasBinaryBiproduct.{u1, u3} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u3} C _inst_1 _inst_2) X Y] [_inst_7 : CategoryTheory.Limits.HasBinaryBiproduct.{u2, u4} D _inst_3 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u4} D _inst_3 _inst_4) (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_3 F) X) (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_3 F) Y)] [_inst_8 : CategoryTheory.Mono.{u2, u4} D _inst_3 (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_3 F) (CategoryTheory.Limits.biprod.{u1, u3} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u3} C _inst_1 _inst_2) X Y _inst_6)) (CategoryTheory.Limits.biprod.{u2, u4} D _inst_3 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u4} D _inst_3 _inst_4) (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_3 F) X) (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_3 F) Y) _inst_7) (CategoryTheory.Functor.biprodComparison.{u1, u2, u3, u4} C _inst_1 D _inst_3 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u3} C _inst_1 _inst_2) (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u4} D _inst_3 _inst_4) F X Y _inst_6 _inst_7)], CategoryTheory.Limits.PreservesBinaryBiproduct.{u1, u2, u3, u4} C _inst_1 D _inst_3 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u3} C _inst_1 _inst_2) (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u4} D _inst_3 _inst_4) X Y F _inst_5
Case conversion may be inaccurate. Consider using '#align category_theory.limits.preserves_binary_biproduct_of_mono_biprod_comparison CategoryTheory.Limits.preservesBinaryBiproductOfMonoBiprodComparison‚Çì'. -/
/-- If the (product-like) biproduct comparison for `F`, `X` and `Y` is a monomorphism, then
    `F` preserves the biproduct of `X` and `Y`. For the converse, see `map_biprod`. -/
def preservesBinaryBiproductOfMonoBiprodComparison {X Y : C} [HasBinaryBiproduct X Y]
    [HasBinaryBiproduct (F.obj X) (F.obj Y)] [Mono (biprodComparison F X Y)] :
    PreservesBinaryBiproduct X Y F :=
  by
  have :
    prod_comparison F X Y =
      (F.map_iso (biprod.iso_prod X Y)).inv ‚â´ biprod_comparison F X Y ‚â´ (biprod.iso_prod _ _).hom :=
    by ext <;> simp [‚Üê functor.map_comp]
  haveI : is_iso (biprod_comparison F X Y) := is_iso_of_mono_of_is_split_epi _
  haveI : is_iso (prod_comparison F X Y) := by
    rw [this]
    infer_instance
  haveI := preserves_limit_pair.of_iso_prod_comparison F X Y
  apply preserves_binary_biproduct_of_preserves_binary_product
#align category_theory.limits.preserves_binary_biproduct_of_mono_biprod_comparison CategoryTheory.Limits.preservesBinaryBiproductOfMonoBiprodComparison

/- warning: category_theory.limits.preserves_binary_biproduct_of_epi_biprod_comparison' -> CategoryTheory.Limits.preservesBinaryBiproductOfEpiBiprodComparison' is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u1, u3} C] [_inst_2 : CategoryTheory.Preadditive.{u1, u3} C _inst_1] {D : Type.{u4}} [_inst_3 : CategoryTheory.Category.{u2, u4} D] [_inst_4 : CategoryTheory.Preadditive.{u2, u4} D _inst_3] (F : CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_3) [_inst_5 : CategoryTheory.Functor.PreservesZeroMorphisms.{u1, u2, u3, u4} C _inst_1 D _inst_3 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u3} C _inst_1 _inst_2) (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u4} D _inst_3 _inst_4) F] {X : C} {Y : C} [_inst_6 : CategoryTheory.Limits.HasBinaryBiproduct.{u1, u3} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u3} C _inst_1 _inst_2) X Y] [_inst_7 : CategoryTheory.Limits.HasBinaryBiproduct.{u2, u4} D _inst_3 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u4} D _inst_3 _inst_4) (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_3 F X) (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_3 F Y)] [_inst_8 : CategoryTheory.Epi.{u2, u4} D _inst_3 (CategoryTheory.Limits.biprod.{u2, u4} D _inst_3 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u4} D _inst_3 _inst_4) (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_3 F X) (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_3 F Y) _inst_7) (CategoryTheory.Functor.obj.{u1, u2, u3, u4} C _inst_1 D _inst_3 F (CategoryTheory.Limits.biprod.{u1, u3} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u3} C _inst_1 _inst_2) X Y _inst_6)) (CategoryTheory.Functor.biprodComparison'.{u1, u2, u3, u4} C _inst_1 D _inst_3 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u3} C _inst_1 _inst_2) (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u4} D _inst_3 _inst_4) F X Y _inst_6 _inst_7)], CategoryTheory.Limits.PreservesBinaryBiproduct.{u1, u2, u3, u4} C _inst_1 D _inst_3 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u3} C _inst_1 _inst_2) (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u4} D _inst_3 _inst_4) X Y F _inst_5
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u1, u3} C] [_inst_2 : CategoryTheory.Preadditive.{u1, u3} C _inst_1] {D : Type.{u4}} [_inst_3 : CategoryTheory.Category.{u2, u4} D] [_inst_4 : CategoryTheory.Preadditive.{u2, u4} D _inst_3] (F : CategoryTheory.Functor.{u1, u2, u3, u4} C _inst_1 D _inst_3) [_inst_5 : CategoryTheory.Functor.PreservesZeroMorphisms.{u1, u2, u3, u4} C _inst_1 D _inst_3 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u3} C _inst_1 _inst_2) (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u4} D _inst_3 _inst_4) F] {X : C} {Y : C} [_inst_6 : CategoryTheory.Limits.HasBinaryBiproduct.{u1, u3} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u3} C _inst_1 _inst_2) X Y] [_inst_7 : CategoryTheory.Limits.HasBinaryBiproduct.{u2, u4} D _inst_3 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u4} D _inst_3 _inst_4) (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_3 F) X) (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_3 F) Y)] [_inst_8 : CategoryTheory.Epi.{u2, u4} D _inst_3 (CategoryTheory.Limits.biprod.{u2, u4} D _inst_3 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u4} D _inst_3 _inst_4) (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_3 F) X) (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_3 F) Y) _inst_7) (Prefunctor.obj.{succ u1, succ u2, u3, u4} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u3} C (CategoryTheory.Category.toCategoryStruct.{u1, u3} C _inst_1)) D (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} D (CategoryTheory.Category.toCategoryStruct.{u2, u4} D _inst_3)) (CategoryTheory.Functor.toPrefunctor.{u1, u2, u3, u4} C _inst_1 D _inst_3 F) (CategoryTheory.Limits.biprod.{u1, u3} C _inst_1 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u3} C _inst_1 _inst_2) X Y _inst_6)) (CategoryTheory.Functor.biprodComparison'.{u1, u2, u3, u4} C _inst_1 D _inst_3 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u3} C _inst_1 _inst_2) (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u4} D _inst_3 _inst_4) F X Y _inst_6 _inst_7)], CategoryTheory.Limits.PreservesBinaryBiproduct.{u1, u2, u3, u4} C _inst_1 D _inst_3 (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u1, u3} C _inst_1 _inst_2) (CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.{u2, u4} D _inst_3 _inst_4) X Y F _inst_5
Case conversion may be inaccurate. Consider using '#align category_theory.limits.preserves_binary_biproduct_of_epi_biprod_comparison' CategoryTheory.Limits.preservesBinaryBiproductOfEpiBiprodComparison'‚Çì'. -/
/-- If the (coproduct-like) biproduct comparison for `F`, `X` and `Y` is an epimorphism, then
    `F` preserves the biproduct of `X` and `Y`. For the converse, see `map_biprod`. -/
def preservesBinaryBiproductOfEpiBiprodComparison' {X Y : C} [HasBinaryBiproduct X Y]
    [HasBinaryBiproduct (F.obj X) (F.obj Y)] [Epi (biprodComparison' F X Y)] :
    PreservesBinaryBiproduct X Y F :=
  by
  haveI : epi (split_epi_biprod_comparison F X Y).section_ := by simpa
  haveI : is_iso (biprod_comparison F X Y) :=
    is_iso.of_epi_section' (split_epi_biprod_comparison F X Y)
  apply preserves_binary_biproduct_of_mono_biprod_comparison
#align category_theory.limits.preserves_binary_biproduct_of_epi_biprod_comparison' CategoryTheory.Limits.preservesBinaryBiproductOfEpiBiprodComparison'

#print CategoryTheory.Limits.preservesBinaryBiproductsOfPreservesBinaryProducts /-
/-- A functor between preadditive categories that preserves (zero morphisms and) binary products
    preserves binary biproducts. -/
def preservesBinaryBiproductsOfPreservesBinaryProducts
    [PreservesLimitsOfShape (Discrete WalkingPair) F] : PreservesBinaryBiproducts F
    where preserves X Y := preservesBinaryBiproductOfPreservesBinaryProduct F
#align category_theory.limits.preserves_binary_biproducts_of_preserves_binary_products CategoryTheory.Limits.preservesBinaryBiproductsOfPreservesBinaryProducts
-/

#print CategoryTheory.Limits.preservesBinaryCoproductOfPreservesBinaryBiproduct /-
/-- A functor between preadditive categories that preserves (zero morphisms and) binary biproducts
    preserves binary coproducts. -/
def preservesBinaryCoproductOfPreservesBinaryBiproduct {X Y : C} [PreservesBinaryBiproduct X Y F] :
    PreservesColimit (pair X Y) F
    where preserves c hc :=
    IsColimit.ofIsoColimit
        ((IsColimit.precomposeHomEquiv (diagram_iso_pair _) _).symm
          (isBinaryBilimitOfPreserves F
              (binaryBiconeIsBilimitOfColimitCoconeOfIsColimit hc)).IsColimit) <|
      Cocones.ext (Iso.refl _) fun j => by
        rcases j with ‚ü®‚ü®‚ü©‚ü©
        tidy
#align category_theory.limits.preserves_binary_coproduct_of_preserves_binary_biproduct CategoryTheory.Limits.preservesBinaryCoproductOfPreservesBinaryBiproduct
-/

section

attribute [local instance] preserves_binary_coproduct_of_preserves_binary_biproduct

#print CategoryTheory.Limits.preservesBinaryCoproductsOfPreservesBinaryBiproducts /-
/-- A functor between preadditive categories that preserves (zero morphisms and) binary biproducts
    preserves binary coproducts. -/
def preservesBinaryCoproductsOfPreservesBinaryBiproducts [PreservesBinaryBiproducts F] :
    PreservesColimitsOfShape (Discrete WalkingPair) F
    where PreservesColimit K := preservesColimitOfIsoDiagram _ (diagramIsoPair _).symm
#align category_theory.limits.preserves_binary_coproducts_of_preserves_binary_biproducts CategoryTheory.Limits.preservesBinaryCoproductsOfPreservesBinaryBiproducts
-/

end

#print CategoryTheory.Limits.preservesBinaryBiproductOfPreservesBinaryCoproduct /-
/-- A functor between preadditive categories that preserves (zero morphisms and) binary coproducts
    preserves binary biproducts. -/
def preservesBinaryBiproductOfPreservesBinaryCoproduct {X Y : C} [PreservesColimit (pair X Y) F] :
    PreservesBinaryBiproduct X Y F
    where preserves b hb :=
    isBinaryBilimitOfIsColimit _ <|
      IsColimit.ofIsoColimit
          ((IsColimit.precomposeInvEquiv (diagram_iso_pair _) (F.mapCocone b.toCocone)).symm
            (isColimitOfPreserves F hb.IsColimit)) <|
        Cocones.ext (Iso.refl _) fun j => by
          rcases j with ‚ü®‚ü®‚ü©‚ü©
          tidy
#align category_theory.limits.preserves_binary_biproduct_of_preserves_binary_coproduct CategoryTheory.Limits.preservesBinaryBiproductOfPreservesBinaryCoproduct
-/

#print CategoryTheory.Limits.preservesBinaryBiproductsOfPreservesBinaryCoproducts /-
/-- A functor between preadditive categories that preserves (zero morphisms and) binary coproducts
    preserves binary biproducts. -/
def preservesBinaryBiproductsOfPreservesBinaryCoproducts
    [PreservesColimitsOfShape (Discrete WalkingPair) F] : PreservesBinaryBiproducts F
    where preserves X Y := preservesBinaryBiproductOfPreservesBinaryCoproduct F
#align category_theory.limits.preserves_binary_biproducts_of_preserves_binary_coproducts CategoryTheory.Limits.preservesBinaryBiproductsOfPreservesBinaryCoproducts
-/

end Limits

end Preadditive

end CategoryTheory

