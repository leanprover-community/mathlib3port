/-
Copyright (c) 2020 Bhavik Mehta. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Bhavik Mehta

! This file was ported from Lean 3 source module category_theory.sites.sheaf_of_types
! leanprover-community/mathlib commit d64d67d000b974f0d86a2be7918cf800be6271c8
! Please do not edit these lines, except to modify the commit id
! if you have ported upstream changes.
-/
import Mathbin.CategoryTheory.Sites.Pretopology
import Mathbin.CategoryTheory.Limits.Shapes.Types

/-!
# Sheaves of types on a Grothendieck topology

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

Defines the notion of a sheaf of types (usually called a sheaf of sets by mathematicians)
on a category equipped with a Grothendieck topology, as well as a range of equivalent
conditions useful in different situations.

First define what it means for a presheaf `P : Cáµ’áµ– â¥¤ Type v` to be a sheaf *for* a particular
presieve `R` on `X`:
* A *family of elements* `x` for `P` at `R` is an element `x_f` of `P Y` for every `f : Y âŸ¶ X` in
  `R`. See `family_of_elements`.
* The family `x` is *compatible* if, for any `fâ‚ : Yâ‚ âŸ¶ X` and `fâ‚‚ : Yâ‚‚ âŸ¶ X` both in `R`,
  and any `gâ‚ : Z âŸ¶ Yâ‚` and `gâ‚‚ : Z âŸ¶ Yâ‚‚` such that `gâ‚ â‰« fâ‚ = gâ‚‚ â‰« fâ‚‚`, the restriction of
  `x_fâ‚` along `gâ‚` agrees with the restriction of `x_fâ‚‚` along `gâ‚‚`.
  See `family_of_elements.compatible`.
* An *amalgamation* `t` for the family is an element of `P X` such that for every `f : Y âŸ¶ X` in
  `R`, the restriction of `t` on `f` is `x_f`.
  See `family_of_elements.is_amalgamation`.
We then say `P` is *separated* for `R` if every compatible family has at most one amalgamation,
and it is a *sheaf* for `R` if every compatible family has a unique amalgamation.
See `is_separated_for` and `is_sheaf_for`.

In the special case where `R` is a sieve, the compatibility condition can be simplified:
* The family `x` is *compatible* if, for any `f : Y âŸ¶ X` in `R` and `g : Z âŸ¶ Y`, the restriction of
  `x_f` along `g` agrees with `x_(g â‰« f)` (which is well defined since `g â‰« f` is in `R`).
See `family_of_elements.sieve_compatible` and `compatible_iff_sieve_compatible`.

In the special case where `C` has pullbacks, the compatibility condition can be simplified:
* The family `x` is *compatible* if, for any `f : Y âŸ¶ X` and `g : Z âŸ¶ X` both in `R`,
  the restriction of `x_f` along `Ï€â‚ : pullback f g âŸ¶ Y` agrees with the restriction of `x_g`
  along `Ï€â‚‚ : pullback f g âŸ¶ Z`.
See `family_of_elements.pullback_compatible` and `pullback_compatible_iff`.

Now given a Grothendieck topology `J`, `P` is a sheaf if it is a sheaf for every sieve in the
topology. See `is_sheaf`.

In the case where the topology is generated by a basis, it suffices to check `P` is a sheaf for
every presieve in the pretopology. See `is_sheaf_pretopology`.

We also provide equivalent conditions to satisfy alternate definitions given in the literature.

* Stacks: In `equalizer.presieve.sheaf_condition`, the sheaf condition at a presieve is shown to be
  equivalent to that of https://stacks.math.columbia.edu/tag/00VM (and combined with
  `is_sheaf_pretopology`, this shows the notions of `is_sheaf` are exactly equivalent.)

  The condition of https://stacks.math.columbia.edu/tag/00Z8 is virtually identical to the
  statement of `yoneda_condition_iff_sheaf_condition` (since the bijection described there carries
  the same information as the unique existence.)

* Maclane-Moerdijk [MM92]: Using `compatible_iff_sieve_compatible`, the definitions of `is_sheaf`
  are equivalent. There are also alternate definitions given:
  - Yoneda condition: Defined in `yoneda_sheaf_condition` and equivalence in
    `yoneda_condition_iff_sheaf_condition`.
  - Equalizer condition (Equation 3): Defined in the `equalizer.sieve` namespace, and equivalence
    in `equalizer.sieve.sheaf_condition`.
  - Matching family for presieves with pullback: `pullback_compatible_iff`.
  - Sheaf for a pretopology (Prop 1): `is_sheaf_pretopology` combined with the previous.
  - Sheaf for a pretopology as equalizer (Prop 1, bis): `equalizer.presieve.sheaf_condition`
    combined with the previous.

## Implementation

The sheaf condition is given as a proposition, rather than a subsingleton in `Type (max uâ‚ v)`.
This doesn't seem to make a big difference, other than making a couple of definitions noncomputable,
but it means that equivalent conditions can be given as `â†”` statements rather than `â‰ƒ` statements,
which can be convenient.

## References

* [MM92]: *Sheaves in geometry and logic*, Saunders MacLane, and Ieke Moerdijk:
  Chapter III, Section 4.
* [Elephant]: *Sketches of an Elephant*, P. T. Johnstone: C2.1.
* https://stacks.math.columbia.edu/tag/00VL (sheaves on a pretopology or site)
* https://stacks.math.columbia.edu/tag/00ZB (sheaves on a topology)

-/


universe w vâ‚ vâ‚‚ uâ‚ uâ‚‚

namespace CategoryTheory

open Opposite CategoryTheory Category Limits Sieve

namespace Presieve

variable {C : Type uâ‚} [Category.{vâ‚} C]

variable {P Q U : Cáµ’áµ– â¥¤ Type w}

variable {X Y : C} {S : Sieve X} {R : Presieve X}

variable (J Jâ‚‚ : GrothendieckTopology C)

#print CategoryTheory.Presieve.FamilyOfElements /-
/-- A family of elements for a presheaf `P` given a collection of arrows `R` with fixed codomain `X`
consists of an element of `P Y` for every `f : Y âŸ¶ X` in `R`.
A presheaf is a sheaf (resp, separated) if every *compatible* family of elements has exactly one
(resp, at most one) amalgamation.

This data is referred to as a `family` in [MM92], Chapter III, Section 4. It is also a concrete
version of the elements of the middle object in https://stacks.math.columbia.edu/tag/00VM which is
more useful for direct calculations. It is also used implicitly in Definition C2.1.2 in [Elephant].
-/
def FamilyOfElements (P : Cáµ’áµ– â¥¤ Type w) (R : Presieve X) :=
  âˆ€ â¦ƒY : Câ¦„ (f : Y âŸ¶ X), R f â†’ P.obj (op Y)
#align category_theory.presieve.family_of_elements CategoryTheory.Presieve.FamilyOfElements
-/

instance : Inhabited (FamilyOfElements P (âŠ¥ : Presieve X)) :=
  âŸ¨fun Y f => False.elimâŸ©

/- warning: category_theory.presieve.family_of_elements.restrict -> CategoryTheory.Presieve.FamilyOfElements.restrict is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] {P : CategoryTheory.Functor.{u2, u1, u3, succ u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) Type.{u1} CategoryTheory.types.{u1}} {X : C} {Râ‚ : CategoryTheory.Presieve.{u2, u3} C _inst_1 X} {Râ‚‚ : CategoryTheory.Presieve.{u2, u3} C _inst_1 X}, (LE.le.{max u3 u2} (CategoryTheory.Presieve.{u2, u3} C _inst_1 X) (Preorder.toHasLe.{max u3 u2} (CategoryTheory.Presieve.{u2, u3} C _inst_1 X) (PartialOrder.toPreorder.{max u3 u2} (CategoryTheory.Presieve.{u2, u3} C _inst_1 X) (CompleteSemilatticeInf.toPartialOrder.{max u3 u2} (CategoryTheory.Presieve.{u2, u3} C _inst_1 X) (CompleteLattice.toCompleteSemilatticeInf.{max u3 u2} (CategoryTheory.Presieve.{u2, u3} C _inst_1 X) (CategoryTheory.Presieve.completeLattice.{u3, u2} C _inst_1 X))))) Râ‚ Râ‚‚) -> (CategoryTheory.Presieve.FamilyOfElements.{u1, u2, u3} C _inst_1 X P Râ‚‚) -> (CategoryTheory.Presieve.FamilyOfElements.{u1, u2, u3} C _inst_1 X P Râ‚)
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] {P : CategoryTheory.Functor.{u2, u1, u3, succ u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) Type.{u1} CategoryTheory.types.{u1}} {X : C} {Râ‚ : CategoryTheory.Presieve.{u2, u3} C _inst_1 X} {Râ‚‚ : CategoryTheory.Presieve.{u2, u3} C _inst_1 X}, (LE.le.{max u3 u2} (CategoryTheory.Presieve.{u2, u3} C _inst_1 X) (Preorder.toLE.{max u3 u2} (CategoryTheory.Presieve.{u2, u3} C _inst_1 X) (PartialOrder.toPreorder.{max u3 u2} (CategoryTheory.Presieve.{u2, u3} C _inst_1 X) (CompleteSemilatticeInf.toPartialOrder.{max u3 u2} (CategoryTheory.Presieve.{u2, u3} C _inst_1 X) (CompleteLattice.toCompleteSemilatticeInf.{max u3 u2} (CategoryTheory.Presieve.{u2, u3} C _inst_1 X) (CategoryTheory.instCompleteLatticePresieve.{u2, u3} C _inst_1 X))))) Râ‚ Râ‚‚) -> (CategoryTheory.Presieve.FamilyOfElements.{u1, u2, u3} C _inst_1 X P Râ‚‚) -> (CategoryTheory.Presieve.FamilyOfElements.{u1, u2, u3} C _inst_1 X P Râ‚)
Case conversion may be inaccurate. Consider using '#align category_theory.presieve.family_of_elements.restrict CategoryTheory.Presieve.FamilyOfElements.restrictâ‚“'. -/
/-- A family of elements for a presheaf on the presieve `Râ‚‚` can be restricted to a smaller presieve
`Râ‚`.
-/
def FamilyOfElements.restrict {Râ‚ Râ‚‚ : Presieve X} (h : Râ‚ â‰¤ Râ‚‚) :
    FamilyOfElements P Râ‚‚ â†’ FamilyOfElements P Râ‚ := fun x Y f hf => x f (h _ hf)
#align category_theory.presieve.family_of_elements.restrict CategoryTheory.Presieve.FamilyOfElements.restrict

#print CategoryTheory.Presieve.FamilyOfElements.Compatible /-
/-- A family of elements for the arrow set `R` is *compatible* if for any `fâ‚ : Yâ‚ âŸ¶ X` and
`fâ‚‚ : Yâ‚‚ âŸ¶ X` in `R`, and any `gâ‚ : Z âŸ¶ Yâ‚` and `gâ‚‚ : Z âŸ¶ Yâ‚‚`, if the square `gâ‚ â‰« fâ‚ = gâ‚‚ â‰« fâ‚‚`
commutes then the elements of `P Z` obtained by restricting the element of `P Yâ‚` along `gâ‚` and
restricting the element of `P Yâ‚‚` along `gâ‚‚` are the same.

In special cases, this condition can be simplified, see `pullback_compatible_iff` and
`compatible_iff_sieve_compatible`.

This is referred to as a "compatible family" in Definition C2.1.2 of [Elephant], and on nlab:
https://ncatlab.org/nlab/show/sheaf#GeneralDefinitionInComponents
-/
def FamilyOfElements.Compatible (x : FamilyOfElements P R) : Prop :=
  âˆ€ â¦ƒYâ‚ Yâ‚‚ Zâ¦„ (gâ‚ : Z âŸ¶ Yâ‚) (gâ‚‚ : Z âŸ¶ Yâ‚‚) â¦ƒfâ‚ : Yâ‚ âŸ¶ Xâ¦„ â¦ƒfâ‚‚ : Yâ‚‚ âŸ¶ Xâ¦„ (hâ‚ : R fâ‚) (hâ‚‚ : R fâ‚‚),
    gâ‚ â‰« fâ‚ = gâ‚‚ â‰« fâ‚‚ â†’ P.map gâ‚.op (x fâ‚ hâ‚) = P.map gâ‚‚.op (x fâ‚‚ hâ‚‚)
#align category_theory.presieve.family_of_elements.compatible CategoryTheory.Presieve.FamilyOfElements.Compatible
-/

#print CategoryTheory.Presieve.FamilyOfElements.PullbackCompatible /-
/--
If the category `C` has pullbacks, this is an alternative condition for a family of elements to be
compatible: For any `f : Y âŸ¶ X` and `g : Z âŸ¶ X` in the presieve `R`, the restriction of the
given elements for `f` and `g` to the pullback agree.
This is equivalent to being compatible (provided `C` has pullbacks), shown in
`pullback_compatible_iff`.

This is the definition for a "matching" family given in [MM92], Chapter III, Section 4,
Equation (5). Viewing the type `family_of_elements` as the middle object of the fork in
https://stacks.math.columbia.edu/tag/00VM, this condition expresses that `prâ‚€* (x) = prâ‚* (x)`,
using the notation defined there.
-/
def FamilyOfElements.PullbackCompatible (x : FamilyOfElements P R) [HasPullbacks C] : Prop :=
  âˆ€ â¦ƒYâ‚ Yâ‚‚â¦„ â¦ƒfâ‚ : Yâ‚ âŸ¶ Xâ¦„ â¦ƒfâ‚‚ : Yâ‚‚ âŸ¶ Xâ¦„ (hâ‚ : R fâ‚) (hâ‚‚ : R fâ‚‚),
    P.map (pullback.fst : pullback fâ‚ fâ‚‚ âŸ¶ _).op (x fâ‚ hâ‚) = P.map pullback.snd.op (x fâ‚‚ hâ‚‚)
#align category_theory.presieve.family_of_elements.pullback_compatible CategoryTheory.Presieve.FamilyOfElements.PullbackCompatible
-/

#print CategoryTheory.Presieve.pullbackCompatible_iff /-
theorem pullbackCompatible_iff (x : FamilyOfElements P R) [HasPullbacks C] :
    x.Compatible â†” x.PullbackCompatible := by
  constructor
  Â· intro t Yâ‚ Yâ‚‚ fâ‚ fâ‚‚ hfâ‚ hfâ‚‚
    apply t
    apply pullback.condition
  Â· intro t Yâ‚ Yâ‚‚ Z gâ‚ gâ‚‚ fâ‚ fâ‚‚ hfâ‚ hfâ‚‚ comm
    rw [â† pullback.lift_fst _ _ comm, op_comp, functor_to_types.map_comp_apply, t hfâ‚ hfâ‚‚, â†
      functor_to_types.map_comp_apply, â† op_comp, pullback.lift_snd]
#align category_theory.presieve.pullback_compatible_iff CategoryTheory.Presieve.pullbackCompatible_iff
-/

/- warning: category_theory.presieve.family_of_elements.compatible.restrict -> CategoryTheory.Presieve.FamilyOfElements.Compatible.restrict is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] {P : CategoryTheory.Functor.{u2, u1, u3, succ u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) Type.{u1} CategoryTheory.types.{u1}} {X : C} {Râ‚ : CategoryTheory.Presieve.{u2, u3} C _inst_1 X} {Râ‚‚ : CategoryTheory.Presieve.{u2, u3} C _inst_1 X} (h : LE.le.{max u3 u2} (CategoryTheory.Presieve.{u2, u3} C _inst_1 X) (Preorder.toHasLe.{max u3 u2} (CategoryTheory.Presieve.{u2, u3} C _inst_1 X) (PartialOrder.toPreorder.{max u3 u2} (CategoryTheory.Presieve.{u2, u3} C _inst_1 X) (CompleteSemilatticeInf.toPartialOrder.{max u3 u2} (CategoryTheory.Presieve.{u2, u3} C _inst_1 X) (CompleteLattice.toCompleteSemilatticeInf.{max u3 u2} (CategoryTheory.Presieve.{u2, u3} C _inst_1 X) (CategoryTheory.Presieve.completeLattice.{u3, u2} C _inst_1 X))))) Râ‚ Râ‚‚) {x : CategoryTheory.Presieve.FamilyOfElements.{u1, u2, u3} C _inst_1 X P Râ‚‚}, (CategoryTheory.Presieve.FamilyOfElements.Compatible.{u1, u2, u3} C _inst_1 P X Râ‚‚ x) -> (CategoryTheory.Presieve.FamilyOfElements.Compatible.{u1, u2, u3} C _inst_1 P X Râ‚ (CategoryTheory.Presieve.FamilyOfElements.restrict.{u1, u2, u3} C _inst_1 P X Râ‚ Râ‚‚ h x))
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] {P : CategoryTheory.Functor.{u2, u1, u3, succ u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) Type.{u1} CategoryTheory.types.{u1}} {X : C} {Râ‚ : CategoryTheory.Presieve.{u2, u3} C _inst_1 X} {Râ‚‚ : CategoryTheory.Presieve.{u2, u3} C _inst_1 X} (h : LE.le.{max u3 u2} (CategoryTheory.Presieve.{u2, u3} C _inst_1 X) (Preorder.toLE.{max u3 u2} (CategoryTheory.Presieve.{u2, u3} C _inst_1 X) (PartialOrder.toPreorder.{max u3 u2} (CategoryTheory.Presieve.{u2, u3} C _inst_1 X) (CompleteSemilatticeInf.toPartialOrder.{max u3 u2} (CategoryTheory.Presieve.{u2, u3} C _inst_1 X) (CompleteLattice.toCompleteSemilatticeInf.{max u3 u2} (CategoryTheory.Presieve.{u2, u3} C _inst_1 X) (CategoryTheory.instCompleteLatticePresieve.{u2, u3} C _inst_1 X))))) Râ‚ Râ‚‚) {x : CategoryTheory.Presieve.FamilyOfElements.{u1, u2, u3} C _inst_1 X P Râ‚‚}, (CategoryTheory.Presieve.FamilyOfElements.Compatible.{u1, u2, u3} C _inst_1 P X Râ‚‚ x) -> (CategoryTheory.Presieve.FamilyOfElements.Compatible.{u1, u2, u3} C _inst_1 P X Râ‚ (CategoryTheory.Presieve.FamilyOfElements.restrict.{u1, u2, u3} C _inst_1 P X Râ‚ Râ‚‚ h x))
Case conversion may be inaccurate. Consider using '#align category_theory.presieve.family_of_elements.compatible.restrict CategoryTheory.Presieve.FamilyOfElements.Compatible.restrictâ‚“'. -/
/-- The restriction of a compatible family is compatible. -/
theorem FamilyOfElements.Compatible.restrict {Râ‚ Râ‚‚ : Presieve X} (h : Râ‚ â‰¤ Râ‚‚)
    {x : FamilyOfElements P Râ‚‚} : x.Compatible â†’ (x.restrict h).Compatible :=
  fun q Yâ‚ Yâ‚‚ Z gâ‚ gâ‚‚ fâ‚ fâ‚‚ hâ‚ hâ‚‚ comm => q gâ‚ gâ‚‚ (h _ hâ‚) (h _ hâ‚‚) comm
#align category_theory.presieve.family_of_elements.compatible.restrict CategoryTheory.Presieve.FamilyOfElements.Compatible.restrict

#print CategoryTheory.Presieve.FamilyOfElements.sieveExtend /-
/-- Extend a family of elements to the sieve generated by an arrow set.
This is the construction described as "easy" in Lemma C2.1.3 of [Elephant].
-/
noncomputable def FamilyOfElements.sieveExtend (x : FamilyOfElements P R) :
    FamilyOfElements P (generate R) := fun Z f hf =>
  P.map hf.choose_spec.some.op (x _ hf.choose_spec.choose_spec.choose_spec.1)
#align category_theory.presieve.family_of_elements.sieve_extend CategoryTheory.Presieve.FamilyOfElements.sieveExtend
-/

#print CategoryTheory.Presieve.FamilyOfElements.Compatible.sieveExtend /-
/-- The extension of a compatible family to the generated sieve is compatible. -/
theorem FamilyOfElements.Compatible.sieveExtend {x : FamilyOfElements P R} (hx : x.Compatible) :
    x.sieveExtend.Compatible := by
  intro _ _ _ _ _ _ _ hâ‚ hâ‚‚ comm
  iterate 2 erw [â† functor_to_types.map_comp_apply]; rw [â† op_comp]; apply hx
  simp [comm, hâ‚.some_spec.some_spec.some_spec.2, hâ‚‚.some_spec.some_spec.some_spec.2]
#align category_theory.presieve.family_of_elements.compatible.sieve_extend CategoryTheory.Presieve.FamilyOfElements.Compatible.sieveExtend
-/

/- warning: category_theory.presieve.extend_agrees -> CategoryTheory.Presieve.extend_agrees is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] {P : CategoryTheory.Functor.{u2, u1, u3, succ u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) Type.{u1} CategoryTheory.types.{u1}} {X : C} {Y : C} {R : CategoryTheory.Presieve.{u2, u3} C _inst_1 X} {x : CategoryTheory.Presieve.FamilyOfElements.{u1, u2, u3} C _inst_1 X P R}, (CategoryTheory.Presieve.FamilyOfElements.Compatible.{u1, u2, u3} C _inst_1 P X R x) -> (forall {f : Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) Y X} (hf : R Y f), Eq.{succ u1} (CategoryTheory.Functor.obj.{u2, u1, u3, succ u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) Type.{u1} CategoryTheory.types.{u1} P (Opposite.op.{succ u3} C Y)) (CategoryTheory.Presieve.FamilyOfElements.sieveExtend.{u1, u2, u3} C _inst_1 P X R x Y f (CategoryTheory.Sieve.le_generate.{u2, u3} C _inst_1 X R Y f hf)) (x Y f hf))
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] {P : CategoryTheory.Functor.{u2, u1, u3, succ u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) Type.{u1} CategoryTheory.types.{u1}} {X : C} {Y : C} {R : CategoryTheory.Presieve.{u2, u3} C _inst_1 X} {x : CategoryTheory.Presieve.FamilyOfElements.{u1, u2, u3} C _inst_1 X P R}, (CategoryTheory.Presieve.FamilyOfElements.Compatible.{u1, u2, u3} C _inst_1 P X R x) -> (forall {f : Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) Y X} (hf : R Y f), Eq.{succ u1} (Prefunctor.obj.{succ u2, succ u1, u3, succ u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u2, u1, u3, succ u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) Type.{u1} CategoryTheory.types.{u1} P) (Opposite.op.{succ u3} C Y)) (CategoryTheory.Presieve.FamilyOfElements.sieveExtend.{u1, u2, u3} C _inst_1 P X R x Y f (CategoryTheory.Sieve.le_generate.{u2, u3} C _inst_1 X R Y f hf)) (x Y f hf))
Case conversion may be inaccurate. Consider using '#align category_theory.presieve.extend_agrees CategoryTheory.Presieve.extend_agreesâ‚“'. -/
/-- The extension of a family agrees with the original family. -/
theorem extend_agrees {x : FamilyOfElements P R} (t : x.Compatible) {f : Y âŸ¶ X} (hf : R f) :
    x.sieveExtend f (le_generate R Y hf) = x f hf :=
  by
  have h := (le_generate R Y hf).choose_spec
  unfold family_of_elements.sieve_extend
  rw [t h.some (ðŸ™ _) _ hf _]
  Â· simp;
  Â· rw [id_comp]
    exact h.some_spec.some_spec.2
#align category_theory.presieve.extend_agrees CategoryTheory.Presieve.extend_agrees

#print CategoryTheory.Presieve.restrict_extend /-
/-- The restriction of an extension is the original. -/
@[simp]
theorem restrict_extend {x : FamilyOfElements P R} (t : x.Compatible) :
    x.sieveExtend.restrict (le_generate R) = x :=
  by
  ext (Y f hf)
  exact extend_agrees t hf
#align category_theory.presieve.restrict_extend CategoryTheory.Presieve.restrict_extend
-/

#print CategoryTheory.Presieve.FamilyOfElements.SieveCompatible /-
/--
If the arrow set for a family of elements is actually a sieve (i.e. it is downward closed) then the
consistency condition can be simplified.
This is an equivalent condition, see `compatible_iff_sieve_compatible`.

This is the notion of "matching" given for families on sieves given in [MM92], Chapter III,
Section 4, Equation 1, and nlab: https://ncatlab.org/nlab/show/matching+family.
See also the discussion before Lemma C2.1.4 of [Elephant].
-/
def FamilyOfElements.SieveCompatible (x : FamilyOfElements P S) : Prop :=
  âˆ€ â¦ƒY Zâ¦„ (f : Y âŸ¶ X) (g : Z âŸ¶ Y) (hf), x (g â‰« f) (S.downward_closed hf g) = P.map g.op (x f hf)
#align category_theory.presieve.family_of_elements.sieve_compatible CategoryTheory.Presieve.FamilyOfElements.SieveCompatible
-/

#print CategoryTheory.Presieve.compatible_iff_sieveCompatible /-
theorem compatible_iff_sieveCompatible (x : FamilyOfElements P S) :
    x.Compatible â†” x.SieveCompatible := by
  constructor
  Â· intro h Y Z f g hf
    simpa using h (ðŸ™ _) g (S.downward_closed hf g) hf (id_comp _)
  Â· intro h Yâ‚ Yâ‚‚ Z gâ‚ gâ‚‚ fâ‚ fâ‚‚ hâ‚ hâ‚‚ k
    simp_rw [â† h fâ‚ gâ‚ hâ‚, k, h fâ‚‚ gâ‚‚ hâ‚‚]
#align category_theory.presieve.compatible_iff_sieve_compatible CategoryTheory.Presieve.compatible_iff_sieveCompatible
-/

#print CategoryTheory.Presieve.FamilyOfElements.Compatible.to_sieveCompatible /-
theorem FamilyOfElements.Compatible.to_sieveCompatible {x : FamilyOfElements P S}
    (t : x.Compatible) : x.SieveCompatible :=
  (compatible_iff_sieveCompatible x).1 t
#align category_theory.presieve.family_of_elements.compatible.to_sieve_compatible CategoryTheory.Presieve.FamilyOfElements.Compatible.to_sieveCompatible
-/

#print CategoryTheory.Presieve.extend_restrict /-
/--
Given a family of elements `x` for the sieve `S` generated by a presieve `R`, if `x` is restricted
to `R` and then extended back up to `S`, the resulting extension equals `x`.
-/
@[simp]
theorem extend_restrict {x : FamilyOfElements P (generate R)} (t : x.Compatible) :
    (x.restrict (le_generate R)).sieveExtend = x :=
  by
  rw [compatible_iff_sieve_compatible] at t
  ext (_ _ h); apply (t _ _ _).symm.trans; congr
  exact h.some_spec.some_spec.some_spec.2
#align category_theory.presieve.extend_restrict CategoryTheory.Presieve.extend_restrict
-/

#print CategoryTheory.Presieve.restrict_inj /-
/--
Two compatible families on the sieve generated by a presieve `R` are equal if and only if they are
equal when restricted to `R`.
-/
theorem restrict_inj {xâ‚ xâ‚‚ : FamilyOfElements P (generate R)} (tâ‚ : xâ‚.Compatible)
    (tâ‚‚ : xâ‚‚.Compatible) : xâ‚.restrict (le_generate R) = xâ‚‚.restrict (le_generate R) â†’ xâ‚ = xâ‚‚ :=
  fun h => by
  rw [â† extend_restrict tâ‚, â† extend_restrict tâ‚‚]
  congr
  exact h
#align category_theory.presieve.restrict_inj CategoryTheory.Presieve.restrict_inj
-/

#print CategoryTheory.Presieve.compatibleEquivGenerateSieveCompatible /-
/-- Compatible families of elements for a presheaf of types `P` and a presieve `R`
    are in 1-1 correspondence with compatible families for the same presheaf and
    the sieve generated by `R`, through extension and restriction. -/
@[simps]
noncomputable def compatibleEquivGenerateSieveCompatible :
    { x : FamilyOfElements P R // x.Compatible } â‰ƒ
      { x : FamilyOfElements P (generate R) // x.Compatible }
    where
  toFun x := âŸ¨x.1.sieveExtend, x.2.sieveExtendâŸ©
  invFun x := âŸ¨x.1.restrict (le_generate R), x.2.restrict _âŸ©
  left_inv x := Subtype.ext (restrict_extend x.2)
  right_inv x := Subtype.ext (extend_restrict x.2)
#align category_theory.presieve.compatible_equiv_generate_sieve_compatible CategoryTheory.Presieve.compatibleEquivGenerateSieveCompatible
-/

/- warning: category_theory.presieve.family_of_elements.comp_of_compatible -> CategoryTheory.Presieve.FamilyOfElements.comp_of_compatible is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] {P : CategoryTheory.Functor.{u2, u1, u3, succ u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) Type.{u1} CategoryTheory.types.{u1}} {X : C} {Y : C} (S : CategoryTheory.Sieve.{u2, u3} C _inst_1 X) {x : CategoryTheory.Presieve.FamilyOfElements.{u1, u2, u3} C _inst_1 X P (coeFn.{max (succ u3) (succ u2), max (succ u3) (succ u2)} (CategoryTheory.Sieve.{u2, u3} C _inst_1 X) (fun (_x : CategoryTheory.Sieve.{u2, u3} C _inst_1 X) => CategoryTheory.Presieve.{u2, u3} C _inst_1 X) (CategoryTheory.Sieve.hasCoeToFun.{u2, u3} C _inst_1 X) S)}, (CategoryTheory.Presieve.FamilyOfElements.Compatible.{u1, u2, u3} C _inst_1 P X (coeFn.{max (succ u3) (succ u2), max (succ u3) (succ u2)} (CategoryTheory.Sieve.{u2, u3} C _inst_1 X) (fun (_x : CategoryTheory.Sieve.{u2, u3} C _inst_1 X) => CategoryTheory.Presieve.{u2, u3} C _inst_1 X) (CategoryTheory.Sieve.hasCoeToFun.{u2, u3} C _inst_1 X) S) x) -> (forall {f : Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) Y X} (hf : coeFn.{max (succ u3) (succ u2), max (succ u3) (succ u2)} (CategoryTheory.Sieve.{u2, u3} C _inst_1 X) (fun (_x : CategoryTheory.Sieve.{u2, u3} C _inst_1 X) => CategoryTheory.Presieve.{u2, u3} C _inst_1 X) (CategoryTheory.Sieve.hasCoeToFun.{u2, u3} C _inst_1 X) S Y f) {Z : C} (g : Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) Z Y), Eq.{succ u1} (CategoryTheory.Functor.obj.{u2, u1, u3, succ u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) Type.{u1} CategoryTheory.types.{u1} P (Opposite.op.{succ u3} C Z)) (x Z (CategoryTheory.CategoryStruct.comp.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1) Z Y X g f) (CategoryTheory.Sieve.downward_closed.{u2, u3} C _inst_1 X Y Z S f hf g)) (CategoryTheory.Functor.map.{u2, u1, u3, succ u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) Type.{u1} CategoryTheory.types.{u1} P (Opposite.op.{succ u3} C Y) (Opposite.op.{succ u3} C Z) (Quiver.Hom.op.{u3, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) Z Y g) (x Y f hf)))
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] {P : CategoryTheory.Functor.{u2, u1, u3, succ u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) Type.{u1} CategoryTheory.types.{u1}} {X : C} {Y : C} (S : CategoryTheory.Sieve.{u2, u3} C _inst_1 X) {x : CategoryTheory.Presieve.FamilyOfElements.{u1, u2, u3} C _inst_1 X P (CategoryTheory.Sieve.arrows.{u2, u3} C _inst_1 X S)}, (CategoryTheory.Presieve.FamilyOfElements.Compatible.{u1, u2, u3} C _inst_1 P X (CategoryTheory.Sieve.arrows.{u2, u3} C _inst_1 X S) x) -> (forall {f : Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) Y X} (hf : CategoryTheory.Sieve.arrows.{u2, u3} C _inst_1 X S Y f) {Z : C} (g : Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) Z Y), Eq.{succ u1} (Prefunctor.obj.{succ u2, succ u1, u3, succ u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u2, u1, u3, succ u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) Type.{u1} CategoryTheory.types.{u1} P) (Opposite.op.{succ u3} C Z)) (x Z (CategoryTheory.CategoryStruct.comp.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1) Z Y X g f) (CategoryTheory.Sieve.downward_closed.{u2, u3} C _inst_1 X S Y Z f hf g)) (Prefunctor.map.{succ u2, succ u1, u3, succ u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u2, u1, u3, succ u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) Type.{u1} CategoryTheory.types.{u1} P) (Opposite.op.{succ u3} C Y) (Opposite.op.{succ u3} C Z) (Quiver.Hom.op.{u3, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) Z Y g) (x Y f hf)))
Case conversion may be inaccurate. Consider using '#align category_theory.presieve.family_of_elements.comp_of_compatible CategoryTheory.Presieve.FamilyOfElements.comp_of_compatibleâ‚“'. -/
theorem FamilyOfElements.comp_of_compatible (S : Sieve X) {x : FamilyOfElements P S}
    (t : x.Compatible) {f : Y âŸ¶ X} (hf : S f) {Z} (g : Z âŸ¶ Y) :
    x (g â‰« f) (S.downward_closed hf g) = P.map g.op (x f hf) := by
  simpa using t (ðŸ™ _) g (S.downward_closed hf g) hf (id_comp _)
#align category_theory.presieve.family_of_elements.comp_of_compatible CategoryTheory.Presieve.FamilyOfElements.comp_of_compatible

section FunctorPullback

variable {D : Type uâ‚‚} [Category.{vâ‚‚} D] (F : D â¥¤ C) {Z : D}

variable {T : Presieve (F.obj Z)} {x : FamilyOfElements P T}

/- warning: category_theory.presieve.family_of_elements.functor_pullback -> CategoryTheory.Presieve.FamilyOfElements.functorPullback is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u4}} [_inst_1 : CategoryTheory.Category.{u2, u4} C] {P : CategoryTheory.Functor.{u2, u1, u4, succ u1} (Opposite.{succ u4} C) (CategoryTheory.Category.opposite.{u2, u4} C _inst_1) Type.{u1} CategoryTheory.types.{u1}} {D : Type.{u5}} [_inst_2 : CategoryTheory.Category.{u3, u5} D] (F : CategoryTheory.Functor.{u3, u2, u5, u4} D _inst_2 C _inst_1) {Z : D} {T : CategoryTheory.Presieve.{u2, u4} C _inst_1 (CategoryTheory.Functor.obj.{u3, u2, u5, u4} D _inst_2 C _inst_1 F Z)}, (CategoryTheory.Presieve.FamilyOfElements.{u1, u2, u4} C _inst_1 (CategoryTheory.Functor.obj.{u3, u2, u5, u4} D _inst_2 C _inst_1 F Z) P T) -> (CategoryTheory.Presieve.FamilyOfElements.{u1, u3, u5} D _inst_2 Z (CategoryTheory.Functor.comp.{u3, u2, u1, u5, u4, succ u1} (Opposite.{succ u5} D) (CategoryTheory.Category.opposite.{u3, u5} D _inst_2) (Opposite.{succ u4} C) (CategoryTheory.Category.opposite.{u2, u4} C _inst_1) Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.Functor.op.{u3, u2, u5, u4} D _inst_2 C _inst_1 F) P) (CategoryTheory.Presieve.functorPullback.{u3, u2, u5, u4} D _inst_2 C _inst_1 F Z T))
but is expected to have type
  forall {C : Type.{u4}} [_inst_1 : CategoryTheory.Category.{u2, u4} C] {P : CategoryTheory.Functor.{u2, u1, u4, succ u1} (Opposite.{succ u4} C) (CategoryTheory.Category.opposite.{u2, u4} C _inst_1) Type.{u1} CategoryTheory.types.{u1}} {D : Type.{u5}} [_inst_2 : CategoryTheory.Category.{u3, u5} D] (F : CategoryTheory.Functor.{u3, u2, u5, u4} D _inst_2 C _inst_1) {Z : D} {T : CategoryTheory.Presieve.{u2, u4} C _inst_1 (Prefunctor.obj.{succ u3, succ u2, u5, u4} D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u3, u2, u5, u4} D _inst_2 C _inst_1 F) Z)}, (CategoryTheory.Presieve.FamilyOfElements.{u1, u2, u4} C _inst_1 (Prefunctor.obj.{succ u3, succ u2, u5, u4} D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u3, u2, u5, u4} D _inst_2 C _inst_1 F) Z) P T) -> (CategoryTheory.Presieve.FamilyOfElements.{u1, u3, u5} D _inst_2 Z (CategoryTheory.Functor.comp.{u3, u2, u1, u5, u4, succ u1} (Opposite.{succ u5} D) (CategoryTheory.Category.opposite.{u3, u5} D _inst_2) (Opposite.{succ u4} C) (CategoryTheory.Category.opposite.{u2, u4} C _inst_1) Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.Functor.op.{u3, u2, u5, u4} D _inst_2 C _inst_1 F) P) (CategoryTheory.Presieve.functorPullback.{u3, u2, u5, u4} D _inst_2 C _inst_1 F Z T))
Case conversion may be inaccurate. Consider using '#align category_theory.presieve.family_of_elements.functor_pullback CategoryTheory.Presieve.FamilyOfElements.functorPullbackâ‚“'. -/
/--
Given a family of elements of a sieve `S` on `F(X)`, we can realize it as a family of elements of
`S.functor_pullback F`.
-/
def FamilyOfElements.functorPullback (x : FamilyOfElements P T) :
    FamilyOfElements (F.op â‹™ P) (T.functorPullback F) := fun Y f hf => x (F.map f) hf
#align category_theory.presieve.family_of_elements.functor_pullback CategoryTheory.Presieve.FamilyOfElements.functorPullback

/- warning: category_theory.presieve.family_of_elements.compatible.functor_pullback -> CategoryTheory.Presieve.FamilyOfElements.Compatible.functorPullback is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u4}} [_inst_1 : CategoryTheory.Category.{u2, u4} C] {P : CategoryTheory.Functor.{u2, u1, u4, succ u1} (Opposite.{succ u4} C) (CategoryTheory.Category.opposite.{u2, u4} C _inst_1) Type.{u1} CategoryTheory.types.{u1}} {D : Type.{u5}} [_inst_2 : CategoryTheory.Category.{u3, u5} D] (F : CategoryTheory.Functor.{u3, u2, u5, u4} D _inst_2 C _inst_1) {Z : D} {T : CategoryTheory.Presieve.{u2, u4} C _inst_1 (CategoryTheory.Functor.obj.{u3, u2, u5, u4} D _inst_2 C _inst_1 F Z)} {x : CategoryTheory.Presieve.FamilyOfElements.{u1, u2, u4} C _inst_1 (CategoryTheory.Functor.obj.{u3, u2, u5, u4} D _inst_2 C _inst_1 F Z) P T}, (CategoryTheory.Presieve.FamilyOfElements.Compatible.{u1, u2, u4} C _inst_1 P (CategoryTheory.Functor.obj.{u3, u2, u5, u4} D _inst_2 C _inst_1 F Z) T x) -> (CategoryTheory.Presieve.FamilyOfElements.Compatible.{u1, u3, u5} D _inst_2 (CategoryTheory.Functor.comp.{u3, u2, u1, u5, u4, succ u1} (Opposite.{succ u5} D) (CategoryTheory.Category.opposite.{u3, u5} D _inst_2) (Opposite.{succ u4} C) (CategoryTheory.Category.opposite.{u2, u4} C _inst_1) Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.Functor.op.{u3, u2, u5, u4} D _inst_2 C _inst_1 F) P) Z (CategoryTheory.Presieve.functorPullback.{u3, u2, u5, u4} D _inst_2 C _inst_1 F Z T) (CategoryTheory.Presieve.FamilyOfElements.functorPullback.{u1, u2, u3, u4, u5} C _inst_1 P D _inst_2 F Z T x))
but is expected to have type
  forall {C : Type.{u4}} [_inst_1 : CategoryTheory.Category.{u2, u4} C] {P : CategoryTheory.Functor.{u2, u1, u4, succ u1} (Opposite.{succ u4} C) (CategoryTheory.Category.opposite.{u2, u4} C _inst_1) Type.{u1} CategoryTheory.types.{u1}} {D : Type.{u5}} [_inst_2 : CategoryTheory.Category.{u3, u5} D] (F : CategoryTheory.Functor.{u3, u2, u5, u4} D _inst_2 C _inst_1) {Z : D} {T : CategoryTheory.Presieve.{u2, u4} C _inst_1 (Prefunctor.obj.{succ u3, succ u2, u5, u4} D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u3, u2, u5, u4} D _inst_2 C _inst_1 F) Z)} {x : CategoryTheory.Presieve.FamilyOfElements.{u1, u2, u4} C _inst_1 (Prefunctor.obj.{succ u3, succ u2, u5, u4} D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u3, u2, u5, u4} D _inst_2 C _inst_1 F) Z) P T}, (CategoryTheory.Presieve.FamilyOfElements.Compatible.{u1, u2, u4} C _inst_1 P (Prefunctor.obj.{succ u3, succ u2, u5, u4} D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u3, u2, u5, u4} D _inst_2 C _inst_1 F) Z) T x) -> (CategoryTheory.Presieve.FamilyOfElements.Compatible.{u1, u3, u5} D _inst_2 (CategoryTheory.Functor.comp.{u3, u2, u1, u5, u4, succ u1} (Opposite.{succ u5} D) (CategoryTheory.Category.opposite.{u3, u5} D _inst_2) (Opposite.{succ u4} C) (CategoryTheory.Category.opposite.{u2, u4} C _inst_1) Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.Functor.op.{u3, u2, u5, u4} D _inst_2 C _inst_1 F) P) Z (CategoryTheory.Presieve.functorPullback.{u3, u2, u5, u4} D _inst_2 C _inst_1 F Z T) (CategoryTheory.Presieve.FamilyOfElements.functorPullback.{u1, u2, u3, u4, u5} C _inst_1 P D _inst_2 F Z T x))
Case conversion may be inaccurate. Consider using '#align category_theory.presieve.family_of_elements.compatible.functor_pullback CategoryTheory.Presieve.FamilyOfElements.Compatible.functorPullbackâ‚“'. -/
theorem FamilyOfElements.Compatible.functorPullback (h : x.Compatible) :
    (x.functorPullback F).Compatible :=
  by
  intro Zâ‚ Zâ‚‚ W gâ‚ gâ‚‚ fâ‚ fâ‚‚ hâ‚ hâ‚‚ eq
  exact h (F.map gâ‚) (F.map gâ‚‚) hâ‚ hâ‚‚ (by simp only [â† F.map_comp, Eq])
#align category_theory.presieve.family_of_elements.compatible.functor_pullback CategoryTheory.Presieve.FamilyOfElements.Compatible.functorPullback

end FunctorPullback

/- warning: category_theory.presieve.family_of_elements.functor_pushforward -> CategoryTheory.Presieve.FamilyOfElements.functorPushforward is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u4}} [_inst_1 : CategoryTheory.Category.{u2, u4} C] {P : CategoryTheory.Functor.{u2, u1, u4, succ u1} (Opposite.{succ u4} C) (CategoryTheory.Category.opposite.{u2, u4} C _inst_1) Type.{u1} CategoryTheory.types.{u1}} {D : Type.{u5}} [_inst_2 : CategoryTheory.Category.{u3, u5} D] (F : CategoryTheory.Functor.{u3, u2, u5, u4} D _inst_2 C _inst_1) {X : D} {T : CategoryTheory.Presieve.{u3, u5} D _inst_2 X}, (CategoryTheory.Presieve.FamilyOfElements.{u1, u3, u5} D _inst_2 X (CategoryTheory.Functor.comp.{u3, u2, u1, u5, u4, succ u1} (Opposite.{succ u5} D) (CategoryTheory.Category.opposite.{u3, u5} D _inst_2) (Opposite.{succ u4} C) (CategoryTheory.Category.opposite.{u2, u4} C _inst_1) Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.Functor.op.{u3, u2, u5, u4} D _inst_2 C _inst_1 F) P) T) -> (CategoryTheory.Presieve.FamilyOfElements.{u1, u2, u4} C _inst_1 (CategoryTheory.Functor.obj.{u3, u2, u5, u4} D _inst_2 C _inst_1 F X) P (CategoryTheory.Presieve.functorPushforward.{u3, u2, u5, u4} D _inst_2 C _inst_1 F X T))
but is expected to have type
  forall {C : Type.{u4}} [_inst_1 : CategoryTheory.Category.{u2, u4} C] {P : CategoryTheory.Functor.{u2, u1, u4, succ u1} (Opposite.{succ u4} C) (CategoryTheory.Category.opposite.{u2, u4} C _inst_1) Type.{u1} CategoryTheory.types.{u1}} {D : Type.{u5}} [_inst_2 : CategoryTheory.Category.{u3, u5} D] (F : CategoryTheory.Functor.{u3, u2, u5, u4} D _inst_2 C _inst_1) {X : D} {T : CategoryTheory.Presieve.{u3, u5} D _inst_2 X}, (CategoryTheory.Presieve.FamilyOfElements.{u1, u3, u5} D _inst_2 X (CategoryTheory.Functor.comp.{u3, u2, u1, u5, u4, succ u1} (Opposite.{succ u5} D) (CategoryTheory.Category.opposite.{u3, u5} D _inst_2) (Opposite.{succ u4} C) (CategoryTheory.Category.opposite.{u2, u4} C _inst_1) Type.{u1} CategoryTheory.types.{u1} (CategoryTheory.Functor.op.{u3, u2, u5, u4} D _inst_2 C _inst_1 F) P) T) -> (CategoryTheory.Presieve.FamilyOfElements.{u1, u2, u4} C _inst_1 (Prefunctor.obj.{succ u3, succ u2, u5, u4} D (CategoryTheory.CategoryStruct.toQuiver.{u3, u5} D (CategoryTheory.Category.toCategoryStruct.{u3, u5} D _inst_2)) C (CategoryTheory.CategoryStruct.toQuiver.{u2, u4} C (CategoryTheory.Category.toCategoryStruct.{u2, u4} C _inst_1)) (CategoryTheory.Functor.toPrefunctor.{u3, u2, u5, u4} D _inst_2 C _inst_1 F) X) P (CategoryTheory.Presieve.functorPushforward.{u3, u2, u5, u4} D _inst_2 C _inst_1 F X T))
Case conversion may be inaccurate. Consider using '#align category_theory.presieve.family_of_elements.functor_pushforward CategoryTheory.Presieve.FamilyOfElements.functorPushforwardâ‚“'. -/
/-- Given a family of elements of a sieve `S` on `X` whose values factors through `F`, we can
realize it as a family of elements of `S.functor_pushforward F`. Since the preimage is obtained by
choice, this is not well-defined generally.
-/
noncomputable def FamilyOfElements.functorPushforward {D : Type uâ‚‚} [Category.{vâ‚‚} D] (F : D â¥¤ C)
    {X : D} {T : Presieve X} (x : FamilyOfElements (F.op â‹™ P) T) :
    FamilyOfElements P (T.functorPushforward F) := fun Y f h =>
  by
  obtain âŸ¨Z, g, h, hâ‚, _âŸ© := get_functor_pushforward_structure h
  exact P.map h.op (x g hâ‚)
#align category_theory.presieve.family_of_elements.functor_pushforward CategoryTheory.Presieve.FamilyOfElements.functorPushforward

section Pullback

#print CategoryTheory.Presieve.FamilyOfElements.pullback /-
/-- Given a family of elements of a sieve `S` on `X`, and a map `Y âŸ¶ X`, we can obtain a
family of elements of `S.pullback f` by taking the same elements.
-/
def FamilyOfElements.pullback (f : Y âŸ¶ X) (x : FamilyOfElements P S) :
    FamilyOfElements P (S.pullback f) := fun _ g hg => x (g â‰« f) hg
#align category_theory.presieve.family_of_elements.pullback CategoryTheory.Presieve.FamilyOfElements.pullback
-/

#print CategoryTheory.Presieve.FamilyOfElements.Compatible.pullback /-
theorem FamilyOfElements.Compatible.pullback (f : Y âŸ¶ X) {x : FamilyOfElements P S}
    (h : x.Compatible) : (x.pullback f).Compatible :=
  by
  simp only [compatible_iff_sieve_compatible] at hâŠ¢
  intro W Z fâ‚ fâ‚‚ hf
  unfold family_of_elements.pullback
  rw [â† h (fâ‚ â‰« f) fâ‚‚ hf]
  simp only [assoc]
#align category_theory.presieve.family_of_elements.compatible.pullback CategoryTheory.Presieve.FamilyOfElements.Compatible.pullback
-/

end Pullback

#print CategoryTheory.Presieve.FamilyOfElements.compPresheafMap /-
/-- Given a morphism of presheaves `f : P âŸ¶ Q`, we can take a family of elements valued in `P` to a
family of elements valued in `Q` by composing with `f`.
-/
def FamilyOfElements.compPresheafMap (f : P âŸ¶ Q) (x : FamilyOfElements P R) :
    FamilyOfElements Q R := fun Y g hg => f.app (op Y) (x g hg)
#align category_theory.presieve.family_of_elements.comp_presheaf_map CategoryTheory.Presieve.FamilyOfElements.compPresheafMap
-/

#print CategoryTheory.Presieve.FamilyOfElements.compPresheafMap_id /-
@[simp]
theorem FamilyOfElements.compPresheafMap_id (x : FamilyOfElements P R) :
    x.compPresheafMap (ðŸ™ P) = x :=
  rfl
#align category_theory.presieve.family_of_elements.comp_presheaf_map_id CategoryTheory.Presieve.FamilyOfElements.compPresheafMap_id
-/

#print CategoryTheory.Presieve.FamilyOfElements.compPresheafMap_comp /-
@[simp]
theorem FamilyOfElements.compPresheafMap_comp (x : FamilyOfElements P R) (f : P âŸ¶ Q) (g : Q âŸ¶ U) :
    (x.compPresheafMap f).compPresheafMap g = x.compPresheafMap (f â‰« g) :=
  rfl
#align category_theory.presieve.family_of_elements.comp_prersheaf_map_comp CategoryTheory.Presieve.FamilyOfElements.compPresheafMap_comp
-/

#print CategoryTheory.Presieve.FamilyOfElements.Compatible.compPresheafMap /-
theorem FamilyOfElements.Compatible.compPresheafMap (f : P âŸ¶ Q) {x : FamilyOfElements P R}
    (h : x.Compatible) : (x.compPresheafMap f).Compatible :=
  by
  intro Zâ‚ Zâ‚‚ W gâ‚ gâ‚‚ fâ‚ fâ‚‚ hâ‚ hâ‚‚ eq
  unfold family_of_elements.comp_presheaf_map
  rwa [â† functor_to_types.naturality, â† functor_to_types.naturality, h]
#align category_theory.presieve.family_of_elements.compatible.comp_presheaf_map CategoryTheory.Presieve.FamilyOfElements.Compatible.compPresheafMap
-/

/- warning: category_theory.presieve.family_of_elements.is_amalgamation -> CategoryTheory.Presieve.FamilyOfElements.IsAmalgamation is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] {P : CategoryTheory.Functor.{u2, u1, u3, succ u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) Type.{u1} CategoryTheory.types.{u1}} {X : C} {R : CategoryTheory.Presieve.{u2, u3} C _inst_1 X}, (CategoryTheory.Presieve.FamilyOfElements.{u1, u2, u3} C _inst_1 X P R) -> (CategoryTheory.Functor.obj.{u2, u1, u3, succ u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) Type.{u1} CategoryTheory.types.{u1} P (Opposite.op.{succ u3} C X)) -> Prop
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] {P : CategoryTheory.Functor.{u2, u1, u3, succ u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) Type.{u1} CategoryTheory.types.{u1}} {X : C} {R : CategoryTheory.Presieve.{u2, u3} C _inst_1 X}, (CategoryTheory.Presieve.FamilyOfElements.{u1, u2, u3} C _inst_1 X P R) -> (Prefunctor.obj.{succ u2, succ u1, u3, succ u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u2, u1, u3, succ u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) Type.{u1} CategoryTheory.types.{u1} P) (Opposite.op.{succ u3} C X)) -> Prop
Case conversion may be inaccurate. Consider using '#align category_theory.presieve.family_of_elements.is_amalgamation CategoryTheory.Presieve.FamilyOfElements.IsAmalgamationâ‚“'. -/
/--
The given element `t` of `P.obj (op X)` is an *amalgamation* for the family of elements `x` if every
restriction `P.map f.op t = x_f` for every arrow `f` in the presieve `R`.

This is the definition given in  https://ncatlab.org/nlab/show/sheaf#GeneralDefinitionInComponents,
and https://ncatlab.org/nlab/show/matching+family, as well as [MM92], Chapter III, Section 4,
equation (2).
-/
def FamilyOfElements.IsAmalgamation (x : FamilyOfElements P R) (t : P.obj (op X)) : Prop :=
  âˆ€ â¦ƒY : Câ¦„ (f : Y âŸ¶ X) (h : R f), P.map f.op t = x f h
#align category_theory.presieve.family_of_elements.is_amalgamation CategoryTheory.Presieve.FamilyOfElements.IsAmalgamation

/- warning: category_theory.presieve.family_of_elements.is_amalgamation.comp_presheaf_map -> CategoryTheory.Presieve.FamilyOfElements.IsAmalgamation.compPresheafMap is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] {P : CategoryTheory.Functor.{u2, u1, u3, succ u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) Type.{u1} CategoryTheory.types.{u1}} {Q : CategoryTheory.Functor.{u2, u1, u3, succ u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) Type.{u1} CategoryTheory.types.{u1}} {X : C} {R : CategoryTheory.Presieve.{u2, u3} C _inst_1 X} {x : CategoryTheory.Presieve.FamilyOfElements.{u1, u2, u3} C _inst_1 X P R} {t : CategoryTheory.Functor.obj.{u2, u1, u3, succ u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) Type.{u1} CategoryTheory.types.{u1} P (Opposite.op.{succ u3} C X)} (f : Quiver.Hom.{succ (max u3 u1), max u2 u1 u3 (succ u1)} (CategoryTheory.Functor.{u2, u1, u3, succ u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u1, max u2 u1 u3 (succ u1)} (CategoryTheory.Functor.{u2, u1, u3, succ u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Category.toCategoryStruct.{max u3 u1, max u2 u1 u3 (succ u1)} (CategoryTheory.Functor.{u2, u1, u3, succ u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u2, u1, u3, succ u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) Type.{u1} CategoryTheory.types.{u1}))) P Q), (CategoryTheory.Presieve.FamilyOfElements.IsAmalgamation.{u1, u2, u3} C _inst_1 P X R x t) -> (CategoryTheory.Presieve.FamilyOfElements.IsAmalgamation.{u1, u2, u3} C _inst_1 Q X R (CategoryTheory.Presieve.FamilyOfElements.compPresheafMap.{u1, u2, u3} C _inst_1 P Q X R f x) (CategoryTheory.NatTrans.app.{u2, u1, u3, succ u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) Type.{u1} CategoryTheory.types.{u1} P Q f (Opposite.op.{succ u3} C X) t))
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] {P : CategoryTheory.Functor.{u2, u1, u3, succ u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) Type.{u1} CategoryTheory.types.{u1}} {Q : CategoryTheory.Functor.{u2, u1, u3, succ u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) Type.{u1} CategoryTheory.types.{u1}} {X : C} {R : CategoryTheory.Presieve.{u2, u3} C _inst_1 X} {x : CategoryTheory.Presieve.FamilyOfElements.{u1, u2, u3} C _inst_1 X P R} {t : Prefunctor.obj.{succ u2, succ u1, u3, succ u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u2, u1, u3, succ u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) Type.{u1} CategoryTheory.types.{u1} P) (Opposite.op.{succ u3} C X)} (f : Quiver.Hom.{max (succ u3) (succ u1), max (max u3 u2) (succ u1)} (CategoryTheory.Functor.{u2, u1, u3, succ u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.CategoryStruct.toQuiver.{max u3 u1, max (max u3 u2) (succ u1)} (CategoryTheory.Functor.{u2, u1, u3, succ u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Category.toCategoryStruct.{max u3 u1, max (max u3 u2) (succ u1)} (CategoryTheory.Functor.{u2, u1, u3, succ u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u2, u1, u3, succ u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) Type.{u1} CategoryTheory.types.{u1}))) P Q), (CategoryTheory.Presieve.FamilyOfElements.IsAmalgamation.{u1, u2, u3} C _inst_1 P X R x t) -> (CategoryTheory.Presieve.FamilyOfElements.IsAmalgamation.{u1, u2, u3} C _inst_1 Q X R (CategoryTheory.Presieve.FamilyOfElements.compPresheafMap.{u1, u2, u3} C _inst_1 P Q X R f x) (CategoryTheory.NatTrans.app.{u2, u1, u3, succ u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) Type.{u1} CategoryTheory.types.{u1} P Q f (Opposite.op.{succ u3} C X) t))
Case conversion may be inaccurate. Consider using '#align category_theory.presieve.family_of_elements.is_amalgamation.comp_presheaf_map CategoryTheory.Presieve.FamilyOfElements.IsAmalgamation.compPresheafMapâ‚“'. -/
theorem FamilyOfElements.IsAmalgamation.compPresheafMap {x : FamilyOfElements P R} {t} (f : P âŸ¶ Q)
    (h : x.IsAmalgamation t) : (x.compPresheafMap f).IsAmalgamation (f.app (op X) t) :=
  by
  intro Y g hg
  dsimp [family_of_elements.comp_presheaf_map]
  change (f.app _ â‰« Q.map _) _ = _
  simp [â† f.naturality, h g hg]
#align category_theory.presieve.family_of_elements.is_amalgamation.comp_presheaf_map CategoryTheory.Presieve.FamilyOfElements.IsAmalgamation.compPresheafMap

/- warning: category_theory.presieve.is_compatible_of_exists_amalgamation -> CategoryTheory.Presieve.is_compatible_of_exists_amalgamation is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] {P : CategoryTheory.Functor.{u2, u1, u3, succ u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) Type.{u1} CategoryTheory.types.{u1}} {X : C} {R : CategoryTheory.Presieve.{u2, u3} C _inst_1 X} (x : CategoryTheory.Presieve.FamilyOfElements.{u1, u2, u3} C _inst_1 X P R), (Exists.{succ u1} (CategoryTheory.Functor.obj.{u2, u1, u3, succ u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) Type.{u1} CategoryTheory.types.{u1} P (Opposite.op.{succ u3} C X)) (fun (t : CategoryTheory.Functor.obj.{u2, u1, u3, succ u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) Type.{u1} CategoryTheory.types.{u1} P (Opposite.op.{succ u3} C X)) => CategoryTheory.Presieve.FamilyOfElements.IsAmalgamation.{u1, u2, u3} C _inst_1 P X R x t)) -> (CategoryTheory.Presieve.FamilyOfElements.Compatible.{u1, u2, u3} C _inst_1 P X R x)
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] {P : CategoryTheory.Functor.{u2, u1, u3, succ u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) Type.{u1} CategoryTheory.types.{u1}} {X : C} {R : CategoryTheory.Presieve.{u2, u3} C _inst_1 X} (x : CategoryTheory.Presieve.FamilyOfElements.{u1, u2, u3} C _inst_1 X P R), (Exists.{succ u1} (Prefunctor.obj.{succ u2, succ u1, u3, succ u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u2, u1, u3, succ u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) Type.{u1} CategoryTheory.types.{u1} P) (Opposite.op.{succ u3} C X)) (fun (t : Prefunctor.obj.{succ u2, succ u1, u3, succ u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u2, u1, u3, succ u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) Type.{u1} CategoryTheory.types.{u1} P) (Opposite.op.{succ u3} C X)) => CategoryTheory.Presieve.FamilyOfElements.IsAmalgamation.{u1, u2, u3} C _inst_1 P X R x t)) -> (CategoryTheory.Presieve.FamilyOfElements.Compatible.{u1, u2, u3} C _inst_1 P X R x)
Case conversion may be inaccurate. Consider using '#align category_theory.presieve.is_compatible_of_exists_amalgamation CategoryTheory.Presieve.is_compatible_of_exists_amalgamationâ‚“'. -/
theorem is_compatible_of_exists_amalgamation (x : FamilyOfElements P R)
    (h : âˆƒ t, x.IsAmalgamation t) : x.Compatible :=
  by
  cases' h with t ht
  intro Yâ‚ Yâ‚‚ Z gâ‚ gâ‚‚ fâ‚ fâ‚‚ hâ‚ hâ‚‚ comm
  rw [â† ht _ hâ‚, â† ht _ hâ‚‚, â† functor_to_types.map_comp_apply, â† op_comp, comm]
  simp
#align category_theory.presieve.is_compatible_of_exists_amalgamation CategoryTheory.Presieve.is_compatible_of_exists_amalgamation

/- warning: category_theory.presieve.is_amalgamation_restrict -> CategoryTheory.Presieve.isAmalgamation_restrict is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] {P : CategoryTheory.Functor.{u2, u1, u3, succ u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) Type.{u1} CategoryTheory.types.{u1}} {X : C} {Râ‚ : CategoryTheory.Presieve.{u2, u3} C _inst_1 X} {Râ‚‚ : CategoryTheory.Presieve.{u2, u3} C _inst_1 X} (h : LE.le.{max u3 u2} (CategoryTheory.Presieve.{u2, u3} C _inst_1 X) (Preorder.toHasLe.{max u3 u2} (CategoryTheory.Presieve.{u2, u3} C _inst_1 X) (PartialOrder.toPreorder.{max u3 u2} (CategoryTheory.Presieve.{u2, u3} C _inst_1 X) (CompleteSemilatticeInf.toPartialOrder.{max u3 u2} (CategoryTheory.Presieve.{u2, u3} C _inst_1 X) (CompleteLattice.toCompleteSemilatticeInf.{max u3 u2} (CategoryTheory.Presieve.{u2, u3} C _inst_1 X) (CategoryTheory.Presieve.completeLattice.{u3, u2} C _inst_1 X))))) Râ‚ Râ‚‚) (x : CategoryTheory.Presieve.FamilyOfElements.{u1, u2, u3} C _inst_1 X P Râ‚‚) (t : CategoryTheory.Functor.obj.{u2, u1, u3, succ u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) Type.{u1} CategoryTheory.types.{u1} P (Opposite.op.{succ u3} C X)), (CategoryTheory.Presieve.FamilyOfElements.IsAmalgamation.{u1, u2, u3} C _inst_1 P X Râ‚‚ x t) -> (CategoryTheory.Presieve.FamilyOfElements.IsAmalgamation.{u1, u2, u3} C _inst_1 P X Râ‚ (CategoryTheory.Presieve.FamilyOfElements.restrict.{u1, u2, u3} C _inst_1 P X Râ‚ Râ‚‚ h x) t)
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] {P : CategoryTheory.Functor.{u2, u1, u3, succ u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) Type.{u1} CategoryTheory.types.{u1}} {X : C} {Râ‚ : CategoryTheory.Presieve.{u2, u3} C _inst_1 X} {Râ‚‚ : CategoryTheory.Presieve.{u2, u3} C _inst_1 X} (h : LE.le.{max u3 u2} (CategoryTheory.Presieve.{u2, u3} C _inst_1 X) (Preorder.toLE.{max u3 u2} (CategoryTheory.Presieve.{u2, u3} C _inst_1 X) (PartialOrder.toPreorder.{max u3 u2} (CategoryTheory.Presieve.{u2, u3} C _inst_1 X) (CompleteSemilatticeInf.toPartialOrder.{max u3 u2} (CategoryTheory.Presieve.{u2, u3} C _inst_1 X) (CompleteLattice.toCompleteSemilatticeInf.{max u3 u2} (CategoryTheory.Presieve.{u2, u3} C _inst_1 X) (CategoryTheory.instCompleteLatticePresieve.{u2, u3} C _inst_1 X))))) Râ‚ Râ‚‚) (x : CategoryTheory.Presieve.FamilyOfElements.{u1, u2, u3} C _inst_1 X P Râ‚‚) (t : Prefunctor.obj.{succ u2, succ u1, u3, succ u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u2, u1, u3, succ u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) Type.{u1} CategoryTheory.types.{u1} P) (Opposite.op.{succ u3} C X)), (CategoryTheory.Presieve.FamilyOfElements.IsAmalgamation.{u1, u2, u3} C _inst_1 P X Râ‚‚ x t) -> (CategoryTheory.Presieve.FamilyOfElements.IsAmalgamation.{u1, u2, u3} C _inst_1 P X Râ‚ (CategoryTheory.Presieve.FamilyOfElements.restrict.{u1, u2, u3} C _inst_1 P X Râ‚ Râ‚‚ h x) t)
Case conversion may be inaccurate. Consider using '#align category_theory.presieve.is_amalgamation_restrict CategoryTheory.Presieve.isAmalgamation_restrictâ‚“'. -/
theorem isAmalgamation_restrict {Râ‚ Râ‚‚ : Presieve X} (h : Râ‚ â‰¤ Râ‚‚) (x : FamilyOfElements P Râ‚‚)
    (t : P.obj (op X)) (ht : x.IsAmalgamation t) : (x.restrict h).IsAmalgamation t := fun Y f hf =>
  ht f (h Y hf)
#align category_theory.presieve.is_amalgamation_restrict CategoryTheory.Presieve.isAmalgamation_restrict

/- warning: category_theory.presieve.is_amalgamation_sieve_extend -> CategoryTheory.Presieve.isAmalgamation_sieveExtend is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] {P : CategoryTheory.Functor.{u2, u1, u3, succ u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) Type.{u1} CategoryTheory.types.{u1}} {X : C} {R : CategoryTheory.Presieve.{u2, u3} C _inst_1 X} (x : CategoryTheory.Presieve.FamilyOfElements.{u1, u2, u3} C _inst_1 X P R) (t : CategoryTheory.Functor.obj.{u2, u1, u3, succ u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) Type.{u1} CategoryTheory.types.{u1} P (Opposite.op.{succ u3} C X)), (CategoryTheory.Presieve.FamilyOfElements.IsAmalgamation.{u1, u2, u3} C _inst_1 P X R x t) -> (CategoryTheory.Presieve.FamilyOfElements.IsAmalgamation.{u1, u2, u3} C _inst_1 P X (coeFn.{max (succ u3) (succ u2), max (succ u3) (succ u2)} (CategoryTheory.Sieve.{u2, u3} C _inst_1 X) (fun (_x : CategoryTheory.Sieve.{u2, u3} C _inst_1 X) => CategoryTheory.Presieve.{u2, u3} C _inst_1 X) (CategoryTheory.Sieve.hasCoeToFun.{u2, u3} C _inst_1 X) (CategoryTheory.Sieve.generate.{u2, u3} C _inst_1 X R)) (CategoryTheory.Presieve.FamilyOfElements.sieveExtend.{u1, u2, u3} C _inst_1 P X R x) t)
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] {P : CategoryTheory.Functor.{u2, u1, u3, succ u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) Type.{u1} CategoryTheory.types.{u1}} {X : C} {R : CategoryTheory.Presieve.{u2, u3} C _inst_1 X} (x : CategoryTheory.Presieve.FamilyOfElements.{u1, u2, u3} C _inst_1 X P R) (t : Prefunctor.obj.{succ u2, succ u1, u3, succ u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u2, u1, u3, succ u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) Type.{u1} CategoryTheory.types.{u1} P) (Opposite.op.{succ u3} C X)), (CategoryTheory.Presieve.FamilyOfElements.IsAmalgamation.{u1, u2, u3} C _inst_1 P X R x t) -> (CategoryTheory.Presieve.FamilyOfElements.IsAmalgamation.{u1, u2, u3} C _inst_1 P X (CategoryTheory.Sieve.arrows.{u2, u3} C _inst_1 X (CategoryTheory.Sieve.generate.{u2, u3} C _inst_1 X R)) (CategoryTheory.Presieve.FamilyOfElements.sieveExtend.{u1, u2, u3} C _inst_1 P X R x) t)
Case conversion may be inaccurate. Consider using '#align category_theory.presieve.is_amalgamation_sieve_extend CategoryTheory.Presieve.isAmalgamation_sieveExtendâ‚“'. -/
theorem isAmalgamation_sieveExtend {R : Presieve X} (x : FamilyOfElements P R) (t : P.obj (op X))
    (ht : x.IsAmalgamation t) : x.sieveExtend.IsAmalgamation t :=
  by
  intro Y f hf
  dsimp [family_of_elements.sieve_extend]
  rw [â† ht _, â† functor_to_types.map_comp_apply, â† op_comp, hf.some_spec.some_spec.some_spec.2]
#align category_theory.presieve.is_amalgamation_sieve_extend CategoryTheory.Presieve.isAmalgamation_sieveExtend

#print CategoryTheory.Presieve.IsSeparatedFor /-
/-- A presheaf is separated for a presieve if there is at most one amalgamation. -/
def IsSeparatedFor (P : Cáµ’áµ– â¥¤ Type w) (R : Presieve X) : Prop :=
  âˆ€ (x : FamilyOfElements P R) (tâ‚ tâ‚‚), x.IsAmalgamation tâ‚ â†’ x.IsAmalgamation tâ‚‚ â†’ tâ‚ = tâ‚‚
#align category_theory.presieve.is_separated_for CategoryTheory.Presieve.IsSeparatedFor
-/

/- warning: category_theory.presieve.is_separated_for.ext -> CategoryTheory.Presieve.IsSeparatedFor.ext is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] {P : CategoryTheory.Functor.{u2, u1, u3, succ u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) Type.{u1} CategoryTheory.types.{u1}} {X : C} {R : CategoryTheory.Presieve.{u2, u3} C _inst_1 X}, (CategoryTheory.Presieve.IsSeparatedFor.{u1, u2, u3} C _inst_1 X P R) -> (forall {tâ‚ : CategoryTheory.Functor.obj.{u2, u1, u3, succ u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) Type.{u1} CategoryTheory.types.{u1} P (Opposite.op.{succ u3} C X)} {tâ‚‚ : CategoryTheory.Functor.obj.{u2, u1, u3, succ u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) Type.{u1} CategoryTheory.types.{u1} P (Opposite.op.{succ u3} C X)}, (forall {{Y : C}} {{f : Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) Y X}}, (R Y f) -> (Eq.{succ u1} (CategoryTheory.Functor.obj.{u2, u1, u3, succ u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) Type.{u1} CategoryTheory.types.{u1} P (Opposite.op.{succ u3} C Y)) (CategoryTheory.Functor.map.{u2, u1, u3, succ u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) Type.{u1} CategoryTheory.types.{u1} P (Opposite.op.{succ u3} C X) (Opposite.op.{succ u3} C Y) (Quiver.Hom.op.{u3, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) Y X f) tâ‚) (CategoryTheory.Functor.map.{u2, u1, u3, succ u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) Type.{u1} CategoryTheory.types.{u1} P (Opposite.op.{succ u3} C X) (Opposite.op.{succ u3} C Y) (Quiver.Hom.op.{u3, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) Y X f) tâ‚‚))) -> (Eq.{succ u1} (CategoryTheory.Functor.obj.{u2, u1, u3, succ u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) Type.{u1} CategoryTheory.types.{u1} P (Opposite.op.{succ u3} C X)) tâ‚ tâ‚‚))
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] {P : CategoryTheory.Functor.{u2, u1, u3, succ u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) Type.{u1} CategoryTheory.types.{u1}} {X : C} {R : CategoryTheory.Presieve.{u2, u3} C _inst_1 X}, (CategoryTheory.Presieve.IsSeparatedFor.{u1, u2, u3} C _inst_1 X P R) -> (forall {tâ‚ : Prefunctor.obj.{succ u2, succ u1, u3, succ u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u2, u1, u3, succ u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) Type.{u1} CategoryTheory.types.{u1} P) (Opposite.op.{succ u3} C X)} {tâ‚‚ : Prefunctor.obj.{succ u2, succ u1, u3, succ u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u2, u1, u3, succ u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) Type.{u1} CategoryTheory.types.{u1} P) (Opposite.op.{succ u3} C X)}, (forall {{Y : C}} {{f : Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) Y X}}, (R Y f) -> (Eq.{succ u1} (Prefunctor.obj.{succ u2, succ u1, u3, succ u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u2, u1, u3, succ u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) Type.{u1} CategoryTheory.types.{u1} P) (Opposite.op.{succ u3} C Y)) (Prefunctor.map.{succ u2, succ u1, u3, succ u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u2, u1, u3, succ u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) Type.{u1} CategoryTheory.types.{u1} P) (Opposite.op.{succ u3} C X) (Opposite.op.{succ u3} C Y) (Quiver.Hom.op.{u3, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) Y X f) tâ‚) (Prefunctor.map.{succ u2, succ u1, u3, succ u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u2, u1, u3, succ u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) Type.{u1} CategoryTheory.types.{u1} P) (Opposite.op.{succ u3} C X) (Opposite.op.{succ u3} C Y) (Quiver.Hom.op.{u3, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) Y X f) tâ‚‚))) -> (Eq.{succ u1} (Prefunctor.obj.{succ u2, succ u1, u3, succ u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u2, u1, u3, succ u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) Type.{u1} CategoryTheory.types.{u1} P) (Opposite.op.{succ u3} C X)) tâ‚ tâ‚‚))
Case conversion may be inaccurate. Consider using '#align category_theory.presieve.is_separated_for.ext CategoryTheory.Presieve.IsSeparatedFor.extâ‚“'. -/
theorem IsSeparatedFor.ext {R : Presieve X} (hR : IsSeparatedFor P R) {tâ‚ tâ‚‚ : P.obj (op X)}
    (h : âˆ€ â¦ƒYâ¦„ â¦ƒf : Y âŸ¶ Xâ¦„ (hf : R f), P.map f.op tâ‚ = P.map f.op tâ‚‚) : tâ‚ = tâ‚‚ :=
  hR (fun Y f hf => P.map f.op tâ‚‚) tâ‚ tâ‚‚ (fun Y f hf => h hf) fun Y f hf => rfl
#align category_theory.presieve.is_separated_for.ext CategoryTheory.Presieve.IsSeparatedFor.ext

#print CategoryTheory.Presieve.isSeparatedFor_iff_generate /-
theorem isSeparatedFor_iff_generate : IsSeparatedFor P R â†” IsSeparatedFor P (generate R) :=
  by
  constructor
  Â· intro h x tâ‚ tâ‚‚ htâ‚ htâ‚‚
    apply h (x.restrict (le_generate R)) tâ‚ tâ‚‚ _ _
    Â· exact is_amalgamation_restrict _ x tâ‚ htâ‚
    Â· exact is_amalgamation_restrict _ x tâ‚‚ htâ‚‚
  Â· intro h x tâ‚ tâ‚‚ htâ‚ htâ‚‚
    apply h x.sieve_extend
    Â· exact is_amalgamation_sieve_extend x tâ‚ htâ‚
    Â· exact is_amalgamation_sieve_extend x tâ‚‚ htâ‚‚
#align category_theory.presieve.is_separated_for_iff_generate CategoryTheory.Presieve.isSeparatedFor_iff_generate
-/

/- warning: category_theory.presieve.is_separated_for_top -> CategoryTheory.Presieve.isSeparatedFor_top is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] {X : C} (P : CategoryTheory.Functor.{u2, u1, u3, succ u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) Type.{u1} CategoryTheory.types.{u1}), CategoryTheory.Presieve.IsSeparatedFor.{u1, u2, u3} C _inst_1 X P (Top.top.{max u3 u2} (CategoryTheory.Presieve.{u2, u3} C _inst_1 X) (CompleteLattice.toHasTop.{max u3 u2} (CategoryTheory.Presieve.{u2, u3} C _inst_1 X) (CategoryTheory.Presieve.completeLattice.{u3, u2} C _inst_1 X)))
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] {X : C} (P : CategoryTheory.Functor.{u2, u1, u3, succ u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) Type.{u1} CategoryTheory.types.{u1}), CategoryTheory.Presieve.IsSeparatedFor.{u1, u2, u3} C _inst_1 X P (Top.top.{max u3 u2} (CategoryTheory.Presieve.{u2, u3} C _inst_1 X) (CompleteLattice.toTop.{max u3 u2} (CategoryTheory.Presieve.{u2, u3} C _inst_1 X) (CategoryTheory.instCompleteLatticePresieve.{u2, u3} C _inst_1 X)))
Case conversion may be inaccurate. Consider using '#align category_theory.presieve.is_separated_for_top CategoryTheory.Presieve.isSeparatedFor_topâ‚“'. -/
theorem isSeparatedFor_top (P : Cáµ’áµ– â¥¤ Type w) : IsSeparatedFor P (âŠ¤ : Presieve X) :=
  fun x tâ‚ tâ‚‚ hâ‚ hâ‚‚ => by
  have qâ‚ := hâ‚ (ðŸ™ X) (by simp)
  have qâ‚‚ := hâ‚‚ (ðŸ™ X) (by simp)
  simp only [op_id, functor_to_types.map_id_apply] at qâ‚ qâ‚‚
  rw [qâ‚, qâ‚‚]
#align category_theory.presieve.is_separated_for_top CategoryTheory.Presieve.isSeparatedFor_top

#print CategoryTheory.Presieve.IsSheafFor /-
/-- We define `P` to be a sheaf for the presieve `R` if every compatible family has a unique
amalgamation.

This is the definition of a sheaf for the given presieve given in C2.1.2 of [Elephant], and
https://ncatlab.org/nlab/show/sheaf#GeneralDefinitionInComponents.
Using `compatible_iff_sieve_compatible`,
this is equivalent to the definition of a sheaf in [MM92], Chapter III, Section 4.
-/
def IsSheafFor (P : Cáµ’áµ– â¥¤ Type w) (R : Presieve X) : Prop :=
  âˆ€ x : FamilyOfElements P R, x.Compatible â†’ âˆƒ! t, x.IsAmalgamation t
#align category_theory.presieve.is_sheaf_for CategoryTheory.Presieve.IsSheafFor
-/

#print CategoryTheory.Presieve.YonedaSheafCondition /-
/-- This is an equivalent condition to be a sheaf, which is useful for the abstraction to local
operators on elementary toposes. However this definition is defined only for sieves, not presieves.
The equivalence between this and `is_sheaf_for` is given in `yoneda_condition_iff_sheaf_condition`.
This version is also useful to establish that being a sheaf is preserved under isomorphism of
presheaves.

See the discussion before Equation (3) of [MM92], Chapter III, Section 4. See also C2.1.4 of
[Elephant]. This is also a direct reformulation of <https://stacks.math.columbia.edu/tag/00Z8>.
-/
def YonedaSheafCondition (P : Cáµ’áµ– â¥¤ Type vâ‚) (S : Sieve X) : Prop :=
  âˆ€ f : S.Functor âŸ¶ P, âˆƒ! g, S.functorInclusion â‰« g = f
#align category_theory.presieve.yoneda_sheaf_condition CategoryTheory.Presieve.YonedaSheafCondition
-/

#print CategoryTheory.Presieve.natTransEquivCompatibleFamily /-
-- TODO: We can generalize the universe parameter vâ‚ above by composing with
-- appropriate `ulift_functor`s.
/-- (Implementation). This is a (primarily internal) equivalence between natural transformations
and compatible families.

Cf the discussion after Lemma 7.47.10 in <https://stacks.math.columbia.edu/tag/00YW>. See also
the proof of C2.1.4 of [Elephant], and the discussion in [MM92], Chapter III, Section 4.
-/
def natTransEquivCompatibleFamily {P : Cáµ’áµ– â¥¤ Type vâ‚} :
    (S.Functor âŸ¶ P) â‰ƒ { x : FamilyOfElements P S // x.Compatible }
    where
  toFun Î± := by
    refine' âŸ¨fun Y f hf => _, _âŸ©
    Â· apply Î±.app (op Y) âŸ¨_, hfâŸ©
    Â· rw [compatible_iff_sieve_compatible]
      intro Y Z f g hf
      dsimp
      rw [â† functor_to_types.naturality _ _ Î± g.op]
      rfl
  invFun t :=
    { app := fun Y f => t.1 _ f.2
      naturality' := fun Y Z g => by
        ext âŸ¨f, hfâŸ©
        apply t.2.to_sieveCompatible _ }
  left_inv Î± := by
    ext (XâŸ¨_, _âŸ©)
    rfl
  right_inv := by
    rintro âŸ¨x, hxâŸ©
    rfl
#align category_theory.presieve.nat_trans_equiv_compatible_family CategoryTheory.Presieve.natTransEquivCompatibleFamily
-/

/- warning: category_theory.presieve.extension_iff_amalgamation -> CategoryTheory.Presieve.extension_iff_amalgamation is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {X : C} {S : CategoryTheory.Sieve.{u1, u2} C _inst_1 X} {P : CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}} (x : Quiver.Hom.{succ (max u2 u1), max u1 u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u1 u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u1 u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}))) (CategoryTheory.Sieve.functor.{u1, u2} C _inst_1 X S) P) (g : Quiver.Hom.{succ (max u2 u1), max u1 u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u1 u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u1 u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}))) (CategoryTheory.Functor.obj.{u1, max u2 u1, u2, max u1 u2 (succ u1)} C _inst_1 (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.yoneda.{u1, u2} C _inst_1) X) P), Iff (Eq.{succ (max u2 u1)} (Quiver.Hom.{succ (max u2 u1), max u1 u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u1 u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u1 u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}))) (CategoryTheory.Sieve.functor.{u1, u2} C _inst_1 X S) P) (CategoryTheory.CategoryStruct.comp.{max u2 u1, max u1 u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u1 u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Sieve.functor.{u1, u2} C _inst_1 X S) (CategoryTheory.Functor.obj.{u1, max u2 u1, u2, max u1 u2 (succ u1)} C _inst_1 (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.yoneda.{u1, u2} C _inst_1) X) P (CategoryTheory.Sieve.functorInclusion.{u1, u2} C _inst_1 X S) g) x) (CategoryTheory.Presieve.FamilyOfElements.IsAmalgamation.{u1, u1, u2} C _inst_1 P X (coeFn.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (CategoryTheory.Sieve.{u1, u2} C _inst_1 X) (fun (_x : CategoryTheory.Sieve.{u1, u2} C _inst_1 X) => CategoryTheory.Presieve.{u1, u2} C _inst_1 X) (CategoryTheory.Sieve.hasCoeToFun.{u1, u2} C _inst_1 X) S) (Subtype.val.{max (succ u2) (succ u1)} (CategoryTheory.Presieve.FamilyOfElements.{u1, u1, u2} C _inst_1 X P (coeFn.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (CategoryTheory.Sieve.{u1, u2} C _inst_1 X) (fun (_x : CategoryTheory.Sieve.{u1, u2} C _inst_1 X) => CategoryTheory.Presieve.{u1, u2} C _inst_1 X) (CategoryTheory.Sieve.hasCoeToFun.{u1, u2} C _inst_1 X) S)) (fun (x : CategoryTheory.Presieve.FamilyOfElements.{u1, u1, u2} C _inst_1 X P (coeFn.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (CategoryTheory.Sieve.{u1, u2} C _inst_1 X) (fun (_x : CategoryTheory.Sieve.{u1, u2} C _inst_1 X) => CategoryTheory.Presieve.{u1, u2} C _inst_1 X) (CategoryTheory.Sieve.hasCoeToFun.{u1, u2} C _inst_1 X) S)) => CategoryTheory.Presieve.FamilyOfElements.Compatible.{u1, u1, u2} C _inst_1 P X (coeFn.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (CategoryTheory.Sieve.{u1, u2} C _inst_1 X) (fun (_x : CategoryTheory.Sieve.{u1, u2} C _inst_1 X) => CategoryTheory.Presieve.{u1, u2} C _inst_1 X) (CategoryTheory.Sieve.hasCoeToFun.{u1, u2} C _inst_1 X) S) x) (coeFn.{max 1 (max (succ (max u2 u1)) 1 (succ u2) (succ u1)) (max 1 (succ u2) (succ u1)) (succ (max u2 u1)), max (succ (max u2 u1)) 1 (succ u2) (succ u1)} (Equiv.{succ (max u2 u1), max 1 (succ u2) (succ u1)} (Quiver.Hom.{succ (max u2 u1), max u1 u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u1 u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u1 u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}))) (CategoryTheory.Sieve.functor.{u1, u2} C _inst_1 X S) P) (Subtype.{max (succ u2) (succ u1)} (CategoryTheory.Presieve.FamilyOfElements.{u1, u1, u2} C _inst_1 X P (coeFn.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (CategoryTheory.Sieve.{u1, u2} C _inst_1 X) (fun (_x : CategoryTheory.Sieve.{u1, u2} C _inst_1 X) => CategoryTheory.Presieve.{u1, u2} C _inst_1 X) (CategoryTheory.Sieve.hasCoeToFun.{u1, u2} C _inst_1 X) S)) (fun (x : CategoryTheory.Presieve.FamilyOfElements.{u1, u1, u2} C _inst_1 X P (coeFn.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (CategoryTheory.Sieve.{u1, u2} C _inst_1 X) (fun (_x : CategoryTheory.Sieve.{u1, u2} C _inst_1 X) => CategoryTheory.Presieve.{u1, u2} C _inst_1 X) (CategoryTheory.Sieve.hasCoeToFun.{u1, u2} C _inst_1 X) S)) => CategoryTheory.Presieve.FamilyOfElements.Compatible.{u1, u1, u2} C _inst_1 P X (coeFn.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (CategoryTheory.Sieve.{u1, u2} C _inst_1 X) (fun (_x : CategoryTheory.Sieve.{u1, u2} C _inst_1 X) => CategoryTheory.Presieve.{u1, u2} C _inst_1 X) (CategoryTheory.Sieve.hasCoeToFun.{u1, u2} C _inst_1 X) S) x))) (fun (_x : Equiv.{succ (max u2 u1), max 1 (succ u2) (succ u1)} (Quiver.Hom.{succ (max u2 u1), max u1 u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u1 u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u1 u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}))) (CategoryTheory.Sieve.functor.{u1, u2} C _inst_1 X S) P) (Subtype.{max (succ u2) (succ u1)} (CategoryTheory.Presieve.FamilyOfElements.{u1, u1, u2} C _inst_1 X P (coeFn.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (CategoryTheory.Sieve.{u1, u2} C _inst_1 X) (fun (_x : CategoryTheory.Sieve.{u1, u2} C _inst_1 X) => CategoryTheory.Presieve.{u1, u2} C _inst_1 X) (CategoryTheory.Sieve.hasCoeToFun.{u1, u2} C _inst_1 X) S)) (fun (x : CategoryTheory.Presieve.FamilyOfElements.{u1, u1, u2} C _inst_1 X P (coeFn.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (CategoryTheory.Sieve.{u1, u2} C _inst_1 X) (fun (_x : CategoryTheory.Sieve.{u1, u2} C _inst_1 X) => CategoryTheory.Presieve.{u1, u2} C _inst_1 X) (CategoryTheory.Sieve.hasCoeToFun.{u1, u2} C _inst_1 X) S)) => CategoryTheory.Presieve.FamilyOfElements.Compatible.{u1, u1, u2} C _inst_1 P X (coeFn.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (CategoryTheory.Sieve.{u1, u2} C _inst_1 X) (fun (_x : CategoryTheory.Sieve.{u1, u2} C _inst_1 X) => CategoryTheory.Presieve.{u1, u2} C _inst_1 X) (CategoryTheory.Sieve.hasCoeToFun.{u1, u2} C _inst_1 X) S) x))) => (Quiver.Hom.{succ (max u2 u1), max u1 u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u1 u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u1 u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}))) (CategoryTheory.Sieve.functor.{u1, u2} C _inst_1 X S) P) -> (Subtype.{max (succ u2) (succ u1)} (CategoryTheory.Presieve.FamilyOfElements.{u1, u1, u2} C _inst_1 X P (coeFn.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (CategoryTheory.Sieve.{u1, u2} C _inst_1 X) (fun (_x : CategoryTheory.Sieve.{u1, u2} C _inst_1 X) => CategoryTheory.Presieve.{u1, u2} C _inst_1 X) (CategoryTheory.Sieve.hasCoeToFun.{u1, u2} C _inst_1 X) S)) (fun (x : CategoryTheory.Presieve.FamilyOfElements.{u1, u1, u2} C _inst_1 X P (coeFn.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (CategoryTheory.Sieve.{u1, u2} C _inst_1 X) (fun (_x : CategoryTheory.Sieve.{u1, u2} C _inst_1 X) => CategoryTheory.Presieve.{u1, u2} C _inst_1 X) (CategoryTheory.Sieve.hasCoeToFun.{u1, u2} C _inst_1 X) S)) => CategoryTheory.Presieve.FamilyOfElements.Compatible.{u1, u1, u2} C _inst_1 P X (coeFn.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (CategoryTheory.Sieve.{u1, u2} C _inst_1 X) (fun (_x : CategoryTheory.Sieve.{u1, u2} C _inst_1 X) => CategoryTheory.Presieve.{u1, u2} C _inst_1 X) (CategoryTheory.Sieve.hasCoeToFun.{u1, u2} C _inst_1 X) S) x))) (Equiv.hasCoeToFun.{succ (max u2 u1), max 1 (succ u2) (succ u1)} (Quiver.Hom.{succ (max u2 u1), max u1 u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u1 u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u1 u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}))) (CategoryTheory.Sieve.functor.{u1, u2} C _inst_1 X S) P) (Subtype.{max (succ u2) (succ u1)} (CategoryTheory.Presieve.FamilyOfElements.{u1, u1, u2} C _inst_1 X P (coeFn.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (CategoryTheory.Sieve.{u1, u2} C _inst_1 X) (fun (_x : CategoryTheory.Sieve.{u1, u2} C _inst_1 X) => CategoryTheory.Presieve.{u1, u2} C _inst_1 X) (CategoryTheory.Sieve.hasCoeToFun.{u1, u2} C _inst_1 X) S)) (fun (x : CategoryTheory.Presieve.FamilyOfElements.{u1, u1, u2} C _inst_1 X P (coeFn.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (CategoryTheory.Sieve.{u1, u2} C _inst_1 X) (fun (_x : CategoryTheory.Sieve.{u1, u2} C _inst_1 X) => CategoryTheory.Presieve.{u1, u2} C _inst_1 X) (CategoryTheory.Sieve.hasCoeToFun.{u1, u2} C _inst_1 X) S)) => CategoryTheory.Presieve.FamilyOfElements.Compatible.{u1, u1, u2} C _inst_1 P X (coeFn.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (CategoryTheory.Sieve.{u1, u2} C _inst_1 X) (fun (_x : CategoryTheory.Sieve.{u1, u2} C _inst_1 X) => CategoryTheory.Presieve.{u1, u2} C _inst_1 X) (CategoryTheory.Sieve.hasCoeToFun.{u1, u2} C _inst_1 X) S) x))) (CategoryTheory.Presieve.natTransEquivCompatibleFamily.{u1, u2} C _inst_1 X S P) x)) (coeFn.{max 1 (max (succ (max u2 u1)) (succ u1)) (succ u1) (succ (max u2 u1)), max (succ (max u2 u1)) (succ u1)} (Equiv.{succ (max u2 u1), succ u1} (Quiver.Hom.{succ (max u2 u1), max u1 u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u1 u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u1 u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}))) (CategoryTheory.Functor.obj.{u1, max u2 u1, u2, max u1 u2 (succ u1)} C _inst_1 (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.yoneda.{u1, u2} C _inst_1) X) P) (CategoryTheory.Functor.obj.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1} P (Opposite.op.{succ u2} C X))) (fun (_x : Equiv.{succ (max u2 u1), succ u1} (Quiver.Hom.{succ (max u2 u1), max u1 u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u1 u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u1 u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}))) (CategoryTheory.Functor.obj.{u1, max u2 u1, u2, max u1 u2 (succ u1)} C _inst_1 (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.yoneda.{u1, u2} C _inst_1) X) P) (CategoryTheory.Functor.obj.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1} P (Opposite.op.{succ u2} C X))) => (Quiver.Hom.{succ (max u2 u1), max u1 u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u1 u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u1 u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}))) (CategoryTheory.Functor.obj.{u1, max u2 u1, u2, max u1 u2 (succ u1)} C _inst_1 (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.yoneda.{u1, u2} C _inst_1) X) P) -> (CategoryTheory.Functor.obj.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1} P (Opposite.op.{succ u2} C X))) (Equiv.hasCoeToFun.{succ (max u2 u1), succ u1} (Quiver.Hom.{succ (max u2 u1), max u1 u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u1 u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u1 u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}))) (CategoryTheory.Functor.obj.{u1, max u2 u1, u2, max u1 u2 (succ u1)} C _inst_1 (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.yoneda.{u1, u2} C _inst_1) X) P) (CategoryTheory.Functor.obj.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1} P (Opposite.op.{succ u2} C X))) (CategoryTheory.yonedaEquiv.{u1, u2} C _inst_1 X P) g))
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {X : C} {S : CategoryTheory.Sieve.{u1, u2} C _inst_1 X} {P : CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}} (x : Quiver.Hom.{max (succ u2) (succ u1), max u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}))) (CategoryTheory.Sieve.functor.{u1, u2} C _inst_1 X S) P) (g : Quiver.Hom.{max (succ u2) (succ u1), max (succ u1) u2} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}))) (Prefunctor.obj.{succ u1, max (succ u1) (succ u2), u2, max (succ u1) u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}))) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u2, max u2 (succ u1)} C _inst_1 (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.yoneda.{u1, u2} C _inst_1)) X) P), Iff (Eq.{max (succ u2) (succ u1)} (Quiver.Hom.{succ (max u2 u1), max u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}))) (CategoryTheory.Sieve.functor.{u1, u2} C _inst_1 X S) P) (CategoryTheory.CategoryStruct.comp.{max u2 u1, max u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Sieve.functor.{u1, u2} C _inst_1 X S) (Prefunctor.obj.{succ u1, max (succ u1) (succ u2), u2, max (succ u1) u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}))) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u2, max u2 (succ u1)} C _inst_1 (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.yoneda.{u1, u2} C _inst_1)) X) P (CategoryTheory.Sieve.functorInclusion.{u1, u2} C _inst_1 X S) g) x) (CategoryTheory.Presieve.FamilyOfElements.IsAmalgamation.{u1, u1, u2} C _inst_1 P X (CategoryTheory.Sieve.arrows.{u1, u2} C _inst_1 X S) (Subtype.val.{max (succ u2) (succ u1)} (CategoryTheory.Presieve.FamilyOfElements.{u1, u1, u2} C _inst_1 X P (CategoryTheory.Sieve.arrows.{u1, u2} C _inst_1 X S)) (fun (x : CategoryTheory.Presieve.FamilyOfElements.{u1, u1, u2} C _inst_1 X P (CategoryTheory.Sieve.arrows.{u1, u2} C _inst_1 X S)) => CategoryTheory.Presieve.FamilyOfElements.Compatible.{u1, u1, u2} C _inst_1 P X (CategoryTheory.Sieve.arrows.{u1, u2} C _inst_1 X S) x) (FunLike.coe.{max (succ u2) (succ u1), max (succ u2) (succ u1), max (succ u2) (succ u1)} (Equiv.{max (succ u2) (succ u1), max 1 (succ u2) (succ u1)} (Quiver.Hom.{max (succ u2) (succ u1), max u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}))) (CategoryTheory.Sieve.functor.{u1, u2} C _inst_1 X S) P) (Subtype.{max (succ u2) (succ u1)} (CategoryTheory.Presieve.FamilyOfElements.{u1, u1, u2} C _inst_1 X P (CategoryTheory.Sieve.arrows.{u1, u2} C _inst_1 X S)) (fun (x : CategoryTheory.Presieve.FamilyOfElements.{u1, u1, u2} C _inst_1 X P (CategoryTheory.Sieve.arrows.{u1, u2} C _inst_1 X S)) => CategoryTheory.Presieve.FamilyOfElements.Compatible.{u1, u1, u2} C _inst_1 P X (CategoryTheory.Sieve.arrows.{u1, u2} C _inst_1 X S) x))) (Quiver.Hom.{max (succ u2) (succ u1), max u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}))) (CategoryTheory.Sieve.functor.{u1, u2} C _inst_1 X S) P) (fun (_x : Quiver.Hom.{max (succ u2) (succ u1), max u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}))) (CategoryTheory.Sieve.functor.{u1, u2} C _inst_1 X S) P) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.812 : Quiver.Hom.{max (succ u2) (succ u1), max u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}))) (CategoryTheory.Sieve.functor.{u1, u2} C _inst_1 X S) P) => Subtype.{max (succ u2) (succ u1)} (CategoryTheory.Presieve.FamilyOfElements.{u1, u1, u2} C _inst_1 X P (CategoryTheory.Sieve.arrows.{u1, u2} C _inst_1 X S)) (fun (x : CategoryTheory.Presieve.FamilyOfElements.{u1, u1, u2} C _inst_1 X P (CategoryTheory.Sieve.arrows.{u1, u2} C _inst_1 X S)) => CategoryTheory.Presieve.FamilyOfElements.Compatible.{u1, u1, u2} C _inst_1 P X (CategoryTheory.Sieve.arrows.{u1, u2} C _inst_1 X S) x)) _x) (Equiv.instFunLikeEquiv.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (Quiver.Hom.{max (succ u2) (succ u1), max u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}))) (CategoryTheory.Sieve.functor.{u1, u2} C _inst_1 X S) P) (Subtype.{max (succ u2) (succ u1)} (CategoryTheory.Presieve.FamilyOfElements.{u1, u1, u2} C _inst_1 X P (CategoryTheory.Sieve.arrows.{u1, u2} C _inst_1 X S)) (fun (x : CategoryTheory.Presieve.FamilyOfElements.{u1, u1, u2} C _inst_1 X P (CategoryTheory.Sieve.arrows.{u1, u2} C _inst_1 X S)) => CategoryTheory.Presieve.FamilyOfElements.Compatible.{u1, u1, u2} C _inst_1 P X (CategoryTheory.Sieve.arrows.{u1, u2} C _inst_1 X S) x))) (CategoryTheory.Presieve.natTransEquivCompatibleFamily.{u1, u2} C _inst_1 X S P) x)) (FunLike.coe.{max (succ u2) (succ u1), max (succ u2) (succ u1), succ u1} (Equiv.{max (succ u2) (succ u1), succ u1} (Quiver.Hom.{max (succ u2) (succ u1), max (succ u1) u2} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}))) (Prefunctor.obj.{succ u1, max (succ u1) (succ u2), u2, max (succ u1) u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}))) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u2, max u2 (succ u1)} C _inst_1 (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.yoneda.{u1, u2} C _inst_1)) X) P) (Prefunctor.obj.{succ u1, succ u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} (Opposite.{succ u2} C) (CategoryTheory.Category.toCategoryStruct.{u1, u2} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1))) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1} P) (Opposite.op.{succ u2} C X))) (Quiver.Hom.{max (succ u2) (succ u1), max (succ u1) u2} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}))) (Prefunctor.obj.{succ u1, max (succ u1) (succ u2), u2, max (succ u1) u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}))) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u2, max u2 (succ u1)} C _inst_1 (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.yoneda.{u1, u2} C _inst_1)) X) P) (fun (_x : Quiver.Hom.{max (succ u2) (succ u1), max (succ u1) u2} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}))) (Prefunctor.obj.{succ u1, max (succ u1) (succ u2), u2, max (succ u1) u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}))) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u2, max u2 (succ u1)} C _inst_1 (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.yoneda.{u1, u2} C _inst_1)) X) P) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.812 : Quiver.Hom.{max (succ u2) (succ u1), max (succ u1) u2} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}))) (Prefunctor.obj.{succ u1, max (succ u1) (succ u2), u2, max (succ u1) u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}))) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u2, max u2 (succ u1)} C _inst_1 (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.yoneda.{u1, u2} C _inst_1)) X) P) => Prefunctor.obj.{succ u1, succ u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} (Opposite.{succ u2} C) (CategoryTheory.Category.toCategoryStruct.{u1, u2} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1))) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1} P) (Opposite.op.{succ u2} C X)) _x) (Equiv.instFunLikeEquiv.{max (succ u2) (succ u1), succ u1} (Quiver.Hom.{max (succ u2) (succ u1), max (succ u1) u2} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}))) (Prefunctor.obj.{succ u1, max (succ u1) (succ u2), u2, max (succ u1) u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}))) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u2, max u2 (succ u1)} C _inst_1 (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.yoneda.{u1, u2} C _inst_1)) X) P) (Prefunctor.obj.{succ u1, succ u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} (Opposite.{succ u2} C) (CategoryTheory.Category.toCategoryStruct.{u1, u2} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1))) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1} P) (Opposite.op.{succ u2} C X))) (CategoryTheory.yonedaEquiv.{u1, u2} C _inst_1 X P) g))
Case conversion may be inaccurate. Consider using '#align category_theory.presieve.extension_iff_amalgamation CategoryTheory.Presieve.extension_iff_amalgamationâ‚“'. -/
/-- (Implementation). A lemma useful to prove `yoneda_condition_iff_sheaf_condition`. -/
theorem extension_iff_amalgamation {P : Cáµ’áµ– â¥¤ Type vâ‚} (x : S.Functor âŸ¶ P) (g : yoneda.obj X âŸ¶ P) :
    S.functorInclusion â‰« g = x â†”
      (natTransEquivCompatibleFamily x).1.IsAmalgamation (yonedaEquiv g) :=
  by
  change _ â†” âˆ€ â¦ƒY : Câ¦„ (f : Y âŸ¶ X) (h : S f), P.map f.op (yoneda_equiv g) = x.app (op Y) âŸ¨f, hâŸ©
  constructor
  Â· rintro rfl Y f hf
    rw [yoneda_equiv_naturality]
    dsimp
    simp
  -- See note [dsimp, simp].
  Â· intro h
    ext (YâŸ¨f, hfâŸ©)
    have : _ = x.app Y _ := h f hf
    rw [yoneda_equiv_naturality] at this
    rw [â† this]
    dsimp
    simp
#align category_theory.presieve.extension_iff_amalgamation CategoryTheory.Presieve.extension_iff_amalgamation

#print CategoryTheory.Presieve.isSheafFor_iff_yonedaSheafCondition /-
-- See note [dsimp, simp].
/-- The yoneda version of the sheaf condition is equivalent to the sheaf condition.

C2.1.4 of [Elephant].
-/
theorem isSheafFor_iff_yonedaSheafCondition {P : Cáµ’áµ– â¥¤ Type vâ‚} :
    IsSheafFor P S â†” YonedaSheafCondition P S :=
  by
  rw [is_sheaf_for, yoneda_sheaf_condition]
  simp_rw [extension_iff_amalgamation]
  rw [Equiv.forall_congr_left' nat_trans_equiv_compatible_family]
  rw [Subtype.forall]
  apply ball_congr
  intro x hx
  rw [Equiv.exists_unique_congr_left _]
  simp
#align category_theory.presieve.is_sheaf_for_iff_yoneda_sheaf_condition CategoryTheory.Presieve.isSheafFor_iff_yonedaSheafCondition
-/

/- warning: category_theory.presieve.is_sheaf_for.extend -> CategoryTheory.Presieve.IsSheafFor.extend is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {X : C} {S : CategoryTheory.Sieve.{u1, u2} C _inst_1 X} {P : CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}}, (CategoryTheory.Presieve.IsSheafFor.{u1, u1, u2} C _inst_1 X P (coeFn.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (CategoryTheory.Sieve.{u1, u2} C _inst_1 X) (fun (_x : CategoryTheory.Sieve.{u1, u2} C _inst_1 X) => CategoryTheory.Presieve.{u1, u2} C _inst_1 X) (CategoryTheory.Sieve.hasCoeToFun.{u1, u2} C _inst_1 X) S)) -> (Quiver.Hom.{succ (max u2 u1), max u1 u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u1 u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u1 u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}))) (CategoryTheory.Sieve.functor.{u1, u2} C _inst_1 X S) P) -> (Quiver.Hom.{succ (max u2 u1), max u1 u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u1 u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u1 u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}))) (CategoryTheory.Functor.obj.{u1, max u2 u1, u2, max u1 u2 (succ u1)} C _inst_1 (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.yoneda.{u1, u2} C _inst_1) X) P)
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {X : C} {S : CategoryTheory.Sieve.{u1, u2} C _inst_1 X} {P : CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}}, (CategoryTheory.Presieve.IsSheafFor.{u1, u1, u2} C _inst_1 X P (CategoryTheory.Sieve.arrows.{u1, u2} C _inst_1 X S)) -> (Quiver.Hom.{max (succ u2) (succ u1), max u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}))) (CategoryTheory.Sieve.functor.{u1, u2} C _inst_1 X S) P) -> (Quiver.Hom.{max (succ u2) (succ u1), max (succ u1) u2} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}))) (Prefunctor.obj.{succ u1, max (succ u1) (succ u2), u2, max (succ u1) u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}))) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u2, max u2 (succ u1)} C _inst_1 (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.yoneda.{u1, u2} C _inst_1)) X) P)
Case conversion may be inaccurate. Consider using '#align category_theory.presieve.is_sheaf_for.extend CategoryTheory.Presieve.IsSheafFor.extendâ‚“'. -/
/--
If `P` is a sheaf for the sieve `S` on `X`, a natural transformation from `S` (viewed as a functor)
to `P` can be (uniquely) extended to all of `yoneda.obj X`.

      f
   S  â†’  P
   â†“  â†—
   yX

-/
noncomputable def IsSheafFor.extend {P : Cáµ’áµ– â¥¤ Type vâ‚} (h : IsSheafFor P S) (f : S.Functor âŸ¶ P) :
    yoneda.obj X âŸ¶ P :=
  (isSheafFor_iff_yonedaSheafCondition.1 h f).exists.some
#align category_theory.presieve.is_sheaf_for.extend CategoryTheory.Presieve.IsSheafFor.extend

#print CategoryTheory.Presieve.IsSheafFor.functorInclusion_comp_extend /-
/--
Show that the extension of `f : S.functor âŸ¶ P` to all of `yoneda.obj X` is in fact an extension, ie
that the triangle below commutes, provided `P` is a sheaf for `S`

      f
   S  â†’  P
   â†“  â†—
   yX

-/
@[simp, reassoc]
theorem IsSheafFor.functorInclusion_comp_extend {P : Cáµ’áµ– â¥¤ Type vâ‚} (h : IsSheafFor P S)
    (f : S.Functor âŸ¶ P) : S.functorInclusion â‰« h.extend f = f :=
  (isSheafFor_iff_yonedaSheafCondition.1 h f).exists.choose_spec
#align category_theory.presieve.is_sheaf_for.functor_inclusion_comp_extend CategoryTheory.Presieve.IsSheafFor.functorInclusion_comp_extend
-/

/- warning: category_theory.presieve.is_sheaf_for.unique_extend -> CategoryTheory.Presieve.IsSheafFor.unique_extend is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {X : C} {S : CategoryTheory.Sieve.{u1, u2} C _inst_1 X} {P : CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}} (h : CategoryTheory.Presieve.IsSheafFor.{u1, u1, u2} C _inst_1 X P (coeFn.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (CategoryTheory.Sieve.{u1, u2} C _inst_1 X) (fun (_x : CategoryTheory.Sieve.{u1, u2} C _inst_1 X) => CategoryTheory.Presieve.{u1, u2} C _inst_1 X) (CategoryTheory.Sieve.hasCoeToFun.{u1, u2} C _inst_1 X) S)) {f : Quiver.Hom.{succ (max u2 u1), max u1 u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u1 u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u1 u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}))) (CategoryTheory.Sieve.functor.{u1, u2} C _inst_1 X S) P} (t : Quiver.Hom.{succ (max u2 u1), max u1 u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u1 u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u1 u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}))) (CategoryTheory.Functor.obj.{u1, max u2 u1, u2, max u1 u2 (succ u1)} C _inst_1 (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.yoneda.{u1, u2} C _inst_1) X) P), (Eq.{succ (max u2 u1)} (Quiver.Hom.{succ (max u2 u1), max u1 u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u1 u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u1 u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}))) (CategoryTheory.Sieve.functor.{u1, u2} C _inst_1 X S) P) (CategoryTheory.CategoryStruct.comp.{max u2 u1, max u1 u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u1 u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Sieve.functor.{u1, u2} C _inst_1 X S) (CategoryTheory.Functor.obj.{u1, max u2 u1, u2, max u1 u2 (succ u1)} C _inst_1 (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.yoneda.{u1, u2} C _inst_1) X) P (CategoryTheory.Sieve.functorInclusion.{u1, u2} C _inst_1 X S) t) f) -> (Eq.{succ (max u2 u1)} (Quiver.Hom.{succ (max u2 u1), max u1 u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u1 u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u1 u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}))) (CategoryTheory.Functor.obj.{u1, max u2 u1, u2, max u1 u2 (succ u1)} C _inst_1 (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.yoneda.{u1, u2} C _inst_1) X) P) t (CategoryTheory.Presieve.IsSheafFor.extend.{u1, u2} C _inst_1 X S P h f))
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {X : C} {S : CategoryTheory.Sieve.{u1, u2} C _inst_1 X} {P : CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}} (h : CategoryTheory.Presieve.IsSheafFor.{u1, u1, u2} C _inst_1 X P (CategoryTheory.Sieve.arrows.{u1, u2} C _inst_1 X S)) {f : Quiver.Hom.{max (succ u2) (succ u1), max u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}))) (CategoryTheory.Sieve.functor.{u1, u2} C _inst_1 X S) P} (t : Quiver.Hom.{max (succ u2) (succ u1), max (succ u1) u2} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}))) (Prefunctor.obj.{succ u1, max (succ u1) (succ u2), u2, max (succ u1) u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}))) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u2, max u2 (succ u1)} C _inst_1 (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.yoneda.{u1, u2} C _inst_1)) X) P), (Eq.{max (succ u2) (succ u1)} (Quiver.Hom.{succ (max u2 u1), max u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}))) (CategoryTheory.Sieve.functor.{u1, u2} C _inst_1 X S) P) (CategoryTheory.CategoryStruct.comp.{max u2 u1, max u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Sieve.functor.{u1, u2} C _inst_1 X S) (Prefunctor.obj.{succ u1, max (succ u1) (succ u2), u2, max (succ u1) u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}))) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u2, max u2 (succ u1)} C _inst_1 (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.yoneda.{u1, u2} C _inst_1)) X) P (CategoryTheory.Sieve.functorInclusion.{u1, u2} C _inst_1 X S) t) f) -> (Eq.{max (succ u2) (succ u1)} (Quiver.Hom.{max (succ u2) (succ u1), max (succ u1) u2} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}))) (Prefunctor.obj.{succ u1, max (succ u1) (succ u2), u2, max (succ u1) u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}))) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u2, max u2 (succ u1)} C _inst_1 (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.yoneda.{u1, u2} C _inst_1)) X) P) t (CategoryTheory.Presieve.IsSheafFor.extend.{u1, u2} C _inst_1 X S P h f))
Case conversion may be inaccurate. Consider using '#align category_theory.presieve.is_sheaf_for.unique_extend CategoryTheory.Presieve.IsSheafFor.unique_extendâ‚“'. -/
/-- The extension of `f` to `yoneda.obj X` is unique. -/
theorem IsSheafFor.unique_extend {P : Cáµ’áµ– â¥¤ Type vâ‚} (h : IsSheafFor P S) {f : S.Functor âŸ¶ P}
    (t : yoneda.obj X âŸ¶ P) (ht : S.functorInclusion â‰« t = f) : t = h.extend f :=
  (isSheafFor_iff_yonedaSheafCondition.1 h f).unique ht (h.functorInclusion_comp_extend f)
#align category_theory.presieve.is_sheaf_for.unique_extend CategoryTheory.Presieve.IsSheafFor.unique_extend

/- warning: category_theory.presieve.is_sheaf_for.hom_ext -> CategoryTheory.Presieve.IsSheafFor.hom_ext is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {X : C} {S : CategoryTheory.Sieve.{u1, u2} C _inst_1 X} {P : CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}}, (CategoryTheory.Presieve.IsSheafFor.{u1, u1, u2} C _inst_1 X P (coeFn.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (CategoryTheory.Sieve.{u1, u2} C _inst_1 X) (fun (_x : CategoryTheory.Sieve.{u1, u2} C _inst_1 X) => CategoryTheory.Presieve.{u1, u2} C _inst_1 X) (CategoryTheory.Sieve.hasCoeToFun.{u1, u2} C _inst_1 X) S)) -> (forall (tâ‚ : Quiver.Hom.{succ (max u2 u1), max u1 u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u1 u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u1 u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}))) (CategoryTheory.Functor.obj.{u1, max u2 u1, u2, max u1 u2 (succ u1)} C _inst_1 (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.yoneda.{u1, u2} C _inst_1) X) P) (tâ‚‚ : Quiver.Hom.{succ (max u2 u1), max u1 u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u1 u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u1 u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}))) (CategoryTheory.Functor.obj.{u1, max u2 u1, u2, max u1 u2 (succ u1)} C _inst_1 (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.yoneda.{u1, u2} C _inst_1) X) P), (Eq.{succ (max u2 u1)} (Quiver.Hom.{succ (max u2 u1), max u1 u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u1 u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u1 u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}))) (CategoryTheory.Sieve.functor.{u1, u2} C _inst_1 X S) P) (CategoryTheory.CategoryStruct.comp.{max u2 u1, max u1 u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u1 u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Sieve.functor.{u1, u2} C _inst_1 X S) (CategoryTheory.Functor.obj.{u1, max u2 u1, u2, max u1 u2 (succ u1)} C _inst_1 (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.yoneda.{u1, u2} C _inst_1) X) P (CategoryTheory.Sieve.functorInclusion.{u1, u2} C _inst_1 X S) tâ‚) (CategoryTheory.CategoryStruct.comp.{max u2 u1, max u1 u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u1 u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Sieve.functor.{u1, u2} C _inst_1 X S) (CategoryTheory.Functor.obj.{u1, max u2 u1, u2, max u1 u2 (succ u1)} C _inst_1 (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.yoneda.{u1, u2} C _inst_1) X) P (CategoryTheory.Sieve.functorInclusion.{u1, u2} C _inst_1 X S) tâ‚‚)) -> (Eq.{succ (max u2 u1)} (Quiver.Hom.{succ (max u2 u1), max u1 u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u1 u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u1 u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}))) (CategoryTheory.Functor.obj.{u1, max u2 u1, u2, max u1 u2 (succ u1)} C _inst_1 (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.yoneda.{u1, u2} C _inst_1) X) P) tâ‚ tâ‚‚))
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] {X : C} {S : CategoryTheory.Sieve.{u1, u2} C _inst_1 X} {P : CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}}, (CategoryTheory.Presieve.IsSheafFor.{u1, u1, u2} C _inst_1 X P (CategoryTheory.Sieve.arrows.{u1, u2} C _inst_1 X S)) -> (forall (tâ‚ : Quiver.Hom.{max (succ u2) (succ u1), max (succ u1) u2} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}))) (Prefunctor.obj.{succ u1, max (succ u1) (succ u2), u2, max (succ u1) u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}))) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u2, max u2 (succ u1)} C _inst_1 (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.yoneda.{u1, u2} C _inst_1)) X) P) (tâ‚‚ : Quiver.Hom.{max (succ u2) (succ u1), max (succ u1) u2} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}))) (Prefunctor.obj.{succ u1, max (succ u1) (succ u2), u2, max (succ u1) u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}))) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u2, max u2 (succ u1)} C _inst_1 (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.yoneda.{u1, u2} C _inst_1)) X) P), (Eq.{max (succ u2) (succ u1)} (Quiver.Hom.{succ (max u2 u1), max u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}))) (CategoryTheory.Sieve.functor.{u1, u2} C _inst_1 X S) P) (CategoryTheory.CategoryStruct.comp.{max u2 u1, max u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Sieve.functor.{u1, u2} C _inst_1 X S) (Prefunctor.obj.{succ u1, max (succ u1) (succ u2), u2, max (succ u1) u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}))) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u2, max u2 (succ u1)} C _inst_1 (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.yoneda.{u1, u2} C _inst_1)) X) P (CategoryTheory.Sieve.functorInclusion.{u1, u2} C _inst_1 X S) tâ‚) (CategoryTheory.CategoryStruct.comp.{max u2 u1, max u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Sieve.functor.{u1, u2} C _inst_1 X S) (Prefunctor.obj.{succ u1, max (succ u1) (succ u2), u2, max (succ u1) u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}))) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u2, max u2 (succ u1)} C _inst_1 (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.yoneda.{u1, u2} C _inst_1)) X) P (CategoryTheory.Sieve.functorInclusion.{u1, u2} C _inst_1 X S) tâ‚‚)) -> (Eq.{max (succ u2) (succ u1)} (Quiver.Hom.{max (succ u2) (succ u1), max (succ u1) u2} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}))) (Prefunctor.obj.{succ u1, max (succ u1) (succ u2), u2, max (succ u1) u2} C (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} C (CategoryTheory.Category.toCategoryStruct.{u1, u2} C _inst_1)) (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max u2 (succ u1)} (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}))) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u2, max u2 (succ u1)} C _inst_1 (CategoryTheory.Functor.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u1, u1, u2, succ u1} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.yoneda.{u1, u2} C _inst_1)) X) P) tâ‚ tâ‚‚))
Case conversion may be inaccurate. Consider using '#align category_theory.presieve.is_sheaf_for.hom_ext CategoryTheory.Presieve.IsSheafFor.hom_extâ‚“'. -/
/--
If `P` is a sheaf for the sieve `S` on `X`, then if two natural transformations from `yoneda.obj X`
to `P` agree when restricted to the subfunctor given by `S`, they are equal.
-/
theorem IsSheafFor.hom_ext {P : Cáµ’áµ– â¥¤ Type vâ‚} (h : IsSheafFor P S) (tâ‚ tâ‚‚ : yoneda.obj X âŸ¶ P)
    (ht : S.functorInclusion â‰« tâ‚ = S.functorInclusion â‰« tâ‚‚) : tâ‚ = tâ‚‚ :=
  (h.unique_extend tâ‚ ht).trans (h.unique_extend tâ‚‚ rfl).symm
#align category_theory.presieve.is_sheaf_for.hom_ext CategoryTheory.Presieve.IsSheafFor.hom_ext

/- warning: category_theory.presieve.is_separated_for_and_exists_is_amalgamation_iff_sheaf_for -> CategoryTheory.Presieve.isSeparatedFor_and_exists_isAmalgamation_iff_isSheafFor is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] {P : CategoryTheory.Functor.{u2, u1, u3, succ u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) Type.{u1} CategoryTheory.types.{u1}} {X : C} {R : CategoryTheory.Presieve.{u2, u3} C _inst_1 X}, Iff (And (CategoryTheory.Presieve.IsSeparatedFor.{u1, u2, u3} C _inst_1 X P R) (forall (x : CategoryTheory.Presieve.FamilyOfElements.{u1, u2, u3} C _inst_1 X P R), (CategoryTheory.Presieve.FamilyOfElements.Compatible.{u1, u2, u3} C _inst_1 P X R x) -> (Exists.{succ u1} (CategoryTheory.Functor.obj.{u2, u1, u3, succ u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) Type.{u1} CategoryTheory.types.{u1} P (Opposite.op.{succ u3} C X)) (fun (t : CategoryTheory.Functor.obj.{u2, u1, u3, succ u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) Type.{u1} CategoryTheory.types.{u1} P (Opposite.op.{succ u3} C X)) => CategoryTheory.Presieve.FamilyOfElements.IsAmalgamation.{u1, u2, u3} C _inst_1 P X R x t)))) (CategoryTheory.Presieve.IsSheafFor.{u1, u2, u3} C _inst_1 X P R)
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] {P : CategoryTheory.Functor.{u2, u1, u3, succ u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) Type.{u1} CategoryTheory.types.{u1}} {X : C} {R : CategoryTheory.Presieve.{u2, u3} C _inst_1 X}, Iff (And (CategoryTheory.Presieve.IsSeparatedFor.{u1, u2, u3} C _inst_1 X P R) (forall (x : CategoryTheory.Presieve.FamilyOfElements.{u1, u2, u3} C _inst_1 X P R), (CategoryTheory.Presieve.FamilyOfElements.Compatible.{u1, u2, u3} C _inst_1 P X R x) -> (Exists.{succ u1} (Prefunctor.obj.{succ u2, succ u1, u3, succ u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u2, u1, u3, succ u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) Type.{u1} CategoryTheory.types.{u1} P) (Opposite.op.{succ u3} C X)) (fun (t : Prefunctor.obj.{succ u2, succ u1, u3, succ u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u2, u1, u3, succ u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) Type.{u1} CategoryTheory.types.{u1} P) (Opposite.op.{succ u3} C X)) => CategoryTheory.Presieve.FamilyOfElements.IsAmalgamation.{u1, u2, u3} C _inst_1 P X R x t)))) (CategoryTheory.Presieve.IsSheafFor.{u1, u2, u3} C _inst_1 X P R)
Case conversion may be inaccurate. Consider using '#align category_theory.presieve.is_separated_for_and_exists_is_amalgamation_iff_sheaf_for CategoryTheory.Presieve.isSeparatedFor_and_exists_isAmalgamation_iff_isSheafForâ‚“'. -/
/-- `P` is a sheaf for `R` iff it is separated for `R` and there exists an amalgamation. -/
theorem isSeparatedFor_and_exists_isAmalgamation_iff_isSheafFor :
    (IsSeparatedFor P R âˆ§ âˆ€ x : FamilyOfElements P R, x.Compatible â†’ âˆƒ t, x.IsAmalgamation t) â†”
      IsSheafFor P R :=
  by
  rw [is_separated_for, â† forall_and]
  apply forall_congr'
  intro x
  constructor
  Â· intro z hx
    exact existsUnique_of_exists_of_unique (z.2 hx) z.1
  Â· intro h
    refine' âŸ¨_, ExistsUnique.exists âˆ˜ hâŸ©
    intro tâ‚ tâ‚‚ htâ‚ htâ‚‚
    apply (h _).unique htâ‚ htâ‚‚
    exact is_compatible_of_exists_amalgamation x âŸ¨_, htâ‚‚âŸ©
#align category_theory.presieve.is_separated_for_and_exists_is_amalgamation_iff_sheaf_for CategoryTheory.Presieve.isSeparatedFor_and_exists_isAmalgamation_iff_isSheafFor

/- warning: category_theory.presieve.is_separated_for.is_sheaf_for -> CategoryTheory.Presieve.IsSeparatedFor.isSheafFor is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] {P : CategoryTheory.Functor.{u2, u1, u3, succ u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) Type.{u1} CategoryTheory.types.{u1}} {X : C} {R : CategoryTheory.Presieve.{u2, u3} C _inst_1 X}, (CategoryTheory.Presieve.IsSeparatedFor.{u1, u2, u3} C _inst_1 X P R) -> (forall (x : CategoryTheory.Presieve.FamilyOfElements.{u1, u2, u3} C _inst_1 X P R), (CategoryTheory.Presieve.FamilyOfElements.Compatible.{u1, u2, u3} C _inst_1 P X R x) -> (Exists.{succ u1} (CategoryTheory.Functor.obj.{u2, u1, u3, succ u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) Type.{u1} CategoryTheory.types.{u1} P (Opposite.op.{succ u3} C X)) (fun (t : CategoryTheory.Functor.obj.{u2, u1, u3, succ u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) Type.{u1} CategoryTheory.types.{u1} P (Opposite.op.{succ u3} C X)) => CategoryTheory.Presieve.FamilyOfElements.IsAmalgamation.{u1, u2, u3} C _inst_1 P X R x t))) -> (CategoryTheory.Presieve.IsSheafFor.{u1, u2, u3} C _inst_1 X P R)
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] {P : CategoryTheory.Functor.{u2, u1, u3, succ u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) Type.{u1} CategoryTheory.types.{u1}} {X : C} {R : CategoryTheory.Presieve.{u2, u3} C _inst_1 X}, (CategoryTheory.Presieve.IsSeparatedFor.{u1, u2, u3} C _inst_1 X P R) -> (forall (x : CategoryTheory.Presieve.FamilyOfElements.{u1, u2, u3} C _inst_1 X P R), (CategoryTheory.Presieve.FamilyOfElements.Compatible.{u1, u2, u3} C _inst_1 P X R x) -> (Exists.{succ u1} (Prefunctor.obj.{succ u2, succ u1, u3, succ u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u2, u1, u3, succ u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) Type.{u1} CategoryTheory.types.{u1} P) (Opposite.op.{succ u3} C X)) (fun (t : Prefunctor.obj.{succ u2, succ u1, u3, succ u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u2, u1, u3, succ u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) Type.{u1} CategoryTheory.types.{u1} P) (Opposite.op.{succ u3} C X)) => CategoryTheory.Presieve.FamilyOfElements.IsAmalgamation.{u1, u2, u3} C _inst_1 P X R x t))) -> (CategoryTheory.Presieve.IsSheafFor.{u1, u2, u3} C _inst_1 X P R)
Case conversion may be inaccurate. Consider using '#align category_theory.presieve.is_separated_for.is_sheaf_for CategoryTheory.Presieve.IsSeparatedFor.isSheafForâ‚“'. -/
/-- If `P` is separated for `R` and every family has an amalgamation, then `P` is a sheaf for `R`.
-/
theorem IsSeparatedFor.isSheafFor (t : IsSeparatedFor P R) :
    (âˆ€ x : FamilyOfElements P R, x.Compatible â†’ âˆƒ t, x.IsAmalgamation t) â†’ IsSheafFor P R :=
  by
  rw [â† is_separated_for_and_exists_is_amalgamation_iff_sheaf_for]
  exact And.intro t
#align category_theory.presieve.is_separated_for.is_sheaf_for CategoryTheory.Presieve.IsSeparatedFor.isSheafFor

#print CategoryTheory.Presieve.IsSheafFor.isSeparatedFor /-
/-- If `P` is a sheaf for `R`, it is separated for `R`. -/
theorem IsSheafFor.isSeparatedFor : IsSheafFor P R â†’ IsSeparatedFor P R := fun q =>
  (isSeparatedFor_and_exists_isAmalgamation_iff_isSheafFor.2 q).1
#align category_theory.presieve.is_sheaf_for.is_separated_for CategoryTheory.Presieve.IsSheafFor.isSeparatedFor
-/

/- warning: category_theory.presieve.is_sheaf_for.amalgamate -> CategoryTheory.Presieve.IsSheafFor.amalgamate is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] {P : CategoryTheory.Functor.{u2, u1, u3, succ u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) Type.{u1} CategoryTheory.types.{u1}} {X : C} {R : CategoryTheory.Presieve.{u2, u3} C _inst_1 X}, (CategoryTheory.Presieve.IsSheafFor.{u1, u2, u3} C _inst_1 X P R) -> (forall (x : CategoryTheory.Presieve.FamilyOfElements.{u1, u2, u3} C _inst_1 X P R), (CategoryTheory.Presieve.FamilyOfElements.Compatible.{u1, u2, u3} C _inst_1 P X R x) -> (CategoryTheory.Functor.obj.{u2, u1, u3, succ u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) Type.{u1} CategoryTheory.types.{u1} P (Opposite.op.{succ u3} C X)))
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] {P : CategoryTheory.Functor.{u2, u1, u3, succ u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) Type.{u1} CategoryTheory.types.{u1}} {X : C} {R : CategoryTheory.Presieve.{u2, u3} C _inst_1 X}, (CategoryTheory.Presieve.IsSheafFor.{u1, u2, u3} C _inst_1 X P R) -> (forall (x : CategoryTheory.Presieve.FamilyOfElements.{u1, u2, u3} C _inst_1 X P R), (CategoryTheory.Presieve.FamilyOfElements.Compatible.{u1, u2, u3} C _inst_1 P X R x) -> (Prefunctor.obj.{succ u2, succ u1, u3, succ u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u2, u1, u3, succ u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) Type.{u1} CategoryTheory.types.{u1} P) (Opposite.op.{succ u3} C X)))
Case conversion may be inaccurate. Consider using '#align category_theory.presieve.is_sheaf_for.amalgamate CategoryTheory.Presieve.IsSheafFor.amalgamateâ‚“'. -/
/-- Get the amalgamation of the given compatible family, provided we have a sheaf. -/
noncomputable def IsSheafFor.amalgamate (t : IsSheafFor P R) (x : FamilyOfElements P R)
    (hx : x.Compatible) : P.obj (op X) :=
  (t x hx).exists.some
#align category_theory.presieve.is_sheaf_for.amalgamate CategoryTheory.Presieve.IsSheafFor.amalgamate

#print CategoryTheory.Presieve.IsSheafFor.isAmalgamation /-
theorem IsSheafFor.isAmalgamation (t : IsSheafFor P R) {x : FamilyOfElements P R}
    (hx : x.Compatible) : x.IsAmalgamation (t.amalgamate x hx) :=
  (t x hx).exists.choose_spec
#align category_theory.presieve.is_sheaf_for.is_amalgamation CategoryTheory.Presieve.IsSheafFor.isAmalgamation
-/

/- warning: category_theory.presieve.is_sheaf_for.valid_glue -> CategoryTheory.Presieve.IsSheafFor.valid_glue is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] {P : CategoryTheory.Functor.{u2, u1, u3, succ u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) Type.{u1} CategoryTheory.types.{u1}} {X : C} {Y : C} {R : CategoryTheory.Presieve.{u2, u3} C _inst_1 X} (t : CategoryTheory.Presieve.IsSheafFor.{u1, u2, u3} C _inst_1 X P R) {x : CategoryTheory.Presieve.FamilyOfElements.{u1, u2, u3} C _inst_1 X P R} (hx : CategoryTheory.Presieve.FamilyOfElements.Compatible.{u1, u2, u3} C _inst_1 P X R x) (f : Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) Y X) (Hf : R Y f), Eq.{succ u1} (CategoryTheory.Functor.obj.{u2, u1, u3, succ u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) Type.{u1} CategoryTheory.types.{u1} P (Opposite.op.{succ u3} C Y)) (CategoryTheory.Functor.map.{u2, u1, u3, succ u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) Type.{u1} CategoryTheory.types.{u1} P (Opposite.op.{succ u3} C X) (Opposite.op.{succ u3} C Y) (Quiver.Hom.op.{u3, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) Y X f) (CategoryTheory.Presieve.IsSheafFor.amalgamate.{u1, u2, u3} C _inst_1 P X R t x hx)) (x Y f Hf)
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] {P : CategoryTheory.Functor.{u2, u1, u3, succ u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) Type.{u1} CategoryTheory.types.{u1}} {X : C} {Y : C} {R : CategoryTheory.Presieve.{u2, u3} C _inst_1 X} (t : CategoryTheory.Presieve.IsSheafFor.{u1, u2, u3} C _inst_1 X P R) {x : CategoryTheory.Presieve.FamilyOfElements.{u1, u2, u3} C _inst_1 X P R} (hx : CategoryTheory.Presieve.FamilyOfElements.Compatible.{u1, u2, u3} C _inst_1 P X R x) (f : Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) Y X) (Hf : R Y f), Eq.{succ u1} (Prefunctor.obj.{succ u2, succ u1, u3, succ u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u2, u1, u3, succ u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) Type.{u1} CategoryTheory.types.{u1} P) (Opposite.op.{succ u3} C Y)) (Prefunctor.map.{succ u2, succ u1, u3, succ u1} (Opposite.{succ u3} C) (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.toCategoryStruct.{u2, u3} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1))) Type.{u1} (CategoryTheory.CategoryStruct.toQuiver.{u1, succ u1} Type.{u1} (CategoryTheory.Category.toCategoryStruct.{u1, succ u1} Type.{u1} CategoryTheory.types.{u1})) (CategoryTheory.Functor.toPrefunctor.{u2, u1, u3, succ u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) Type.{u1} CategoryTheory.types.{u1} P) (Opposite.op.{succ u3} C X) (Opposite.op.{succ u3} C Y) (Quiver.Hom.op.{u3, succ u2} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) Y X f) (CategoryTheory.Presieve.IsSheafFor.amalgamate.{u1, u2, u3} C _inst_1 P X R t x hx)) (x Y f Hf)
Case conversion may be inaccurate. Consider using '#align category_theory.presieve.is_sheaf_for.valid_glue CategoryTheory.Presieve.IsSheafFor.valid_glueâ‚“'. -/
@[simp]
theorem IsSheafFor.valid_glue (t : IsSheafFor P R) {x : FamilyOfElements P R} (hx : x.Compatible)
    (f : Y âŸ¶ X) (Hf : R f) : P.map f.op (t.amalgamate x hx) = x f Hf :=
  t.IsAmalgamation hx f Hf
#align category_theory.presieve.is_sheaf_for.valid_glue CategoryTheory.Presieve.IsSheafFor.valid_glue

#print CategoryTheory.Presieve.isSheafFor_iff_generate /-
/-- C2.1.3 in [Elephant] -/
theorem isSheafFor_iff_generate (R : Presieve X) : IsSheafFor P R â†” IsSheafFor P (generate R) :=
  by
  rw [â† is_separated_for_and_exists_is_amalgamation_iff_sheaf_for]
  rw [â† is_separated_for_and_exists_is_amalgamation_iff_sheaf_for]
  rw [â† is_separated_for_iff_generate]
  apply and_congr (Iff.refl _)
  constructor
  Â· intro q x hx
    apply Exists.imp _ (q _ (hx.restrict (le_generate R)))
    intro t ht
    simpa [hx] using is_amalgamation_sieve_extend _ _ ht
  Â· intro q x hx
    apply Exists.imp _ (q _ hx.sieve_extend)
    intro t ht
    simpa [hx] using is_amalgamation_restrict (le_generate R) _ _ ht
#align category_theory.presieve.is_sheaf_for_iff_generate CategoryTheory.Presieve.isSheafFor_iff_generate
-/

/-- Every presheaf is a sheaf for the family {ðŸ™ X}.

[Elephant] C2.1.5(i)
-/
theorem isSheafFor_singleton_iso (P : Cáµ’áµ– â¥¤ Type w) : IsSheafFor P (Presieve.singleton (ðŸ™ X)) :=
  by
  intro x hx
  refine' âŸ¨x _ (presieve.singleton_self _), _, _âŸ©
  Â· rintro _ _ âŸ¨rfl, rflâŸ©
    simp
  Â· intro t ht
    simpa using ht _ (presieve.singleton_self _)
#align category_theory.presieve.is_sheaf_for_singleton_iso CategoryTheory.Presieve.isSheafFor_singletonâ‚“_iso

/- warning: category_theory.presieve.is_sheaf_for_top_sieve -> CategoryTheory.Presieve.isSheafFor_top_sieve is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] {X : C} (P : CategoryTheory.Functor.{u2, u1, u3, succ u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) Type.{u1} CategoryTheory.types.{u1}), CategoryTheory.Presieve.IsSheafFor.{u1, u2, u3} C _inst_1 X P (coeFn.{max (succ u3) (succ u2), max (succ u3) (succ u2)} (CategoryTheory.Sieve.{u2, u3} C _inst_1 X) (fun (_x : CategoryTheory.Sieve.{u2, u3} C _inst_1 X) => CategoryTheory.Presieve.{u2, u3} C _inst_1 X) (CategoryTheory.Sieve.hasCoeToFun.{u2, u3} C _inst_1 X) (Top.top.{max u3 u2} (CategoryTheory.Sieve.{u2, u3} C _inst_1 X) (CompleteLattice.toHasTop.{max u3 u2} (CategoryTheory.Sieve.{u2, u3} C _inst_1 X) (CategoryTheory.Sieve.completeLattice.{u2, u3} C _inst_1 X))))
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] {X : C} (P : CategoryTheory.Functor.{u2, u1, u3, succ u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) Type.{u1} CategoryTheory.types.{u1}), CategoryTheory.Presieve.IsSheafFor.{u1, u2, u3} C _inst_1 X P (CategoryTheory.Sieve.arrows.{u2, u3} C _inst_1 X (Top.top.{max u3 u2} (CategoryTheory.Sieve.{u2, u3} C _inst_1 X) (CompleteLattice.toTop.{max u3 u2} (CategoryTheory.Sieve.{u2, u3} C _inst_1 X) (CategoryTheory.Sieve.instCompleteLatticeSieve.{u2, u3} C _inst_1 X))))
Case conversion may be inaccurate. Consider using '#align category_theory.presieve.is_sheaf_for_top_sieve CategoryTheory.Presieve.isSheafFor_top_sieveâ‚“'. -/
/-- Every presheaf is a sheaf for the maximal sieve.

[Elephant] C2.1.5(ii)
-/
theorem isSheafFor_top_sieve (P : Cáµ’áµ– â¥¤ Type w) : IsSheafFor P ((âŠ¤ : Sieve X) : Presieve X) :=
  by
  rw [â† generate_of_singleton_is_split_epi (ðŸ™ X)]
  rw [â† is_sheaf_for_iff_generate]
  apply is_sheaf_for_singleton_iso
#align category_theory.presieve.is_sheaf_for_top_sieve CategoryTheory.Presieve.isSheafFor_top_sieve

#print CategoryTheory.Presieve.isSheafFor_iso /-
/-- If `P` is a sheaf for `S`, and it is iso to `P'`, then `P'` is a sheaf for `S`. This shows that
"being a sheaf for a presieve" is a mathematical or hygenic property.
-/
theorem isSheafFor_iso {P' : Cáµ’áµ– â¥¤ Type w} (i : P â‰… P') : IsSheafFor P R â†’ IsSheafFor P' R :=
  by
  intro h x hx
  let x' := x.comp_presheaf_map i.inv
  have : x'.compatible := family_of_elements.compatible.comp_presheaf_map i.inv hx
  obtain âŸ¨t, ht1, ht2âŸ© := h x' this
  use i.hom.app _ t
  fconstructor
  Â· convert family_of_elements.is_amalgamation.comp_presheaf_map i.hom ht1
    dsimp [x']
    simp
  Â· intro y hy
    rw [show y = (i.inv.app (op X) â‰« i.hom.app (op X)) y by simp]
    simp [ht2 (i.inv.app _ y) (family_of_elements.is_amalgamation.comp_presheaf_map i.inv hy)]
#align category_theory.presieve.is_sheaf_for_iso CategoryTheory.Presieve.isSheafFor_iso
-/

/- warning: category_theory.presieve.is_sheaf_for_subsieve_aux -> CategoryTheory.Presieve.isSheafFor_subsieve_aux is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] {X : C} (P : CategoryTheory.Functor.{u2, u1, u3, succ u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) {S : CategoryTheory.Sieve.{u2, u3} C _inst_1 X} {R : CategoryTheory.Presieve.{u2, u3} C _inst_1 X}, (LE.le.{max u3 u2} ((fun (_x : CategoryTheory.Sieve.{u2, u3} C _inst_1 X) => CategoryTheory.Presieve.{u2, u3} C _inst_1 X) S) (Preorder.toHasLe.{max u3 u2} ((fun (_x : CategoryTheory.Sieve.{u2, u3} C _inst_1 X) => CategoryTheory.Presieve.{u2, u3} C _inst_1 X) S) (PartialOrder.toPreorder.{max u3 u2} ((fun (_x : CategoryTheory.Sieve.{u2, u3} C _inst_1 X) => CategoryTheory.Presieve.{u2, u3} C _inst_1 X) S) (CompleteSemilatticeInf.toPartialOrder.{max u3 u2} ((fun (_x : CategoryTheory.Sieve.{u2, u3} C _inst_1 X) => CategoryTheory.Presieve.{u2, u3} C _inst_1 X) S) (CompleteLattice.toCompleteSemilatticeInf.{max u3 u2} ((fun (_x : CategoryTheory.Sieve.{u2, u3} C _inst_1 X) => CategoryTheory.Presieve.{u2, u3} C _inst_1 X) S) (CategoryTheory.Presieve.completeLattice.{u3, u2} C _inst_1 X))))) (coeFn.{max (succ u3) (succ u2), max (succ u3) (succ u2)} (CategoryTheory.Sieve.{u2, u3} C _inst_1 X) (fun (_x : CategoryTheory.Sieve.{u2, u3} C _inst_1 X) => CategoryTheory.Presieve.{u2, u3} C _inst_1 X) (CategoryTheory.Sieve.hasCoeToFun.{u2, u3} C _inst_1 X) S) R) -> (CategoryTheory.Presieve.IsSheafFor.{u1, u2, u3} C _inst_1 X P (coeFn.{max (succ u3) (succ u2), max (succ u3) (succ u2)} (CategoryTheory.Sieve.{u2, u3} C _inst_1 X) (fun (_x : CategoryTheory.Sieve.{u2, u3} C _inst_1 X) => CategoryTheory.Presieve.{u2, u3} C _inst_1 X) (CategoryTheory.Sieve.hasCoeToFun.{u2, u3} C _inst_1 X) S)) -> (forall {{Y : C}} {{f : Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) Y X}}, (R Y f) -> (CategoryTheory.Presieve.IsSeparatedFor.{u1, u2, u3} C _inst_1 Y P (coeFn.{max (succ u3) (succ u2), max (succ u3) (succ u2)} (CategoryTheory.Sieve.{u2, u3} C _inst_1 Y) (fun (_x : CategoryTheory.Sieve.{u2, u3} C _inst_1 Y) => CategoryTheory.Presieve.{u2, u3} C _inst_1 Y) (CategoryTheory.Sieve.hasCoeToFun.{u2, u3} C _inst_1 Y) (CategoryTheory.Sieve.pullback.{u2, u3} C _inst_1 X Y f S)))) -> (CategoryTheory.Presieve.IsSheafFor.{u1, u2, u3} C _inst_1 X P R)
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] {X : C} (P : CategoryTheory.Functor.{u2, u1, u3, succ u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) {S : CategoryTheory.Sieve.{u2, u3} C _inst_1 X} {R : CategoryTheory.Presieve.{u2, u3} C _inst_1 X}, (LE.le.{max u3 u2} (CategoryTheory.Presieve.{u2, u3} C _inst_1 X) (Preorder.toLE.{max u3 u2} (CategoryTheory.Presieve.{u2, u3} C _inst_1 X) (PartialOrder.toPreorder.{max u3 u2} (CategoryTheory.Presieve.{u2, u3} C _inst_1 X) (CompleteSemilatticeInf.toPartialOrder.{max u3 u2} (CategoryTheory.Presieve.{u2, u3} C _inst_1 X) (CompleteLattice.toCompleteSemilatticeInf.{max u3 u2} (CategoryTheory.Presieve.{u2, u3} C _inst_1 X) (CategoryTheory.instCompleteLatticePresieve.{u2, u3} C _inst_1 X))))) (CategoryTheory.Sieve.arrows.{u2, u3} C _inst_1 X S) R) -> (CategoryTheory.Presieve.IsSheafFor.{u1, u2, u3} C _inst_1 X P (CategoryTheory.Sieve.arrows.{u2, u3} C _inst_1 X S)) -> (forall {{Y : C}} {{f : Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) Y X}}, (R Y f) -> (CategoryTheory.Presieve.IsSeparatedFor.{u1, u2, u3} C _inst_1 Y P (CategoryTheory.Sieve.arrows.{u2, u3} C _inst_1 Y (CategoryTheory.Sieve.pullback.{u2, u3} C _inst_1 X Y f S)))) -> (CategoryTheory.Presieve.IsSheafFor.{u1, u2, u3} C _inst_1 X P R)
Case conversion may be inaccurate. Consider using '#align category_theory.presieve.is_sheaf_for_subsieve_aux CategoryTheory.Presieve.isSheafFor_subsieve_auxâ‚“'. -/
/-- If a presieve `R` on `X` has a subsieve `S` such that:

* `P` is a sheaf for `S`.
* For every `f` in `R`, `P` is separated for the pullback of `S` along `f`,

then `P` is a sheaf for `R`.

This is closely related to [Elephant] C2.1.6(i).
-/
theorem isSheafFor_subsieve_aux (P : Cáµ’áµ– â¥¤ Type w) {S : Sieve X} {R : Presieve X}
    (h : (S : Presieve X) â‰¤ R) (hS : IsSheafFor P S)
    (trans : âˆ€ â¦ƒYâ¦„ â¦ƒf : Y âŸ¶ Xâ¦„, R f â†’ IsSeparatedFor P (S.pullback f)) : IsSheafFor P R :=
  by
  rw [â† is_separated_for_and_exists_is_amalgamation_iff_sheaf_for]
  constructor
  Â· intro x tâ‚ tâ‚‚ htâ‚ htâ‚‚
    exact
      hS.is_separated_for _ _ _ (is_amalgamation_restrict h x tâ‚ htâ‚)
        (is_amalgamation_restrict h x tâ‚‚ htâ‚‚)
  Â· intro x hx
    use hS.amalgamate _ (hx.restrict h)
    intro W j hj
    apply (trans hj).ext
    intro Y f hf
    rw [â† functor_to_types.map_comp_apply, â† op_comp, hS.valid_glue (hx.restrict h) _ hf,
      family_of_elements.restrict, â† hx (ðŸ™ _) f _ _ (id_comp _)]
    simp
#align category_theory.presieve.is_sheaf_for_subsieve_aux CategoryTheory.Presieve.isSheafFor_subsieve_aux

/- warning: category_theory.presieve.is_sheaf_for_subsieve -> CategoryTheory.Presieve.isSheafFor_subsieve is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] {X : C} (P : CategoryTheory.Functor.{u2, u1, u3, succ u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) {S : CategoryTheory.Sieve.{u2, u3} C _inst_1 X} {R : CategoryTheory.Presieve.{u2, u3} C _inst_1 X}, (LE.le.{max u3 u2} ((fun (_x : CategoryTheory.Sieve.{u2, u3} C _inst_1 X) => CategoryTheory.Presieve.{u2, u3} C _inst_1 X) S) (Preorder.toHasLe.{max u3 u2} ((fun (_x : CategoryTheory.Sieve.{u2, u3} C _inst_1 X) => CategoryTheory.Presieve.{u2, u3} C _inst_1 X) S) (PartialOrder.toPreorder.{max u3 u2} ((fun (_x : CategoryTheory.Sieve.{u2, u3} C _inst_1 X) => CategoryTheory.Presieve.{u2, u3} C _inst_1 X) S) (CompleteSemilatticeInf.toPartialOrder.{max u3 u2} ((fun (_x : CategoryTheory.Sieve.{u2, u3} C _inst_1 X) => CategoryTheory.Presieve.{u2, u3} C _inst_1 X) S) (CompleteLattice.toCompleteSemilatticeInf.{max u3 u2} ((fun (_x : CategoryTheory.Sieve.{u2, u3} C _inst_1 X) => CategoryTheory.Presieve.{u2, u3} C _inst_1 X) S) (CategoryTheory.Presieve.completeLattice.{u3, u2} C _inst_1 X))))) (coeFn.{max (succ u3) (succ u2), max (succ u3) (succ u2)} (CategoryTheory.Sieve.{u2, u3} C _inst_1 X) (fun (_x : CategoryTheory.Sieve.{u2, u3} C _inst_1 X) => CategoryTheory.Presieve.{u2, u3} C _inst_1 X) (CategoryTheory.Sieve.hasCoeToFun.{u2, u3} C _inst_1 X) S) R) -> (forall {{Y : C}} (f : Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) Y X), CategoryTheory.Presieve.IsSheafFor.{u1, u2, u3} C _inst_1 Y P (coeFn.{max (succ u3) (succ u2), max (succ u3) (succ u2)} (CategoryTheory.Sieve.{u2, u3} C _inst_1 Y) (fun (_x : CategoryTheory.Sieve.{u2, u3} C _inst_1 Y) => CategoryTheory.Presieve.{u2, u3} C _inst_1 Y) (CategoryTheory.Sieve.hasCoeToFun.{u2, u3} C _inst_1 Y) (CategoryTheory.Sieve.pullback.{u2, u3} C _inst_1 X Y f S))) -> (CategoryTheory.Presieve.IsSheafFor.{u1, u2, u3} C _inst_1 X P R)
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] {X : C} (P : CategoryTheory.Functor.{u2, u1, u3, succ u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) {S : CategoryTheory.Sieve.{u2, u3} C _inst_1 X} {R : CategoryTheory.Presieve.{u2, u3} C _inst_1 X}, (LE.le.{max u3 u2} (CategoryTheory.Presieve.{u2, u3} C _inst_1 X) (Preorder.toLE.{max u3 u2} (CategoryTheory.Presieve.{u2, u3} C _inst_1 X) (PartialOrder.toPreorder.{max u3 u2} (CategoryTheory.Presieve.{u2, u3} C _inst_1 X) (CompleteSemilatticeInf.toPartialOrder.{max u3 u2} (CategoryTheory.Presieve.{u2, u3} C _inst_1 X) (CompleteLattice.toCompleteSemilatticeInf.{max u3 u2} (CategoryTheory.Presieve.{u2, u3} C _inst_1 X) (CategoryTheory.instCompleteLatticePresieve.{u2, u3} C _inst_1 X))))) (CategoryTheory.Sieve.arrows.{u2, u3} C _inst_1 X S) R) -> (forall {{Y : C}} (f : Quiver.Hom.{succ u2, u3} C (CategoryTheory.CategoryStruct.toQuiver.{u2, u3} C (CategoryTheory.Category.toCategoryStruct.{u2, u3} C _inst_1)) Y X), CategoryTheory.Presieve.IsSheafFor.{u1, u2, u3} C _inst_1 Y P (CategoryTheory.Sieve.arrows.{u2, u3} C _inst_1 Y (CategoryTheory.Sieve.pullback.{u2, u3} C _inst_1 X Y f S))) -> (CategoryTheory.Presieve.IsSheafFor.{u1, u2, u3} C _inst_1 X P R)
Case conversion may be inaccurate. Consider using '#align category_theory.presieve.is_sheaf_for_subsieve CategoryTheory.Presieve.isSheafFor_subsieveâ‚“'. -/
/--
If `P` is a sheaf for every pullback of the sieve `S`, then `P` is a sheaf for any presieve which
contains `S`.
This is closely related to [Elephant] C2.1.6.
-/
theorem isSheafFor_subsieve (P : Cáµ’áµ– â¥¤ Type w) {S : Sieve X} {R : Presieve X}
    (h : (S : Presieve X) â‰¤ R) (trans : âˆ€ â¦ƒYâ¦„ (f : Y âŸ¶ X), IsSheafFor P (S.pullback f)) :
    IsSheafFor P R :=
  isSheafFor_subsieve_aux P h (by simpa using trans (ðŸ™ _)) fun Y f hf => (trans f).IsSeparatedFor
#align category_theory.presieve.is_sheaf_for_subsieve CategoryTheory.Presieve.isSheafFor_subsieve

#print CategoryTheory.Presieve.IsSeparated /-
/-- A presheaf is separated for a topology if it is separated for every sieve in the topology. -/
def IsSeparated (P : Cáµ’áµ– â¥¤ Type w) : Prop :=
  âˆ€ {X} (S : Sieve X), S âˆˆ J X â†’ IsSeparatedFor P S
#align category_theory.presieve.is_separated CategoryTheory.Presieve.IsSeparated
-/

#print CategoryTheory.Presieve.IsSheaf /-
/-- A presheaf is a sheaf for a topology if it is a sheaf for every sieve in the topology.

If the given topology is given by a pretopology, `is_sheaf_for_pretopology` shows it suffices to
check the sheaf condition at presieves in the pretopology.
-/
def IsSheaf (P : Cáµ’áµ– â¥¤ Type w) : Prop :=
  âˆ€ â¦ƒXâ¦„ (S : Sieve X), S âˆˆ J X â†’ IsSheafFor P S
#align category_theory.presieve.is_sheaf CategoryTheory.Presieve.IsSheaf
-/

#print CategoryTheory.Presieve.IsSheaf.isSheafFor /-
theorem IsSheaf.isSheafFor {P : Cáµ’áµ– â¥¤ Type w} (hp : IsSheaf J P) (R : Presieve X)
    (hr : generate R âˆˆ J X) : IsSheafFor P R :=
  (isSheafFor_iff_generate R).2 <| hp _ hr
#align category_theory.presieve.is_sheaf.is_sheaf_for CategoryTheory.Presieve.IsSheaf.isSheafFor
-/

#print CategoryTheory.Presieve.isSheaf_of_le /-
theorem isSheaf_of_le (P : Cáµ’áµ– â¥¤ Type w) {Jâ‚ Jâ‚‚ : GrothendieckTopology C} :
    Jâ‚ â‰¤ Jâ‚‚ â†’ IsSheaf Jâ‚‚ P â†’ IsSheaf Jâ‚ P := fun h t X S hS => t S (h _ hS)
#align category_theory.presieve.is_sheaf_of_le CategoryTheory.Presieve.isSheaf_of_le
-/

#print CategoryTheory.Presieve.isSeparated_of_isSheaf /-
theorem isSeparated_of_isSheaf (P : Cáµ’áµ– â¥¤ Type w) (h : IsSheaf J P) : IsSeparated J P :=
  fun X S hS => (h S hS).IsSeparatedFor
#align category_theory.presieve.is_separated_of_is_sheaf CategoryTheory.Presieve.isSeparated_of_isSheaf
-/

#print CategoryTheory.Presieve.isSheaf_iso /-
/-- The property of being a sheaf is preserved by isomorphism. -/
theorem isSheaf_iso {P' : Cáµ’áµ– â¥¤ Type w} (i : P â‰… P') (h : IsSheaf J P) : IsSheaf J P' :=
  fun X S hS => isSheafFor_iso i (h S hS)
#align category_theory.presieve.is_sheaf_iso CategoryTheory.Presieve.isSheaf_iso
-/

#print CategoryTheory.Presieve.isSheaf_of_yoneda /-
theorem isSheaf_of_yoneda {P : Cáµ’áµ– â¥¤ Type vâ‚}
    (h : âˆ€ {X} (S : Sieve X), S âˆˆ J X â†’ YonedaSheafCondition P S) : IsSheaf J P := fun X S hS =>
  isSheafFor_iff_yonedaSheafCondition.2 (h _ hS)
#align category_theory.presieve.is_sheaf_of_yoneda CategoryTheory.Presieve.isSheaf_of_yoneda
-/

#print CategoryTheory.Presieve.isSheaf_pretopology /-
/-- For a topology generated by a basis, it suffices to check the sheaf condition on the basis
presieves only.
-/
theorem isSheaf_pretopology [HasPullbacks C] (K : Pretopology C) :
    IsSheaf (K.toGrothendieck C) P â†” âˆ€ {X : C} (R : Presieve X), R âˆˆ K X â†’ IsSheafFor P R :=
  by
  constructor
  Â· intro PJ X R hR
    rw [is_sheaf_for_iff_generate]
    apply PJ (sieve.generate R) âŸ¨_, hR, le_generate RâŸ©
  Â· rintro PK X S âŸ¨R, hR, RSâŸ©
    have gRS : â‡‘(generate R) â‰¤ S := by
      apply gi_generate.gc.monotone_u
      rwa [sets_iff_generate]
    apply is_sheaf_for_subsieve P gRS _
    intro Y f
    rw [â† pullback_arrows_comm, â† is_sheaf_for_iff_generate]
    exact PK (pullback_arrows f R) (K.pullbacks f R hR)
#align category_theory.presieve.is_sheaf_pretopology CategoryTheory.Presieve.isSheaf_pretopology
-/

/- warning: category_theory.presieve.is_sheaf_bot -> CategoryTheory.Presieve.isSheaf_bot is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] {P : CategoryTheory.Functor.{u2, u1, u3, succ u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) Type.{u1} CategoryTheory.types.{u1}}, CategoryTheory.Presieve.IsSheaf.{u1, u2, u3} C _inst_1 (Bot.bot.{max u3 u2} (CategoryTheory.GrothendieckTopology.{u2, u3} C _inst_1) (CompleteLattice.toHasBot.{max u3 u2} (CategoryTheory.GrothendieckTopology.{u2, u3} C _inst_1) (CategoryTheory.GrothendieckTopology.completeLattice.{u2, u3} C _inst_1))) P
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C] {P : CategoryTheory.Functor.{u2, u1, u3, succ u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) Type.{u1} CategoryTheory.types.{u1}}, CategoryTheory.Presieve.IsSheaf.{u1, u2, u3} C _inst_1 (Bot.bot.{max u3 u2} (CategoryTheory.GrothendieckTopology.{u2, u3} C _inst_1) (CompleteLattice.toBot.{max u3 u2} (CategoryTheory.GrothendieckTopology.{u2, u3} C _inst_1) (CategoryTheory.GrothendieckTopology.instCompleteLatticeGrothendieckTopology.{u2, u3} C _inst_1))) P
Case conversion may be inaccurate. Consider using '#align category_theory.presieve.is_sheaf_bot CategoryTheory.Presieve.isSheaf_botâ‚“'. -/
/-- Any presheaf is a sheaf for the bottom (trivial) grothendieck topology. -/
theorem isSheaf_bot : IsSheaf (âŠ¥ : GrothendieckTopology C) P := fun X => by
  simp [is_sheaf_for_top_sieve]
#align category_theory.presieve.is_sheaf_bot CategoryTheory.Presieve.isSheaf_bot

end Presieve

namespace Equalizer

variable {C : Type uâ‚} [Category.{vâ‚} C] (P : Cáµ’áµ– â¥¤ Type max vâ‚ uâ‚) {X : C} (R : Presieve X)
  (S : Sieve X)

noncomputable section

#print CategoryTheory.Equalizer.FirstObj /-
/--
The middle object of the fork diagram given in Equation (3) of [MM92], as well as the fork diagram
of <https://stacks.math.columbia.edu/tag/00VM>.
-/
def FirstObj : Type max vâ‚ uâ‚ :=
  âˆ fun f : Î£Y, { f : Y âŸ¶ X // R f } => P.obj (op f.1)
#align category_theory.equalizer.first_obj CategoryTheory.Equalizer.FirstObj
-/

#print CategoryTheory.Equalizer.firstObjEqFamily /-
/-- Show that `first_obj` is isomorphic to `family_of_elements`. -/
@[simps]
def firstObjEqFamily : FirstObj P R â‰… R.FamilyOfElements P
    where
  Hom t Y f hf := Pi.Ï€ (fun f : Î£Y, { f : Y âŸ¶ X // R f } => P.obj (op f.1)) âŸ¨_, _, hfâŸ© t
  inv := Pi.lift fun f x => x _ f.2.2
  hom_inv_id' := by
    ext (âŸ¨Y, f, hfâŸ©p)
    simpa
  inv_hom_id' := by
    ext (x Y f hf)
    apply limits.types.limit.lift_Ï€_apply'
#align category_theory.equalizer.first_obj_eq_family CategoryTheory.Equalizer.firstObjEqFamily
-/

instance : Inhabited (FirstObj P (âŠ¥ : Presieve X)) :=
  (firstObjEqFamily P _).toEquiv.Inhabited

/- warning: category_theory.equalizer.fork_map -> CategoryTheory.Equalizer.forkMap is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] (P : CategoryTheory.Functor.{u1, max u1 u2, u2, succ (max u1 u2)} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{max u1 u2} CategoryTheory.types.{max u1 u2}) {X : C} (R : CategoryTheory.Presieve.{u1, u2} C _inst_1 X), Quiver.Hom.{succ (max u1 u2), succ (max u1 u2)} Type.{max u1 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u1 u2, succ (max u1 u2)} Type.{max u1 u2} (CategoryTheory.Category.toCategoryStruct.{max u1 u2, succ (max u1 u2)} Type.{max u1 u2} CategoryTheory.types.{max u1 u2})) (CategoryTheory.Functor.obj.{u1, max u1 u2, u2, succ (max u1 u2)} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{max u1 u2} CategoryTheory.types.{max u1 u2} P (Opposite.op.{succ u2} C X)) (CategoryTheory.Equalizer.FirstObj.{u1, u2} C _inst_1 P X R)
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] (P : CategoryTheory.Functor.{u1, max u2 u1, u2, max (succ u2) (succ u1)} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{max u1 u2} CategoryTheory.types.{max u2 u1}) {X : C} (R : CategoryTheory.Presieve.{u1, u2} C _inst_1 X), Quiver.Hom.{max (succ u2) (succ u1), max (succ u2) (succ u1)} Type.{max u1 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} CategoryTheory.types.{max u2 u1})) (Prefunctor.obj.{succ u1, max (succ u2) (succ u1), u2, max (succ u2) (succ u1)} (Opposite.{succ u2} C) (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} (Opposite.{succ u2} C) (CategoryTheory.Category.toCategoryStruct.{u1, u2} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1))) Type.{max u1 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u2, max (succ u2) (succ u1)} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{max u1 u2} CategoryTheory.types.{max u2 u1} P) (Opposite.op.{succ u2} C X)) (CategoryTheory.Equalizer.FirstObj.{u1, u2} C _inst_1 P X R)
Case conversion may be inaccurate. Consider using '#align category_theory.equalizer.fork_map CategoryTheory.Equalizer.forkMapâ‚“'. -/
/--
The left morphism of the fork diagram given in Equation (3) of [MM92], as well as the fork diagram
of <https://stacks.math.columbia.edu/tag/00VM>.
-/
def forkMap : P.obj (op X) âŸ¶ FirstObj P R :=
  Pi.lift fun f => P.map f.2.1.op
#align category_theory.equalizer.fork_map CategoryTheory.Equalizer.forkMap

/-!
This section establishes the equivalence between the sheaf condition of Equation (3) [MM92] and
the definition of `is_sheaf_for`.
-/


namespace Sieve

#print CategoryTheory.Equalizer.Sieve.SecondObj /-
/-- The rightmost object of the fork diagram of Equation (3) [MM92], which contains the data used
to check a family is compatible.
-/
def SecondObj : Type max vâ‚ uâ‚ :=
  âˆ fun f : Î£(Y Z : _)(g : Z âŸ¶ Y), { f' : Y âŸ¶ X // S f' } => P.obj (op f.2.1)
#align category_theory.equalizer.sieve.second_obj CategoryTheory.Equalizer.Sieve.SecondObj
-/

#print CategoryTheory.Equalizer.Sieve.firstMap /-
/-- The map `p` of Equations (3,4) [MM92]. -/
def firstMap : FirstObj P S âŸ¶ SecondObj P S :=
  Pi.lift fun fg =>
    Pi.Ï€ _ (âŸ¨_, _, S.downward_closed fg.2.2.2.2 fg.2.2.1âŸ© : Î£Y, { f : Y âŸ¶ X // S f })
#align category_theory.equalizer.sieve.first_map CategoryTheory.Equalizer.Sieve.firstMap
-/

instance : Inhabited (SecondObj P (âŠ¥ : Sieve X)) :=
  âŸ¨firstMap _ _ defaultâŸ©

#print CategoryTheory.Equalizer.Sieve.secondMap /-
/-- The map `a` of Equations (3,4) [MM92]. -/
def secondMap : FirstObj P S âŸ¶ SecondObj P S :=
  Pi.lift fun fg => Pi.Ï€ _ âŸ¨_, fg.2.2.2âŸ© â‰« P.map fg.2.2.1.op
#align category_theory.equalizer.sieve.second_map CategoryTheory.Equalizer.Sieve.secondMap
-/

/- warning: category_theory.equalizer.sieve.w -> CategoryTheory.Equalizer.Sieve.w is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] (P : CategoryTheory.Functor.{u1, max u1 u2, u2, succ (max u1 u2)} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{max u1 u2} CategoryTheory.types.{max u1 u2}) {X : C} (S : CategoryTheory.Sieve.{u1, u2} C _inst_1 X), Eq.{succ (max u1 u2)} (Quiver.Hom.{succ (max u1 u2), succ (max u1 u2)} Type.{max u1 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u1 u2, succ (max u1 u2)} Type.{max u1 u2} (CategoryTheory.Category.toCategoryStruct.{max u1 u2, succ (max u1 u2)} Type.{max u1 u2} CategoryTheory.types.{max u1 u2})) (CategoryTheory.Functor.obj.{u1, max u1 u2, u2, succ (max u1 u2)} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{max u1 u2} CategoryTheory.types.{max u1 u2} P (Opposite.op.{succ u2} C X)) (CategoryTheory.Equalizer.Sieve.SecondObj.{u1, u2} C _inst_1 P X S)) (CategoryTheory.CategoryStruct.comp.{max u1 u2, succ (max u1 u2)} Type.{max u1 u2} (CategoryTheory.Category.toCategoryStruct.{max u1 u2, succ (max u1 u2)} Type.{max u1 u2} CategoryTheory.types.{max u1 u2}) (CategoryTheory.Functor.obj.{u1, max u1 u2, u2, succ (max u1 u2)} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{max u1 u2} CategoryTheory.types.{max u1 u2} P (Opposite.op.{succ u2} C X)) (CategoryTheory.Equalizer.FirstObj.{u1, u2} C _inst_1 P X (coeFn.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (CategoryTheory.Sieve.{u1, u2} C _inst_1 X) (fun (_x : CategoryTheory.Sieve.{u1, u2} C _inst_1 X) => CategoryTheory.Presieve.{u1, u2} C _inst_1 X) (CategoryTheory.Sieve.hasCoeToFun.{u1, u2} C _inst_1 X) S)) (CategoryTheory.Equalizer.Sieve.SecondObj.{u1, u2} C _inst_1 P X S) (CategoryTheory.Equalizer.forkMap.{u1, u2} C _inst_1 P X (coeFn.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (CategoryTheory.Sieve.{u1, u2} C _inst_1 X) (fun (_x : CategoryTheory.Sieve.{u1, u2} C _inst_1 X) => CategoryTheory.Presieve.{u1, u2} C _inst_1 X) (CategoryTheory.Sieve.hasCoeToFun.{u1, u2} C _inst_1 X) S)) (CategoryTheory.Equalizer.Sieve.firstMap.{u1, u2} C _inst_1 P X S)) (CategoryTheory.CategoryStruct.comp.{max u1 u2, succ (max u1 u2)} Type.{max u1 u2} (CategoryTheory.Category.toCategoryStruct.{max u1 u2, succ (max u1 u2)} Type.{max u1 u2} CategoryTheory.types.{max u1 u2}) (CategoryTheory.Functor.obj.{u1, max u1 u2, u2, succ (max u1 u2)} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{max u1 u2} CategoryTheory.types.{max u1 u2} P (Opposite.op.{succ u2} C X)) (CategoryTheory.Equalizer.FirstObj.{u1, u2} C _inst_1 P X (coeFn.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (CategoryTheory.Sieve.{u1, u2} C _inst_1 X) (fun (_x : CategoryTheory.Sieve.{u1, u2} C _inst_1 X) => CategoryTheory.Presieve.{u1, u2} C _inst_1 X) (CategoryTheory.Sieve.hasCoeToFun.{u1, u2} C _inst_1 X) S)) (CategoryTheory.Equalizer.Sieve.SecondObj.{u1, u2} C _inst_1 P X S) (CategoryTheory.Equalizer.forkMap.{u1, u2} C _inst_1 P X (coeFn.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (CategoryTheory.Sieve.{u1, u2} C _inst_1 X) (fun (_x : CategoryTheory.Sieve.{u1, u2} C _inst_1 X) => CategoryTheory.Presieve.{u1, u2} C _inst_1 X) (CategoryTheory.Sieve.hasCoeToFun.{u1, u2} C _inst_1 X) S)) (CategoryTheory.Equalizer.Sieve.secondMap.{u1, u2} C _inst_1 P X S))
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] (P : CategoryTheory.Functor.{u1, max u2 u1, u2, max (succ u2) (succ u1)} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{max u1 u2} CategoryTheory.types.{max u2 u1}) {X : C} (S : CategoryTheory.Sieve.{u1, u2} C _inst_1 X), Eq.{max (succ u2) (succ u1)} (Quiver.Hom.{succ (max u2 u1), max (succ u2) (succ u1)} Type.{max u1 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} CategoryTheory.types.{max u2 u1})) (Prefunctor.obj.{succ u1, max (succ u2) (succ u1), u2, max (succ u2) (succ u1)} (Opposite.{succ u2} C) (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} (Opposite.{succ u2} C) (CategoryTheory.Category.toCategoryStruct.{u1, u2} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1))) Type.{max u1 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u2, max (succ u2) (succ u1)} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{max u1 u2} CategoryTheory.types.{max u2 u1} P) (Opposite.op.{succ u2} C X)) (CategoryTheory.Equalizer.Sieve.SecondObj.{u1, u2} C _inst_1 P X S)) (CategoryTheory.CategoryStruct.comp.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} CategoryTheory.types.{max u2 u1}) (Prefunctor.obj.{succ u1, max (succ u2) (succ u1), u2, max (succ u2) (succ u1)} (Opposite.{succ u2} C) (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} (Opposite.{succ u2} C) (CategoryTheory.Category.toCategoryStruct.{u1, u2} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1))) Type.{max u1 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u2, max (succ u2) (succ u1)} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{max u1 u2} CategoryTheory.types.{max u2 u1} P) (Opposite.op.{succ u2} C X)) (CategoryTheory.Equalizer.FirstObj.{u1, u2} C _inst_1 P X (CategoryTheory.Sieve.arrows.{u1, u2} C _inst_1 X S)) (CategoryTheory.Equalizer.Sieve.SecondObj.{u1, u2} C _inst_1 P X S) (CategoryTheory.Equalizer.forkMap.{u1, u2} C _inst_1 P X (CategoryTheory.Sieve.arrows.{u1, u2} C _inst_1 X S)) (CategoryTheory.Equalizer.Sieve.firstMap.{u1, u2} C _inst_1 P X S)) (CategoryTheory.CategoryStruct.comp.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} CategoryTheory.types.{max u2 u1}) (Prefunctor.obj.{succ u1, max (succ u2) (succ u1), u2, max (succ u2) (succ u1)} (Opposite.{succ u2} C) (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} (Opposite.{succ u2} C) (CategoryTheory.Category.toCategoryStruct.{u1, u2} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1))) Type.{max u1 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u2, max (succ u2) (succ u1)} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{max u1 u2} CategoryTheory.types.{max u2 u1} P) (Opposite.op.{succ u2} C X)) (CategoryTheory.Equalizer.FirstObj.{u1, u2} C _inst_1 P X (CategoryTheory.Sieve.arrows.{u1, u2} C _inst_1 X S)) (CategoryTheory.Equalizer.Sieve.SecondObj.{u1, u2} C _inst_1 P X S) (CategoryTheory.Equalizer.forkMap.{u1, u2} C _inst_1 P X (CategoryTheory.Sieve.arrows.{u1, u2} C _inst_1 X S)) (CategoryTheory.Equalizer.Sieve.secondMap.{u1, u2} C _inst_1 P X S))
Case conversion may be inaccurate. Consider using '#align category_theory.equalizer.sieve.w CategoryTheory.Equalizer.Sieve.wâ‚“'. -/
theorem w : forkMap P S â‰« firstMap P S = forkMap P S â‰« secondMap P S :=
  by
  apply limit.hom_ext
  rintro âŸ¨Y, Z, g, f, hfâŸ©
  simp [first_map, second_map, fork_map]
#align category_theory.equalizer.sieve.w CategoryTheory.Equalizer.Sieve.w

#print CategoryTheory.Equalizer.Sieve.compatible_iff /-
/--
The family of elements given by `x : first_obj P S` is compatible iff `first_map` and `second_map`
map it to the same point.
-/
theorem compatible_iff (x : FirstObj P S) :
    ((firstObjEqFamily P S).Hom x).Compatible â†” firstMap P S x = secondMap P S x :=
  by
  rw [presieve.compatible_iff_sieve_compatible]
  constructor
  Â· intro t
    ext âŸ¨Y, Z, g, f, hfâŸ©
    simpa [first_map, second_map] using t _ g hf
  Â· intro t Y Z f g hf
    rw [types.limit_ext_iff'] at t
    simpa [first_map, second_map] using t âŸ¨âŸ¨Y, Z, g, f, hfâŸ©âŸ©
#align category_theory.equalizer.sieve.compatible_iff CategoryTheory.Equalizer.Sieve.compatible_iff
-/

/- warning: category_theory.equalizer.sieve.equalizer_sheaf_condition -> CategoryTheory.Equalizer.Sieve.equalizer_sheaf_condition is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] (P : CategoryTheory.Functor.{u1, max u1 u2, u2, succ (max u1 u2)} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{max u1 u2} CategoryTheory.types.{max u1 u2}) {X : C} (S : CategoryTheory.Sieve.{u1, u2} C _inst_1 X), Iff (CategoryTheory.Presieve.IsSheafFor.{max u1 u2, u1, u2} C _inst_1 X P (coeFn.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (CategoryTheory.Sieve.{u1, u2} C _inst_1 X) (fun (_x : CategoryTheory.Sieve.{u1, u2} C _inst_1 X) => CategoryTheory.Presieve.{u1, u2} C _inst_1 X) (CategoryTheory.Sieve.hasCoeToFun.{u1, u2} C _inst_1 X) S)) (Nonempty.{succ (succ (max u1 u2))} (CategoryTheory.Limits.IsLimit.{0, max u1 u2, 0, succ (max u1 u2)} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory Type.{max u1 u2} CategoryTheory.types.{max u1 u2} (CategoryTheory.Limits.parallelPair.{max u1 u2, succ (max u1 u2)} Type.{max u1 u2} CategoryTheory.types.{max u1 u2} (CategoryTheory.Equalizer.FirstObj.{u1, u2} C _inst_1 P X (coeFn.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (CategoryTheory.Sieve.{u1, u2} C _inst_1 X) (fun (_x : CategoryTheory.Sieve.{u1, u2} C _inst_1 X) => CategoryTheory.Presieve.{u1, u2} C _inst_1 X) (CategoryTheory.Sieve.hasCoeToFun.{u1, u2} C _inst_1 X) S)) (CategoryTheory.Equalizer.Sieve.SecondObj.{u1, u2} C _inst_1 P X S) (CategoryTheory.Equalizer.Sieve.firstMap.{u1, u2} C _inst_1 P X S) (CategoryTheory.Equalizer.Sieve.secondMap.{u1, u2} C _inst_1 P X S)) (CategoryTheory.Limits.Fork.ofÎ¹.{max u1 u2, succ (max u1 u2)} Type.{max u1 u2} CategoryTheory.types.{max u1 u2} (CategoryTheory.Equalizer.FirstObj.{u1, u2} C _inst_1 P X (coeFn.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (CategoryTheory.Sieve.{u1, u2} C _inst_1 X) (fun (_x : CategoryTheory.Sieve.{u1, u2} C _inst_1 X) => CategoryTheory.Presieve.{u1, u2} C _inst_1 X) (CategoryTheory.Sieve.hasCoeToFun.{u1, u2} C _inst_1 X) S)) (CategoryTheory.Equalizer.Sieve.SecondObj.{u1, u2} C _inst_1 P X S) (CategoryTheory.Equalizer.Sieve.firstMap.{u1, u2} C _inst_1 P X S) (CategoryTheory.Equalizer.Sieve.secondMap.{u1, u2} C _inst_1 P X S) (CategoryTheory.Functor.obj.{u1, max u1 u2, u2, succ (max u1 u2)} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{max u1 u2} CategoryTheory.types.{max u1 u2} P (Opposite.op.{succ u2} C X)) (CategoryTheory.Equalizer.forkMap.{u1, u2} C _inst_1 P X (coeFn.{max (succ u2) (succ u1), max (succ u2) (succ u1)} (CategoryTheory.Sieve.{u1, u2} C _inst_1 X) (fun (_x : CategoryTheory.Sieve.{u1, u2} C _inst_1 X) => CategoryTheory.Presieve.{u1, u2} C _inst_1 X) (CategoryTheory.Sieve.hasCoeToFun.{u1, u2} C _inst_1 X) S)) (CategoryTheory.Equalizer.Sieve.w.{u1, u2} C _inst_1 P X S))))
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] (P : CategoryTheory.Functor.{u1, max u2 u1, u2, max (succ u2) (succ u1)} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{max u1 u2} CategoryTheory.types.{max u2 u1}) {X : C} (S : CategoryTheory.Sieve.{u1, u2} C _inst_1 X), Iff (CategoryTheory.Presieve.IsSheafFor.{max u2 u1, u1, u2} C _inst_1 X P (CategoryTheory.Sieve.arrows.{u1, u2} C _inst_1 X S)) (Nonempty.{max (succ (max (succ u2) (succ u1))) (succ (max u2 u1))} (CategoryTheory.Limits.IsLimit.{0, max u2 u1, 0, max (succ u2) (succ u1)} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory Type.{max u1 u2} CategoryTheory.types.{max u2 u1} (CategoryTheory.Limits.parallelPair.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} CategoryTheory.types.{max u2 u1} (CategoryTheory.Equalizer.FirstObj.{u1, u2} C _inst_1 P X (CategoryTheory.Sieve.arrows.{u1, u2} C _inst_1 X S)) (CategoryTheory.Equalizer.Sieve.SecondObj.{u1, u2} C _inst_1 P X S) (CategoryTheory.Equalizer.Sieve.firstMap.{u1, u2} C _inst_1 P X S) (CategoryTheory.Equalizer.Sieve.secondMap.{u1, u2} C _inst_1 P X S)) (CategoryTheory.Limits.Fork.ofÎ¹.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} CategoryTheory.types.{max u2 u1} (CategoryTheory.Equalizer.FirstObj.{u1, u2} C _inst_1 P X (CategoryTheory.Sieve.arrows.{u1, u2} C _inst_1 X S)) (CategoryTheory.Equalizer.Sieve.SecondObj.{u1, u2} C _inst_1 P X S) (CategoryTheory.Equalizer.Sieve.firstMap.{u1, u2} C _inst_1 P X S) (CategoryTheory.Equalizer.Sieve.secondMap.{u1, u2} C _inst_1 P X S) (Prefunctor.obj.{succ u1, max (succ u2) (succ u1), u2, max (succ u2) (succ u1)} (Opposite.{succ u2} C) (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} (Opposite.{succ u2} C) (CategoryTheory.Category.toCategoryStruct.{u1, u2} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1))) Type.{max u1 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u2, max (succ u2) (succ u1)} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{max u1 u2} CategoryTheory.types.{max u2 u1} P) (Opposite.op.{succ u2} C X)) (CategoryTheory.Equalizer.forkMap.{u1, u2} C _inst_1 P X (CategoryTheory.Sieve.arrows.{u1, u2} C _inst_1 X S)) (CategoryTheory.Equalizer.Sieve.w.{u1, u2} C _inst_1 P X S))))
Case conversion may be inaccurate. Consider using '#align category_theory.equalizer.sieve.equalizer_sheaf_condition CategoryTheory.Equalizer.Sieve.equalizer_sheaf_conditionâ‚“'. -/
/-- `P` is a sheaf for `S`, iff the fork given by `w` is an equalizer. -/
theorem equalizer_sheaf_condition :
    Presieve.IsSheafFor P S â†” Nonempty (IsLimit (Fork.ofÎ¹ _ (w P S))) :=
  by
  rw [types.type_equalizer_iff_unique, â†
    Equiv.forall_congr_left (first_obj_eq_family P S).toEquiv.symm]
  simp_rw [â† compatible_iff]
  simp only [inv_hom_id_apply, iso.to_equiv_symm_fun]
  apply ball_congr
  intro x tx
  apply existsUnique_congr
  intro t
  rw [â† iso.to_equiv_symm_fun]
  rw [Equiv.eq_symm_apply]
  constructor
  Â· intro q
    ext (Y f hf)
    simpa [first_obj_eq_family, fork_map] using q _ _
  Â· intro q Y f hf
    rw [â† q]
    simp [first_obj_eq_family, fork_map]
#align category_theory.equalizer.sieve.equalizer_sheaf_condition CategoryTheory.Equalizer.Sieve.equalizer_sheaf_condition

end Sieve

/-!
This section establishes the equivalence between the sheaf condition of
https://stacks.math.columbia.edu/tag/00VM and the definition of `is_sheaf_for`.
-/


namespace Presieve

variable [HasPullbacks C]

#print CategoryTheory.Equalizer.Presieve.SecondObj /-
/-- The rightmost object of the fork diagram of https://stacks.math.columbia.edu/tag/00VM, which
contains the data used to check a family of elements for a presieve is compatible.
-/
def SecondObj : Type max vâ‚ uâ‚ :=
  âˆ fun fg : (Î£Y, { f : Y âŸ¶ X // R f }) Ã— Î£Z, { g : Z âŸ¶ X // R g } =>
    P.obj (op (pullback fg.1.2.1 fg.2.2.1))
#align category_theory.equalizer.presieve.second_obj CategoryTheory.Equalizer.Presieve.SecondObj
-/

#print CategoryTheory.Equalizer.Presieve.firstMap /-
/-- The map `prâ‚€*` of <https://stacks.math.columbia.edu/tag/00VL>. -/
def firstMap : FirstObj P R âŸ¶ SecondObj P R :=
  Pi.lift fun fg => Pi.Ï€ _ _ â‰« P.map pullback.fst.op
#align category_theory.equalizer.presieve.first_map CategoryTheory.Equalizer.Presieve.firstMap
-/

instance : Inhabited (SecondObj P (âŠ¥ : Presieve X)) :=
  âŸ¨firstMap _ _ defaultâŸ©

#print CategoryTheory.Equalizer.Presieve.secondMap /-
/-- The map `prâ‚*` of <https://stacks.math.columbia.edu/tag/00VL>. -/
def secondMap : FirstObj P R âŸ¶ SecondObj P R :=
  Pi.lift fun fg => Pi.Ï€ _ _ â‰« P.map pullback.snd.op
#align category_theory.equalizer.presieve.second_map CategoryTheory.Equalizer.Presieve.secondMap
-/

/- warning: category_theory.equalizer.presieve.w -> CategoryTheory.Equalizer.Presieve.w is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] (P : CategoryTheory.Functor.{u1, max u1 u2, u2, succ (max u1 u2)} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{max u1 u2} CategoryTheory.types.{max u1 u2}) {X : C} (R : CategoryTheory.Presieve.{u1, u2} C _inst_1 X) [_inst_2 : CategoryTheory.Limits.HasPullbacks.{u1, u2} C _inst_1], Eq.{succ (max u1 u2)} (Quiver.Hom.{succ (max u1 u2), succ (max u1 u2)} Type.{max u1 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u1 u2, succ (max u1 u2)} Type.{max u1 u2} (CategoryTheory.Category.toCategoryStruct.{max u1 u2, succ (max u1 u2)} Type.{max u1 u2} CategoryTheory.types.{max u1 u2})) (CategoryTheory.Functor.obj.{u1, max u1 u2, u2, succ (max u1 u2)} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{max u1 u2} CategoryTheory.types.{max u1 u2} P (Opposite.op.{succ u2} C X)) (CategoryTheory.Equalizer.Presieve.SecondObj.{u1, u2} C _inst_1 P X R _inst_2)) (CategoryTheory.CategoryStruct.comp.{max u1 u2, succ (max u1 u2)} Type.{max u1 u2} (CategoryTheory.Category.toCategoryStruct.{max u1 u2, succ (max u1 u2)} Type.{max u1 u2} CategoryTheory.types.{max u1 u2}) (CategoryTheory.Functor.obj.{u1, max u1 u2, u2, succ (max u1 u2)} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{max u1 u2} CategoryTheory.types.{max u1 u2} P (Opposite.op.{succ u2} C X)) (CategoryTheory.Equalizer.FirstObj.{u1, u2} C _inst_1 P X R) (CategoryTheory.Equalizer.Presieve.SecondObj.{u1, u2} C _inst_1 P X R _inst_2) (CategoryTheory.Equalizer.forkMap.{u1, u2} C _inst_1 P X R) (CategoryTheory.Equalizer.Presieve.firstMap.{u1, u2} C _inst_1 P X R _inst_2)) (CategoryTheory.CategoryStruct.comp.{max u1 u2, succ (max u1 u2)} Type.{max u1 u2} (CategoryTheory.Category.toCategoryStruct.{max u1 u2, succ (max u1 u2)} Type.{max u1 u2} CategoryTheory.types.{max u1 u2}) (CategoryTheory.Functor.obj.{u1, max u1 u2, u2, succ (max u1 u2)} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{max u1 u2} CategoryTheory.types.{max u1 u2} P (Opposite.op.{succ u2} C X)) (CategoryTheory.Equalizer.FirstObj.{u1, u2} C _inst_1 P X R) (CategoryTheory.Equalizer.Presieve.SecondObj.{u1, u2} C _inst_1 P X R _inst_2) (CategoryTheory.Equalizer.forkMap.{u1, u2} C _inst_1 P X R) (CategoryTheory.Equalizer.Presieve.secondMap.{u1, u2} C _inst_1 P X R _inst_2))
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] (P : CategoryTheory.Functor.{u1, max u2 u1, u2, max (succ u2) (succ u1)} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{max u1 u2} CategoryTheory.types.{max u2 u1}) {X : C} (R : CategoryTheory.Presieve.{u1, u2} C _inst_1 X) [_inst_2 : CategoryTheory.Limits.HasPullbacks.{u1, u2} C _inst_1], Eq.{max (succ u2) (succ u1)} (Quiver.Hom.{succ (max u2 u1), max (succ u2) (succ u1)} Type.{max u1 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} CategoryTheory.types.{max u2 u1})) (Prefunctor.obj.{succ u1, max (succ u2) (succ u1), u2, max (succ u2) (succ u1)} (Opposite.{succ u2} C) (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} (Opposite.{succ u2} C) (CategoryTheory.Category.toCategoryStruct.{u1, u2} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1))) Type.{max u1 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u2, max (succ u2) (succ u1)} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{max u1 u2} CategoryTheory.types.{max u2 u1} P) (Opposite.op.{succ u2} C X)) (CategoryTheory.Equalizer.Presieve.SecondObj.{u1, u2} C _inst_1 P X R _inst_2)) (CategoryTheory.CategoryStruct.comp.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} CategoryTheory.types.{max u2 u1}) (Prefunctor.obj.{succ u1, max (succ u2) (succ u1), u2, max (succ u2) (succ u1)} (Opposite.{succ u2} C) (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} (Opposite.{succ u2} C) (CategoryTheory.Category.toCategoryStruct.{u1, u2} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1))) Type.{max u1 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u2, max (succ u2) (succ u1)} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{max u1 u2} CategoryTheory.types.{max u2 u1} P) (Opposite.op.{succ u2} C X)) (CategoryTheory.Equalizer.FirstObj.{u1, u2} C _inst_1 P X R) (CategoryTheory.Equalizer.Presieve.SecondObj.{u1, u2} C _inst_1 P X R _inst_2) (CategoryTheory.Equalizer.forkMap.{u1, u2} C _inst_1 P X R) (CategoryTheory.Equalizer.Presieve.firstMap.{u1, u2} C _inst_1 P X R _inst_2)) (CategoryTheory.CategoryStruct.comp.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} CategoryTheory.types.{max u2 u1}) (Prefunctor.obj.{succ u1, max (succ u2) (succ u1), u2, max (succ u2) (succ u1)} (Opposite.{succ u2} C) (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} (Opposite.{succ u2} C) (CategoryTheory.Category.toCategoryStruct.{u1, u2} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1))) Type.{max u1 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u2, max (succ u2) (succ u1)} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{max u1 u2} CategoryTheory.types.{max u2 u1} P) (Opposite.op.{succ u2} C X)) (CategoryTheory.Equalizer.FirstObj.{u1, u2} C _inst_1 P X R) (CategoryTheory.Equalizer.Presieve.SecondObj.{u1, u2} C _inst_1 P X R _inst_2) (CategoryTheory.Equalizer.forkMap.{u1, u2} C _inst_1 P X R) (CategoryTheory.Equalizer.Presieve.secondMap.{u1, u2} C _inst_1 P X R _inst_2))
Case conversion may be inaccurate. Consider using '#align category_theory.equalizer.presieve.w CategoryTheory.Equalizer.Presieve.wâ‚“'. -/
theorem w : forkMap P R â‰« firstMap P R = forkMap P R â‰« secondMap P R :=
  by
  apply limit.hom_ext
  rintro âŸ¨âŸ¨Y, f, hfâŸ©, âŸ¨Z, g, hgâŸ©âŸ©
  simp only [first_map, second_map, fork_map]
  simp only [limit.lift_Ï€, limit.lift_Ï€_assoc, assoc, fan.mk_Ï€_app, Subtype.coe_mk,
    Subtype.val_eq_coe]
  rw [â† P.map_comp, â† op_comp, pullback.condition]
  simp
#align category_theory.equalizer.presieve.w CategoryTheory.Equalizer.Presieve.w

#print CategoryTheory.Equalizer.Presieve.compatible_iff /-
/--
The family of elements given by `x : first_obj P S` is compatible iff `first_map` and `second_map`
map it to the same point.
-/
theorem compatible_iff (x : FirstObj P R) :
    ((firstObjEqFamily P R).Hom x).Compatible â†” firstMap P R x = secondMap P R x :=
  by
  rw [presieve.pullback_compatible_iff]
  constructor
  Â· intro t
    ext âŸ¨âŸ¨Y, f, hfâŸ©, Z, g, hgâŸ©
    simpa [first_map, second_map] using t hf hg
  Â· intro t Y Z f g hf hg
    rw [types.limit_ext_iff'] at t
    simpa [first_map, second_map] using t âŸ¨âŸ¨âŸ¨Y, f, hfâŸ©, Z, g, hgâŸ©âŸ©
#align category_theory.equalizer.presieve.compatible_iff CategoryTheory.Equalizer.Presieve.compatible_iff
-/

/- warning: category_theory.equalizer.presieve.sheaf_condition -> CategoryTheory.Equalizer.Presieve.sheaf_condition is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] (P : CategoryTheory.Functor.{u1, max u1 u2, u2, succ (max u1 u2)} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{max u1 u2} CategoryTheory.types.{max u1 u2}) {X : C} (R : CategoryTheory.Presieve.{u1, u2} C _inst_1 X) [_inst_2 : CategoryTheory.Limits.HasPullbacks.{u1, u2} C _inst_1], Iff (CategoryTheory.Presieve.IsSheafFor.{max u1 u2, u1, u2} C _inst_1 X P R) (Nonempty.{succ (succ (max u1 u2))} (CategoryTheory.Limits.IsLimit.{0, max u1 u2, 0, succ (max u1 u2)} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory Type.{max u1 u2} CategoryTheory.types.{max u1 u2} (CategoryTheory.Limits.parallelPair.{max u1 u2, succ (max u1 u2)} Type.{max u1 u2} CategoryTheory.types.{max u1 u2} (CategoryTheory.Equalizer.FirstObj.{u1, u2} C _inst_1 P X R) (CategoryTheory.Equalizer.Presieve.SecondObj.{u1, u2} C _inst_1 P X R _inst_2) (CategoryTheory.Equalizer.Presieve.firstMap.{u1, u2} C _inst_1 P X R _inst_2) (CategoryTheory.Equalizer.Presieve.secondMap.{u1, u2} C _inst_1 P X R _inst_2)) (CategoryTheory.Limits.Fork.ofÎ¹.{max u1 u2, succ (max u1 u2)} Type.{max u1 u2} CategoryTheory.types.{max u1 u2} (CategoryTheory.Equalizer.FirstObj.{u1, u2} C _inst_1 P X R) (CategoryTheory.Equalizer.Presieve.SecondObj.{u1, u2} C _inst_1 P X R _inst_2) (CategoryTheory.Equalizer.Presieve.firstMap.{u1, u2} C _inst_1 P X R _inst_2) (CategoryTheory.Equalizer.Presieve.secondMap.{u1, u2} C _inst_1 P X R _inst_2) (CategoryTheory.Functor.obj.{u1, max u1 u2, u2, succ (max u1 u2)} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{max u1 u2} CategoryTheory.types.{max u1 u2} P (Opposite.op.{succ u2} C X)) (CategoryTheory.Equalizer.forkMap.{u1, u2} C _inst_1 P X R) (CategoryTheory.Equalizer.Presieve.w.{u1, u2} C _inst_1 P X R _inst_2))))
but is expected to have type
  forall {C : Type.{u2}} [_inst_1 : CategoryTheory.Category.{u1, u2} C] (P : CategoryTheory.Functor.{u1, max u2 u1, u2, max (succ u2) (succ u1)} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{max u1 u2} CategoryTheory.types.{max u2 u1}) {X : C} (R : CategoryTheory.Presieve.{u1, u2} C _inst_1 X) [_inst_2 : CategoryTheory.Limits.HasPullbacks.{u1, u2} C _inst_1], Iff (CategoryTheory.Presieve.IsSheafFor.{max u2 u1, u1, u2} C _inst_1 X P R) (Nonempty.{max (succ (max (succ u2) (succ u1))) (succ (max u2 u1))} (CategoryTheory.Limits.IsLimit.{0, max u2 u1, 0, max (succ u2) (succ u1)} CategoryTheory.Limits.WalkingParallelPair CategoryTheory.Limits.walkingParallelPairHomCategory Type.{max u1 u2} CategoryTheory.types.{max u2 u1} (CategoryTheory.Limits.parallelPair.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} CategoryTheory.types.{max u2 u1} (CategoryTheory.Equalizer.FirstObj.{u1, u2} C _inst_1 P X R) (CategoryTheory.Equalizer.Presieve.SecondObj.{u1, u2} C _inst_1 P X R _inst_2) (CategoryTheory.Equalizer.Presieve.firstMap.{u1, u2} C _inst_1 P X R _inst_2) (CategoryTheory.Equalizer.Presieve.secondMap.{u1, u2} C _inst_1 P X R _inst_2)) (CategoryTheory.Limits.Fork.ofÎ¹.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} CategoryTheory.types.{max u2 u1} (CategoryTheory.Equalizer.FirstObj.{u1, u2} C _inst_1 P X R) (CategoryTheory.Equalizer.Presieve.SecondObj.{u1, u2} C _inst_1 P X R _inst_2) (CategoryTheory.Equalizer.Presieve.firstMap.{u1, u2} C _inst_1 P X R _inst_2) (CategoryTheory.Equalizer.Presieve.secondMap.{u1, u2} C _inst_1 P X R _inst_2) (Prefunctor.obj.{succ u1, max (succ u2) (succ u1), u2, max (succ u2) (succ u1)} (Opposite.{succ u2} C) (CategoryTheory.CategoryStruct.toQuiver.{u1, u2} (Opposite.{succ u2} C) (CategoryTheory.Category.toCategoryStruct.{u1, u2} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1))) Type.{max u1 u2} (CategoryTheory.CategoryStruct.toQuiver.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} (CategoryTheory.Category.toCategoryStruct.{max u2 u1, max (succ u2) (succ u1)} Type.{max u1 u2} CategoryTheory.types.{max u2 u1})) (CategoryTheory.Functor.toPrefunctor.{u1, max u2 u1, u2, max (succ u2) (succ u1)} (Opposite.{succ u2} C) (CategoryTheory.Category.opposite.{u1, u2} C _inst_1) Type.{max u1 u2} CategoryTheory.types.{max u2 u1} P) (Opposite.op.{succ u2} C X)) (CategoryTheory.Equalizer.forkMap.{u1, u2} C _inst_1 P X R) (CategoryTheory.Equalizer.Presieve.w.{u1, u2} C _inst_1 P X R _inst_2))))
Case conversion may be inaccurate. Consider using '#align category_theory.equalizer.presieve.sheaf_condition CategoryTheory.Equalizer.Presieve.sheaf_conditionâ‚“'. -/
/-- `P` is a sheaf for `R`, iff the fork given by `w` is an equalizer.
See <https://stacks.math.columbia.edu/tag/00VM>.
-/
theorem sheaf_condition : R.IsSheafFor P â†” Nonempty (IsLimit (Fork.ofÎ¹ _ (w P R))) :=
  by
  rw [types.type_equalizer_iff_unique]
  erw [â† Equiv.forall_congr_left (first_obj_eq_family P R).toEquiv.symm]
  simp_rw [â† compatible_iff, â† iso.to_equiv_fun, Equiv.apply_symm_apply]
  apply ball_congr
  intro x hx
  apply existsUnique_congr
  intro t
  rw [Equiv.eq_symm_apply]
  constructor
  Â· intro q
    ext (Y f hf)
    simpa [fork_map] using q _ _
  Â· intro q Y f hf
    rw [â† q]
    simp [fork_map]
#align category_theory.equalizer.presieve.sheaf_condition CategoryTheory.Equalizer.Presieve.sheaf_condition

end Presieve

end Equalizer

variable {C : Type uâ‚} [Category.{vâ‚} C]

variable (J : GrothendieckTopology C)

#print CategoryTheory.SheafOfTypes /-
/-- The category of sheaves on a grothendieck topology. -/
structure SheafOfTypes (J : GrothendieckTopology C) : Type max uâ‚ vâ‚ (w + 1) where
  val : Cáµ’áµ– â¥¤ Type w
  cond : Presieve.IsSheaf J val
#align category_theory.SheafOfTypes CategoryTheory.SheafOfTypes
-/

namespace SheafOfTypes

variable {J}

#print CategoryTheory.SheafOfTypes.Hom /-
/-- Morphisms between sheaves of types are just morphisms between the underlying presheaves. -/
@[ext]
structure Hom (X Y : SheafOfTypes J) where
  val : X.val âŸ¶ Y.val
#align category_theory.SheafOfTypes.hom CategoryTheory.SheafOfTypes.Hom
-/

@[simps]
instance : Category (SheafOfTypes J) where
  Hom := Hom
  id X := âŸ¨ðŸ™ _âŸ©
  comp X Y Z f g := âŸ¨f.val â‰« g.valâŸ©
  id_comp' X Y f := Hom.ext _ _ <| id_comp _
  comp_id' X Y f := Hom.ext _ _ <| comp_id _
  assoc' X Y Z W f g h := Hom.ext _ _ <| assoc _ _ _

-- Let's make the inhabited linter happy...
instance (X : SheafOfTypes J) : Inhabited (Hom X X) :=
  âŸ¨ðŸ™ XâŸ©

end SheafOfTypes

#print CategoryTheory.sheafOfTypesToPresheaf /-
/-- The inclusion functor from sheaves to presheaves. -/
@[simps]
def sheafOfTypesToPresheaf : SheafOfTypes J â¥¤ Cáµ’áµ– â¥¤ Type w
    where
  obj := SheafOfTypes.val
  map X Y f := f.val
  map_id' X := rfl
  map_comp' X Y Z f g := rfl
#align category_theory.SheafOfTypes_to_presheaf CategoryTheory.sheafOfTypesToPresheaf
-/

instance : Full (sheafOfTypesToPresheaf J) where Preimage X Y f := âŸ¨fâŸ©

instance : Faithful (sheafOfTypesToPresheaf J) where

/- warning: category_theory.SheafOfTypes_bot_equiv -> CategoryTheory.sheafOfTypesBotEquiv is a dubious translation:
lean 3 declaration is
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C], CategoryTheory.Equivalence.{max u1 u3, max u3 u1, max u3 u2 (succ u1), max u2 u1 u3 (succ u1)} (CategoryTheory.SheafOfTypes.{u1, u2, u3} C _inst_1 (Bot.bot.{max u3 u2} (CategoryTheory.GrothendieckTopology.{u2, u3} C _inst_1) (CompleteLattice.toHasBot.{max u3 u2} (CategoryTheory.GrothendieckTopology.{u2, u3} C _inst_1) (CategoryTheory.GrothendieckTopology.completeLattice.{u2, u3} C _inst_1)))) (CategoryTheory.SheafOfTypes.CategoryTheory.category.{u2, u3, u1} C _inst_1 (Bot.bot.{max u3 u2} (CategoryTheory.GrothendieckTopology.{u2, u3} C _inst_1) (CompleteLattice.toHasBot.{max u3 u2} (CategoryTheory.GrothendieckTopology.{u2, u3} C _inst_1) (CategoryTheory.GrothendieckTopology.completeLattice.{u2, u3} C _inst_1)))) (CategoryTheory.Functor.{u2, u1, u3, succ u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.Functor.category.{u2, u1, u3, succ u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) Type.{u1} CategoryTheory.types.{u1})
but is expected to have type
  forall {C : Type.{u3}} [_inst_1 : CategoryTheory.Category.{u2, u3} C], CategoryTheory.Equivalence.{max u3 u1, max u3 u1, max (max u3 u2) (succ u1), max (max (max (succ u1) u3) u1) u2} (CategoryTheory.SheafOfTypes.{u1, u2, u3} C _inst_1 (Bot.bot.{max u3 u2} (CategoryTheory.GrothendieckTopology.{u2, u3} C _inst_1) (CompleteLattice.toBot.{max u3 u2} (CategoryTheory.GrothendieckTopology.{u2, u3} C _inst_1) (CategoryTheory.GrothendieckTopology.instCompleteLatticeGrothendieckTopology.{u2, u3} C _inst_1)))) (CategoryTheory.Functor.{u2, u1, u3, succ u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) Type.{u1} CategoryTheory.types.{u1}) (CategoryTheory.SheafOfTypes.instCategorySheafOfTypes.{u2, u3, u1} C _inst_1 (Bot.bot.{max u3 u2} (CategoryTheory.GrothendieckTopology.{u2, u3} C _inst_1) (CompleteLattice.toBot.{max u3 u2} (CategoryTheory.GrothendieckTopology.{u2, u3} C _inst_1) (CategoryTheory.GrothendieckTopology.instCompleteLatticeGrothendieckTopology.{u2, u3} C _inst_1)))) (CategoryTheory.Functor.category.{u2, u1, u3, succ u1} (Opposite.{succ u3} C) (CategoryTheory.Category.opposite.{u2, u3} C _inst_1) Type.{u1} CategoryTheory.types.{u1})
Case conversion may be inaccurate. Consider using '#align category_theory.SheafOfTypes_bot_equiv CategoryTheory.sheafOfTypesBotEquivâ‚“'. -/
/--
The category of sheaves on the bottom (trivial) grothendieck topology is equivalent to the category
of presheaves.
-/
@[simps]
def sheafOfTypesBotEquiv : SheafOfTypes (âŠ¥ : GrothendieckTopology C) â‰Œ Cáµ’áµ– â¥¤ Type w
    where
  Functor := sheafOfTypesToPresheaf _
  inverse :=
    { obj := fun P => âŸ¨P, Presieve.isSheaf_botâŸ©
      map := fun Pâ‚ Pâ‚‚ f => (sheafOfTypesToPresheaf _).Preimage f }
  unitIso :=
    { Hom := { app := fun _ => âŸ¨ðŸ™ _âŸ© }
      inv := { app := fun _ => âŸ¨ðŸ™ _âŸ© } }
  counitIso := Iso.refl _
#align category_theory.SheafOfTypes_bot_equiv CategoryTheory.sheafOfTypesBotEquiv

instance : Inhabited (SheafOfTypes (âŠ¥ : GrothendieckTopology C)) :=
  âŸ¨sheafOfTypesBotEquiv.inverse.obj ((Functor.const _).obj PUnit)âŸ©

end CategoryTheory

