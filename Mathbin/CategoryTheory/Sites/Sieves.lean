import Mathbin.Order.CompleteLattice
import Mathbin.CategoryTheory.Over
import Mathbin.CategoryTheory.Yoneda
import Mathbin.CategoryTheory.Limits.Shapes.Pullbacks
import Mathbin.Data.Set.Lattice

/-!
# Theory of sieves

- For an object `X` of a category `C`, a `sieve X` is a set of morphisms to `X`
  which is closed under left-composition.
- The complete lattice structure on sieves is given, as well as the Galois insertion
  given by downward-closing.
- A `sieve X` (functorially) induces a presheaf on `C` together with a monomorphism to
  the yoneda embedding of `X`.

## Tags

sieve, pullback
-/


universe vâ‚ vâ‚‚ vâ‚ƒ uâ‚ uâ‚‚ uâ‚ƒ

namespace CategoryTheory

open Category Limits

variable {C : Type uâ‚} [category.{vâ‚} C] {D : Type uâ‚‚} [category.{vâ‚‚} D] (F : C â¥¤ D)

variable {X Y Z : C} (f : Y âŸ¶ X)

-- ././Mathport/Syntax/Translate/Basic.lean:833:9: unsupported derive handler complete_lattice
/--  A set of arrows all with codomain `X`. -/
def presieve (X : C) :=
  âˆ€ â¦ƒYâ¦„, Set (Y âŸ¶ X)deriving [anonymous]

namespace Presieve

instance : Inhabited (presieve X) :=
  âŸ¨âŠ¤âŸ©

/-- 
Given a set of arrows `S` all with codomain `X`, and a set of arrows with codomain `Y` for each
`f : Y âŸ¶ X` in `S`, produce a set of arrows with codomain `X`:
`{ g â‰« f | (f : Y âŸ¶ X) âˆˆ S, (g : Z âŸ¶ Y) âˆˆ R f }`.
-/
def bind (S : presieve X) (R : âˆ€ â¦ƒYâ¦„ â¦ƒf : Y âŸ¶ Xâ¦„, S f â†’ presieve Y) : presieve X := fun Z h =>
  âˆƒ (Y : C)(g : Z âŸ¶ Y)(f : Y âŸ¶ X)(H : S f), R H g âˆ§ g â‰« f = h

@[simp]
theorem bind_comp {S : presieve X} {R : âˆ€ â¦ƒY : Câ¦„ â¦ƒf : Y âŸ¶ Xâ¦„, S f â†’ presieve Y} {g : Z âŸ¶ Y} (hâ‚ : S f) (hâ‚‚ : R hâ‚ g) :
    bind S R (g â‰« f) :=
  âŸ¨_, _, _, hâ‚, hâ‚‚, rflâŸ©

/--  The singleton presieve.  -/
inductive singleton : presieve X
  | mk : singleton f

@[simp]
theorem singleton_eq_iff_domain (f g : Y âŸ¶ X) : singleton f g â†” f = g := by
  constructor
  Â·
    rintro âŸ¨a, rflâŸ©
    rfl
  Â·
    rintro rfl
    apply singleton.mk

theorem singleton_self : singleton f f :=
  singleton.mk

/-- 
Pullback a set of arrows with given codomain along a fixed map, by taking the pullback in the
category.
This is not the same as the arrow set of `sieve.pullback`, but there is a relation between them
in `pullback_arrows_comm`.
-/
inductive pullback_arrows [has_pullbacks C] (R : presieve X) : presieve Y
  | mk (Z : C) (h : Z âŸ¶ X) : R h â†’ pullback_arrows (pullback.snd : pullback h f âŸ¶ Y)

theorem pullback_singleton [has_pullbacks C] (g : Z âŸ¶ X) :
    pullback_arrows f (singleton g) = singleton (pullback.snd : pullback g f âŸ¶ _) := by
  ext W h
  constructor
  Â·
    rintro âŸ¨W, _, _, _âŸ©
    exact singleton.mk
  Â·
    rintro âŸ¨_âŸ©
    exact pullback_arrows.mk Z g singleton.mk

/--  Construct the presieve given by the family of arrows indexed by `Î¹`. -/
inductive of_arrows {Î¹ : Type _} (Y : Î¹ â†’ C) (f : âˆ€ i, Y i âŸ¶ X) : presieve X
  | mk (i : Î¹) : of_arrows (f i)

theorem of_arrows_punit : (of_arrows _ fun _ : PUnit => f) = singleton f := by
  ext Y g
  constructor
  Â·
    rintro âŸ¨_âŸ©
    apply singleton.mk
  Â·
    rintro âŸ¨_âŸ©
    exact of_arrows.mk PUnit.unit

theorem of_arrows_pullback [has_pullbacks C] {Î¹ : Type _} (Z : Î¹ â†’ C) (g : âˆ€ i : Î¹, Z i âŸ¶ X) :
    (of_arrows (fun i => pullback (g i) f) fun i => pullback.snd) = pullback_arrows f (of_arrows Z g) := by
  ext T h
  constructor
  Â·
    rintro âŸ¨hkâŸ©
    exact pullback_arrows.mk _ _ (of_arrows.mk hk)
  Â·
    rintro âŸ¨W, k, hkâ‚âŸ©
    cases' hkâ‚ with i hi
    apply of_arrows.mk

theorem of_arrows_bind {Î¹ : Type _} (Z : Î¹ â†’ C) (g : âˆ€ i : Î¹, Z i âŸ¶ X) (j : âˆ€ â¦ƒYâ¦„ f : Y âŸ¶ X, of_arrows Z g f â†’ Type _)
    (W : âˆ€ â¦ƒYâ¦„ f : Y âŸ¶ X H, j f H â†’ C) (k : âˆ€ â¦ƒYâ¦„ f : Y âŸ¶ X H i, W f H i âŸ¶ Y) :
    ((of_arrows Z g).bind fun Y f H => of_arrows (W f H) (k f H)) =
      of_arrows (fun i => W (g i.1) _ i.2) fun ij => k (g ij.1) _ ij.2 â‰« g ij.1 :=
  by
  ext Y f
  constructor
  Â·
    rintro âŸ¨_, _, _, âŸ¨iâŸ©, âŸ¨i'âŸ©, rflâŸ©
    exact of_arrows.mk (Sigma.mk _ _)
  Â·
    rintro âŸ¨iâŸ©
    exact bind_comp _ (of_arrows.mk _) (of_arrows.mk _)

/--  Given a presieve on `F(X)`, we can define a presieve on `X` by taking the preimage via `F`. -/
def functor_pullback (R : presieve (F.obj X)) : presieve X := fun _ f => R (F.map f)

@[simp]
theorem functor_pullback_mem (R : presieve (F.obj X)) {Y} (f : Y âŸ¶ X) : R.functor_pullback F f â†” R (F.map f) :=
  Iff.rfl

@[simp]
theorem functor_pullback_id (R : presieve X) : R.functor_pullback (ğŸ­ _) = R :=
  rfl

section FunctorPushforward

variable {E : Type uâ‚ƒ} [category.{vâ‚ƒ} E] (G : D â¥¤ E)

/-- 
Given a presieve on `X`, we can define a presieve on `F(X)` (which is actually a sieve)
by taking the sieve generated by the image via `F`.
-/
def functor_pushforward (S : presieve X) : presieve (F.obj X) := fun Y f =>
  âˆƒ (Z : C)(g : Z âŸ¶ X)(h : Y âŸ¶ F.obj Z), S g âˆ§ f = h â‰« F.map g

/-- 
An auxillary definition in order to fix the choice of the preimages between various definitions.
-/
@[nolint has_inhabited_instance]
structure functor_pushforward_structure (S : presieve X) {Y} (f : Y âŸ¶ F.obj X) where
  preobj : C
  premap : preobj âŸ¶ X
  lift : Y âŸ¶ F.obj preobj
  cover : S premap
  fac : f = lift â‰« F.map premap

/--  The fixed choice of a preimage. -/
noncomputable def get_functor_pushforward_structure {F : C â¥¤ D} {S : presieve X} {Y : D} {f : Y âŸ¶ F.obj X}
    (h : S.functor_pushforward F f) : functor_pushforward_structure F S f := by
  choose Z f' g hâ‚ h using h
  exact âŸ¨Z, f', g, hâ‚, hâŸ©

theorem functor_pushforward_comp (R : presieve X) :
    R.functor_pushforward (F â‹™ G) = (R.functor_pushforward F).FunctorPushforward G := by
  ext x f
  constructor
  Â·
    rintro âŸ¨X, fâ‚, gâ‚, hâ‚, rflâŸ©
    exact
      âŸ¨F.obj X, F.map fâ‚, gâ‚,
        âŸ¨X, fâ‚, ğŸ™ _, hâ‚, by
          simp âŸ©,
        rflâŸ©
  Â·
    rintro âŸ¨X, fâ‚, gâ‚, âŸ¨X', fâ‚‚, gâ‚‚, hâ‚, rflâŸ©, rflâŸ©
    use
      âŸ¨X', fâ‚‚, gâ‚ â‰« G.map gâ‚‚, hâ‚, by
        simp âŸ©

theorem image_mem_functor_pushforward (R : presieve X) {f : Y âŸ¶ X} (h : R f) : R.functor_pushforward F (F.map f) :=
  âŸ¨Y, f, ğŸ™ _, h, by
    simp âŸ©

end FunctorPushforward

end Presieve

/-- 
For an object `X` of a category `C`, a `sieve X` is a set of morphisms to `X` which is closed under
left-composition.
-/
structure sieve {C : Type uâ‚} [category.{vâ‚} C] (X : C) where
  Arrows : presieve X
  downward_closed' : âˆ€ {Y Z f} hf : arrows f g : Z âŸ¶ Y, arrows (g â‰« f)

namespace Sieve

instance : CoeFun (sieve X) fun _ => presieve X :=
  âŸ¨sieve.arrowsâŸ©

initialize_simps_projections Sieve (Arrows â†’ apply)

variable {S R : sieve X}

@[simp]
theorem downward_closed (S : sieve X) {f : Y âŸ¶ X} (hf : S f) (g : Z âŸ¶ Y) : S (g â‰« f) :=
  S.downward_closed' hf g

theorem arrows_ext : âˆ€ {R S : sieve X}, R.arrows = S.arrows â†’ R = S
  | âŸ¨Ra, _âŸ©, âŸ¨Sa, _âŸ©, rfl => rfl

@[ext]
protected theorem ext {R S : sieve X} (h : âˆ€ â¦ƒYâ¦„ f : Y âŸ¶ X, R f â†” S f) : R = S :=
  arrows_ext $ funext $ fun x => funext $ fun f => propext $ h f

protected theorem ext_iff {R S : sieve X} : R = S â†” âˆ€ â¦ƒYâ¦„ f : Y âŸ¶ X, R f â†” S f :=
  âŸ¨fun h Y f => h â–¸ Iff.rfl, sieve.extâŸ©

open Lattice

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
 (Command.declModifiers
  [(Command.docComment "/--" " The supremum of a collection of sieves: the union of them all. -/")]
  []
  [(Command.protected "protected")]
  []
  []
  [])
 (Command.def
  "def"
  (Command.declId `Sup [])
  (Command.optDeclSig
   [(Term.explicitBinder "(" [`ğ’®] [":" (Term.app `Set [(Term.app `sieve [`X])])] [] ")")]
   [(Term.typeSpec ":" (Term.app `sieve [`X]))])
  (Command.declValSimple
   ":="
   (Term.structInst
    "{"
    []
    [(group
      (Term.structInstField
       (Term.structInstLVal `Arrows [])
       ":="
       (Term.fun
        "fun"
        (Term.basicFun
         [(Term.simpleBinder [`Y] [])]
         "=>"
         (Set.Â«term{_|_}Â»
          "{"
          `f
          "|"
          (Mathlib.ExtendedBinder.Â«termâˆƒ___,_Â» "âˆƒ" `S (Â«binderTermâˆˆ_Â» "âˆˆ" `ğ’®) "," (Term.app `sieve.arrows [`S `f]))
          "}"))))
      [","])
     (group
      (Term.structInstField
       (Term.structInstLVal `downward_closed' [])
       ":="
       (Term.fun
        "fun"
        (Term.basicFun
         [(Term.simpleBinder [`Y `Z `f] [])]
         "=>"
         (Term.byTactic
          "by"
          (Tactic.tacticSeq
           (Tactic.tacticSeq1Indented
            [(group
              (Tactic.rintro
               "rintro"
               [(Tactic.rintroPat.one
                 (Tactic.rcasesPat.tuple
                  "âŸ¨"
                  [(Tactic.rcasesPatLo (Tactic.rcasesPatMed [(Tactic.rcasesPat.one `S)]) [])
                   ","
                   (Tactic.rcasesPatLo (Tactic.rcasesPatMed [(Tactic.rcasesPat.one `hS)]) [])
                   ","
                   (Tactic.rcasesPatLo (Tactic.rcasesPatMed [(Tactic.rcasesPat.one `hf)]) [])]
                  "âŸ©"))
                (Tactic.rintroPat.one (Tactic.rcasesPat.one `g))]
               [])
              [])
             (group
              (Tactic.exact
               "exact"
               (Term.anonymousCtor "âŸ¨" [`S "," `hS "," (Term.app `S.downward_closed [`hf (Term.hole "_")])] "âŸ©"))
              [])]))))))
      [])]
    (Term.optEllipsis [])
    []
    "}")
   [])
  []
  []
  []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declaration', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declaration', expected 'Lean.Parser.Command.declaration.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.abbrev.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.def.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.declValSimple.antiquot'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  (Term.structInst
   "{"
   []
   [(group
     (Term.structInstField
      (Term.structInstLVal `Arrows [])
      ":="
      (Term.fun
       "fun"
       (Term.basicFun
        [(Term.simpleBinder [`Y] [])]
        "=>"
        (Set.Â«term{_|_}Â»
         "{"
         `f
         "|"
         (Mathlib.ExtendedBinder.Â«termâˆƒ___,_Â» "âˆƒ" `S (Â«binderTermâˆˆ_Â» "âˆˆ" `ğ’®) "," (Term.app `sieve.arrows [`S `f]))
         "}"))))
     [","])
    (group
     (Term.structInstField
      (Term.structInstLVal `downward_closed' [])
      ":="
      (Term.fun
       "fun"
       (Term.basicFun
        [(Term.simpleBinder [`Y `Z `f] [])]
        "=>"
        (Term.byTactic
         "by"
         (Tactic.tacticSeq
          (Tactic.tacticSeq1Indented
           [(group
             (Tactic.rintro
              "rintro"
              [(Tactic.rintroPat.one
                (Tactic.rcasesPat.tuple
                 "âŸ¨"
                 [(Tactic.rcasesPatLo (Tactic.rcasesPatMed [(Tactic.rcasesPat.one `S)]) [])
                  ","
                  (Tactic.rcasesPatLo (Tactic.rcasesPatMed [(Tactic.rcasesPat.one `hS)]) [])
                  ","
                  (Tactic.rcasesPatLo (Tactic.rcasesPatMed [(Tactic.rcasesPat.one `hf)]) [])]
                 "âŸ©"))
               (Tactic.rintroPat.one (Tactic.rcasesPat.one `g))]
              [])
             [])
            (group
             (Tactic.exact
              "exact"
              (Term.anonymousCtor "âŸ¨" [`S "," `hS "," (Term.app `S.downward_closed [`hf (Term.hole "_")])] "âŸ©"))
             [])]))))))
     [])]
   (Term.optEllipsis [])
   []
   "}")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.structInst', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.structInst', expected 'Lean.Parser.Term.structInst.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.optEllipsis', expected 'Lean.Parser.Term.optEllipsis.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'group', expected 'many.antiquot_scope'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.structInstField', expected 'Lean.Parser.Term.structInstFieldAbbrev.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.structInstField', expected 'Lean.Parser.Term.structInstFieldAbbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.structInstField', expected 'Lean.Parser.Term.structInstField.antiquot'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  (Term.fun
   "fun"
   (Term.basicFun
    [(Term.simpleBinder [`Y `Z `f] [])]
    "=>"
    (Term.byTactic
     "by"
     (Tactic.tacticSeq
      (Tactic.tacticSeq1Indented
       [(group
         (Tactic.rintro
          "rintro"
          [(Tactic.rintroPat.one
            (Tactic.rcasesPat.tuple
             "âŸ¨"
             [(Tactic.rcasesPatLo (Tactic.rcasesPatMed [(Tactic.rcasesPat.one `S)]) [])
              ","
              (Tactic.rcasesPatLo (Tactic.rcasesPatMed [(Tactic.rcasesPat.one `hS)]) [])
              ","
              (Tactic.rcasesPatLo (Tactic.rcasesPatMed [(Tactic.rcasesPat.one `hf)]) [])]
             "âŸ©"))
           (Tactic.rintroPat.one (Tactic.rcasesPat.one `g))]
          [])
         [])
        (group
         (Tactic.exact
          "exact"
          (Term.anonymousCtor "âŸ¨" [`S "," `hS "," (Term.app `S.downward_closed [`hf (Term.hole "_")])] "âŸ©"))
         [])])))))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.fun', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.fun', expected 'Lean.Parser.Term.fun.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.basicFun', expected 'Lean.Parser.Term.basicFun.antiquot'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  (Term.byTactic
   "by"
   (Tactic.tacticSeq
    (Tactic.tacticSeq1Indented
     [(group
       (Tactic.rintro
        "rintro"
        [(Tactic.rintroPat.one
          (Tactic.rcasesPat.tuple
           "âŸ¨"
           [(Tactic.rcasesPatLo (Tactic.rcasesPatMed [(Tactic.rcasesPat.one `S)]) [])
            ","
            (Tactic.rcasesPatLo (Tactic.rcasesPatMed [(Tactic.rcasesPat.one `hS)]) [])
            ","
            (Tactic.rcasesPatLo (Tactic.rcasesPatMed [(Tactic.rcasesPat.one `hf)]) [])]
           "âŸ©"))
         (Tactic.rintroPat.one (Tactic.rcasesPat.one `g))]
        [])
       [])
      (group
       (Tactic.exact
        "exact"
        (Term.anonymousCtor "âŸ¨" [`S "," `hS "," (Term.app `S.downward_closed [`hf (Term.hole "_")])] "âŸ©"))
       [])])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.byTactic', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.byTactic', expected 'Lean.Parser.Term.byTactic.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq', expected 'Lean.Parser.Tactic.tacticSeq.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeq1Indented.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'group', expected 'many.antiquot_scope'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  (Tactic.exact
   "exact"
   (Term.anonymousCtor "âŸ¨" [`S "," `hS "," (Term.app `S.downward_closed [`hf (Term.hole "_")])] "âŸ©"))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.exact', expected 'antiquot'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  (Term.anonymousCtor "âŸ¨" [`S "," `hS "," (Term.app `S.downward_closed [`hf (Term.hole "_")])] "âŸ©")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.anonymousCtor', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.anonymousCtor', expected 'Lean.Parser.Term.anonymousCtor.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'sepBy.antiquot_scope'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  (Term.app `S.downward_closed [`hf (Term.hole "_")])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'many.antiquot_scope'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.namedArgument.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.ellipsis.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  (Term.hole "_")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.hole', expected 'Lean.Parser.Term.hole.antiquot'
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'many.antiquot_scope'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1023, term))
  `hf
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'ident.antiquot'
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (some 1023, term)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
  `S.downward_closed
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'ident.antiquot'
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'sepBy.antiquot_scope'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  `hS
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'ident.antiquot'
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'sepBy.antiquot_scope'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  `S
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'ident.antiquot'
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'group', expected 'many.antiquot_scope'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, tactic))
  (Tactic.rintro
   "rintro"
   [(Tactic.rintroPat.one
     (Tactic.rcasesPat.tuple
      "âŸ¨"
      [(Tactic.rcasesPatLo (Tactic.rcasesPatMed [(Tactic.rcasesPat.one `S)]) [])
       ","
       (Tactic.rcasesPatLo (Tactic.rcasesPatMed [(Tactic.rcasesPat.one `hS)]) [])
       ","
       (Tactic.rcasesPatLo (Tactic.rcasesPatMed [(Tactic.rcasesPat.one `hf)]) [])]
      "âŸ©"))
    (Tactic.rintroPat.one (Tactic.rcasesPat.one `g))]
   [])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.rintro', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.rintroPat.one', expected 'many.antiquot_scope'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.rintroPat.one', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.rcasesPat.one', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'ident.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.rintroPat.one', expected 'many.antiquot_scope'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.rintroPat.one', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.rcasesPat.tuple', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.rcasesPatLo', expected 'sepBy.antiquot_scope'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.rcasesPat.one', expected 'sepBy.antiquot_scope'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.rcasesPat.one', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'ident.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.rcasesPatLo', expected 'sepBy.antiquot_scope'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.rcasesPat.one', expected 'sepBy.antiquot_scope'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.rcasesPat.one', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'ident.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.rcasesPatLo', expected 'sepBy.antiquot_scope'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.rcasesPat.one', expected 'sepBy.antiquot_scope'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.rcasesPat.one', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'ident.antiquot'
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, tactic) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.simpleBinder', expected 'many.antiquot_scope'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.simpleBinder', expected 'Lean.Parser.Term.strictImplicitBinder.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.simpleBinder', expected 'Lean.Parser.Term.strictImplicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.simpleBinder', expected 'Lean.Parser.Term.implicitBinder.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.simpleBinder', expected 'Lean.Parser.Term.implicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.simpleBinder', expected 'Lean.Parser.Term.instBinder.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.simpleBinder', expected 'Lean.Parser.Term.instBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.simpleBinder', expected 'Lean.Parser.Term.simpleBinder.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'many.antiquot_scope'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'ident.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'many.antiquot_scope'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'ident.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'many.antiquot_scope'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'ident.antiquot'
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (some 0, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.structInstLVal', expected 'Lean.Parser.Term.structInstLVal.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'ident.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'group', expected 'many.antiquot_scope'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Â«,Â»', expected 'optional.antiquot_scope'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.structInstField', expected 'Lean.Parser.Term.structInstFieldAbbrev.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.structInstField', expected 'Lean.Parser.Term.structInstFieldAbbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.structInstField', expected 'Lean.Parser.Term.structInstField.antiquot'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  (Term.fun
   "fun"
   (Term.basicFun
    [(Term.simpleBinder [`Y] [])]
    "=>"
    (Set.Â«term{_|_}Â»
     "{"
     `f
     "|"
     (Mathlib.ExtendedBinder.Â«termâˆƒ___,_Â» "âˆƒ" `S (Â«binderTermâˆˆ_Â» "âˆˆ" `ğ’®) "," (Term.app `sieve.arrows [`S `f]))
     "}")))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.fun', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.fun', expected 'Lean.Parser.Term.fun.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.basicFun', expected 'Lean.Parser.Term.basicFun.antiquot'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  (Set.Â«term{_|_}Â»
   "{"
   `f
   "|"
   (Mathlib.ExtendedBinder.Â«termâˆƒ___,_Â» "âˆƒ" `S (Â«binderTermâˆˆ_Â» "âˆˆ" `ğ’®) "," (Term.app `sieve.arrows [`S `f]))
   "}")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Set.Â«term{_|_}Â»', expected 'antiquot'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  (Mathlib.ExtendedBinder.Â«termâˆƒ___,_Â» "âˆƒ" `S (Â«binderTermâˆˆ_Â» "âˆˆ" `ğ’®) "," (Term.app `sieve.arrows [`S `f]))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Mathlib.ExtendedBinder.Â«termâˆƒ___,_Â»', expected 'antiquot'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  (Term.app `sieve.arrows [`S `f])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'many.antiquot_scope'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  `f
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'ident.antiquot'
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'many.antiquot_scope'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
  `S
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'ident.antiquot'
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
  `sieve.arrows
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'ident.antiquot'
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Â«binderTermâˆˆ_Â»', expected 'antiquot'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  `ğ’®
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'ident.antiquot'
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'ident.antiquot'
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Mathlib.ExtendedBinder.extBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.basicFun', expected 'Lean.Parser.Term.matchAlts.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.basicFun', expected 'Lean.Parser.Term.matchAlts'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.declValEqns.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.declValEqns'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.whereStructInst.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.whereStructInst'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.theorem.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.theorem'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.constant.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.constant'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.instance.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.axiom.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.example.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.inductive.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.classInductive.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.structure.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
/-- The supremum of a collection of sieves: the union of them all. -/ protected
  def
    Sup
    ( ğ’® : Set sieve X ) : sieve X
    :=
      {
        Arrows := fun Y => { f | âˆƒ S âˆˆ ğ’® , sieve.arrows S f } ,
          downward_closed' := fun Y Z f => by rintro âŸ¨ S , hS , hf âŸ© g exact âŸ¨ S , hS , S.downward_closed hf _ âŸ©
        }

/- failed to parenthesize: parenthesize: uncaught backtrack exception
[PrettyPrinter.parenthesize.input] (Command.declaration
 (Command.declModifiers
  [(Command.docComment "/--" " The infimum of a collection of sieves: the intersection of them all. -/")]
  []
  [(Command.protected "protected")]
  []
  []
  [])
 (Command.def
  "def"
  (Command.declId `Inf [])
  (Command.optDeclSig
   [(Term.explicitBinder "(" [`ğ’®] [":" (Term.app `Set [(Term.app `sieve [`X])])] [] ")")]
   [(Term.typeSpec ":" (Term.app `sieve [`X]))])
  (Command.declValSimple
   ":="
   (Term.structInst
    "{"
    []
    [(group
      (Term.structInstField
       (Term.structInstLVal `Arrows [])
       ":="
       (Term.fun
        "fun"
        (Term.basicFun
         [(Term.simpleBinder [`Y] [])]
         "=>"
         (Set.Â«term{_|_}Â»
          "{"
          `f
          "|"
          (Term.forall
           "âˆ€"
           []
           ","
           (Mathlib.ExtendedBinder.Â«termâˆ€___,_Â»
            "âˆ€"
            `S
            (Â«binderTermâˆˆ_Â» "âˆˆ" `ğ’®)
            ","
            (Term.forall "âˆ€" [] "," (Term.app `sieve.arrows [`S `f]))))
          "}"))))
      [","])
     (group
      (Term.structInstField
       (Term.structInstLVal `downward_closed' [])
       ":="
       (Term.fun
        "fun"
        (Term.basicFun
         [(Term.simpleBinder [`Y `Z `f `hf `g `S `H] [])]
         "=>"
         (Term.app `S.downward_closed [(Term.app `hf [`S `H]) `g]))))
      [])]
    (Term.optEllipsis [])
    []
    "}")
   [])
  []
  []
  []))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declaration', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declaration', expected 'Lean.Parser.Command.declaration.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.abbrev.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.abbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.def.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.declValSimple.antiquot'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  (Term.structInst
   "{"
   []
   [(group
     (Term.structInstField
      (Term.structInstLVal `Arrows [])
      ":="
      (Term.fun
       "fun"
       (Term.basicFun
        [(Term.simpleBinder [`Y] [])]
        "=>"
        (Set.Â«term{_|_}Â»
         "{"
         `f
         "|"
         (Term.forall
          "âˆ€"
          []
          ","
          (Mathlib.ExtendedBinder.Â«termâˆ€___,_Â»
           "âˆ€"
           `S
           (Â«binderTermâˆˆ_Â» "âˆˆ" `ğ’®)
           ","
           (Term.forall "âˆ€" [] "," (Term.app `sieve.arrows [`S `f]))))
         "}"))))
     [","])
    (group
     (Term.structInstField
      (Term.structInstLVal `downward_closed' [])
      ":="
      (Term.fun
       "fun"
       (Term.basicFun
        [(Term.simpleBinder [`Y `Z `f `hf `g `S `H] [])]
        "=>"
        (Term.app `S.downward_closed [(Term.app `hf [`S `H]) `g]))))
     [])]
   (Term.optEllipsis [])
   []
   "}")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.structInst', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.structInst', expected 'Lean.Parser.Term.structInst.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.optEllipsis', expected 'Lean.Parser.Term.optEllipsis.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'group', expected 'many.antiquot_scope'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.structInstField', expected 'Lean.Parser.Term.structInstFieldAbbrev.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.structInstField', expected 'Lean.Parser.Term.structInstFieldAbbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.structInstField', expected 'Lean.Parser.Term.structInstField.antiquot'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  (Term.fun
   "fun"
   (Term.basicFun
    [(Term.simpleBinder [`Y `Z `f `hf `g `S `H] [])]
    "=>"
    (Term.app `S.downward_closed [(Term.app `hf [`S `H]) `g])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.fun', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.fun', expected 'Lean.Parser.Term.fun.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.basicFun', expected 'Lean.Parser.Term.basicFun.antiquot'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  (Term.app `S.downward_closed [(Term.app `hf [`S `H]) `g])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'many.antiquot_scope'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  `g
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'ident.antiquot'
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'many.antiquot_scope'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.namedArgument.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.ellipsis.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
  (Term.app `hf [`S `H])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'many.antiquot_scope'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  `H
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'ident.antiquot'
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'many.antiquot_scope'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
  `S
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'ident.antiquot'
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
  `hf
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'ident.antiquot'
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1022, (some 1023, term) <=? (some 1024, term)
[PrettyPrinter.parenthesize] parenthesized: (Term.paren "(" [(Term.app `hf [`S `H]) []] ")")
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
  `S.downward_closed
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'ident.antiquot'
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.simpleBinder', expected 'many.antiquot_scope'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.simpleBinder', expected 'Lean.Parser.Term.strictImplicitBinder.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.simpleBinder', expected 'Lean.Parser.Term.strictImplicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.simpleBinder', expected 'Lean.Parser.Term.implicitBinder.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.simpleBinder', expected 'Lean.Parser.Term.implicitBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.simpleBinder', expected 'Lean.Parser.Term.instBinder.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.simpleBinder', expected 'Lean.Parser.Term.instBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.simpleBinder', expected 'Lean.Parser.Term.simpleBinder.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'many.antiquot_scope'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'ident.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'many.antiquot_scope'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'ident.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'many.antiquot_scope'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'ident.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'many.antiquot_scope'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'ident.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'many.antiquot_scope'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'ident.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'many.antiquot_scope'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'ident.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'many.antiquot_scope'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'ident.antiquot'
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (some 0, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.structInstLVal', expected 'Lean.Parser.Term.structInstLVal.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'ident.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'group', expected 'many.antiquot_scope'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Â«,Â»', expected 'optional.antiquot_scope'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.structInstField', expected 'Lean.Parser.Term.structInstFieldAbbrev.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.structInstField', expected 'Lean.Parser.Term.structInstFieldAbbrev'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.structInstField', expected 'Lean.Parser.Term.structInstField.antiquot'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  (Term.fun
   "fun"
   (Term.basicFun
    [(Term.simpleBinder [`Y] [])]
    "=>"
    (Set.Â«term{_|_}Â»
     "{"
     `f
     "|"
     (Term.forall
      "âˆ€"
      []
      ","
      (Mathlib.ExtendedBinder.Â«termâˆ€___,_Â»
       "âˆ€"
       `S
       (Â«binderTermâˆˆ_Â» "âˆˆ" `ğ’®)
       ","
       (Term.forall "âˆ€" [] "," (Term.app `sieve.arrows [`S `f]))))
     "}")))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.fun', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.fun', expected 'Lean.Parser.Term.fun.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.basicFun', expected 'Lean.Parser.Term.basicFun.antiquot'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  (Set.Â«term{_|_}Â»
   "{"
   `f
   "|"
   (Term.forall
    "âˆ€"
    []
    ","
    (Mathlib.ExtendedBinder.Â«termâˆ€___,_Â»
     "âˆ€"
     `S
     (Â«binderTermâˆˆ_Â» "âˆˆ" `ğ’®)
     ","
     (Term.forall "âˆ€" [] "," (Term.app `sieve.arrows [`S `f]))))
   "}")
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Set.Â«term{_|_}Â»', expected 'antiquot'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  (Term.forall
   "âˆ€"
   []
   ","
   (Mathlib.ExtendedBinder.Â«termâˆ€___,_Â»
    "âˆ€"
    `S
    (Â«binderTermâˆˆ_Â» "âˆˆ" `ğ’®)
    ","
    (Term.forall "âˆ€" [] "," (Term.app `sieve.arrows [`S `f]))))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.forall', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.forall', expected 'Lean.Parser.Term.forall.antiquot'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  (Mathlib.ExtendedBinder.Â«termâˆ€___,_Â»
   "âˆ€"
   `S
   (Â«binderTermâˆˆ_Â» "âˆˆ" `ğ’®)
   ","
   (Term.forall "âˆ€" [] "," (Term.app `sieve.arrows [`S `f])))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Mathlib.ExtendedBinder.Â«termâˆ€___,_Â»', expected 'antiquot'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  (Term.forall "âˆ€" [] "," (Term.app `sieve.arrows [`S `f]))
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.forall', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.forall', expected 'Lean.Parser.Term.forall.antiquot'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  (Term.app `sieve.arrows [`S `f])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.app', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'many.antiquot_scope'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  `f
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'ident.antiquot'
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'many.antiquot_scope'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))
  `S
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'ident.antiquot'
[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (some 1024, term)
[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))
  `sieve.arrows
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'ident.antiquot'
[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1022, term)
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Â«binderTermâˆˆ_Â»', expected 'antiquot'
[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))
  `ğ’®
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'ident.antiquot'
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'ident.antiquot'
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 0, term) <=? (none, [anonymous])
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Mathlib.ExtendedBinder.extBinder'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.basicFun', expected 'Lean.Parser.Term.matchAlts.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Term.basicFun', expected 'Lean.Parser.Term.matchAlts'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.declValEqns.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.declValEqns'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.whereStructInst.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.whereStructInst'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.theorem.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.theorem'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.constant.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.constant'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.instance.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.instance'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.axiom.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.axiom'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.example.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.example'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.inductive.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.inductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.classInductive.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.classInductive'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.structure.antiquot'
[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.def', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception
/-- The infimum of a collection of sieves: the intersection of them all. -/ protected
  def
    Inf
    ( ğ’® : Set sieve X ) : sieve X
    :=
      {
        Arrows := fun Y => { f | âˆ€ , âˆ€ S âˆˆ ğ’® , âˆ€ , sieve.arrows S f } ,
          downward_closed' := fun Y Z f hf g S H => S.downward_closed hf S H g
        }

/--  The union of two sieves is a sieve. -/
protected def union (S R : sieve X) : sieve X :=
  { Arrows := fun Y f => S f âˆ¨ R f,
    downward_closed' := by
      rintro Y Z f (h | h) g <;> simp [h] }

/--  The intersection of two sieves is a sieve. -/
protected def inter (S R : sieve X) : sieve X :=
  { Arrows := fun Y f => S f âˆ§ R f,
    downward_closed' := by
      rintro Y Z f âŸ¨hâ‚, hâ‚‚âŸ© g
      simp [hâ‚, hâ‚‚] }

-- failed to format: format: uncaught backtrack exception
/--
    Sieves on an object `X` form a complete lattice.
    We generate this directly rather than using the galois insertion for nicer definitional properties.
    -/
  instance
    : CompleteLattice ( sieve X )
    where
      le S R := âˆ€ â¦ƒ Y â¦„ f : Y âŸ¶ X , S f â†’ R f
        le_refl S f q := id
        le_trans Sâ‚ Sâ‚‚ Sâ‚ƒ Sâ‚â‚‚ Sâ‚‚â‚ƒ Y f h := Sâ‚‚â‚ƒ _ ( Sâ‚â‚‚ _ h )
        le_antisymm S R p q := sieve.ext fun Y f => âŸ¨ p _ , q _ âŸ©
        top := { Arrows := fun _ => Set.Univ , downward_closed' := fun Y Z f g h => âŸ¨ âŸ© }
        bot := { Arrows := fun _ => âˆ… , downward_closed' := fun _ _ _ p _ => False.elim p }
        sup := sieve.union
        inf := sieve.inter
        sup := sieve.Sup
        inf := sieve.Inf
        le_Sup ğ’® S hS Y f hf := âŸ¨ S , hS , hf âŸ©
        Sup_le â„° S hS Y f := by rintro âŸ¨ R , hR , hf âŸ© apply hS R hR _ hf
        Inf_le _ _ hS _ _ h := h _ hS
        le_Inf _ _ hS _ _ hf _ hR := hS _ hR _ hf
        le_sup_left _ _ _ _ := Or.inl
        le_sup_right _ _ _ _ := Or.inr
        sup_le _ _ _ a b _ _ hf := hf.elim ( a _ ) ( b _ )
        inf_le_left _ _ _ _ := And.left
        inf_le_right _ _ _ _ := And.right
        le_inf _ _ _ p q _ _ z := âŸ¨ p _ z , q _ z âŸ©
        le_top _ _ _ _ := trivialâ‚“
        bot_le _ _ _ := False.elim

/--  The maximal sieve always exists. -/
instance sieve_inhabited : Inhabited (sieve X) :=
  âŸ¨âŠ¤âŸ©

@[simp]
theorem Inf_apply {Ss : Set (sieve X)} {Y} (f : Y âŸ¶ X) : Inf Ss f â†” âˆ€ S : sieve X H : S âˆˆ Ss, S f :=
  Iff.rfl

@[simp]
theorem Sup_apply {Ss : Set (sieve X)} {Y} (f : Y âŸ¶ X) : Sup Ss f â†” âˆƒ (S : sieve X)(H : S âˆˆ Ss), S f :=
  Iff.rfl

@[simp]
theorem inter_apply {R S : sieve X} {Y} (f : Y âŸ¶ X) : (RâŠ“S) f â†” R f âˆ§ S f :=
  Iff.rfl

@[simp]
theorem union_apply {R S : sieve X} {Y} (f : Y âŸ¶ X) : (RâŠ”S) f â†” R f âˆ¨ S f :=
  Iff.rfl

@[simp]
theorem top_apply (f : Y âŸ¶ X) : (âŠ¤ : sieve X) f :=
  trivialâ‚“

/--  Generate the smallest sieve containing the given set of arrows. -/
@[simps]
def generate (R : presieve X) : sieve X :=
  { Arrows := fun Z f => âˆƒ (Y : _)(h : Z âŸ¶ Y)(g : Y âŸ¶ X), R g âˆ§ h â‰« g = f,
    downward_closed' := by
      rintro Y Z _ âŸ¨W, g, f, hf, rflâŸ© h
      exact
        âŸ¨_, h â‰« g, _, hf, by
          simp âŸ© }

/-- 
Given a presieve on `X`, and a sieve on each domain of an arrow in the presieve, we can bind to
produce a sieve on `X`.
-/
@[simps]
def bind (S : presieve X) (R : âˆ€ â¦ƒYâ¦„ â¦ƒf : Y âŸ¶ Xâ¦„, S f â†’ sieve Y) : sieve X :=
  { Arrows := S.bind fun Y f h => R h,
    downward_closed' := by
      rintro Y Z f âŸ¨W, f, h, hh, hf, rflâŸ© g
      exact
        âŸ¨_, g â‰« f, _, hh, by
          simp [hf]âŸ© }

open Order Lattice

theorem sets_iff_generate (R : presieve X) (S : sieve X) : generate R â‰¤ S â†” R â‰¤ S :=
  âŸ¨fun H Y g hg => H _ âŸ¨_, ğŸ™ _, _, hg, category.id_comp _âŸ©, fun ss Y f => by
    rintro âŸ¨Z, f, g, hg, rflâŸ©
    exact S.downward_closed (ss Z hg) fâŸ©

/--  Show that there is a galois insertion (generate, set_over). -/
def gi_generate : GaloisInsertion (generate : presieve X â†’ sieve X) arrows :=
  { gc := sets_iff_generate, choice := fun ğ’¢ _ => generate ğ’¢, choice_eq := fun _ _ => rfl,
    le_l_u := fun S Y f hf => âŸ¨_, ğŸ™ _, _, hf, category.id_comp _âŸ© }

theorem le_generate (R : presieve X) : R â‰¤ generate R :=
  gi_generate.gc.le_u_l R

@[simp]
theorem generate_sieve (S : sieve X) : generate S = S :=
  gi_generate.l_u_eq S

/--  If the identity arrow is in a sieve, the sieve is maximal. -/
theorem id_mem_iff_eq_top : S (ğŸ™ X) â†” S = âŠ¤ :=
  âŸ¨fun h =>
    top_unique $ fun Y f _ => by
      simpa using downward_closed _ h f,
    fun h => h.symm â–¸ trivialâ‚“âŸ©

/--  If an arrow set contains a split epi, it generates the maximal sieve. -/
theorem generate_of_contains_split_epi {R : presieve X} (f : Y âŸ¶ X) [split_epi f] (hf : R f) : generate R = âŠ¤ := by
  rw [â† id_mem_iff_eq_top]
  exact
    âŸ¨_, section_ f, f, hf, by
      simp âŸ©

@[simp]
theorem generate_of_singleton_split_epi (f : Y âŸ¶ X) [split_epi f] : generate (presieve.singleton f) = âŠ¤ :=
  generate_of_contains_split_epi f (presieve.singleton_self _)

@[simp]
theorem generate_top : generate (âŠ¤ : presieve X) = âŠ¤ :=
  generate_of_contains_split_epi (ğŸ™ _) âŸ¨âŸ©

/--  Given a morphism `h : Y âŸ¶ X`, send a sieve S on X to a sieve on Y
    as the inverse image of S with `_ â‰« h`.
    That is, `sieve.pullback S h := (â‰« h) 'â»Â¹ S`. -/
@[simps]
def pullback (h : Y âŸ¶ X) (S : sieve X) : sieve Y :=
  { Arrows := fun Y sl => S (sl â‰« h),
    downward_closed' := fun Z W f g h => by
      simp [g] }

@[simp]
theorem pullback_id : S.pullback (ğŸ™ _) = S := by
  simp [sieve.ext_iff]

@[simp]
theorem pullback_top {f : Y âŸ¶ X} : (âŠ¤ : sieve X).pullback f = âŠ¤ :=
  top_unique fun _ g => id

theorem pullback_comp {f : Y âŸ¶ X} {g : Z âŸ¶ Y} (S : sieve X) : S.pullback (g â‰« f) = (S.pullback f).pullback g := by
  simp [sieve.ext_iff]

@[simp]
theorem pullback_inter {f : Y âŸ¶ X} (S R : sieve X) : (SâŠ“R).pullback f = S.pullback fâŠ“R.pullback f := by
  simp [sieve.ext_iff]

theorem pullback_eq_top_iff_mem (f : Y âŸ¶ X) : S f â†” S.pullback f = âŠ¤ := by
  rw [â† id_mem_iff_eq_top, pullback_apply, category.id_comp]

theorem pullback_eq_top_of_mem (S : sieve X) {f : Y âŸ¶ X} : S f â†’ S.pullback f = âŠ¤ :=
  (pullback_eq_top_iff_mem f).1

/-- 
Push a sieve `R` on `Y` forward along an arrow `f : Y âŸ¶ X`: `gf : Z âŸ¶ X` is in the sieve if `gf`
factors through some `g : Z âŸ¶ Y` which is in `R`.
-/
@[simps]
def pushforward (f : Y âŸ¶ X) (R : sieve Y) : sieve X :=
  { Arrows := fun Z gf => âˆƒ g, g â‰« f = gf âˆ§ R g,
    downward_closed' := fun Zâ‚ Zâ‚‚ g âŸ¨j, k, zâŸ© h =>
      âŸ¨h â‰« j, by
        simp [k], by
        simp [z]âŸ© }

theorem pushforward_apply_comp {R : sieve Y} {Z : C} {g : Z âŸ¶ Y} (hg : R g) (f : Y âŸ¶ X) : R.pushforward f (g â‰« f) :=
  âŸ¨g, rfl, hgâŸ©

theorem pushforward_comp {f : Y âŸ¶ X} {g : Z âŸ¶ Y} (R : sieve Z) :
    R.pushforward (g â‰« f) = (R.pushforward g).pushforward f :=
  sieve.ext fun W h =>
    âŸ¨fun âŸ¨fâ‚, hq, hfâ‚âŸ© =>
      âŸ¨fâ‚ â‰« g, by
        simpa, fâ‚, rfl, hfâ‚âŸ©,
      fun âŸ¨y, hy, z, hR, hzâŸ© =>
      âŸ¨z, by
        rwa [reassoc_of hR], hzâŸ©âŸ©

theorem GaloisConnection (f : Y âŸ¶ X) : GaloisConnection (sieve.pushforward f) (sieve.pullback f) := fun S R =>
  âŸ¨fun hR Z g hg => hR _ âŸ¨g, rfl, hgâŸ©, fun hS Z g âŸ¨h, hg, hhâŸ© => hg â–¸ hS h hhâŸ©

theorem pullback_monotone (f : Y âŸ¶ X) : Monotone (sieve.pullback f) :=
  (GaloisConnection f).monotone_u

theorem pushforward_monotone (f : Y âŸ¶ X) : Monotone (sieve.pushforward f) :=
  (GaloisConnection f).monotone_l

theorem le_pushforward_pullback (f : Y âŸ¶ X) (R : sieve Y) : R â‰¤ (R.pushforward f).pullback f :=
  (GaloisConnection f).le_u_l _

theorem pullback_pushforward_le (f : Y âŸ¶ X) (R : sieve X) : (R.pullback f).pushforward f â‰¤ R :=
  (GaloisConnection f).l_u_le _

theorem pushforward_union {f : Y âŸ¶ X} (S R : sieve Y) : (SâŠ”R).pushforward f = S.pushforward fâŠ”R.pushforward f :=
  (GaloisConnection f).l_sup

theorem pushforward_le_bind_of_mem (S : presieve X) (R : âˆ€ â¦ƒY : Câ¦„ â¦ƒf : Y âŸ¶ Xâ¦„, S f â†’ sieve Y) (f : Y âŸ¶ X) (h : S f) :
    (R h).pushforward f â‰¤ bind S R := by
  rintro Z _ âŸ¨g, rfl, hgâŸ©
  exact âŸ¨_, g, f, h, hg, rflâŸ©

theorem le_pullback_bind (S : presieve X) (R : âˆ€ â¦ƒY : Câ¦„ â¦ƒf : Y âŸ¶ Xâ¦„, S f â†’ sieve Y) (f : Y âŸ¶ X) (h : S f) :
    R h â‰¤ (bind S R).pullback f := by
  rw [â† GaloisConnection f]
  apply pushforward_le_bind_of_mem

/--  If `f` is a monomorphism, the pushforward-pullback adjunction on sieves is coreflective. -/
def galois_coinsertion_of_mono (f : Y âŸ¶ X) [mono f] : GaloisCoinsertion (sieve.pushforward f) (sieve.pullback f) := by
  apply (GaloisConnection f).toGaloisCoinsertion
  rintro S Z g âŸ¨gâ‚, hf, hgâ‚âŸ©
  rw [cancel_mono f] at hf
  rwa [â† hf]

/--  If `f` is a split epi, the pushforward-pullback adjunction on sieves is reflective. -/
def galois_insertion_of_split_epi (f : Y âŸ¶ X) [split_epi f] :
    GaloisInsertion (sieve.pushforward f) (sieve.pullback f) := by
  apply (GaloisConnection f).toGaloisInsertion
  intro S Z g hg
  refine'
    âŸ¨g â‰« section_ f, by
      simpaâŸ©

theorem pullback_arrows_comm [has_pullbacks C] {X Y : C} (f : Y âŸ¶ X) (R : presieve X) :
    sieve.generate (R.pullback_arrows f) = (sieve.generate R).pullback f := by
  ext Z g
  constructor
  Â·
    rintro âŸ¨_, h, k, hk, rflâŸ©
    cases' hk with W g hg
    change (sieve.generate R).pullback f (h â‰« pullback.snd)
    rw [sieve.pullback_apply, assoc, â† pullback.condition, â† assoc]
    exact sieve.downward_closed _ (sieve.le_generate R W hg) (h â‰« pullback.fst)
  Â·
    rintro âŸ¨W, h, k, hk, commâŸ©
    exact âŸ¨_, _, _, presieve.pullback_arrows.mk _ _ hk, pullback.lift_snd _ _ commâŸ©

section Functor

variable {E : Type uâ‚ƒ} [category.{vâ‚ƒ} E] (G : D â¥¤ E)

/-- 
If `R` is a sieve, then the `category_theory.presieve.functor_pullback` of `R` is actually a sieve.
-/
@[simps]
def functor_pullback (R : sieve (F.obj X)) : sieve X :=
  { Arrows := presieve.functor_pullback F R,
    downward_closed' := fun _ _ f hf g => by
      unfold presieve.functor_pullback
      rw [F.map_comp]
      exact R.downward_closed hf (F.map g) }

@[simp]
theorem functor_pullback_arrows (R : sieve (F.obj X)) : (R.functor_pullback F).Arrows = R.arrows.functor_pullback F :=
  rfl

@[simp]
theorem functor_pullback_id (R : sieve X) : R.functor_pullback (ğŸ­ _) = R := by
  ext
  rfl

theorem functor_pullback_comp (R : sieve ((F â‹™ G).obj X)) :
    R.functor_pullback (F â‹™ G) = (R.functor_pullback G).FunctorPullback F := by
  ext
  rfl

theorem functor_pushforward_extend_eq {R : presieve X} :
    (generate R).Arrows.FunctorPushforward F = R.functor_pushforward F := by
  ext Y f
  constructor
  Â·
    rintro âŸ¨X', g, f', âŸ¨X'', g', f'', hâ‚, rflâŸ©, rflâŸ©
    exact
      âŸ¨X'', f'', f' â‰« F.map g', hâ‚, by
        simp âŸ©
  Â·
    rintro âŸ¨X', g, f', hâ‚, hâ‚‚âŸ©
    exact âŸ¨X', g, f', le_generate R _ hâ‚, hâ‚‚âŸ©

/--  The sieve generated by the image of `R` under `F`. -/
@[simps]
def functor_pushforward (R : sieve X) : sieve (F.obj X) :=
  { Arrows := R.arrows.functor_pushforward F,
    downward_closed' := fun Y Z f h g => by
      obtain âŸ¨X, Î±, Î², hÎ±, rflâŸ© := h
      exact
        âŸ¨X, Î±, g â‰« Î², hÎ±, by
          simp âŸ© }

@[simp]
theorem functor_pushforward_id (R : sieve X) : R.functor_pushforward (ğŸ­ _) = R := by
  ext X f
  constructor
  Â·
    intro hf
    obtain âŸ¨X, g, h, hg, rflâŸ© := hf
    exact R.downward_closed hg h
  Â·
    intro hf
    exact
      âŸ¨X, f, ğŸ™ _, hf, by
        simp âŸ©

theorem functor_pushforward_comp (R : sieve X) :
    R.functor_pushforward (F â‹™ G) = (R.functor_pushforward F).FunctorPushforward G := by
  ext
  simpa [R.arrows.functor_pushforward_comp F G]

theorem functor_galois_connection (X : C) :
    _root_.galois_connection (sieve.functor_pushforward F : sieve X â†’ sieve (F.obj X)) (sieve.functor_pullback F) := by
  intro R S
  constructor
  Â·
    intro hle X f hf
    apply hle
    refine' âŸ¨X, f, ğŸ™ _, hf, _âŸ©
    rw [category.id_comp]
  Â·
    rintro hle Y f âŸ¨X, g, h, hg, rflâŸ©
    apply sieve.downward_closed S
    exact hle g hg

theorem functor_pullback_monotone (X : C) : Monotone (sieve.functor_pullback F : sieve (F.obj X) â†’ sieve X) :=
  (functor_galois_connection F X).monotone_u

theorem functor_pushforward_monotone (X : C) : Monotone (sieve.functor_pushforward F : sieve X â†’ sieve (F.obj X)) :=
  (functor_galois_connection F X).monotone_l

theorem le_functor_pushforward_pullback (R : sieve X) : R â‰¤ (R.functor_pushforward F).FunctorPullback F :=
  (functor_galois_connection F X).le_u_l _

theorem functor_pullback_pushforward_le (R : sieve (F.obj X)) : (R.functor_pullback F).FunctorPushforward F â‰¤ R :=
  (functor_galois_connection F X).l_u_le _

theorem functor_pushforward_union (S R : sieve X) :
    (SâŠ”R).FunctorPushforward F = S.functor_pushforward FâŠ”R.functor_pushforward F :=
  (functor_galois_connection F X).l_sup

theorem functor_pullback_union (S R : sieve (F.obj X)) :
    (SâŠ”R).FunctorPullback F = S.functor_pullback FâŠ”R.functor_pullback F :=
  rfl

theorem functor_pullback_inter (S R : sieve (F.obj X)) :
    (SâŠ“R).FunctorPullback F = S.functor_pullback FâŠ“R.functor_pullback F :=
  rfl

@[simp]
theorem functor_pushforward_bot (F : C â¥¤ D) (X : C) : (âŠ¥ : sieve X).FunctorPushforward F = âŠ¥ :=
  (functor_galois_connection F X).l_bot

@[simp]
theorem functor_pushforward_top (F : C â¥¤ D) (X : C) : (âŠ¤ : sieve X).FunctorPushforward F = âŠ¤ := by
  refine' (generate_sieve _).symm.trans _
  apply generate_of_contains_split_epi (ğŸ™ (F.obj X))
  refine'
    âŸ¨X, ğŸ™ _, ğŸ™ _, trivialâ‚“, by
      simp âŸ©

@[simp]
theorem functor_pullback_bot (F : C â¥¤ D) (X : C) : (âŠ¥ : sieve (F.obj X)).FunctorPullback F = âŠ¥ :=
  rfl

@[simp]
theorem functor_pullback_top (F : C â¥¤ D) (X : C) : (âŠ¤ : sieve (F.obj X)).FunctorPullback F = âŠ¤ :=
  rfl

theorem image_mem_functor_pushforward (R : sieve X) {V} {f : V âŸ¶ X} (h : R f) : R.functor_pushforward F (F.map f) :=
  âŸ¨V, f, ğŸ™ _, h, by
    simp âŸ©

/--  When `F` is essentially surjective and full, the galois connection is a galois insertion. -/
def ess_surj_full_functor_galois_insertion [ess_surj F] [full F] (X : C) :
    GaloisInsertion (sieve.functor_pushforward F : sieve X â†’ sieve (F.obj X)) (sieve.functor_pullback F) := by
  apply (functor_galois_connection F X).toGaloisInsertion
  intro S Y f hf
  refine' âŸ¨_, F.preimage ((F.obj_obj_preimage_iso Y).Hom â‰« f), (F.obj_obj_preimage_iso Y).inv, _âŸ©
  simpa using S.downward_closed hf _

/--  When `F` is fully faithful, the galois connection is a galois coinsertion. -/
def fully_faithful_functor_galois_coinsertion [full F] [faithful F] (X : C) :
    GaloisCoinsertion (sieve.functor_pushforward F : sieve X â†’ sieve (F.obj X)) (sieve.functor_pullback F) := by
  apply (functor_galois_connection F X).toGaloisCoinsertion
  rintro S Y f âŸ¨Z, g, h, hâ‚, hâ‚‚âŸ©
  rw [â† F.image_preimage h, â† F.map_comp] at hâ‚‚
  rw [F.map_injective hâ‚‚]
  exact S.downward_closed hâ‚ _

end Functor

/--  A sieve induces a presheaf. -/
@[simps]
def Functor (S : sieve X) : Cáµ’áµ– â¥¤ Type vâ‚ :=
  { obj := fun Y => { g : Y.unop âŸ¶ X // S g }, map := fun Y Z f g => âŸ¨f.unop â‰« g.1, downward_closed _ g.2 _âŸ© }

/-- 
If a sieve S is contained in a sieve T, then we have a morphism of presheaves on their induced
presheaves.
-/
@[simps]
def nat_trans_of_le {S T : sieve X} (h : S â‰¤ T) : S.functor âŸ¶ T.functor :=
  { app := fun Y f => âŸ¨f.1, h _ f.2âŸ© }

/--  The natural inclusion from the functor induced by a sieve to the yoneda embedding. -/
@[simps]
def functor_inclusion (S : sieve X) : S.functor âŸ¶ yoneda.obj X :=
  { app := fun Y f => f.1 }

theorem nat_trans_of_le_comm {S T : sieve X} (h : S â‰¤ T) :
    nat_trans_of_le h â‰« functor_inclusion _ = functor_inclusion _ :=
  rfl

/--  The presheaf induced by a sieve is a subobject of the yoneda embedding. -/
instance functor_inclusion_is_mono : mono S.functor_inclusion :=
  âŸ¨fun Z f g h => by
    ext Y y
    apply congr_funâ‚“ (nat_trans.congr_app h Y) yâŸ©

/-- 
A natural transformation to a representable functor induces a sieve. This is the left inverse of
`functor_inclusion`, shown in `sieve_of_functor_inclusion`.
-/
@[simps]
def sieve_of_subfunctor {R} (f : R âŸ¶ yoneda.obj X) : sieve X :=
  { Arrows := fun Y g => âˆƒ t, f.app (Opposite.op Y) t = g,
    downward_closed' := fun Y Z _ => by
      rintro âŸ¨t, rflâŸ© g
      refine' âŸ¨R.map g.op t, _âŸ©
      rw [functor_to_types.naturality _ _ f]
      simp }

theorem sieve_of_subfunctor_functor_inclusion : sieve_of_subfunctor S.functor_inclusion = S := by
  ext
  simp only [functor_inclusion_app, sieve_of_subfunctor_apply, Subtype.val_eq_coe]
  constructor
  Â·
    rintro âŸ¨âŸ¨f, hfâŸ©, rflâŸ©
    exact hf
  Â·
    intro hf
    exact âŸ¨âŸ¨_, hfâŸ©, rflâŸ©

instance functor_inclusion_top_is_iso : is_iso (âŠ¤ : sieve X).functorInclusion :=
  âŸ¨âŸ¨{ app := fun Y a => âŸ¨a, âŸ¨âŸ©âŸ© }, by
      tidyâŸ©âŸ©

end Sieve

end CategoryTheory

