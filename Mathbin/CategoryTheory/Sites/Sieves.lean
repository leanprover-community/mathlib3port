import Mathbin.Order.CompleteLattice
import Mathbin.CategoryTheory.Over
import Mathbin.CategoryTheory.Yoneda
import Mathbin.CategoryTheory.Limits.Shapes.Pullbacks
import Mathbin.Data.Set.Lattice

/-!
# Theory of sieves

- For an object `X` of a category `C`, a `sieve X` is a set of morphisms to `X`
  which is closed under left-composition.
- The complete lattice structure on sieves is given, as well as the Galois insertion
  given by downward-closing.
- A `sieve X` (functorially) induces a presheaf on `C` together with a monomorphism to
  the yoneda embedding of `X`.

## Tags

sieve, pullback
-/


universe v‚ÇÅ v‚ÇÇ v‚ÇÉ u‚ÇÅ u‚ÇÇ u‚ÇÉ

namespace CategoryTheory

open Category Limits

variable {C : Type u‚ÇÅ} [category.{v‚ÇÅ} C] {D : Type u‚ÇÇ} [category.{v‚ÇÇ} D] (F : C ‚•§ D)

variable {X Y Z : C} (f : Y ‚ü∂ X)

/-- A set of arrows all with codomain `X`. -/
def presieve (X : C) :=
  ‚àÄ ‚¶ÉY‚¶Ñ, Set (Y ‚ü∂ X)deriving CompleteLattice

namespace Presieve

instance : Inhabited (presieve X) :=
  ‚ü®‚ä§‚ü©

/-- Given a set of arrows `S` all with codomain `X`, and a set of arrows with codomain `Y` for each
`f : Y ‚ü∂ X` in `S`, produce a set of arrows with codomain `X`:
`{ g ‚â´ f | (f : Y ‚ü∂ X) ‚àà S, (g : Z ‚ü∂ Y) ‚àà R f }`.
-/
def bind (S : presieve X) (R : ‚àÄ ‚¶ÉY‚¶Ñ ‚¶Éf : Y ‚ü∂ X‚¶Ñ, S f ‚Üí presieve Y) : presieve X := fun Z h =>
  ‚àÉ (Y : C)(g : Z ‚ü∂ Y)(f : Y ‚ü∂ X)(H : S f), R H g ‚àß g ‚â´ f = h

@[simp]
theorem bind_comp {S : presieve X} {R : ‚àÄ ‚¶ÉY : C‚¶Ñ ‚¶Éf : Y ‚ü∂ X‚¶Ñ, S f ‚Üí presieve Y} {g : Z ‚ü∂ Y} (h‚ÇÅ : S f) (h‚ÇÇ : R h‚ÇÅ g) :
    bind S R (g ‚â´ f) :=
  ‚ü®_, _, _, h‚ÇÅ, h‚ÇÇ, rfl‚ü©

/-- The singleton presieve.  -/
inductive singleton : presieve X
  | mk : singleton f

@[simp]
theorem singleton_eq_iff_domain (f g : Y ‚ü∂ X) : singleton f g ‚Üî f = g := by
  constructor
  ¬∑ rintro ‚ü®a, rfl‚ü©
    rfl
    
  ¬∑ rintro rfl
    apply singleton.mk
    

theorem singleton_self : singleton f f :=
  singleton.mk

/-- Pullback a set of arrows with given codomain along a fixed map, by taking the pullback in the
category.
This is not the same as the arrow set of `sieve.pullback`, but there is a relation between them
in `pullback_arrows_comm`.
-/
inductive pullback_arrows [has_pullbacks C] (R : presieve X) : presieve Y
  | mk (Z : C) (h : Z ‚ü∂ X) : R h ‚Üí pullback_arrows (pullback.snd : pullback h f ‚ü∂ Y)

theorem pullback_singleton [has_pullbacks C] (g : Z ‚ü∂ X) :
    pullback_arrows f (singleton g) = singleton (pullback.snd : pullback g f ‚ü∂ _) := by
  ext W h
  constructor
  ¬∑ rintro ‚ü®W, _, _, _‚ü©
    exact singleton.mk
    
  ¬∑ rintro ‚ü®_‚ü©
    exact pullback_arrows.mk Z g singleton.mk
    

/-- Construct the presieve given by the family of arrows indexed by `Œπ`. -/
inductive of_arrows {Œπ : Type _} (Y : Œπ ‚Üí C) (f : ‚àÄ i, Y i ‚ü∂ X) : presieve X
  | mk (i : Œπ) : of_arrows (f i)

theorem of_arrows_punit : (of_arrows _ fun _ : PUnit => f) = singleton f := by
  ext Y g
  constructor
  ¬∑ rintro ‚ü®_‚ü©
    apply singleton.mk
    
  ¬∑ rintro ‚ü®_‚ü©
    exact of_arrows.mk PUnit.unit
    

theorem of_arrows_pullback [has_pullbacks C] {Œπ : Type _} (Z : Œπ ‚Üí C) (g : ‚àÄ i : Œπ, Z i ‚ü∂ X) :
    (of_arrows (fun i => pullback (g i) f) fun i => pullback.snd) = pullback_arrows f (of_arrows Z g) := by
  ext T h
  constructor
  ¬∑ rintro ‚ü®hk‚ü©
    exact pullback_arrows.mk _ _ (of_arrows.mk hk)
    
  ¬∑ rintro ‚ü®W, k, hk‚ÇÅ‚ü©
    cases' hk‚ÇÅ with i hi
    apply of_arrows.mk
    

theorem of_arrows_bind {Œπ : Type _} (Z : Œπ ‚Üí C) (g : ‚àÄ i : Œπ, Z i ‚ü∂ X) (j : ‚àÄ ‚¶ÉY‚¶Ñ f : Y ‚ü∂ X, of_arrows Z g f ‚Üí Type _)
    (W : ‚àÄ ‚¶ÉY‚¶Ñ f : Y ‚ü∂ X H, j f H ‚Üí C) (k : ‚àÄ ‚¶ÉY‚¶Ñ f : Y ‚ü∂ X H i, W f H i ‚ü∂ Y) :
    ((of_arrows Z g).bind fun Y f H => of_arrows (W f H) (k f H)) =
      of_arrows (fun i : Œ£ i, j _ (of_arrows.mk i) => W (g i.1) _ i.2) fun ij => k (g ij.1) _ ij.2 ‚â´ g ij.1 :=
  by
  ext Y f
  constructor
  ¬∑ rintro ‚ü®_, _, _, ‚ü®i‚ü©, ‚ü®i'‚ü©, rfl‚ü©
    exact of_arrows.mk (Sigma.mk _ _)
    
  ¬∑ rintro ‚ü®i‚ü©
    exact bind_comp _ (of_arrows.mk _) (of_arrows.mk _)
    

/-- Given a presieve on `F(X)`, we can define a presieve on `X` by taking the preimage via `F`. -/
def functor_pullback (R : presieve (F.obj X)) : presieve X := fun _ f => R (F.map f)

@[simp]
theorem functor_pullback_mem (R : presieve (F.obj X)) {Y} (f : Y ‚ü∂ X) : R.functor_pullback F f ‚Üî R (F.map f) :=
  Iff.rfl

@[simp]
theorem functor_pullback_id (R : presieve X) : R.functor_pullback (ùü≠ _) = R :=
  rfl

section FunctorPushforward

variable {E : Type u‚ÇÉ} [category.{v‚ÇÉ} E] (G : D ‚•§ E)

/-- Given a presieve on `X`, we can define a presieve on `F(X)` (which is actually a sieve)
by taking the sieve generated by the image via `F`.
-/
def functor_pushforward (S : presieve X) : presieve (F.obj X) := fun Y f =>
  ‚àÉ (Z : C)(g : Z ‚ü∂ X)(h : Y ‚ü∂ F.obj Z), S g ‚àß f = h ‚â´ F.map g

/-- An auxillary definition in order to fix the choice of the preimages between various definitions.
-/
@[nolint has_inhabited_instance]
structure functor_pushforward_structure (S : presieve X) {Y} (f : Y ‚ü∂ F.obj X) where
  preobj : C
  premap : preobj ‚ü∂ X
  lift : Y ‚ü∂ F.obj preobj
  cover : S premap
  fac : f = lift ‚â´ F.map premap

/-- The fixed choice of a preimage. -/
noncomputable def get_functor_pushforward_structure {F : C ‚•§ D} {S : presieve X} {Y : D} {f : Y ‚ü∂ F.obj X}
    (h : S.functor_pushforward F f) : functor_pushforward_structure F S f := by
  choose Z f' g h‚ÇÅ h using h
  exact ‚ü®Z, f', g, h‚ÇÅ, h‚ü©

theorem functor_pushforward_comp (R : presieve X) :
    R.functor_pushforward (F ‚ãô G) = (R.functor_pushforward F).FunctorPushforward G := by
  ext x f
  constructor
  ¬∑ rintro ‚ü®X, f‚ÇÅ, g‚ÇÅ, h‚ÇÅ, rfl‚ü©
    exact
      ‚ü®F.obj X, F.map f‚ÇÅ, g‚ÇÅ,
        ‚ü®X, f‚ÇÅ, ùüô _, h‚ÇÅ, by
          simp ‚ü©,
        rfl‚ü©
    
  ¬∑ rintro ‚ü®X, f‚ÇÅ, g‚ÇÅ, ‚ü®X', f‚ÇÇ, g‚ÇÇ, h‚ÇÅ, rfl‚ü©, rfl‚ü©
    use
      ‚ü®X', f‚ÇÇ, g‚ÇÅ ‚â´ G.map g‚ÇÇ, h‚ÇÅ, by
        simp ‚ü©
    

theorem image_mem_functor_pushforward (R : presieve X) {f : Y ‚ü∂ X} (h : R f) : R.functor_pushforward F (F.map f) :=
  ‚ü®Y, f, ùüô _, h, by
    simp ‚ü©

end FunctorPushforward

end Presieve

/-- For an object `X` of a category `C`, a `sieve X` is a set of morphisms to `X` which is closed under
left-composition.
-/
structure sieve {C : Type u‚ÇÅ} [category.{v‚ÇÅ} C] (X : C) where
  Arrows : presieve X
  downward_closed' : ‚àÄ {Y Z f} hf : arrows f g : Z ‚ü∂ Y, arrows (g ‚â´ f)

namespace Sieve

instance : CoeFun (sieve X) fun _ => presieve X :=
  ‚ü®sieve.arrows‚ü©

initialize_simps_projections Sieve (Arrows ‚Üí apply)

variable {S R : sieve X}

@[simp]
theorem downward_closed (S : sieve X) {f : Y ‚ü∂ X} (hf : S f) (g : Z ‚ü∂ Y) : S (g ‚â´ f) :=
  S.downward_closed' hf g

theorem arrows_ext : ‚àÄ {R S : sieve X}, R.arrows = S.arrows ‚Üí R = S
  | ‚ü®Ra, _‚ü©, ‚ü®Sa, _‚ü©, rfl => rfl

@[ext]
protected theorem ext {R S : sieve X} (h : ‚àÄ ‚¶ÉY‚¶Ñ f : Y ‚ü∂ X, R f ‚Üî S f) : R = S :=
  arrows_ext $ funext $ fun x => funext $ fun f => propext $ h f

protected theorem ext_iff {R S : sieve X} : R = S ‚Üî ‚àÄ ‚¶ÉY‚¶Ñ f : Y ‚ü∂ X, R f ‚Üî S f :=
  ‚ü®fun h Y f => h ‚ñ∏ Iff.rfl, sieve.ext‚ü©

open Lattice

/-- The supremum of a collection of sieves: the union of them all. -/
protected def Sup (ùíÆ : Set (sieve X)) : sieve X where
  Arrows := fun Y => { f | ‚àÉ S ‚àà ùíÆ, sieve.arrows S f }
  downward_closed' := fun Y Z f => by
    rintro ‚ü®S, hS, hf‚ü© g
    exact ‚ü®S, hS, S.downward_closed hf _‚ü©

/-- The infimum of a collection of sieves: the intersection of them all. -/
protected def Inf (ùíÆ : Set (sieve X)) : sieve X where
  Arrows := fun Y => { f | ‚àÄ, ‚àÄ S ‚àà ùíÆ, ‚àÄ, sieve.arrows S f }
  downward_closed' := fun Y Z f hf g S H => S.downward_closed (hf S H) g

/-- The union of two sieves is a sieve. -/
protected def union (S R : sieve X) : sieve X where
  Arrows := fun Y f => S f ‚à® R f
  downward_closed' := by
    rintro Y Z f (h | h) g <;> simp [h]

/-- The intersection of two sieves is a sieve. -/
protected def inter (S R : sieve X) : sieve X where
  Arrows := fun Y f => S f ‚àß R f
  downward_closed' := by
    rintro Y Z f ‚ü®h‚ÇÅ, h‚ÇÇ‚ü© g
    simp [h‚ÇÅ, h‚ÇÇ]

/-- Sieves on an object `X` form a complete lattice.
We generate this directly rather than using the galois insertion for nicer definitional properties.
-/
instance : CompleteLattice (sieve X) where
  le := fun S R => ‚àÄ ‚¶ÉY‚¶Ñ f : Y ‚ü∂ X, S f ‚Üí R f
  le_refl := fun S f q => id
  le_trans := fun S‚ÇÅ S‚ÇÇ S‚ÇÉ S‚ÇÅ‚ÇÇ S‚ÇÇ‚ÇÉ Y f h => S‚ÇÇ‚ÇÉ _ (S‚ÇÅ‚ÇÇ _ h)
  le_antisymm := fun S R p q => sieve.ext fun Y f => ‚ü®p _, q _‚ü©
  top := { Arrows := fun _ => Set.Univ, downward_closed' := fun Y Z f g h => ‚ü®‚ü© }
  bot := { Arrows := fun _ => ‚àÖ, downward_closed' := fun _ _ _ p _ => False.elim p }
  sup := sieve.union
  inf := sieve.inter
  sup := sieve.Sup
  inf := sieve.Inf
  le_Sup := fun ùíÆ S hS Y f hf => ‚ü®S, hS, hf‚ü©
  Sup_le := fun ‚Ñ∞ S hS Y f => by
    rintro ‚ü®R, hR, hf‚ü©
    apply hS R hR _ hf
  Inf_le := fun _ _ hS _ _ h => h _ hS
  le_Inf := fun _ _ hS _ _ hf _ hR => hS _ hR _ hf
  le_sup_left := fun _ _ _ _ => Or.inl
  le_sup_right := fun _ _ _ _ => Or.inr
  sup_le := fun _ _ _ a b _ _ hf => hf.elim (a _) (b _)
  inf_le_left := fun _ _ _ _ => And.left
  inf_le_right := fun _ _ _ _ => And.right
  le_inf := fun _ _ _ p q _ _ z => ‚ü®p _ z, q _ z‚ü©
  le_top := fun _ _ _ _ => trivial‚Çì
  bot_le := fun _ _ _ => False.elim

/-- The maximal sieve always exists. -/
instance sieve_inhabited : Inhabited (sieve X) :=
  ‚ü®‚ä§‚ü©

@[simp]
theorem Inf_apply {Ss : Set (sieve X)} {Y} (f : Y ‚ü∂ X) : Inf Ss f ‚Üî ‚àÄ S : sieve X H : S ‚àà Ss, S f :=
  Iff.rfl

@[simp]
theorem Sup_apply {Ss : Set (sieve X)} {Y} (f : Y ‚ü∂ X) : Sup Ss f ‚Üî ‚àÉ (S : sieve X)(H : S ‚àà Ss), S f :=
  Iff.rfl

@[simp]
theorem inter_apply {R S : sieve X} {Y} (f : Y ‚ü∂ X) : (R‚äìS) f ‚Üî R f ‚àß S f :=
  Iff.rfl

@[simp]
theorem union_apply {R S : sieve X} {Y} (f : Y ‚ü∂ X) : (R‚äîS) f ‚Üî R f ‚à® S f :=
  Iff.rfl

@[simp]
theorem top_apply (f : Y ‚ü∂ X) : (‚ä§ : sieve X) f :=
  trivial‚Çì

/-- Generate the smallest sieve containing the given set of arrows. -/
@[simps]
def generate (R : presieve X) : sieve X where
  Arrows := fun Z f => ‚àÉ (Y : _)(h : Z ‚ü∂ Y)(g : Y ‚ü∂ X), R g ‚àß h ‚â´ g = f
  downward_closed' := by
    rintro Y Z _ ‚ü®W, g, f, hf, rfl‚ü© h
    exact
      ‚ü®_, h ‚â´ g, _, hf, by
        simp ‚ü©

/-- Given a presieve on `X`, and a sieve on each domain of an arrow in the presieve, we can bind to
produce a sieve on `X`.
-/
@[simps]
def bind (S : presieve X) (R : ‚àÄ ‚¶ÉY‚¶Ñ ‚¶Éf : Y ‚ü∂ X‚¶Ñ, S f ‚Üí sieve Y) : sieve X where
  Arrows := S.bind fun Y f h => R h
  downward_closed' := by
    rintro Y Z f ‚ü®W, f, h, hh, hf, rfl‚ü© g
    exact
      ‚ü®_, g ‚â´ f, _, hh, by
        simp [hf]‚ü©

open Order Lattice

theorem sets_iff_generate (R : presieve X) (S : sieve X) : generate R ‚â§ S ‚Üî R ‚â§ S :=
  ‚ü®fun H Y g hg => H _ ‚ü®_, ùüô _, _, hg, category.id_comp _‚ü©, fun ss Y f => by
    rintro ‚ü®Z, f, g, hg, rfl‚ü©
    exact S.downward_closed (ss Z hg) f‚ü©

/-- Show that there is a galois insertion (generate, set_over). -/
def gi_generate : GaloisInsertion (generate : presieve X ‚Üí sieve X) arrows where
  gc := sets_iff_generate
  choice := fun ùí¢ _ => generate ùí¢
  choice_eq := fun _ _ => rfl
  le_l_u := fun S Y f hf => ‚ü®_, ùüô _, _, hf, category.id_comp _‚ü©

theorem le_generate (R : presieve X) : R ‚â§ generate R :=
  gi_generate.gc.le_u_l R

@[simp]
theorem generate_sieve (S : sieve X) : generate S = S :=
  gi_generate.l_u_eq S

/-- If the identity arrow is in a sieve, the sieve is maximal. -/
theorem id_mem_iff_eq_top : S (ùüô X) ‚Üî S = ‚ä§ :=
  ‚ü®fun h =>
    top_unique $ fun Y f _ => by
      simpa using downward_closed _ h f,
    fun h => h.symm ‚ñ∏ trivial‚Çì‚ü©

/-- If an arrow set contains a split epi, it generates the maximal sieve. -/
theorem generate_of_contains_split_epi {R : presieve X} (f : Y ‚ü∂ X) [split_epi f] (hf : R f) : generate R = ‚ä§ := by
  rw [‚Üê id_mem_iff_eq_top]
  exact
    ‚ü®_, section_ f, f, hf, by
      simp ‚ü©

@[simp]
theorem generate_of_singleton_split_epi (f : Y ‚ü∂ X) [split_epi f] : generate (presieve.singleton f) = ‚ä§ :=
  generate_of_contains_split_epi f (presieve.singleton_self _)

@[simp]
theorem generate_top : generate (‚ä§ : presieve X) = ‚ä§ :=
  generate_of_contains_split_epi (ùüô _) ‚ü®‚ü©

/-- Given a morphism `h : Y ‚ü∂ X`, send a sieve S on X to a sieve on Y
    as the inverse image of S with `_ ‚â´ h`.
    That is, `sieve.pullback S h := (‚â´ h) '‚Åª¬π S`. -/
@[simps]
def pullback (h : Y ‚ü∂ X) (S : sieve X) : sieve Y where
  Arrows := fun Y sl => S (sl ‚â´ h)
  downward_closed' := fun Z W f g h => by
    simp [g]

@[simp]
theorem pullback_id : S.pullback (ùüô _) = S := by
  simp [sieve.ext_iff]

@[simp]
theorem pullback_top {f : Y ‚ü∂ X} : (‚ä§ : sieve X).pullback f = ‚ä§ :=
  top_unique fun _ g => id

theorem pullback_comp {f : Y ‚ü∂ X} {g : Z ‚ü∂ Y} (S : sieve X) : S.pullback (g ‚â´ f) = (S.pullback f).pullback g := by
  simp [sieve.ext_iff]

@[simp]
theorem pullback_inter {f : Y ‚ü∂ X} (S R : sieve X) : (S‚äìR).pullback f = S.pullback f‚äìR.pullback f := by
  simp [sieve.ext_iff]

theorem pullback_eq_top_iff_mem (f : Y ‚ü∂ X) : S f ‚Üî S.pullback f = ‚ä§ := by
  rw [‚Üê id_mem_iff_eq_top, pullback_apply, category.id_comp]

theorem pullback_eq_top_of_mem (S : sieve X) {f : Y ‚ü∂ X} : S f ‚Üí S.pullback f = ‚ä§ :=
  (pullback_eq_top_iff_mem f).1

/-- Push a sieve `R` on `Y` forward along an arrow `f : Y ‚ü∂ X`: `gf : Z ‚ü∂ X` is in the sieve if `gf`
factors through some `g : Z ‚ü∂ Y` which is in `R`.
-/
@[simps]
def pushforward (f : Y ‚ü∂ X) (R : sieve Y) : sieve X where
  Arrows := fun Z gf => ‚àÉ g, g ‚â´ f = gf ‚àß R g
  downward_closed' := fun Z‚ÇÅ Z‚ÇÇ g ‚ü®j, k, z‚ü© h =>
    ‚ü®h ‚â´ j, by
      simp [k], by
      simp [z]‚ü©

theorem pushforward_apply_comp {R : sieve Y} {Z : C} {g : Z ‚ü∂ Y} (hg : R g) (f : Y ‚ü∂ X) : R.pushforward f (g ‚â´ f) :=
  ‚ü®g, rfl, hg‚ü©

theorem pushforward_comp {f : Y ‚ü∂ X} {g : Z ‚ü∂ Y} (R : sieve Z) :
    R.pushforward (g ‚â´ f) = (R.pushforward g).pushforward f :=
  sieve.ext fun W h =>
    ‚ü®fun ‚ü®f‚ÇÅ, hq, hf‚ÇÅ‚ü© =>
      ‚ü®f‚ÇÅ ‚â´ g, by
        simpa, f‚ÇÅ, rfl, hf‚ÇÅ‚ü©,
      fun ‚ü®y, hy, z, hR, hz‚ü© =>
      ‚ü®z, by
        rwa [reassoc_of hR], hz‚ü©‚ü©

theorem GaloisConnection (f : Y ‚ü∂ X) : GaloisConnection (sieve.pushforward f) (sieve.pullback f) := fun S R =>
  ‚ü®fun hR Z g hg => hR _ ‚ü®g, rfl, hg‚ü©, fun hS Z g ‚ü®h, hg, hh‚ü© => hg ‚ñ∏ hS h hh‚ü©

theorem pullback_monotone (f : Y ‚ü∂ X) : Monotone (sieve.pullback f) :=
  (GaloisConnection f).monotone_u

theorem pushforward_monotone (f : Y ‚ü∂ X) : Monotone (sieve.pushforward f) :=
  (GaloisConnection f).monotone_l

theorem le_pushforward_pullback (f : Y ‚ü∂ X) (R : sieve Y) : R ‚â§ (R.pushforward f).pullback f :=
  (GaloisConnection f).le_u_l _

theorem pullback_pushforward_le (f : Y ‚ü∂ X) (R : sieve X) : (R.pullback f).pushforward f ‚â§ R :=
  (GaloisConnection f).l_u_le _

theorem pushforward_union {f : Y ‚ü∂ X} (S R : sieve Y) : (S‚äîR).pushforward f = S.pushforward f‚äîR.pushforward f :=
  (GaloisConnection f).l_sup

theorem pushforward_le_bind_of_mem (S : presieve X) (R : ‚àÄ ‚¶ÉY : C‚¶Ñ ‚¶Éf : Y ‚ü∂ X‚¶Ñ, S f ‚Üí sieve Y) (f : Y ‚ü∂ X) (h : S f) :
    (R h).pushforward f ‚â§ bind S R := by
  rintro Z _ ‚ü®g, rfl, hg‚ü©
  exact ‚ü®_, g, f, h, hg, rfl‚ü©

theorem le_pullback_bind (S : presieve X) (R : ‚àÄ ‚¶ÉY : C‚¶Ñ ‚¶Éf : Y ‚ü∂ X‚¶Ñ, S f ‚Üí sieve Y) (f : Y ‚ü∂ X) (h : S f) :
    R h ‚â§ (bind S R).pullback f := by
  rw [‚Üê GaloisConnection f]
  apply pushforward_le_bind_of_mem

/-- If `f` is a monomorphism, the pushforward-pullback adjunction on sieves is coreflective. -/
def galois_coinsertion_of_mono (f : Y ‚ü∂ X) [mono f] : GaloisCoinsertion (sieve.pushforward f) (sieve.pullback f) := by
  apply (GaloisConnection f).toGaloisCoinsertion
  rintro S Z g ‚ü®g‚ÇÅ, hf, hg‚ÇÅ‚ü©
  rw [cancel_mono f] at hf
  rwa [‚Üê hf]

/-- If `f` is a split epi, the pushforward-pullback adjunction on sieves is reflective. -/
def galois_insertion_of_split_epi (f : Y ‚ü∂ X) [split_epi f] :
    GaloisInsertion (sieve.pushforward f) (sieve.pullback f) := by
  apply (GaloisConnection f).toGaloisInsertion
  intro S Z g hg
  refine'
    ‚ü®g ‚â´ section_ f, by
      simpa‚ü©

theorem pullback_arrows_comm [has_pullbacks C] {X Y : C} (f : Y ‚ü∂ X) (R : presieve X) :
    sieve.generate (R.pullback_arrows f) = (sieve.generate R).pullback f := by
  ext Z g
  constructor
  ¬∑ rintro ‚ü®_, h, k, hk, rfl‚ü©
    cases' hk with W g hg
    change (sieve.generate R).pullback f (h ‚â´ pullback.snd)
    rw [sieve.pullback_apply, assoc, ‚Üê pullback.condition, ‚Üê assoc]
    exact sieve.downward_closed _ (sieve.le_generate R W hg) (h ‚â´ pullback.fst)
    
  ¬∑ rintro ‚ü®W, h, k, hk, comm‚ü©
    exact ‚ü®_, _, _, presieve.pullback_arrows.mk _ _ hk, pullback.lift_snd _ _ comm‚ü©
    

section Functor

variable {E : Type u‚ÇÉ} [category.{v‚ÇÉ} E] (G : D ‚•§ E)

/-- If `R` is a sieve, then the `category_theory.presieve.functor_pullback` of `R` is actually a sieve.
-/
@[simps]
def functor_pullback (R : sieve (F.obj X)) : sieve X where
  Arrows := presieve.functor_pullback F R
  downward_closed' := fun _ _ f hf g => by
    unfold presieve.functor_pullback
    rw [F.map_comp]
    exact R.downward_closed hf (F.map g)

@[simp]
theorem functor_pullback_arrows (R : sieve (F.obj X)) : (R.functor_pullback F).Arrows = R.arrows.functor_pullback F :=
  rfl

@[simp]
theorem functor_pullback_id (R : sieve X) : R.functor_pullback (ùü≠ _) = R := by
  ext
  rfl

theorem functor_pullback_comp (R : sieve ((F ‚ãô G).obj X)) :
    R.functor_pullback (F ‚ãô G) = (R.functor_pullback G).FunctorPullback F := by
  ext
  rfl

theorem functor_pushforward_extend_eq {R : presieve X} :
    (generate R).Arrows.FunctorPushforward F = R.functor_pushforward F := by
  ext Y f
  constructor
  ¬∑ rintro ‚ü®X', g, f', ‚ü®X'', g', f'', h‚ÇÅ, rfl‚ü©, rfl‚ü©
    exact
      ‚ü®X'', f'', f' ‚â´ F.map g', h‚ÇÅ, by
        simp ‚ü©
    
  ¬∑ rintro ‚ü®X', g, f', h‚ÇÅ, h‚ÇÇ‚ü©
    exact ‚ü®X', g, f', le_generate R _ h‚ÇÅ, h‚ÇÇ‚ü©
    

/-- The sieve generated by the image of `R` under `F`. -/
@[simps]
def functor_pushforward (R : sieve X) : sieve (F.obj X) where
  Arrows := R.arrows.functor_pushforward F
  downward_closed' := fun Y Z f h g => by
    obtain ‚ü®X, Œ±, Œ≤, hŒ±, rfl‚ü© := h
    exact
      ‚ü®X, Œ±, g ‚â´ Œ≤, hŒ±, by
        simp ‚ü©

@[simp]
theorem functor_pushforward_id (R : sieve X) : R.functor_pushforward (ùü≠ _) = R := by
  ext X f
  constructor
  ¬∑ intro hf
    obtain ‚ü®X, g, h, hg, rfl‚ü© := hf
    exact R.downward_closed hg h
    
  ¬∑ intro hf
    exact
      ‚ü®X, f, ùüô _, hf, by
        simp ‚ü©
    

theorem functor_pushforward_comp (R : sieve X) :
    R.functor_pushforward (F ‚ãô G) = (R.functor_pushforward F).FunctorPushforward G := by
  ext
  simpa [R.arrows.functor_pushforward_comp F G]

theorem functor_galois_connection (X : C) :
    _root_.galois_connection (sieve.functor_pushforward F : sieve X ‚Üí sieve (F.obj X)) (sieve.functor_pullback F) := by
  intro R S
  constructor
  ¬∑ intro hle X f hf
    apply hle
    refine' ‚ü®X, f, ùüô _, hf, _‚ü©
    rw [category.id_comp]
    
  ¬∑ rintro hle Y f ‚ü®X, g, h, hg, rfl‚ü©
    apply sieve.downward_closed S
    exact hle g hg
    

theorem functor_pullback_monotone (X : C) : Monotone (sieve.functor_pullback F : sieve (F.obj X) ‚Üí sieve X) :=
  (functor_galois_connection F X).monotone_u

theorem functor_pushforward_monotone (X : C) : Monotone (sieve.functor_pushforward F : sieve X ‚Üí sieve (F.obj X)) :=
  (functor_galois_connection F X).monotone_l

theorem le_functor_pushforward_pullback (R : sieve X) : R ‚â§ (R.functor_pushforward F).FunctorPullback F :=
  (functor_galois_connection F X).le_u_l _

theorem functor_pullback_pushforward_le (R : sieve (F.obj X)) : (R.functor_pullback F).FunctorPushforward F ‚â§ R :=
  (functor_galois_connection F X).l_u_le _

theorem functor_pushforward_union (S R : sieve X) :
    (S‚äîR).FunctorPushforward F = S.functor_pushforward F‚äîR.functor_pushforward F :=
  (functor_galois_connection F X).l_sup

theorem functor_pullback_union (S R : sieve (F.obj X)) :
    (S‚äîR).FunctorPullback F = S.functor_pullback F‚äîR.functor_pullback F :=
  rfl

theorem functor_pullback_inter (S R : sieve (F.obj X)) :
    (S‚äìR).FunctorPullback F = S.functor_pullback F‚äìR.functor_pullback F :=
  rfl

@[simp]
theorem functor_pushforward_bot (F : C ‚•§ D) (X : C) : (‚ä• : sieve X).FunctorPushforward F = ‚ä• :=
  (functor_galois_connection F X).l_bot

@[simp]
theorem functor_pushforward_top (F : C ‚•§ D) (X : C) : (‚ä§ : sieve X).FunctorPushforward F = ‚ä§ := by
  refine' (generate_sieve _).symm.trans _
  apply generate_of_contains_split_epi (ùüô (F.obj X))
  refine'
    ‚ü®X, ùüô _, ùüô _, trivial‚Çì, by
      simp ‚ü©

@[simp]
theorem functor_pullback_bot (F : C ‚•§ D) (X : C) : (‚ä• : sieve (F.obj X)).FunctorPullback F = ‚ä• :=
  rfl

@[simp]
theorem functor_pullback_top (F : C ‚•§ D) (X : C) : (‚ä§ : sieve (F.obj X)).FunctorPullback F = ‚ä§ :=
  rfl

theorem image_mem_functor_pushforward (R : sieve X) {V} {f : V ‚ü∂ X} (h : R f) : R.functor_pushforward F (F.map f) :=
  ‚ü®V, f, ùüô _, h, by
    simp ‚ü©

/-- When `F` is essentially surjective and full, the galois connection is a galois insertion. -/
def ess_surj_full_functor_galois_insertion [ess_surj F] [full F] (X : C) :
    GaloisInsertion (sieve.functor_pushforward F : sieve X ‚Üí sieve (F.obj X)) (sieve.functor_pullback F) := by
  apply (functor_galois_connection F X).toGaloisInsertion
  intro S Y f hf
  refine' ‚ü®_, F.preimage ((F.obj_obj_preimage_iso Y).Hom ‚â´ f), (F.obj_obj_preimage_iso Y).inv, _‚ü©
  simpa using S.downward_closed hf _

/-- When `F` is fully faithful, the galois connection is a galois coinsertion. -/
def fully_faithful_functor_galois_coinsertion [full F] [faithful F] (X : C) :
    GaloisCoinsertion (sieve.functor_pushforward F : sieve X ‚Üí sieve (F.obj X)) (sieve.functor_pullback F) := by
  apply (functor_galois_connection F X).toGaloisCoinsertion
  rintro S Y f ‚ü®Z, g, h, h‚ÇÅ, h‚ÇÇ‚ü©
  rw [‚Üê F.image_preimage h, ‚Üê F.map_comp] at h‚ÇÇ
  rw [F.map_injective h‚ÇÇ]
  exact S.downward_closed h‚ÇÅ _

end Functor

/-- A sieve induces a presheaf. -/
@[simps]
def Functor (S : sieve X) : C·µí·µñ ‚•§ Type v‚ÇÅ where
  obj := fun Y => { g : Y.unop ‚ü∂ X // S g }
  map := fun Y Z f g => ‚ü®f.unop ‚â´ g.1, downward_closed _ g.2 _‚ü©

/-- If a sieve S is contained in a sieve T, then we have a morphism of presheaves on their induced
presheaves.
-/
@[simps]
def nat_trans_of_le {S T : sieve X} (h : S ‚â§ T) : S.functor ‚ü∂ T.functor where
  app := fun Y f => ‚ü®f.1, h _ f.2‚ü©

/-- The natural inclusion from the functor induced by a sieve to the yoneda embedding. -/
@[simps]
def functor_inclusion (S : sieve X) : S.functor ‚ü∂ yoneda.obj X where
  app := fun Y f => f.1

theorem nat_trans_of_le_comm {S T : sieve X} (h : S ‚â§ T) :
    nat_trans_of_le h ‚â´ functor_inclusion _ = functor_inclusion _ :=
  rfl

/-- The presheaf induced by a sieve is a subobject of the yoneda embedding. -/
instance functor_inclusion_is_mono : mono S.functor_inclusion :=
  ‚ü®fun Z f g h => by
    ext Y y
    apply congr_fun‚Çì (nat_trans.congr_app h Y) y‚ü©

/-- A natural transformation to a representable functor induces a sieve. This is the left inverse of
`functor_inclusion`, shown in `sieve_of_functor_inclusion`.
-/
@[simps]
def sieve_of_subfunctor {R} (f : R ‚ü∂ yoneda.obj X) : sieve X where
  Arrows := fun Y g => ‚àÉ t, f.app (Opposite.op Y) t = g
  downward_closed' := fun Y Z _ => by
    rintro ‚ü®t, rfl‚ü© g
    refine' ‚ü®R.map g.op t, _‚ü©
    rw [functor_to_types.naturality _ _ f]
    simp

theorem sieve_of_subfunctor_functor_inclusion : sieve_of_subfunctor S.functor_inclusion = S := by
  ext
  simp only [functor_inclusion_app, sieve_of_subfunctor_apply, Subtype.val_eq_coe]
  constructor
  ¬∑ rintro ‚ü®‚ü®f, hf‚ü©, rfl‚ü©
    exact hf
    
  ¬∑ intro hf
    exact ‚ü®‚ü®_, hf‚ü©, rfl‚ü©
    

instance functor_inclusion_top_is_iso : is_iso (‚ä§ : sieve X).functorInclusion :=
  ‚ü®‚ü®{ app := fun Y a => ‚ü®a, ‚ü®‚ü©‚ü© }, by
      tidy‚ü©‚ü©

end Sieve

end CategoryTheory

