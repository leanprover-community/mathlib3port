import Mathbin.GroupTheory.Perm.Fin 
import Mathbin.Tactic.IntervalCases

/-!
# Alternating Groups

The alternating group on a finite type `α` is the subgroup of the permutation group `perm α`
consisting of the even permutations.

## Main definitions

* `alternating_group α` is the alternating group on `α`, defined as a `subgroup (perm α)`.

## Main results
* `two_mul_card_alternating_group` shows that the alternating group is half as large as
  the permutation group it is a subgroup of.

* `closure_three_cycles_eq_alternating` shows that the alternating group is
  generated by 3-cycles.

* `alternating_group.is_simple_group_five` shows that the alternating group on `fin 5` is simple.
  The proof shows that the normal closure of any non-identity element of this group contains a
  3-cycle.

## Tags
alternating group permutation


## TODO
* Show that `alternating_group α` is simple if and only if `fintype.card α ≠ 4`.

-/


open Equiv Equiv.Perm Subgroup Fintype

variable(α : Type _)[Fintype α][DecidableEq α]

-- error in GroupTheory.SpecificGroups.Alternating: ././Mathport/Syntax/Translate/Basic.lean:704:9: unsupported derive handler fintype
/-- The alternating group on a finite type, realized as a subgroup of `equiv.perm`.
  For $A_n$, use `alternating_group (fin n)`. -/ @[derive #[expr fintype]] def alternating_group : subgroup (perm α) :=
sign.ker

instance  [Subsingleton α] : Unique (alternatingGroup α) :=
  ⟨⟨1⟩, fun ⟨p, hp⟩ => Subtype.eq (Subsingleton.elimₓ p _)⟩

variable{α}

theorem alternating_group_eq_sign_ker : alternatingGroup α = sign.ker :=
  rfl

namespace Equiv.Perm

@[simp]
theorem mem_alternating_group {f : perm α} : f ∈ alternatingGroup α ↔ sign f = 1 :=
  sign.mem_ker

theorem prod_list_swap_mem_alternating_group_iff_even_length {l : List (perm α)} (hl : ∀ g _ : g ∈ l, is_swap g) :
  l.prod ∈ alternatingGroup α ↔ Even l.length :=
  by 
    rw [mem_alternating_group, sign_prod_list_swap hl, ←Units.coe_eq_one, Units.coe_pow, Units.coe_neg_one,
      Nat.neg_one_pow_eq_one_iff_even]
    decide

theorem is_three_cycle.mem_alternating_group {f : perm α} (h : is_three_cycle f) : f ∈ alternatingGroup α :=
  mem_alternating_group.2 h.sign

theorem fin_rotate_bit1_mem_alternating_group {n : ℕ} : finRotate (bit1 n) ∈ alternatingGroup (Finₓ (bit1 n)) :=
  by 
    rw [mem_alternating_group, bit1, sign_fin_rotate, pow_bit0', Int.units_mul_self, one_pow]

end Equiv.Perm

theorem two_mul_card_alternating_group [Nontrivial α] : (2*card (alternatingGroup α)) = card (perm α) :=
  by 
    let this := (QuotientGroup.quotientKerEquivOfSurjective _ (sign_surjective α)).toEquiv 
    rw [←Fintype.card_units_int, ←Fintype.card_congr this]
    exact (Subgroup.card_eq_card_quotient_mul_card_subgroup _).symm

namespace alternatingGroup

open Equiv.Perm

instance normal : (alternatingGroup α).Normal :=
  sign.normal_ker

-- error in GroupTheory.SpecificGroups.Alternating: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
theorem is_conj_of
{σ τ : alternating_group α}
(hc : is_conj (σ : perm α) (τ : perm α))
(hσ : «expr ≤ »(«expr + »((σ : perm α).support.card, 2), fintype.card α)) : is_conj σ τ :=
begin
  obtain ["⟨", ident σ, ",", ident hσ, "⟩", ":=", expr σ],
  obtain ["⟨", ident τ, ",", ident hτ, "⟩", ":=", expr τ],
  obtain ["⟨", ident π, ",", ident hπ, "⟩", ":=", expr is_conj_iff.1 hc],
  rw ["[", expr subtype.coe_mk, ",", expr subtype.coe_mk, "]"] ["at", ident hπ],
  cases [expr int.units_eq_one_or (sign π)] ["with", ident h, ident h],
  { rw [expr is_conj_iff] [],
    refine [expr ⟨⟨π, mem_alternating_group.mp h⟩, subtype.val_injective _⟩],
    simpa [] [] ["only"] ["[", expr subtype.val_eq_coe, ",", expr subgroup.coe_mul, ",", expr coe_inv, ",", expr coe_mk, "]"] [] ["using", expr hπ] },
  { have [ident h2] [":", expr «expr ≤ »(2, «expr ᶜ»(σ.support).card)] [],
    { rw ["[", expr finset.card_compl, ",", expr le_tsub_iff_left σ.support.card_le_univ, "]"] [],
      exact [expr hσ] },
    obtain ["⟨", ident a, ",", ident ha, ",", ident b, ",", ident hb, ",", ident ab, "⟩", ":=", expr finset.one_lt_card.1 h2],
    refine [expr is_conj_iff.2 ⟨⟨«expr * »(π, swap a b), _⟩, subtype.val_injective _⟩],
    { rw ["[", expr mem_alternating_group, ",", expr monoid_hom.map_mul, ",", expr h, ",", expr sign_swap ab, ",", expr int.units_mul_self, "]"] [] },
    { simp [] [] ["only"] ["[", "<-", expr hπ, ",", expr coe_mk, ",", expr subgroup.coe_mul, ",", expr subtype.val_eq_coe, "]"] [] [],
      have [ident hd] [":", expr disjoint (swap a b) σ] [],
      { rw ["[", expr disjoint_iff_disjoint_support, ",", expr support_swap ab, ",", expr finset.disjoint_insert_left, ",", expr finset.disjoint_singleton_left, "]"] [],
        exact [expr ⟨finset.mem_compl.1 ha, finset.mem_compl.1 hb⟩] },
      rw ["[", expr mul_assoc π _ σ, ",", expr hd.commute.eq, ",", expr coe_inv, ",", expr coe_mk, "]"] [],
      simp [] [] [] ["[", expr mul_assoc, "]"] [] [] } }
end

theorem is_three_cycle_is_conj (h5 : 5 ≤ Fintype.card α) {σ τ : alternatingGroup α} (hσ : is_three_cycle (σ : perm α))
  (hτ : is_three_cycle (τ : perm α)) : IsConj σ τ :=
  alternatingGroup.is_conj_of (is_conj_iff_cycle_type_eq.2 (hσ.trans hτ.symm))
    (by 
      rwa [hσ.card_support])

end alternatingGroup

namespace Equiv.Perm

open alternatingGroup

@[simp]
theorem closure_three_cycles_eq_alternating : closure { σ:perm α | is_three_cycle σ } = alternatingGroup α :=
  (closure_eq_of_le _ fun σ hσ => mem_alternating_group.2 hσ.sign)$
    fun σ hσ =>
      by 
        suffices hind :
          ∀ n : ℕ l : List (perm α) hl : ∀ g, g ∈ l → is_swap g hn : l.length = 2*n,
            l.prod ∈ closure { σ:perm α | is_three_cycle σ }
        ·
          obtain ⟨l, rfl, hl⟩ := trunc_swap_factors σ 
          obtain ⟨n, hn⟩ := (prod_list_swap_mem_alternating_group_iff_even_length hl).1 hσ 
          exact hind n l hl hn 
        intro n 
        induction' n with n ih <;> intro l hl hn
        ·
          simp [List.length_eq_zero.1 hn, one_mem]
        rw [Nat.mul_succ] at hn 
        obtain ⟨a, l, rfl⟩ := l.exists_of_length_succ hn 
        rw [List.length_cons, Nat.succ_inj'] at hn 
        obtain ⟨b, l, rfl⟩ := l.exists_of_length_succ hn 
        rw [List.prod_cons, List.prod_cons, ←mul_assocₓ]
        rw [List.length_cons, Nat.succ_inj'] at hn 
        exact
          mul_mem _
            (is_swap.mul_mem_closure_three_cycles (hl a (List.mem_cons_selfₓ a _))
              (hl b (List.mem_cons_of_memₓ a (l.mem_cons_self b))))
            (ih _ (fun g hg => hl g (List.mem_cons_of_memₓ _ (List.mem_cons_of_memₓ _ hg))) hn)

-- error in GroupTheory.SpecificGroups.Alternating: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
/-- A key lemma to prove $A_5$ is simple. Shows that any normal subgroup of an alternating group on
  at least 5 elements is the entire alternating group if it contains a 3-cycle. -/
theorem is_three_cycle.alternating_normal_closure
(h5 : «expr ≤ »(5, fintype.card α))
{f : perm α}
(hf : is_three_cycle f) : «expr = »(normal_closure ({⟨f, hf.mem_alternating_group⟩} : set (alternating_group α)), «expr⊤»()) :=
eq_top_iff.2 (begin
   have [ident hi] [":", expr function.injective (alternating_group α).subtype] [":=", expr subtype.coe_injective],
   refine [expr eq_top_iff.1 (map_injective hi (le_antisymm (map_mono le_top) _))],
   rw ["[", "<-", expr monoid_hom.range_eq_map, ",", expr subtype_range, ",", expr normal_closure, ",", expr monoid_hom.map_closure, "]"] [],
   refine [expr (le_of_eq closure_three_cycles_eq_alternating.symm).trans (closure_mono _)],
   intros [ident g, ident h],
   obtain ["⟨", ident c, ",", ident rfl, "⟩", ":=", expr is_conj_iff.1 (is_conj_iff_cycle_type_eq.2 (hf.trans h.symm))],
   refine [expr ⟨⟨«expr * »(«expr * »(c, f), «expr ⁻¹»(c)), h.mem_alternating_group⟩, _, rfl⟩],
   rw [expr group.mem_conjugates_of_set_iff] [],
   exact [expr ⟨⟨f, hf.mem_alternating_group⟩, set.mem_singleton _, is_three_cycle_is_conj h5 hf h⟩]
 end)

/-- Part of proving $A_5$ is simple. Shows that the square of any element of $A_5$ with a 3-cycle in
  its cycle decomposition is a 3-cycle, so the normal closure of the original element must be
  $A_5$. -/
theorem is_three_cycle_sq_of_three_mem_cycle_type_five {g : perm (Finₓ 5)} (h : 3 ∈ cycle_type g) :
  is_three_cycle (g*g) :=
  by 
    obtain ⟨c, g', rfl, hd, hc, h3⟩ := mem_cycle_type_iff.1 h 
    simp only [mul_assocₓ]
    rw [hd.commute.eq, ←mul_assocₓ g']
    suffices hg' : orderOf g' ∣ 2
    ·
      rw [←pow_two, order_of_dvd_iff_pow_eq_one.1 hg', one_mulₓ]
      exact (card_support_eq_three_iff.1 h3).is_three_cycle_sq 
    rw [←lcm_cycle_type, Multiset.lcm_dvd]
    intro n hn 
    rw [le_antisymmₓ (two_le_of_mem_cycle_type hn) (le_transₓ (le_card_support_of_mem_cycle_type hn) _)]
    apply le_of_add_le_add_left 
    rw [←hd.card_support_mul, h3]
    exact (c*g').support.card_le_univ

end Equiv.Perm

namespace alternatingGroup

open Equiv.Perm

-- error in GroupTheory.SpecificGroups.Alternating: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
theorem nontrivial_of_three_le_card (h3 : «expr ≤ »(3, card α)) : nontrivial (alternating_group α) :=
begin
  haveI [] [] [":=", expr fintype.one_lt_card_iff_nontrivial.1 (lt_trans exprdec_trivial() h3)],
  rw ["<-", expr fintype.one_lt_card_iff_nontrivial] [],
  refine [expr lt_of_mul_lt_mul_left _ (le_of_lt nat.prime_two.pos)],
  rw ["[", expr two_mul_card_alternating_group, ",", expr card_perm, ",", "<-", expr nat.succ_le_iff, "]"] [],
  exact [expr le_trans h3 (card α).self_le_factorial]
end

instance  {n : ℕ} : Nontrivial (alternatingGroup (Finₓ (n+3))) :=
  nontrivial_of_three_le_card
    (by 
      rw [card_fin]
      exact le_add_left (le_reflₓ 3))

-- error in GroupTheory.SpecificGroups.Alternating: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
/-- The normal closure of the 5-cycle `fin_rotate 5` within $A_5$ is the whole group. This will be
  used to show that the normal closure of any 5-cycle within $A_5$ is the whole group. -/
theorem normal_closure_fin_rotate_five : «expr = »(normal_closure ({⟨fin_rotate 5, fin_rotate_bit1_mem_alternating_group⟩} : set (alternating_group (fin 5))), «expr⊤»()) :=
eq_top_iff.2 (begin
   have [ident h3] [":", expr is_three_cycle «expr * »(«expr * »(«expr * »(fin.cycle_range 2, fin_rotate 5), «expr ⁻¹»(fin.cycle_range 2)), «expr ⁻¹»(fin_rotate 5))] [":=", expr card_support_eq_three_iff.1 exprdec_trivial()],
   rw ["<-", expr h3.alternating_normal_closure (by rw ["[", expr card_fin, "]"] [])] [],
   refine [expr normal_closure_le_normal _],
   rw ["[", expr set.singleton_subset_iff, ",", expr set_like.mem_coe, "]"] [],
   have [ident h] [":", expr «expr ∈ »((⟨fin_rotate 5, fin_rotate_bit1_mem_alternating_group⟩ : alternating_group (fin 5)), normal_closure _)] [":=", expr set_like.mem_coe.1 (subset_normal_closure (set.mem_singleton _))],
   exact [expr mul_mem _ (subgroup.normal_closure_normal.conj_mem _ h ⟨fin.cycle_range 2, fin.is_three_cycle_cycle_range_two.mem_alternating_group⟩) (inv_mem _ h)]
 end)

-- error in GroupTheory.SpecificGroups.Alternating: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
/-- The normal closure of $(04)(13)$ within $A_5$ is the whole group. This will be
  used to show that the normal closure of any permutation of cycle type $(2,2)$ is the whole group.
  -/
theorem normal_closure_swap_mul_swap_five : «expr = »(normal_closure ({⟨«expr * »(swap 0 4, swap 1 3), mem_alternating_group.2 exprdec_trivial()⟩} : set (alternating_group (fin 5))), «expr⊤»()) :=
begin
  let [ident g1] [] [":=", expr (⟨«expr * »(swap 0 2, swap 0 1), mem_alternating_group.2 exprdec_trivial()⟩ : alternating_group (fin 5))],
  let [ident g2] [] [":=", expr (⟨«expr * »(swap 0 4, swap 1 3), mem_alternating_group.2 exprdec_trivial()⟩ : alternating_group (fin 5))],
  have [ident h5] [":", expr «expr = »(«expr * »(«expr * »(«expr * »(g1, g2), «expr ⁻¹»(g1)), «expr ⁻¹»(g2)), ⟨fin_rotate 5, fin_rotate_bit1_mem_alternating_group⟩)] [],
  { rw [expr subtype.ext_iff] [],
    simp [] [] ["only"] ["[", expr fin.coe_mk, ",", expr subgroup.coe_mul, ",", expr subgroup.coe_inv, ",", expr fin.coe_mk, "]"] [] [],
    dec_trivial [] },
  rw ["[", expr eq_top_iff, ",", "<-", expr normal_closure_fin_rotate_five, "]"] [],
  refine [expr normal_closure_le_normal _],
  rw ["[", expr set.singleton_subset_iff, ",", expr set_like.mem_coe, ",", "<-", expr h5, "]"] [],
  have [ident h] [":", expr «expr ∈ »(g2, normal_closure {g2})] [":=", expr set_like.mem_coe.1 (subset_normal_closure (set.mem_singleton _))],
  exact [expr mul_mem _ (subgroup.normal_closure_normal.conj_mem _ h g1) (inv_mem _ h)]
end

-- error in GroupTheory.SpecificGroups.Alternating: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
/-- Shows that any non-identity element of $A_5$ whose cycle decomposition consists only of swaps
  is conjugate to $(04)(13)$. This is used to show that the normal closure of such a permutation
  in $A_5$ is $A_5$. -/
theorem is_conj_swap_mul_swap_of_cycle_type_two
{g : perm (fin 5)}
(ha : «expr ∈ »(g, alternating_group (fin 5)))
(h1 : «expr ≠ »(g, 1))
(h2 : ∀ n, «expr ∈ »(n, cycle_type (g : perm (fin 5))) → «expr = »(n, 2)) : is_conj «expr * »(swap 0 4, swap 1 3) g :=
begin
  have [ident h] [] [":=", expr g.support.card_le_univ],
  rw ["[", "<-", expr sum_cycle_type, ",", expr multiset.eq_repeat_of_mem h2, ",", expr multiset.sum_repeat, ",", expr smul_eq_mul, "]"] ["at", ident h],
  rw ["[", "<-", expr multiset.eq_repeat', "]"] ["at", ident h2],
  have [ident h56] [":", expr «expr ≤ »(5, «expr * »(3, 2))] [":=", expr nat.le_succ 5],
  have [ident h] [] [":=", expr le_of_mul_le_mul_right (le_trans h h56) exprdec_trivial()],
  rw ["[", expr mem_alternating_group, ",", expr sign_of_cycle_type, ",", expr h2, ",", expr multiset.map_repeat, ",", expr multiset.prod_repeat, ",", expr int.units_pow_two, ",", expr units.ext_iff, ",", expr units.coe_one, ",", expr units.coe_pow, ",", expr units.coe_neg_one, ",", expr nat.neg_one_pow_eq_one_iff_even _, "]"] ["at", ident ha],
  swap,
  { dec_trivial [] },
  rw ["[", expr is_conj_iff_cycle_type_eq, ",", expr h2, "]"] [],
  interval_cases [expr multiset.card g.cycle_type] [] [],
  { exact [expr (h1 (card_cycle_type_eq_zero.1 h_1)).elim] },
  { contrapose ["!"] [ident ha],
    simp [] [] [] ["[", expr h_1, "]"] [] [] },
  { have [ident h04] [":", expr «expr ≠ »((0 : fin 5), 4)] [":=", expr exprdec_trivial()],
    have [ident h13] [":", expr «expr ≠ »((1 : fin 5), 3)] [":=", expr exprdec_trivial()],
    rw ["[", expr h_1, ",", expr disjoint.cycle_type, ",", expr (is_cycle_swap h04).cycle_type, ",", expr (is_cycle_swap h13).cycle_type, ",", expr card_support_swap h04, ",", expr card_support_swap h13, "]"] [],
    { refl },
    { rw ["[", expr disjoint_iff_disjoint_support, ",", expr support_swap h04, ",", expr support_swap h13, "]"] [],
      dec_trivial [] } },
  { contrapose ["!"] [ident ha],
    simp [] [] [] ["[", expr h_1, "]"] [] [] }
end

-- error in GroupTheory.SpecificGroups.Alternating: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
/-- Shows that $A_5$ is simple by taking an arbitrary non-identity element and showing by casework
  on its cycle type that its normal closure is all of $A_5$.   -/
instance is_simple_group_five : is_simple_group (alternating_group (fin 5)) :=
⟨exists_pair_ne _, λ H, begin
   introI [ident Hn],
   refine [expr or_not.imp id (λ Hb, _)],
   rw ["[", expr eq_bot_iff_forall, "]"] ["at", ident Hb],
   push_neg ["at", ident Hb],
   obtain ["⟨", "⟨", ident g, ",", ident gA, "⟩", ",", ident gH, ",", ident g1, "⟩", ":", expr «expr∃ , »((x : «expr↥ »(alternating_group (fin 5))), «expr ∧ »(«expr ∈ »(x, H), «expr ≠ »(x, 1))), ":=", expr Hb],
   rw ["[", "<-", expr set_like.mem_coe, ",", "<-", expr set.singleton_subset_iff, "]"] ["at", ident gH],
   refine [expr eq_top_iff.2 (le_trans (ge_of_eq _) (normal_closure_le_normal gH))],
   by_cases [expr h2, ":", expr ∀ n «expr ∈ » g.cycle_type, «expr = »(n, 2)],
   { rw ["[", expr ne.def, ",", expr subtype.ext_iff, "]"] ["at", ident g1],
     exact [expr (is_conj_swap_mul_swap_of_cycle_type_two gA g1 h2).normal_closure_eq_top_of normal_closure_swap_mul_swap_five] },
   push_neg ["at", ident h2],
   obtain ["⟨", ident n, ",", ident ng, ",", ident n2, "⟩", ":", expr «expr∃ , »((n : exprℕ()), «expr ∧ »(«expr ∈ »(n, g.cycle_type), «expr ≠ »(n, 2))), ":=", expr h2],
   have [ident n2'] [":", expr «expr < »(2, n)] [":=", expr lt_of_le_of_ne (two_le_of_mem_cycle_type ng) n2.symm],
   have [ident n5] [":", expr «expr ≤ »(n, 5)] [":=", expr le_trans _ g.support.card_le_univ],
   swap,
   { obtain ["⟨", ident m, ",", ident hm, "⟩", ":=", expr multiset.exists_cons_of_mem ng],
     rw ["[", "<-", expr sum_cycle_type, ",", expr hm, ",", expr multiset.sum_cons, "]"] [],
     exact [expr le_add_right (le_refl _)] },
   interval_cases [expr n] [] [],
   { rw ["[", expr eq_top_iff, ",", "<-", expr (is_three_cycle_sq_of_three_mem_cycle_type_five ng).alternating_normal_closure (by rw [expr card_fin] []), "]"] [],
     refine [expr normal_closure_le_normal _],
     rw ["[", expr set.singleton_subset_iff, ",", expr set_like.mem_coe, "]"] [],
     have [ident h] [] [":=", expr set_like.mem_coe.1 (subset_normal_closure (set.mem_singleton _))],
     exact [expr mul_mem _ h h] },
   { have [ident con] [] [":=", expr mem_alternating_group.1 gA],
     contrapose ["!"] [ident con],
     rw ["[", expr sign_of_cycle_type, ",", expr cycle_type_of_card_le_mem_cycle_type_add_two exprdec_trivial() ng, ",", expr multiset.map_singleton, ",", expr multiset.prod_singleton, "]"] [],
     dec_trivial [] },
   { refine [expr (is_conj_iff_cycle_type_eq.2 _).normal_closure_eq_top_of normal_closure_fin_rotate_five],
     rw ["[", expr cycle_type_of_card_le_mem_cycle_type_add_two exprdec_trivial() ng, ",", expr cycle_type_fin_rotate, "]"] [] }
 end⟩

end alternatingGroup

