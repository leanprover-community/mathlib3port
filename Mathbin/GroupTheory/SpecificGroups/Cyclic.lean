import Mathbin.Algebra.BigOperators.Order 
import Mathbin.Data.Nat.Totient 
import Mathbin.GroupTheory.OrderOfElement 
import Mathbin.Tactic.Group

/-!
# Cyclic groups

A group `G` is called cyclic if there exists an element `g : G` such that every element of `G` is of
the form `g ^ n` for some `n : ℕ`. This file only deals with the predicate on a group to be cyclic.
For the concrete cyclic group of order `n`, see `data.zmod.basic`.

## Main definitions

* `is_cyclic` is a predicate on a group stating that the group is cyclic.

## Main statements

* `is_cyclic_of_prime_card` proves that a finite group of prime order is cyclic.
* `is_simple_group_of_prime_card`, `is_simple_group.is_cyclic`,
  and `is_simple_group.prime_card` classify finite simple abelian groups.

## Implementation details

This file is currently only available for multiplicatively written groups.

## Tags

cyclic group

## TODO

* Add the attribute `@[to_additive]` to the declarations about `is_cyclic`, so that they work for
  additive groups.
-/


universe u

variable {α : Type u} {a : α}

section Cyclic

open_locale BigOperators

attribute [local instance] setFintype

open Subgroup

/-- A group is called *cyclic* if it is generated by a single element. -/
class IsCyclic (α : Type u) [Groupₓ α] : Prop where 
  exists_generator{} : ∃ g : α, ∀ x, x ∈ zpowers g

instance (priority := 100) is_cyclic_of_subsingleton [Groupₓ α] [Subsingleton α] : IsCyclic α :=
  ⟨⟨1,
      fun x =>
        by 
          rw [Subsingleton.elimₓ x 1]
          exact mem_zpowers 1⟩⟩

/-- A cyclic group is always commutative. This is not an `instance` because often we have a better
proof of `comm_group`. -/
def IsCyclic.commGroup [hg : Groupₓ α] [IsCyclic α] : CommGroupₓ α :=
  { hg with
    mul_comm :=
      fun x y =>
        show (x*y) = y*x from
          let ⟨g, hg⟩ := IsCyclic.exists_generator α 
          let ⟨n, hn⟩ := hg x 
          let ⟨m, hm⟩ := hg y 
          hm ▸ hn ▸ zpow_mul_comm _ _ _ }

variable [Groupₓ α]

theorem MonoidHom.map_cyclic {G : Type _} [Groupₓ G] [h : IsCyclic G] (σ : G →* G) : ∃ m : ℤ, ∀ g : G, σ g = g ^ m :=
  by 
    obtain ⟨h, hG⟩ := IsCyclic.exists_generator G 
    obtain ⟨m, hm⟩ := hG (σ h)
    use m 
    intro g 
    obtain ⟨n, rfl⟩ := hG g 
    rw [MonoidHom.map_zpow, ←hm, ←zpow_mul, ←zpow_mul']

theorem is_cyclic_of_order_of_eq_card [Fintype α] (x : α) (hx : orderOf x = Fintype.card α) : IsCyclic α :=
  by 
    classical 
    use x 
    simpRw [←SetLike.mem_coe]
    rw [←Set.eq_univ_iff_forall]
    apply Set.eq_of_subset_of_card_le (Set.subset_univ _)
    rw [Fintype.card_congr (Equiv.Set.univ α), ←hx, order_eq_card_zpowers]

-- error in GroupTheory.SpecificGroups.Cyclic: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
/-- A finite group of prime order is cyclic. -/
theorem is_cyclic_of_prime_card
{α : Type u}
[group α]
[fintype α]
{p : exprℕ()}
[hp : fact p.prime]
(h : «expr = »(fintype.card α, p)) : is_cyclic α :=
⟨begin
   obtain ["⟨", ident g, ",", ident hg, "⟩", ":", expr «expr∃ , »((g : α), «expr ≠ »(g, 1))],
   from [expr fintype.exists_ne_of_one_lt_card (by { rw [expr h] [], exact [expr hp.1.one_lt] }) 1],
   classical,
   have [] [":", expr «expr ∣ »(fintype.card (subgroup.zpowers g), p)] [],
   { rw ["<-", expr h] [],
     apply [expr card_subgroup_dvd_card] },
   rw [expr nat.dvd_prime hp.1] ["at", ident this],
   cases [expr this] [],
   { rw [expr fintype.card_eq_one_iff] ["at", ident this],
     cases [expr this] ["with", ident t, ident ht],
     suffices [] [":", expr «expr = »(g, 1)],
     { contradiction },
     have [ident hgt] [] [":=", expr ht ⟨g, by { change [expr «expr ∈ »(g, subgroup.zpowers g)] [] [],
         exact [expr subgroup.mem_zpowers g] }⟩],
     rw ["[", "<-", expr ht 1, "]"] ["at", ident hgt],
     change [expr «expr = »((⟨_, _⟩ : subgroup.zpowers g), ⟨_, _⟩)] [] ["at", ident hgt],
     simpa [] [] [] [] [] ["using", expr hgt] },
   { use [expr g],
     intro [ident x],
     rw ["[", "<-", expr h, "]"] ["at", ident this],
     rw [expr subgroup.eq_top_of_card_eq _ this] [],
     exact [expr subgroup.mem_top _] }
 end⟩

theorem order_of_eq_card_of_forall_mem_zpowers [Fintype α] {g : α} (hx : ∀ x, x ∈ zpowers g) :
  orderOf g = Fintype.card α :=
  by 
    classical 
    rw [←Fintype.card_congr (Equiv.Set.univ α), order_eq_card_zpowers]
    simp [hx]
    apply Fintype.card_of_finset' 
    simp 
    intro x 
    exact hx x

instance Bot.is_cyclic {α : Type u} [Groupₓ α] : IsCyclic (⊥ : Subgroup α) :=
  ⟨⟨1, fun x => ⟨0, Subtype.eq$ Eq.symm (Subgroup.mem_bot.1 x.2)⟩⟩⟩

-- error in GroupTheory.SpecificGroups.Cyclic: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
instance subgroup.is_cyclic {α : Type u} [group α] [is_cyclic α] (H : subgroup α) : is_cyclic H :=
by haveI [] [] [":=", expr classical.prop_decidable]; exact [expr let ⟨g, hg⟩ := is_cyclic.exists_generator α in
 if hx : «expr∃ , »((x : α), «expr ∧ »(«expr ∈ »(x, H), «expr ≠ »(x, (1 : α)))) then let ⟨x, hx₁, hx₂⟩ := hx in
 let ⟨k, hk⟩ := hg x in
 have hex : «expr∃ , »((n : exprℕ()), «expr ∧ »(«expr < »(0, n), «expr ∈ »(«expr ^ »(g, n), H))), from ⟨k.nat_abs, nat.pos_of_ne_zero (λ
   h, «expr $ »(hx₂, by rw ["[", "<-", expr hk, ",", expr int.eq_zero_of_nat_abs_eq_zero h, ",", expr zpow_zero, "]"] [])), match k, hk with
  | (k : exprℕ()), hk := by rw ["[", expr int.nat_abs_of_nat, ",", "<-", expr zpow_coe_nat, ",", expr hk, "]"] []; exact [expr hx₁]
  | «expr-[1+ ]»(k), hk := by rw ["[", expr int.nat_abs_of_neg_succ_of_nat, ",", "<-", expr subgroup.inv_mem_iff H, "]"] []; simp [] [] [] ["*"] [] ["at", "*"]
  end⟩,
 ⟨⟨⟨«expr ^ »(g, nat.find hex), (nat.find_spec hex).2⟩, λ ⟨x, hx⟩, let ⟨k, hk⟩ := hg x in
   have hk₁ : «expr ∈ »(«expr ^ »(g, «expr * »((nat.find hex : exprℤ()), «expr / »(k, nat.find hex))), zpowers «expr ^ »(g, nat.find hex)), from ⟨«expr / »(k, nat.find hex), by rw ["[", "<-", expr zpow_coe_nat, ",", expr zpow_mul, "]"] []⟩,
   have hk₂ : «expr ∈ »(«expr ^ »(g, «expr * »((nat.find hex : exprℤ()), «expr / »(k, nat.find hex))), H), by { rw [expr zpow_mul] [],
     apply [expr H.zpow_mem],
     exact_mod_cast [expr (nat.find_spec hex).2] },
   have hk₃ : «expr ∈ »(«expr ^ »(g, «expr % »(k, nat.find hex)), H), from «expr $ »((subgroup.mul_mem_cancel_right H hk₂).1, by rw ["[", "<-", expr zpow_add, ",", expr int.mod_add_div, ",", expr hk, "]"] []; exact [expr hx]),
   have hk₄ : «expr = »(«expr % »(k, nat.find hex), «expr % »(k, nat.find hex).nat_abs), by rw [expr int.nat_abs_of_nonneg (int.mod_nonneg _ (int.coe_nat_ne_zero_iff_pos.2 (nat.find_spec hex).1))] [],
   have hk₅ : «expr ∈ »(«expr ^ »(g, «expr % »(k, nat.find hex).nat_abs), H), by rwa ["[", "<-", expr zpow_coe_nat, ",", "<-", expr hk₄, "]"] [],
   have hk₆ : «expr = »(«expr % »(k, (nat.find hex : exprℤ())).nat_abs, 0), from by_contradiction (λ
    h, nat.find_min hex «expr $ »(int.coe_nat_lt.1, by rw ["[", "<-", expr hk₄, "]"] []; exact [expr int.mod_lt_of_pos _ (int.coe_nat_pos.2 (nat.find_spec hex).1)]) ⟨nat.pos_of_ne_zero h, hk₅⟩),
   ⟨«expr / »(k, (nat.find hex : exprℤ())), subtype.ext_iff_val.2 (begin
       suffices [] [":", expr «expr = »(«expr ^ »(g, «expr * »((nat.find hex : exprℤ()), «expr / »(k, nat.find hex))), x)],
       { simpa [] [] [] ["[", expr zpow_mul, "]"] [] [] },
       rw ["[", expr int.mul_div_cancel' (int.dvd_of_mod_eq_zero (int.eq_zero_of_nat_abs_eq_zero hk₆)), ",", expr hk, "]"] []
     end)⟩⟩⟩ else have «expr = »(H, («expr⊥»() : subgroup α)), from «expr $ »(subgroup.ext, λ
  x, ⟨λ
   h, by simp [] [] [] [] [] ["at", "*"]; tauto [], λ
   h, by rw ["[", expr subgroup.mem_bot.1 h, "]"] []; exact [expr H.one_mem]⟩),
 by clear [ident _let_match]; substI [expr this]; apply_instance]

open Finset Nat

section Classical

open_locale Classical

theorem IsCyclic.card_pow_eq_one_le [DecidableEq α] [Fintype α] [IsCyclic α] {n : ℕ} (hn0 : 0 < n) :
  (univ.filter fun a : α => a ^ n = 1).card ≤ n :=
  let ⟨g, hg⟩ := IsCyclic.exists_generator α 
  calc
    (univ.filter fun a : α => a ^ n = 1).card ≤
      (zpowers (g ^ (Fintype.card α / gcd n (Fintype.card α))) : Set α).toFinset.card :=
    card_le_of_subset
      fun x hx =>
        let ⟨m, hm⟩ := show x ∈ Submonoid.powers g from mem_powers_iff_mem_zpowers.2$ hg x 
        Set.mem_to_finset.2
          ⟨(m / (Fintype.card α / gcd n (Fintype.card α)) : ℕ),
            have hgmn : (g ^ m*gcd n (Fintype.card α)) = 1 :=
              by 
                rw [pow_mulₓ, hm, ←pow_gcd_card_eq_one_iff] <;> exact (mem_filter.1 hx).2
            by 
              rw [zpow_coe_nat, ←pow_mulₓ, Nat.mul_div_cancel_left', hm]
              refine' dvd_of_mul_dvd_mul_right (gcd_pos_of_pos_left (Fintype.card α) hn0) _ 
              conv  => toLHS rw [Nat.div_mul_cancelₓ (gcd_dvd_right _ _), ←order_of_eq_card_of_forall_mem_zpowers hg]
              exact order_of_dvd_of_pow_eq_one hgmn⟩
    _ ≤ n :=
    let ⟨m, hm⟩ := gcd_dvd_right n (Fintype.card α)
    have hm0 : 0 < m :=
      Nat.pos_of_ne_zeroₓ$
        fun hm0 =>
          by 
            rw [hm0, mul_zero, Fintype.card_eq_zero_iff] at hm 
            exact hm.elim' 1
    by 
      rw [←Fintype.card_of_finset' _ fun _ => Set.mem_to_finset, ←order_eq_card_zpowers, order_of_pow g,
        order_of_eq_card_of_forall_mem_zpowers hg]
      rw [hm]
      rw [Nat.mul_div_cancel_leftₓ _ (gcd_pos_of_pos_left _ hn0), gcd_mul_left_left, hm, Nat.mul_div_cancelₓ _ hm0]
      exact le_of_dvd hn0 (gcd_dvd_left _ _)
    

end Classical

theorem IsCyclic.exists_monoid_generator [Fintype α] [IsCyclic α] : ∃ x : α, ∀ y : α, y ∈ Submonoid.powers x :=
  by 
    simpRw [mem_powers_iff_mem_zpowers]
    exact IsCyclic.exists_generator α

section 

variable [DecidableEq α] [Fintype α]

theorem IsCyclic.image_range_order_of (ha : ∀ x : α, x ∈ zpowers a) :
  Finset.image (fun i => a ^ i) (range (orderOf a)) = univ :=
  by 
    simpRw [←SetLike.mem_coe]  at ha 
    simp only [image_range_order_of, set.eq_univ_iff_forall.mpr ha]
    convert Set.to_finset_univ

theorem IsCyclic.image_range_card (ha : ∀ x : α, x ∈ zpowers a) :
  Finset.image (fun i => a ^ i) (range (Fintype.card α)) = univ :=
  by 
    rw [←order_of_eq_card_of_forall_mem_zpowers ha, IsCyclic.image_range_order_of ha]

end 

section Totient

variable [DecidableEq α] [Fintype α] (hn : ∀ n : ℕ, 0 < n → (univ.filter fun a : α => a ^ n = 1).card ≤ n)

include hn

theorem card_pow_eq_one_eq_order_of_aux (a : α) :
  (Finset.univ.filter fun b : α => b ^ orderOf a = 1).card = orderOf a :=
  le_antisymmₓ (hn _ (order_of_pos a))
    (calc orderOf a = @Fintype.card (zpowers a) (id _) := order_eq_card_zpowers 
      _ ≤
        @Fintype.card («expr↑ » (univ.filter fun b : α => b ^ orderOf a = 1) : Set α)
          (Fintype.ofFinset _ fun _ => Iff.rfl) :=
      @Fintype.card_le_of_injective (zpowers a) («expr↑ » (univ.filter fun b : α => b ^ orderOf a = 1) : Set α) (id _)
        (id _)
        (fun b =>
          ⟨b.1,
            mem_filter.2
              ⟨mem_univ _,
                let ⟨i, hi⟩ := b.2
                by 
                  rw [←hi, ←zpow_coe_nat, ←zpow_mul, mul_commₓ, zpow_mul, zpow_coe_nat, pow_order_of_eq_one,
                    one_zpow]⟩⟩)
        fun _ _ h => Subtype.eq (Subtype.mk.injₓ h)
      _ = (univ.filter fun b : α => b ^ orderOf a = 1).card := Fintype.card_of_finset _ _
      )

open_locale Nat

-- error in GroupTheory.SpecificGroups.Cyclic: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
private
theorem card_order_of_eq_totient_aux₁ : ∀
{d : exprℕ()}, «expr ∣ »(d, fintype.card α) → «expr < »(0, (univ.filter (λ
   a : α, «expr = »(order_of a, d))).card) → «expr = »((univ.filter (λ
   a : α, «expr = »(order_of a, d))).card, exprφ() d)
| 0 := λ hd hd0, let ⟨a, ha⟩ := card_pos.1 hd0 in
«expr $ »(absurd (mem_filter.1 ha).2, «expr $ »(ne_of_gt, order_of_pos a))
| «expr + »(d, 1) := λ hd hd0, let ⟨a, ha⟩ := card_pos.1 hd0 in
have ha : «expr = »(order_of a, d.succ), from (mem_filter.1 ha).2,
have h : «expr = »(«expr∑ in , »((m), (range d.succ).filter ((«expr ∣ » d.succ)), (univ.filter (λ
    a : α, «expr = »(order_of a, m))).card), «expr∑ in , »((m), (range d.succ).filter ((«expr ∣ » d.succ)), exprφ() m)), from finset.sum_congr rfl (λ
 m hm, have hmd : «expr < »(m, d.succ), from mem_range.1 (mem_filter.1 hm).1,
 have hm : «expr ∣ »(m, d.succ), from (mem_filter.1 hm).2,
 card_order_of_eq_totient_aux₁ (hm.trans hd) (finset.card_pos.2 ⟨«expr ^ »(a, «expr / »(d.succ, m)), mem_filter.2 ⟨mem_univ _, by { rw ["[", expr order_of_pow a, ",", expr ha, ",", expr gcd_eq_right (div_dvd_of_dvd hm), ",", expr nat.div_div_self hm (succ_pos _), "]"] [] }⟩⟩)),
have hinsert : «expr = »(insert d.succ ((range d.succ).filter ((«expr ∣ » d.succ))), (range d.succ.succ).filter ((«expr ∣ » d.succ))), from «expr $ »(finset.ext, λ
 x, ⟨λ
  h, (mem_insert.1 h).elim (λ
   h, by simp [] [] [] ["[", expr h, ",", expr range_succ, "]"] [] []) (by clear [ident _let_match]; simp [] [] [] ["[", expr range_succ, "]"] [] []; tauto []), by clear [ident _let_match]; simp [] [] [] ["[", expr range_succ, "]"] [] [] { contextual := tt }; tauto []⟩),
have hinsert₁ : «expr ∉ »(d.succ, (range d.succ).filter ((«expr ∣ » d.succ))), by simp [] [] [] ["[", expr mem_range, ",", expr zero_le_one, ",", expr le_succ, "]"] [] [],
(add_left_inj «expr∑ in , »((m), (range d.succ).filter ((«expr ∣ » d.succ)), (univ.filter (λ
    a : α, «expr = »(order_of a, m))).card)).1 (calc
   «expr = »(_, «expr∑ in , »((m), insert d.succ (filter ((«expr ∣ » d.succ)) (range d.succ)), (univ.filter (λ
       a : α, «expr = »(order_of a, m))).card)) : eq.symm (finset.sum_insert (by simp [] [] [] ["[", expr mem_range, ",", expr zero_le_one, ",", expr le_succ, "]"] [] []))
   «expr = »(..., «expr∑ in , »((m), (range d.succ.succ).filter ((«expr ∣ » d.succ)), (univ.filter (λ
       a : α, «expr = »(order_of a, m))).card)) : sum_congr hinsert (λ _ _, rfl)
   «expr = »(..., (univ.filter (λ
      a : α, «expr = »(«expr ^ »(a, d.succ), 1))).card) : sum_card_order_of_eq_card_pow_eq_one (succ_pos d)
   «expr = »(..., «expr∑ in , »((m), (range d.succ.succ).filter ((«expr ∣ » d.succ)), exprφ() m)) : «expr ▸ »(ha, «expr ▸ »((card_pow_eq_one_eq_order_of_aux hn a).symm, (sum_totient _).symm))
   «expr = »(..., _) : by rw ["[", expr h, ",", "<-", expr sum_insert hinsert₁, "]"] []; exact [expr finset.sum_congr hinsert.symm (λ
     _ _, rfl)])

theorem card_order_of_eq_totient_aux₂ {d : ℕ} (hd : d ∣ Fintype.card α) :
  (univ.filter fun a : α => orderOf a = d).card = φ d :=
  by_contradiction$
    fun h =>
      have h0 : (univ.filter fun a : α => orderOf a = d).card = 0 :=
        not_not.1 (mt pos_iff_ne_zero.2 (mt (card_order_of_eq_totient_aux₁ hn hd) h))
      let c := Fintype.card α 
      have hc0 : 0 < c := Fintype.card_pos_iff.2 ⟨1⟩
      lt_irreflₓ c$
        calc c = (univ.filter fun a : α => a ^ c = 1).card :=
          congr_argₓ card$
            by 
              simp [Finset.ext_iff, c]
          _ = ∑m in (range c.succ).filter (· ∣ c), (univ.filter fun a : α => orderOf a = m).card :=
          (sum_card_order_of_eq_card_pow_eq_one hc0).symm 
          _ = ∑m in ((range c.succ).filter (· ∣ c)).erase d, (univ.filter fun a : α => orderOf a = m).card :=
          Eq.symm
            (sum_subset (erase_subset _ _)
              fun m hm₁ hm₂ =>
                have  : m = d :=
                  by 
                    simp  at * <;> cc 
                by 
                  simp_all [Finset.ext_iff] <;> exact h0)
          _ ≤ ∑m in ((range c.succ).filter (· ∣ c)).erase d, φ m :=
          sum_le_sum
            fun m hm =>
              have hmc : m ∣ c :=
                by 
                  simp  at hm <;> tauto
              (imp_iff_not_or.1 (card_order_of_eq_totient_aux₁ hn hmc)).elim
                (fun h =>
                  by 
                    simp [Nat.le_zero_iff.1 (le_of_not_gtₓ h), Nat.zero_leₓ])
                fun h =>
                  by 
                    rw [h]
          _ < φ d+∑m in ((range c.succ).filter (· ∣ c)).erase d, φ m :=
          lt_add_of_pos_left _
            (totient_pos (Nat.pos_of_ne_zeroₓ fun h => pos_iff_ne_zero.1 hc0 (eq_zero_of_zero_dvd$ h ▸ hd)))
          _ = ∑m in insert d (((range c.succ).filter (· ∣ c)).erase d), φ m :=
          Eq.symm
            (sum_insert
              (by 
                simp ))
          _ = ∑m in (range c.succ).filter (· ∣ c), φ m :=
          Finset.sum_congr (Finset.insert_erase (mem_filter.2 ⟨mem_range.2 (lt_succ_of_le (le_of_dvd hc0 hd)), hd⟩))
            fun _ _ => rfl 
          _ = c := sum_totient _
          

theorem is_cyclic_of_card_pow_eq_one_le : IsCyclic α :=
  have  : (univ.filter fun a : α => orderOf a = Fintype.card α).Nonempty :=
    card_pos.1$
      by 
        rw [card_order_of_eq_totient_aux₂ hn dvd_rfl] <;> exact totient_pos (Fintype.card_pos_iff.2 ⟨1⟩)
  let ⟨x, hx⟩ := this 
  is_cyclic_of_order_of_eq_card x (Finset.mem_filter.1 hx).2

end Totient

theorem IsCyclic.card_order_of_eq_totient [IsCyclic α] [Fintype α] {d : ℕ} (hd : d ∣ Fintype.card α) :
  (univ.filter fun a : α => orderOf a = d).card = totient d :=
  by 
    classical 
    apply card_order_of_eq_totient_aux₂ (fun n => IsCyclic.card_pow_eq_one_le) hd

-- error in GroupTheory.SpecificGroups.Cyclic: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
/-- A finite group of prime order is simple. -/
theorem is_simple_group_of_prime_card
{α : Type u}
[group α]
[fintype α]
{p : exprℕ()}
[hp : fact p.prime]
(h : «expr = »(fintype.card α, p)) : is_simple_group α :=
⟨begin
   have [ident h'] [] [":=", expr nat.prime.one_lt (fact.out p.prime)],
   rw ["<-", expr h] ["at", ident h'],
   haveI [] [] [":=", expr fintype.one_lt_card_iff_nontrivial.1 h'],
   apply [expr exists_pair_ne α]
 end, λ H Hn, begin
   classical,
   have [ident hcard] [] [":=", expr card_subgroup_dvd_card H],
   rw ["[", expr h, ",", expr dvd_prime (fact.out p.prime), "]"] ["at", ident hcard],
   refine [expr hcard.imp (λ h1, _) (λ hp, _)],
   { haveI [] [] [":=", expr fintype.card_le_one_iff_subsingleton.1 (le_of_eq h1)],
     apply [expr eq_bot_of_subsingleton] },
   { exact [expr eq_top_of_card_eq _ (hp.trans h.symm)] }
 end⟩

end Cyclic

section QuotientCenter

open Subgroup

variable {G : Type _} {H : Type _} [Groupₓ G] [Groupₓ H]

/-- A group is commutative if the quotient by the center is cyclic.
  Also see `comm_group_of_cycle_center_quotient` for the `comm_group` instance -/
theorem commutative_of_cyclic_center_quotient [IsCyclic H] (f : G →* H) (hf : f.ker ≤ center G) (a b : G) :
  (a*b) = b*a :=
  let ⟨⟨x, y, (hxy : f y = x)⟩, (hx : ∀ a : f.range, a ∈ zpowers _)⟩ := IsCyclic.exists_generator f.range 
  let ⟨m, hm⟩ := hx ⟨f a, a, rfl⟩
  let ⟨n, hn⟩ := hx ⟨f b, b, rfl⟩
  have hm : x ^ m = f a :=
    by 
      simpa [Subtype.ext_iff] using hm 
  have hn : x ^ n = f b :=
    by 
      simpa [Subtype.ext_iff] using hn 
  have ha : ((y ^ -m)*a) ∈ center G :=
    hf
      (by 
        rw [f.mem_ker, f.map_mul, f.map_zpow, hxy, zpow_neg, hm, inv_mul_selfₓ])
  have hb : ((y ^ -n)*b) ∈ center G :=
    hf
      (by 
        rw [f.mem_ker, f.map_mul, f.map_zpow, hxy, zpow_neg, hn, inv_mul_selfₓ])
  calc (a*b) = ((y ^ m)*((y ^ -m)*a)*y ^ n)*(y ^ -n)*b :=
    by 
      simp [mul_assocₓ]
    _ = ((y ^ m)*(y ^ n)*(y ^ -m)*a)*(y ^ -n)*b :=
    by 
      rw [mem_center_iff.1 ha]
    _ = (((y ^ m)*y ^ n)*y ^ -m)*a*(y ^ -n)*b :=
    by 
      simp [mul_assocₓ]
    _ = (((y ^ m)*y ^ n)*y ^ -m)*((y ^ -n)*b)*a :=
    by 
      rw [mem_center_iff.1 hb]
    _ = b*a :=
    by 
      group
    

/-- A group is commutative if the quotient by the center is cyclic. -/
def commGroupOfCycleCenterQuotient [IsCyclic H] (f : G →* H) (hf : f.ker ≤ center G) : CommGroupₓ G :=
  { show Groupₓ G by 
      infer_instance with
    mul_comm := commutative_of_cyclic_center_quotient f hf }

end QuotientCenter

namespace IsSimpleGroup

section CommGroupₓ

variable [CommGroupₓ α] [IsSimpleGroup α]

-- error in GroupTheory.SpecificGroups.Cyclic: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
@[priority 100] instance : is_cyclic α :=
begin
  cases [expr subsingleton_or_nontrivial α] ["with", ident hi, ident hi]; haveI [] [] [":=", expr hi],
  { apply [expr is_cyclic_of_subsingleton] },
  { obtain ["⟨", ident g, ",", ident hg, "⟩", ":=", expr exists_ne (1 : α)],
    refine [expr ⟨⟨g, λ x, _⟩⟩],
    cases [expr is_simple_lattice.eq_bot_or_eq_top (subgroup.zpowers g)] ["with", ident hb, ident ht],
    { exfalso,
      apply [expr hg],
      rw ["[", "<-", expr subgroup.mem_bot, ",", "<-", expr hb, "]"] [],
      apply [expr subgroup.mem_zpowers] },
    { rw [expr ht] [],
      apply [expr subgroup.mem_top] } }
end

-- error in GroupTheory.SpecificGroups.Cyclic: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
theorem prime_card [fintype α] : (fintype.card α).prime :=
begin
  have [ident h0] [":", expr «expr < »(0, fintype.card α)] [":=", expr fintype.card_pos_iff.2 (by apply_instance)],
  obtain ["⟨", ident g, ",", ident hg, "⟩", ":=", expr is_cyclic.exists_generator α],
  refine [expr ⟨fintype.one_lt_card_iff_nontrivial.2 infer_instance, λ n hn, _⟩],
  refine [expr (is_simple_lattice.eq_bot_or_eq_top (subgroup.zpowers «expr ^ »(g, n))).symm.imp _ _],
  { intro [ident h],
    have [ident hgo] [] [":=", expr order_of_pow g],
    rw ["[", expr order_of_eq_card_of_forall_mem_zpowers hg, ",", expr nat.gcd_eq_right_iff_dvd.1 hn, ",", expr order_of_eq_card_of_forall_mem_zpowers, ",", expr eq_comm, ",", expr nat.div_eq_iff_eq_mul_left (nat.pos_of_dvd_of_pos hn h0) hn, "]"] ["at", ident hgo],
    { exact [expr (mul_left_cancel₀ (ne_of_gt h0) ((mul_one (fintype.card α)).trans hgo)).symm] },
    { intro [ident x],
      rw [expr h] [],
      exact [expr subgroup.mem_top _] } },
  { intro [ident h],
    apply [expr le_antisymm (nat.le_of_dvd h0 hn)],
    rw ["<-", expr order_of_eq_card_of_forall_mem_zpowers hg] [],
    apply [expr order_of_le_of_pow_eq_one (nat.pos_of_dvd_of_pos hn h0)],
    rw ["[", "<-", expr subgroup.mem_bot, ",", "<-", expr h, "]"] [],
    exact [expr subgroup.mem_zpowers _] }
end

end CommGroupₓ

end IsSimpleGroup

-- error in GroupTheory.SpecificGroups.Cyclic: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
theorem comm_group.is_simple_iff_is_cyclic_and_prime_card
[fintype α]
[comm_group α] : «expr ↔ »(is_simple_group α, «expr ∧ »(is_cyclic α, (fintype.card α).prime)) :=
begin
  split,
  { introI [ident h],
    exact [expr ⟨is_simple_group.is_cyclic, is_simple_group.prime_card⟩] },
  { rintro ["⟨", ident hc, ",", ident hp, "⟩"],
    haveI [] [":", expr fact (fintype.card α).prime] [":=", expr ⟨hp⟩],
    exact [expr is_simple_group_of_prime_card rfl] }
end

