import Mathbin.Data.Bracket 
import Mathbin.GroupTheory.Subgroup.Basic 
import Mathbin.Tactic.Group

/-!
# General commutators.

If `G` is a group and `H₁ H₂ : subgroup G` then the general commutator `⁅H₁, H₂⁆ : subgroup G`
is the subgroup of `G` generated by the commutators `h₁ * h₂ * h₁⁻¹ * h₂⁻¹`.

## Main definitions

* `general_commutator H₁ H₂` : the commutator of the subgroups `H₁` and `H₂`
-/


open Subgroup

variable{G G' : Type _}[Groupₓ G][Groupₓ G']{f : G →* G'}

/-- The commutator of two subgroups `H₁` and `H₂`. -/
instance generalCommutator : HasBracket (Subgroup G) (Subgroup G) :=
  ⟨fun H₁ H₂ => closure { x | ∃ (p : _)(_ : p ∈ H₁)(q : _)(_ : q ∈ H₂), (((p*q)*p⁻¹)*q⁻¹) = x }⟩

theorem general_commutator_def (H₁ H₂ : Subgroup G) :
  ⁅H₁,H₂⁆ = closure { x | ∃ (p : _)(_ : p ∈ H₁)(q : _)(_ : q ∈ H₂), (((p*q)*p⁻¹)*q⁻¹) = x } :=
  rfl

instance general_commutator_normal (H₁ H₂ : Subgroup G) [h₁ : H₁.normal] [h₂ : H₂.normal] : normal ⁅H₁,H₂⁆ :=
  by 
    let base : Set G := { x | ∃ (p : _)(_ : p ∈ H₁)(q : _)(_ : q ∈ H₂), (((p*q)*p⁻¹)*q⁻¹) = x }
    suffices h_base : base = Groupₓ.ConjugatesOfSet base
    ·
      dsimp only [general_commutator_def, ←base]
      rw [h_base]
      exact Subgroup.normal_closure_normal 
    apply Set.Subset.antisymm Groupₓ.subset_conjugates_of_set 
    intro a h 
    simpRw [Groupₓ.mem_conjugates_of_set_iff, is_conj_iff]  at h 
    rcases h with ⟨b, ⟨c, hc, e, he, rfl⟩, d, rfl⟩
    exact
      ⟨(d*c)*d⁻¹, h₁.conj_mem c hc d, (d*e)*d⁻¹, h₂.conj_mem e he d,
        by 
          group⟩

theorem general_commutator_mono {H₁ H₂ K₁ K₂ : Subgroup G} (h₁ : H₁ ≤ K₁) (h₂ : H₂ ≤ K₂) : ⁅H₁,H₂⁆ ≤ ⁅K₁,K₂⁆ :=
  by 
    apply closure_mono 
    rintro x ⟨p, hp, q, hq, rfl⟩
    exact ⟨p, h₁ hp, q, h₂ hq, rfl⟩

theorem general_commutator_def' (H₁ H₂ : Subgroup G) [H₁.normal] [H₂.normal] :
  ⁅H₁,H₂⁆ = normal_closure { x | ∃ (p : _)(_ : p ∈ H₁)(q : _)(_ : q ∈ H₂), (((p*q)*p⁻¹)*q⁻¹) = x } :=
  by 
    rw [←normal_closure_eq_self ⁅H₁,H₂⁆, general_commutator_def, normal_closure_closure_eq_normal_closure]

theorem general_commutator_le (H₁ H₂ : Subgroup G) (K : Subgroup G) :
  ⁅H₁,H₂⁆ ≤ K ↔ ∀ p _ : p ∈ H₁ q _ : q ∈ H₂, (((p*q)*p⁻¹)*q⁻¹) ∈ K :=
  by 
    rw [generalCommutator, closure_le]
    split 
    ·
      intro h p hp q hq 
      exact h ⟨p, hp, q, hq, rfl⟩
    ·
      rintro h x ⟨p, hp, q, hq, rfl⟩
      exact h p hp q hq

theorem general_commutator_containment (H₁ H₂ : Subgroup G) {p q : G} (hp : p ∈ H₁) (hq : q ∈ H₂) :
  (((p*q)*p⁻¹)*q⁻¹) ∈ ⁅H₁,H₂⁆ :=
  (general_commutator_le H₁ H₂ ⁅H₁,H₂⁆).mp (le_reflₓ ⁅H₁,H₂⁆) p hp q hq

theorem general_commutator_comm (H₁ H₂ : Subgroup G) : ⁅H₁,H₂⁆ = ⁅H₂,H₁⁆ :=
  by 
    suffices  : ∀ H₁ H₂ : Subgroup G, ⁅H₁,H₂⁆ ≤ ⁅H₂,H₁⁆
    ·
      exact le_antisymmₓ (this _ _) (this _ _)
    intro H₁ H₂ 
    rw [general_commutator_le]
    intro p hp q hq 
    have h : (((p*q)*p⁻¹)*q⁻¹)⁻¹ ∈ ⁅H₂,H₁⁆ :=
      subset_closure
        ⟨q, hq, p, hp,
          by 
            group⟩
    convert inv_mem ⁅H₂,H₁⁆ h 
    group

theorem general_commutator_le_right (H₁ H₂ : Subgroup G) [h : normal H₂] : ⁅H₁,H₂⁆ ≤ H₂ :=
  by 
    rw [general_commutator_le]
    intro p hp q hq 
    exact mul_mem H₂ (h.conj_mem q hq p) (inv_mem H₂ hq)

theorem general_commutator_le_left (H₁ H₂ : Subgroup G) [h : normal H₁] : ⁅H₁,H₂⁆ ≤ H₁ :=
  by 
    rw [general_commutator_comm]
    exact general_commutator_le_right H₂ H₁

@[simp]
theorem general_commutator_bot (H : Subgroup G) : ⁅H,⊥⁆ = (⊥ : Subgroup G) :=
  by 
    rw [eq_bot_iff]
    exact general_commutator_le_right H ⊥

@[simp]
theorem bot_general_commutator (H : Subgroup G) : ⁅(⊥ : Subgroup G),H⁆ = (⊥ : Subgroup G) :=
  by 
    rw [eq_bot_iff]
    exact general_commutator_le_left ⊥ H

theorem general_commutator_le_inf (H₁ H₂ : Subgroup G) [normal H₁] [normal H₂] : ⁅H₁,H₂⁆ ≤ H₁⊓H₂ :=
  by 
    simp only [general_commutator_le_left, general_commutator_le_right, le_inf_iff, and_selfₓ]

