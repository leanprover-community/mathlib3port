import Mathbin.CategoryTheory.Action 
import Mathbin.Combinatorics.Quiver 
import Mathbin.GroupTheory.IsFreeGroup

/-!
# The Nielsen-Schreier theorem

This file proves that a subgroup of a free group is itself free.

## Main result

- `subgroup_is_free_of_is_free H`: an instance saying that a subgroup of a free group is free.

## Proof overview

The proof is analogous to the proof using covering spaces and fundamental groups of graphs,
but we work directly with groupoids instead of topological spaces. Under this analogy,

- `is_free_groupoid G` corresponds to saying that a space is a graph.
- `End_mul_equiv_subgroup H` plays the role of replacing 'subgroup of fundamental group' with
  'fundamental group of covering space'.
- `action_groupoid_is_free G A` corresponds to the fact that a covering of a (single-vertex)
  graph is a graph.
- `End_is_free T` corresponds to the fact that, given a spanning tree `T` of a
  graph, its fundamental group is free (generated by loops from the complement of the tree).

## Implementation notes

Our definition of `is_free_groupoid` is nonstandard. Normally one would require that functors
`G â¥¤ X` to any _groupoid_ `X` are given by graph homomorphisms from the generators, but we only
consider _groups_ `X`. This simplifies the argument since functor equality is complicated in
general, but simple for functors to single object categories.

## References

https://ncatlab.org/nlab/show/Nielsen-Schreier+theorem

## Tags

free group, free groupoid, Nielsen-Schreier

-/


noncomputable theory

open_locale Classical

universe v u

-- error in GroupTheory.NielsenSchreier: ././Mathport/Syntax/Translate/Basic.lean:882:11: unsupported: unusual advanced open style
open category_theory category_theory.action_category category_theory.single_obj quiver is_free_group as fgp

/-- `is_free_groupoid.generators G` is a type synonym for `G`. We think of this as
the vertices of the generating quiver of `G` when `G` is free. We can't use `G` directly,
since `G` already has a quiver instance from being a groupoid. -/
@[nolint unused_arguments has_inhabited_instance]
def IsFreeGroupoid.Generators G [groupoid G] :=
  G

/-- A groupoid `G` is free when we have the following data:
 - a quiver on `is_free_groupoid.generators G` (a type synonym for `G`)
 - a function `of` taking a generating arrow to a morphism in `G`
 - such that a functor from `G` to any group `X` is uniquely determined
   by assigning labels in `X` to the generating arrows.

   This definition is nonstandard. Normally one would require that functors `G â¥¤ X`
   to any _groupoid_ `X` are given by graph homomorphisms from `generators`. -/
class IsFreeGroupoid(G)[groupoid.{v} G] where 
  quiverGenerators : Quiver.{v + 1} (IsFreeGroupoid.Generators G)
  of : âˆ€ {a b : IsFreeGroupoid.Generators G}, (a âŸ¶ b) â†’ ((show G from a) âŸ¶ b)
  unique_lift :
  âˆ€ {X : Type v} [Groupâ‚“ X] f : labelling (IsFreeGroupoid.Generators G) X,
    âˆƒ!F : G â¥¤ single_obj X, âˆ€ a b g : a âŸ¶ b, F.map (of g) = f g

namespace IsFreeGroupoid

attribute [instance] quiver_generators

/-- Two functors from a free groupoid to a group are equal when they agree on the generating
quiver. -/
@[ext]
theorem ext_functor {G} [groupoid.{v} G] [IsFreeGroupoid G] {X : Type v} [Groupâ‚“ X] (f g : G â¥¤ single_obj X)
  (h : âˆ€ a b e : a âŸ¶ b, f.map (of e) = g.map (of e)) : f = g :=
  let âŸ¨_, _, uâŸ© := @unique_lift G _ _ X _ fun a b : generators G e : a âŸ¶ b => g.map (of e)
  trans (u _ h) (u _ fun _ _ _ => rfl).symm

-- error in GroupTheory.NielsenSchreier: ././Mathport/Syntax/Translate/Basic.lean:177:17: failed to parenthesize: parenthesize: uncaught backtrack exception
/-- An action groupoid over a free froup is free. More generally, one could show that the groupoid
of elements over a free groupoid is free, but this version is easier to prove and suffices for our
purposes.

Analogous to the fact that a covering space of a graph is a graph. (A free groupoid is like a graph,
and a groupoid of elements is like a covering space.) -/
instance action_groupoid_is_free
{G A : Type u}
[group G]
[is_free_group G]
[mul_action G A] : is_free_groupoid (action_category G A) :=
{ quiver_generators := âŸ¨Î» a b, {e : fgp.generators G // Â«expr = Â»(Â«expr â€¢ Â»(fgp.of e, a.back), b.back)}âŸ©,
  of := Î» a b e, âŸ¨fgp.of e, e.propertyâŸ©,
  unique_lift := begin
    introsI [ident X, "_", ident f],
    let [ident f'] [":", expr fgp.generators G â†’ Â«expr â‹Š[ ] Â»(A â†’ X, mul_aut_arrow, G)] [":=", expr Î»
     e, âŸ¨Î» b, @f âŸ¨(), _âŸ© âŸ¨(), bâŸ© âŸ¨e, smul_inv_smul _ bâŸ©, fgp.of eâŸ©],
    rcases [expr fgp.unique_lift f', "with", "âŸ¨", ident F', ",", ident hF', ",", ident uF', "âŸ©"],
    refine [expr âŸ¨uncurry F' _, _, _âŸ©],
    { suffices [] [":", expr Â«expr = Â»(semidirect_product.right_hom.comp F', monoid_hom.id _)],
      { exact [expr monoid_hom.ext_iff.mp this] },
      ext [] [] [],
      rw ["[", expr monoid_hom.comp_apply, ",", expr hF', "]"] [],
      refl },
    { rintros ["âŸ¨", "âŸ¨", "âŸ©", ",", ident a, ":", expr A, "âŸ©", "âŸ¨", "âŸ¨", "âŸ©", ",", ident b, "âŸ©", "âŸ¨", ident e, ",", ident h, ":", expr Â«expr = Â»(Â«expr â€¢ Â»(fgp.of e, a), b), "âŸ©"],
      change [expr Â«expr = Â»((F' (fgp.of _)).left _, _)] [] [],
      rw [expr hF'] [],
      cases [expr inv_smul_eq_iff.mpr h.symm] [],
      refl },
    { intros [ident E, ident hE],
      have [] [":", expr Â«expr = Â»(curry E, F')] [],
      { apply [expr uF'],
        intro [ident e],
        ext [] [] [],
        { convert [] [expr hE _ _ _] [],
          refl },
        { refl } },
      apply [expr functor.hext],
      { intro [],
        apply [expr unit.ext] },
      { refine [expr action_category.cases _],
        intros [],
        simp [] [] ["only"] ["[", "<-", expr this, ",", expr uncurry_map, ",", expr curry_apply_left, ",", expr coe_back, ",", expr hom_of_pair.val, "]"] [] [] } }
  end }

namespace SpanningTree

variable{G : Type u}[groupoid.{u} G][IsFreeGroupoid G](T : WideSubquiver (symmetrify$ generators G))[arborescence T]

/-- The root of `T`, except its type is `G` instead of the type synonym `T`. -/
private def root' : G :=
  show T from root T

/-- A path in the tree gives a hom, by composition. -/
noncomputable def hom_of_path : âˆ€ {a : G}, path (root T) a â†’ (root' T âŸ¶ a)
| _, path.nil => ðŸ™ _
| a, path.cons p f => hom_of_path p â‰« Sum.recOn f.val (fun e => of e) fun e => inv (of e)

/-- For every vertex `a`, there is a canonical hom from the root, given by the path in the tree. -/
def tree_hom (a : G) : root' T âŸ¶ a :=
  hom_of_path T (default _)

/-- Any path to `a` gives `tree_hom T a`, since paths in the tree are unique. -/
theorem tree_hom_eq {a : G} (p : path (root T) a) : tree_hom T a = hom_of_path T p :=
  by 
    rw [tree_hom, Unique.default_eq]

@[simp]
theorem tree_hom_root : tree_hom T (root' T) = ðŸ™ _ :=
  trans (tree_hom_eq T path.nil) rfl

/-- Any hom in `G` can be made into a loop, by conjugating with `tree_hom`s. -/
def loop_of_hom {a b : G} (p : a âŸ¶ b) : End (root' T) :=
  tree_hom T a â‰« p â‰« inv (tree_hom T b)

/-- Turning an edge in the spanning tree into a loop gives the indentity loop. -/
theorem loop_of_hom_eq_id {a b : generators G} e (_ : e âˆˆ wide_subquiver_symmetrify T a b) :
  loop_of_hom T (of e) = ðŸ™ (root' T) :=
  by 
    rw [loop_of_hom, â†category.assoc, is_iso.comp_inv_eq, category.id_comp]
    cases H
    Â·
      rw [tree_hom_eq T (path.cons (default _) âŸ¨Sum.inl e, HâŸ©), hom_of_path]
      rfl
    Â·
      rw [tree_hom_eq T (path.cons (default _) âŸ¨Sum.inr e, HâŸ©), hom_of_path]
      simp only [is_iso.inv_hom_id, category.comp_id, category.assoc, tree_hom]

/-- Since a hom gives a loop, any homomorphism from the vertex group at the root
    extends to a functor on the whole groupoid. -/
@[simps]
def functor_of_monoid_hom {X} [Monoidâ‚“ X] (f : End (root' T) â†’* X) : G â¥¤ single_obj X :=
  { obj := fun _ => (), map := fun a b p => f (loop_of_hom T p),
    map_id' :=
      by 
        intro a 
        rw [loop_of_hom, category.id_comp, is_iso.hom_inv_id, â†End.one_def, f.map_one, id_as_one],
    map_comp' :=
      by 
        intros 
        rw [comp_as_mul, â†f.map_mul]
        simp only [is_iso.inv_hom_id_assoc, loop_of_hom, End.mul_def, category.assoc] }

/-- Given a free groupoid and an arborescence of its generating quiver, the vertex
    group at the root is freely generated by loops coming from generating arrows
    in the complement of the tree. -/
def End_is_free : IsFreeGroup (End (root' T)) :=
  { Generators := Set.Compl (wide_subquiver_equiv_set_total$ wide_subquiver_symmetrify T),
    of := fun e => loop_of_hom T (of e.val.hom),
    unique_lift' :=
      by 
        intros X _ f 
        let f' : labelling (generators G) X :=
          fun a b e => if h : e âˆˆ wide_subquiver_symmetrify T a b then 1 else f âŸ¨âŸ¨a, b, eâŸ©, hâŸ©
        rcases unique_lift f' with âŸ¨F', hF', uF'âŸ©
        refine' âŸ¨F'.map_End _, _, _âŸ©
        Â·
          suffices  : âˆ€ {x y} q : x âŸ¶ y, F'.map (loop_of_hom T q) = (F'.map q : X)
          Â·
            rintro âŸ¨âŸ¨a, b, eâŸ©, hâŸ©
            rw [functor.map_End_apply, this, hF']
            exact dif_neg h 
          intros 
          suffices  : âˆ€ {a} p : path (root' T) a, F'.map (hom_of_path T p) = 1
          Â·
            simp only [this, tree_hom, comp_as_mul, inv_as_inv, loop_of_hom, one_inv, mul_oneâ‚“, one_mulâ‚“,
              functor.map_inv, functor.map_comp]
          intro a p 
          induction' p with b c p e ih
          Â·
            rw [hom_of_path, F'.map_id, id_as_one]
          rw [hom_of_path, F'.map_comp, comp_as_mul, ih, mul_oneâ‚“]
          rcases e with âŸ¨e | e, eTâŸ©
          Â·
            rw [hF']
            exact dif_pos (Or.inl eT)
          Â·
            rw [F'.map_inv, inv_as_inv, inv_eq_one, hF']
            exact dif_pos (Or.inr eT)
        Â·
          intro E hE 
          ext 
          suffices  : (functor_of_monoid_hom T E).map x = F'.map x
          Â·
            simpa only [loop_of_hom, functor_of_monoid_hom_map, is_iso.inv_id, tree_hom_root, category.id_comp,
              category.comp_id] using this 
          congr 
          apply uF' 
          intro a b e 
          change E (loop_of_hom T _) = dite _ _ _ 
          splitIfs
          Â·
            rw [loop_of_hom_eq_id T e h, â†End.one_def, E.map_one]
          Â·
            exact hE âŸ¨âŸ¨a, b, eâŸ©, hâŸ© }

end SpanningTree

/-- Another name for the identity function `G â†’ G`, to help type checking. -/
private def symgen {G : Type u} [groupoid.{v} G] [IsFreeGroupoid G] : G â†’ symmetrify (generators G) :=
  id

/-- If there exists a morphism `a â†’ b` in a free groupoid, then there also exists a zigzag
from `a` to `b` in the generating quiver. -/
theorem path_nonempty_of_hom {G} [groupoid.{u, u} G] [IsFreeGroupoid G] {a b : G} :
  Nonempty (a âŸ¶ b) â†’ Nonempty (path (symgen a) (symgen b)) :=
  by 
    rintro âŸ¨pâŸ©
    rw [â†weakly_connected_component.eq, eq_comm, â†free_group.of_injective.eq_iff, â†mul_inv_eq_one]
    let X := FreeGroup (weakly_connected_component$ symmetrify$ generators G)
    let f : G â†’ X := fun g => FreeGroup.of (Â«exprâ†‘ Â» (symgen g))
    let F : G â¥¤ single_obj X := single_obj.difference_functor f 
    change F.map p = ((CategoryTheory.Functor.const G).obj ()).map p 
    congr 
    ext 
    rw [functor.const.obj_map, id_as_one, difference_functor_map, mul_inv_eq_one]
    apply congr_argâ‚“ FreeGroup.of 
    rw [weakly_connected_component.eq]
    exact âŸ¨hom.to_path (Sum.inr e)âŸ©

/-- Given a connected free groupoid, its generating quiver is rooted-connected. -/
instance generators_connected G [groupoid.{u, u} G] [is_connected G] [IsFreeGroupoid G] (r : G) :
  rooted_connected (symgen r) :=
  âŸ¨fun b => path_nonempty_of_hom (CategoryTheory.nonempty_hom_of_connected_groupoid r b)âŸ©

/-- A vertex group in a free connected groupoid is free. With some work one could drop the
connectedness assumption, by looking at connected components. -/
instance End_is_free_of_connected_free {G} [groupoid G] [is_connected G] [IsFreeGroupoid G] (r : G) :
  IsFreeGroup (End r) :=
  spanning_tree.End_is_free$ geodesic_subtree (symgen r)

end IsFreeGroupoid

/-- The Nielsen-Schreier theorem: a subgroup of a free group is free. -/
instance subgroupIsFreeOfIsFree {G : Type u} [Groupâ‚“ G] [IsFreeGroup G] (H : Subgroup G) : IsFreeGroup H :=
  IsFreeGroup.ofMulEquiv (End_mul_equiv_subgroup H)

